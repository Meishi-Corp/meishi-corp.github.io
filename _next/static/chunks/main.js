_N_E =
(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([["main"],{

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct */ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/extends.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/extends.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! @babel/runtime/helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles */ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");

var iterableToArray = __webpack_require__(/*! ./iterableToArray */ "./node_modules/@babel/runtime/helpers/iterableToArray.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread */ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/@next/polyfill-module/dist/polyfill-module.js":
/*!********************************************************************!*\
  !*** ./node_modules/@next/polyfill-module/dist/polyfill-module.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

"trimStart"in String.prototype||(String.prototype.trimStart=String.prototype.trimLeft),"trimEnd"in String.prototype||(String.prototype.trimEnd=String.prototype.trimRight),"description"in Symbol.prototype||Object.defineProperty(Symbol.prototype,"description",{configurable:!0,get:function(){var t=/\((.*)\)/.exec(this.toString());return t?t[1]:void 0}}),Array.prototype.flat||(Array.prototype.flat=function(t,r){return r=this.concat.apply([],this),t>1&&r.some(Array.isArray)?r.flat(t-1):r},Array.prototype.flatMap=function(t,r){return this.map(t,r).flat()}),Promise.prototype.finally||(Promise.prototype.finally=function(t){if("function"!=typeof t)return this.then(t,t);var r=this.constructor||Promise;return this.then(function(o){return r.resolve(t()).then(function(){return o})},function(o){return r.resolve(t()).then(function(){throw o})})});


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/client.js":
/*!************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/client.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var Bus = __importStar(__webpack_require__(/*! ./internal/bus */ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js"));
var parseStack_1 = __webpack_require__(/*! ./internal/helpers/parseStack */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js");
var isRegistered = false;
var stackTraceLimit = undefined;
function onUnhandledError(ev) {
    var error = ev === null || ev === void 0 ? void 0 : ev.error;
    if (!error || !(error instanceof Error) || typeof error.stack !== 'string') {
        // A non-error was thrown, we don't have anything to show. :-(
        return;
    }
    var e = error;
    Bus.emit({
        type: Bus.TYPE_UNHANDLED_ERROR,
        reason: error,
        frames: parseStack_1.parseStack(e.stack)
    });
}
function onUnhandledRejection(ev) {
    var reason = ev === null || ev === void 0 ? void 0 : ev.reason;
    if (!reason ||
        !(reason instanceof Error) ||
        typeof reason.stack !== 'string') {
        // A non-error was thrown, we don't have anything to show. :-(
        return;
    }
    var e = reason;
    Bus.emit({
        type: Bus.TYPE_UNHANDLED_REJECTION,
        reason: reason,
        frames: parseStack_1.parseStack(e.stack)
    });
}
function register() {
    if (isRegistered) {
        return;
    }
    isRegistered = true;
    try {
        var limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 50;
        stackTraceLimit = limit;
    }
    catch (_a) { }
    window.addEventListener('error', onUnhandledError);
    window.addEventListener('unhandledrejection', onUnhandledRejection);
}
exports.register = register;
function unregister() {
    if (!isRegistered) {
        return;
    }
    isRegistered = false;
    if (stackTraceLimit !== undefined) {
        try {
            Error.stackTraceLimit = stackTraceLimit;
        }
        catch (_a) { }
        stackTraceLimit = undefined;
    }
    window.removeEventListener('error', onUnhandledError);
    window.removeEventListener('unhandledrejection', onUnhandledRejection);
}
exports.unregister = unregister;
function onBuildOk() {
    Bus.emit({ type: Bus.TYPE_BUILD_OK });
}
exports.onBuildOk = onBuildOk;
function onBuildError(message) {
    Bus.emit({ type: Bus.TYPE_BUILD_ERROR, message: message });
}
exports.onBuildError = onBuildError;
function onRefresh() {
    Bus.emit({ type: Bus.TYPE_REFFRESH });
}
exports.onRefresh = onRefresh;
var nodeStackFrames_1 = __webpack_require__(/*! ./internal/helpers/nodeStackFrames */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js");
exports.getNodeError = nodeStackFrames_1.getNodeError;
var ReactDevOverlay_1 = __webpack_require__(/*! ./internal/ReactDevOverlay */ "./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js");
exports.ReactDevOverlay = ReactDevOverlay_1["default"];
//# sourceMappingURL=client.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
var ErrorBoundary = /** @class */ (function (_super) {
    __extends(ErrorBoundary, _super);
    function ErrorBoundary() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = { error: null };
        return _this;
    }
    ErrorBoundary.prototype.componentDidCatch = function (error, 
    // Loosely typed because it depends on the React version and was
    // accidentally excluded in some versions.
    errorInfo) {
        this.props.onError(error, (errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.componentStack) || null);
        this.setState({ error: error });
    };
    ErrorBoundary.prototype.render = function () {
        return this.state.error
            ? // The component has to be unmounted or else it would continue to error
                null
            : this.props.children;
    };
    return ErrorBoundary;
}(react_1["default"].PureComponent));
exports.ErrorBoundary = ErrorBoundary;
//# sourceMappingURL=ErrorBoundary.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
var Bus = __importStar(__webpack_require__(/*! ./bus */ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js"));
var ShadowPortal_1 = __webpack_require__(/*! ./components/ShadowPortal */ "./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js");
var Errors_1 = __webpack_require__(/*! ./container/Errors */ "./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js");
var BuildError_1 = __webpack_require__(/*! ./container/BuildError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js");
var ErrorBoundary_1 = __webpack_require__(/*! ./ErrorBoundary */ "./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js");
var Base_1 = __webpack_require__(/*! ./styles/Base */ "./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js");
var ComponentStyles_1 = __webpack_require__(/*! ./styles/ComponentStyles */ "./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js");
var CssReset_1 = __webpack_require__(/*! ./styles/CssReset */ "./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js");
function reducer(state, ev) {
    switch (ev.type) {
        case Bus.TYPE_BUILD_OK: {
            return __assign(__assign({}, state), { buildError: null });
        }
        case Bus.TYPE_BUILD_ERROR: {
            return __assign(__assign({}, state), { buildError: ev.message });
        }
        case Bus.TYPE_REFFRESH: {
            return __assign(__assign({}, state), { buildError: null, errors: [] });
        }
        case Bus.TYPE_UNHANDLED_ERROR:
        case Bus.TYPE_UNHANDLED_REJECTION: {
            return __assign(__assign({}, state), { nextId: state.nextId + 1, errors: __spread(state.errors, [{ id: state.nextId, event: ev }]) });
        }
        default: {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            var _1 = ev;
            return state;
        }
    }
}
var ReactDevOverlay = function ReactDevOverlay(_a) {
    var children = _a.children;
    var _b = __read(React.useReducer(reducer, { nextId: 1, buildError: null, errors: [] }), 2), state = _b[0], dispatch = _b[1];
    React.useEffect(function () {
        Bus.on(dispatch);
        return function () {
            Bus.off(dispatch);
        };
    }, [dispatch]);
    var onComponentError = React.useCallback(function (_error, _componentStack) {
        // TODO: special handling
    }, []);
    var hasBuildError = state.buildError != null;
    var hasRuntimeErrors = Boolean(state.errors.length);
    var isMounted = hasBuildError || hasRuntimeErrors;
    return (React.createElement(React.Fragment, null,
        React.createElement(ErrorBoundary_1.ErrorBoundary, { onError: onComponentError }, children !== null && children !== void 0 ? children : null),
        isMounted ? (React.createElement(ShadowPortal_1.ShadowPortal, null,
            React.createElement(CssReset_1.CssReset, null),
            React.createElement(Base_1.Base, null),
            React.createElement(ComponentStyles_1.ComponentStyles, null),
            hasBuildError ? (React.createElement(BuildError_1.BuildError, { message: state.buildError })) : hasRuntimeErrors ? (React.createElement(Errors_1.Errors, { errors: state.errors })) : undefined)) : undefined));
};
exports["default"] = ReactDevOverlay;
//# sourceMappingURL=ReactDevOverlay.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js":
/*!******************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/bus.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
exports.TYPE_BUILD_OK = 'build-ok';
exports.TYPE_BUILD_ERROR = 'build-error';
exports.TYPE_REFFRESH = 'fast-refresh';
exports.TYPE_UNHANDLED_ERROR = 'unhandled-error';
exports.TYPE_UNHANDLED_REJECTION = 'unhandled-rejection';
var handlers = new Set();
var queue = [];
function drain() {
    // Draining should never happen synchronously in case multiple handlers are
    // registered.
    setTimeout(function () {
        var _loop_1 = function () {
            var ev = queue.shift();
            handlers.forEach(function (handler) { return handler(ev); });
        };
        while (
        // Until we are out of events:
        Boolean(queue.length) &&
            // Or, if all handlers removed themselves as a result of handling the
            // event(s)
            Boolean(handlers.size)) {
            _loop_1();
        }
    }, 1);
}
function emit(ev) {
    queue.push(Object.freeze(__assign({}, ev)));
    drain();
}
exports.emit = emit;
function on(fn) {
    if (handlers.has(fn)) {
        return false;
    }
    handlers.add(fn);
    drain();
    return true;
}
exports.on = on;
function off(fn) {
    if (handlers.has(fn)) {
        handlers["delete"](fn);
        return true;
    }
    return false;
}
exports.off = off;
//# sourceMappingURL=bus.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var anser_1 = __importDefault(__webpack_require__(/*! anser */ "./node_modules/anser/lib/index.js"));
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
var strip_ansi_1 = __importDefault(__webpack_require__(/*! strip-ansi */ "./node_modules/@next/react-dev-overlay/node_modules/strip-ansi/index.js"));
var stack_frame_1 = __webpack_require__(/*! ../../helpers/stack-frame */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js");
exports.CodeFrame = function CodeFrame(_a) {
    var stackFrame = _a.stackFrame, codeFrame = _a.codeFrame;
    // Strip leading spaces out of the code frame:
    var formattedFrame = React.useMemo(function () {
        var lines = codeFrame.split(/\r?\n/g);
        var prefixLength = lines
            .map(function (line) { return /^>? +\d+ +\| ( *)/.exec(strip_ansi_1["default"](line)); })
            .filter(Boolean)
            .map(function (v) { return v.pop(); })
            .reduce(function (c, n) { return (isNaN(c) ? n.length : Math.min(c, n.length)); }, NaN);
        if (prefixLength > 1) {
            var p_1 = ' '.repeat(prefixLength);
            return lines
                .map(function (line, a) {
                return ~(a = line.indexOf('|'))
                    ? line.substring(0, a) + line.substring(a).replace(p_1, '')
                    : line;
            })
                .join('\n');
        }
        return lines.join('\n');
    }, [codeFrame]);
    var decoded = React.useMemo(function () {
        return anser_1["default"].ansiToJson(formattedFrame, {
            json: true,
            use_classes: true,
            remove_empty: true
        });
    }, [formattedFrame]);
    var open = React.useCallback(function () {
        var _a;
        var params = new URLSearchParams();
        for (var key in stackFrame) {
            params.append(key, ((_a = stackFrame[key]) !== null && _a !== void 0 ? _a : '').toString());
        }
        self
            .fetch(( false || '') + "/__nextjs_launch-editor?" + params.toString())
            .then(function () { }, function () {
            // TODO: report error
        });
    }, [stackFrame]);
    // TODO: make the caret absolute
    return (React.createElement("div", { "data-nextjs-codeframe": true },
        React.createElement("p", { role: "link", onClick: open, tabIndex: 1, title: "Click to open in your editor" },
            React.createElement("span", null,
                stack_frame_1.getFrameSource(stackFrame),
                " @ ",
                stackFrame.methodName),
            React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                React.createElement("path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }),
                React.createElement("polyline", { points: "15 3 21 3 21 9" }),
                React.createElement("line", { x1: "10", y1: "14", x2: "21", y2: "3" }))),
        React.createElement("hr", null),
        React.createElement("pre", null, decoded.map(function (entry, index) { return (React.createElement("span", { key: "frame-" + index, style: __assign({ color: entry.fg ? "var(--color-" + entry.fg + ")" : undefined }, (entry.decoration === 'bold'
                ? { fontWeight: 800 }
                : entry.decoration === 'italic'
                    ? { fontStyle: 'italic' }
                    : undefined)) }, entry.content)); }))));
};
//# sourceMappingURL=CodeFrame.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var CodeFrame_1 = __webpack_require__(/*! ./CodeFrame */ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js");
exports.CodeFrame = CodeFrame_1.CodeFrame;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/styles.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/styles.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-codeframe] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-codeframe]::selection,\n  [data-nextjs-codeframe] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-codeframe] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n\n  [data-nextjs-codeframe] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  [data-nextjs-codeframe] > hr {\n    margin: 0;\n    padding: 0;\n\n    border: none;\n    border-style: solid;\n    border-width: 0;\n    border-bottom-width: 1px;\n    border-color: var(--color-ansi-bright-black);\n  }\n\n  [data-nextjs-codeframe] > p {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    cursor: pointer;\n  }\n  [data-nextjs-codeframe] > p:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-codeframe] > p > svg {\n    width: auto;\n    height: 1em;\n    margin-left: 8px;\n  }\n"], ["\n  [data-nextjs-codeframe] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-codeframe]::selection,\n  [data-nextjs-codeframe] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-codeframe] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n\n  [data-nextjs-codeframe] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  [data-nextjs-codeframe] > hr {\n    margin: 0;\n    padding: 0;\n\n    border: none;\n    border-style: solid;\n    border-width: 0;\n    border-bottom-width: 1px;\n    border-color: var(--color-ansi-bright-black);\n  }\n\n  [data-nextjs-codeframe] > p {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    cursor: pointer;\n  }\n  [data-nextjs-codeframe] > p:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-codeframe] > p > svg {\n    width: auto;\n    height: 1em;\n    margin-left: 8px;\n  }\n"])));
exports.styles = styles;
var templateObject_1;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/Dialog.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/Dialog.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
var use_on_click_outside_1 = __webpack_require__(/*! ../../hooks/use-on-click-outside */ "./node_modules/@next/react-dev-overlay/lib/internal/hooks/use-on-click-outside.js");
var Dialog = function Dialog(_a) {
    var children = _a.children, type = _a.type, onClose = _a.onClose, props = __rest(_a, ["children", "type", "onClose"]);
    var _b = __read(React.useState(null), 2), dialog = _b[0], setDialog = _b[1];
    var onDialog = React.useCallback(function (node) {
        setDialog(node);
    }, []);
    use_on_click_outside_1.useOnClickOutside(dialog, onClose);
    // Make HTMLElements with `role=link` accessible to be triggered by the
    // keyboard, i.e. [Enter].
    React.useEffect(function () {
        if (dialog == null) {
            return;
        }
        var root = dialog.getRootNode();
        // Always true, but we do this for TypeScript:
        if (!(root instanceof ShadowRoot)) {
            return;
        }
        var shadowRoot = root;
        function handler(e) {
            var el = shadowRoot.activeElement;
            if (e.key === 'Enter' &&
                el instanceof HTMLElement &&
                el.getAttribute('role') === 'link') {
                e.preventDefault();
                e.stopPropagation();
                el.click();
            }
        }
        shadowRoot.addEventListener('keydown', handler);
        return function () {
            return shadowRoot.removeEventListener('keydown', handler);
        };
    }, [dialog]);
    return (React.createElement("div", { ref: onDialog, "data-nextjs-dialog": true, tabIndex: -1, role: "dialog", "aria-labelledby": props['aria-labelledby'], "aria-describedby": props['aria-describedby'], "aria-modal": "true" },
        React.createElement("div", { "data-nextjs-dialog-banner": true, className: "banner-" + type }),
        children));
};
exports.Dialog = Dialog;
//# sourceMappingURL=Dialog.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogBody.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogBody.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
var DialogBody = function DialogBody(_a) {
    var children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-dialog-body": true, className: className }, children));
};
exports.DialogBody = DialogBody;
//# sourceMappingURL=DialogBody.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogContent.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogContent.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
var DialogContent = function DialogContent(_a) {
    var children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-dialog-content": true, className: className }, children));
};
exports.DialogContent = DialogContent;
//# sourceMappingURL=DialogContent.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogHeader.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogHeader.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
var DialogHeader = function DialogHeader(_a) {
    var children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-dialog-header": true, className: className }, children));
};
exports.DialogHeader = DialogHeader;
//# sourceMappingURL=DialogHeader.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Dialog_1 = __webpack_require__(/*! ./Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/Dialog.js");
exports.Dialog = Dialog_1.Dialog;
var DialogBody_1 = __webpack_require__(/*! ./DialogBody */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogBody.js");
exports.DialogBody = DialogBody_1.DialogBody;
var DialogContent_1 = __webpack_require__(/*! ./DialogContent */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogContent.js");
exports.DialogContent = DialogContent_1.DialogContent;
var DialogHeader_1 = __webpack_require__(/*! ./DialogHeader */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogHeader.js");
exports.DialogHeader = DialogHeader_1.DialogHeader;
var styles_1 = __webpack_require__(/*! ./styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/styles.js");
exports.styles = styles_1.styles;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/styles.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/styles.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-dialog] {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    margin-right: auto;\n    margin-left: auto;\n    outline: none;\n    background: white;\n    border-radius: var(--size-gap);\n    box-shadow: 0 var(--size-gap-half) var(--size-gap-double)\n      rgba(0, 0, 0, 0.25);\n    max-height: calc(100% - 56px);\n    overflow-y: hidden;\n  }\n\n  @media (max-height: 812px) {\n    [data-nextjs-dialog-overlay] {\n      max-height: calc(100% - 15px);\n    }\n  }\n\n  @media (min-width: 576px) {\n    [data-nextjs-dialog] {\n      max-width: 540px;\n      box-shadow: 0 var(--size-gap) var(--size-gap-quad) rgba(0, 0, 0, 0.25);\n    }\n  }\n\n  @media (min-width: 768px) {\n    [data-nextjs-dialog] {\n      max-width: 720px;\n    }\n  }\n\n  @media (min-width: 992px) {\n    [data-nextjs-dialog] {\n      max-width: 960px;\n    }\n  }\n\n  [data-nextjs-dialog-banner] {\n    position: relative;\n  }\n  [data-nextjs-dialog-banner].banner-warning {\n    border-color: var(--color-ansi-yellow);\n  }\n  [data-nextjs-dialog-banner].banner-error {\n    border-color: var(--color-ansi-red);\n  }\n\n  [data-nextjs-dialog-banner]::after {\n    z-index: 2;\n    content: '';\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 100%;\n    /* banner width: */\n    border-top-width: var(--size-gap-half);\n    border-bottom-width: 0;\n    border-top-style: solid;\n    border-bottom-style: solid;\n    border-top-color: inherit;\n    border-bottom-color: transparent;\n  }\n\n  [data-nextjs-dialog-content] {\n    overflow-y: auto;\n    border: none;\n    margin: 0;\n    /* calc(padding + banner width offset) */\n    padding: calc(var(--size-gap-double) + var(--size-gap-half))\n      var(--size-gap-double);\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-header] {\n    flex-shrink: 0;\n    margin-bottom: var(--size-gap-double);\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-body] {\n    position: relative;\n    flex: 1 1 auto;\n  }\n"], ["\n  [data-nextjs-dialog] {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    margin-right: auto;\n    margin-left: auto;\n    outline: none;\n    background: white;\n    border-radius: var(--size-gap);\n    box-shadow: 0 var(--size-gap-half) var(--size-gap-double)\n      rgba(0, 0, 0, 0.25);\n    max-height: calc(100% - 56px);\n    overflow-y: hidden;\n  }\n\n  @media (max-height: 812px) {\n    [data-nextjs-dialog-overlay] {\n      max-height: calc(100% - 15px);\n    }\n  }\n\n  @media (min-width: 576px) {\n    [data-nextjs-dialog] {\n      max-width: 540px;\n      box-shadow: 0 var(--size-gap) var(--size-gap-quad) rgba(0, 0, 0, 0.25);\n    }\n  }\n\n  @media (min-width: 768px) {\n    [data-nextjs-dialog] {\n      max-width: 720px;\n    }\n  }\n\n  @media (min-width: 992px) {\n    [data-nextjs-dialog] {\n      max-width: 960px;\n    }\n  }\n\n  [data-nextjs-dialog-banner] {\n    position: relative;\n  }\n  [data-nextjs-dialog-banner].banner-warning {\n    border-color: var(--color-ansi-yellow);\n  }\n  [data-nextjs-dialog-banner].banner-error {\n    border-color: var(--color-ansi-red);\n  }\n\n  [data-nextjs-dialog-banner]::after {\n    z-index: 2;\n    content: '';\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 100%;\n    /* banner width: */\n    border-top-width: var(--size-gap-half);\n    border-bottom-width: 0;\n    border-top-style: solid;\n    border-bottom-style: solid;\n    border-top-color: inherit;\n    border-bottom-color: transparent;\n  }\n\n  [data-nextjs-dialog-content] {\n    overflow-y: auto;\n    border: none;\n    margin: 0;\n    /* calc(padding + banner width offset) */\n    padding: calc(var(--size-gap-double) + var(--size-gap-half))\n      var(--size-gap-double);\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-header] {\n    flex-shrink: 0;\n    margin-bottom: var(--size-gap-double);\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-body] {\n    position: relative;\n    flex: 1 1 auto;\n  }\n"])));
exports.styles = styles;
var templateObject_1;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
var LeftRightDialogHeader = function LeftRightDialogHeader(_a) {
    var children = _a.children, className = _a.className, previous = _a.previous, next = _a.next, close = _a.close;
    var buttonLeft = React.useRef(null);
    var buttonRight = React.useRef(null);
    var buttonClose = React.useRef(null);
    var _b = __read(React.useState(null), 2), nav = _b[0], setNav = _b[1];
    var onNav = React.useCallback(function (el) {
        setNav(el);
    }, []);
    React.useEffect(function () {
        if (nav == null) {
            return;
        }
        var root = nav.getRootNode();
        var d = self.document;
        function handler(e) {
            if (e.key === 'ArrowLeft') {
                e.stopPropagation();
                if (buttonLeft.current) {
                    buttonLeft.current.focus();
                }
                previous && previous();
            }
            else if (e.key === 'ArrowRight') {
                e.stopPropagation();
                if (buttonRight.current) {
                    buttonRight.current.focus();
                }
                next && next();
            }
            else if (e.key === 'Escape') {
                e.stopPropagation();
                if (root instanceof ShadowRoot) {
                    var a = root.activeElement;
                    if (a && a !== buttonClose.current && a instanceof HTMLElement) {
                        a.blur();
                        return;
                    }
                }
                if (close) {
                    close();
                }
            }
        }
        root.addEventListener('keydown', handler);
        if (root !== d) {
            d.addEventListener('keydown', handler);
        }
        return function () {
            root.removeEventListener('keydown', handler);
            if (root !== d) {
                d.removeEventListener('keydown', handler);
            }
        };
    }, [close, nav, next, previous]);
    // Unlock focus for browsers like Firefox, that break all user focus if the
    // currently focused item becomes disabled.
    React.useEffect(function () {
        if (nav == null) {
            return;
        }
        var root = nav.getRootNode();
        // Always true, but we do this for TypeScript:
        if (root instanceof ShadowRoot) {
            var a = root.activeElement;
            if (previous == null) {
                if (buttonLeft.current && a === buttonLeft.current) {
                    buttonLeft.current.blur();
                }
            }
            else if (next == null) {
                if (buttonRight.current && a === buttonRight.current) {
                    buttonRight.current.blur();
                }
            }
        }
    }, [nav, next, previous]);
    return (React.createElement("div", { "data-nextjs-dialog-left-right": true, className: className },
        React.createElement("nav", { ref: onNav },
            React.createElement("button", { ref: buttonLeft, type: "button", disabled: previous == null ? true : undefined, "aria-disabled": previous == null ? true : undefined, onClick: previous !== null && previous !== void 0 ? previous : undefined },
                React.createElement("svg", { viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                    React.createElement("path", { d: "M6.99996 1.16666L1.16663 6.99999L6.99996 12.8333M12.8333 6.99999H1.99996H12.8333Z", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))),
            React.createElement("button", { ref: buttonRight, type: "button", disabled: next == null ? true : undefined, "aria-disabled": next == null ? true : undefined, onClick: next !== null && next !== void 0 ? next : undefined },
                React.createElement("svg", { viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                    React.createElement("path", { d: "M6.99996 1.16666L12.8333 6.99999L6.99996 12.8333M1.16663 6.99999H12H1.16663Z", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))),
            "\u00A0",
            children),
        close ? (React.createElement("button", { ref: buttonClose, type: "button", onClick: close, "aria-label": "Close" },
            React.createElement("span", { "aria-hidden": "true" },
                React.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                    React.createElement("path", { d: "M18 6L6 18", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }),
                    React.createElement("path", { d: "M6 6L18 18", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))))) : null));
};
exports.LeftRightDialogHeader = LeftRightDialogHeader;
//# sourceMappingURL=LeftRightDialogHeader.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var LeftRightDialogHeader_1 = __webpack_require__(/*! ./LeftRightDialogHeader */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js");
exports.LeftRightDialogHeader = LeftRightDialogHeader_1.LeftRightDialogHeader;
var styles_1 = __webpack_require__(/*! ./styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js");
exports.styles = styles_1.styles;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-dialog-left-right] {\n    display: flex;\n    flex-direction: row;\n    align-content: center;\n    align-items: center;\n    justify-content: space-between;\n  }\n  [data-nextjs-dialog-left-right] > nav > button {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n\n    width: calc(var(--size-gap-double) + var(--size-gap));\n    height: calc(var(--size-gap-double) + var(--size-gap));\n    font-size: 0;\n    border: none;\n    background-color: rgba(255, 85, 85, 0.1);\n    color: var(--color-ansi-red);\n    cursor: pointer;\n    transition: background-color 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > nav > button > svg {\n    width: auto;\n    height: calc(var(--size-gap) + var(--size-gap-half));\n  }\n  [data-nextjs-dialog-left-right] > nav > button:hover {\n    background-color: rgba(255, 85, 85, 0.2);\n  }\n  [data-nextjs-dialog-left-right] > nav > button:disabled {\n    background-color: rgba(255, 85, 85, 0.1);\n    color: rgba(255, 85, 85, 0.4);\n    cursor: not-allowed;\n  }\n\n  [data-nextjs-dialog-left-right] > nav > button:first-of-type {\n    border-radius: var(--size-gap-half) 0 0 var(--size-gap-half);\n    margin-right: 1px;\n  }\n  [data-nextjs-dialog-left-right] > nav > button:last-of-type {\n    border-radius: 0 var(--size-gap-half) var(--size-gap-half) 0;\n  }\n\n  [data-nextjs-dialog-left-right] > button:last-of-type {\n    border: 0;\n    padding: 0;\n\n    background-color: transparent;\n    appearance: none;\n\n    opacity: 0.4;\n    transition: opacity 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > button:last-of-type:hover {\n    opacity: 0.7;\n  }\n"], ["\n  [data-nextjs-dialog-left-right] {\n    display: flex;\n    flex-direction: row;\n    align-content: center;\n    align-items: center;\n    justify-content: space-between;\n  }\n  [data-nextjs-dialog-left-right] > nav > button {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n\n    width: calc(var(--size-gap-double) + var(--size-gap));\n    height: calc(var(--size-gap-double) + var(--size-gap));\n    font-size: 0;\n    border: none;\n    background-color: rgba(255, 85, 85, 0.1);\n    color: var(--color-ansi-red);\n    cursor: pointer;\n    transition: background-color 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > nav > button > svg {\n    width: auto;\n    height: calc(var(--size-gap) + var(--size-gap-half));\n  }\n  [data-nextjs-dialog-left-right] > nav > button:hover {\n    background-color: rgba(255, 85, 85, 0.2);\n  }\n  [data-nextjs-dialog-left-right] > nav > button:disabled {\n    background-color: rgba(255, 85, 85, 0.1);\n    color: rgba(255, 85, 85, 0.4);\n    cursor: not-allowed;\n  }\n\n  [data-nextjs-dialog-left-right] > nav > button:first-of-type {\n    border-radius: var(--size-gap-half) 0 0 var(--size-gap-half);\n    margin-right: 1px;\n  }\n  [data-nextjs-dialog-left-right] > nav > button:last-of-type {\n    border-radius: 0 var(--size-gap-half) var(--size-gap-half) 0;\n  }\n\n  [data-nextjs-dialog-left-right] > button:last-of-type {\n    border: 0;\n    padding: 0;\n\n    background-color: transparent;\n    appearance: none;\n\n    opacity: 0.4;\n    transition: opacity 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > button:last-of-type:hover {\n    opacity: 0.7;\n  }\n"])));
exports.styles = styles;
var templateObject_1;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/Overlay.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/Overlay.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
// @ts-ignore
var maintain__tab_focus_1 = __importDefault(__webpack_require__(/*! ./maintain--tab-focus */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/maintain--tab-focus.js"));
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
var body_locker_1 = __webpack_require__(/*! ./body-locker */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/body-locker.js");
var Overlay = function Overlay(_a) {
    var className = _a.className, children = _a.children, fixed = _a.fixed;
    React.useEffect(function () {
        body_locker_1.lock();
        return function () {
            body_locker_1.unlock();
        };
    }, []);
    var _b = __read(React.useState(null), 2), overlay = _b[0], setOverlay = _b[1];
    var onOverlay = React.useCallback(function (el) {
        setOverlay(el);
    }, []);
    React.useEffect(function () {
        if (overlay == null) {
            return;
        }
        var handle2 = maintain__tab_focus_1["default"]({ context: overlay });
        return function () {
            handle2.disengage();
        };
    }, [overlay]);
    return (React.createElement("div", { "data-nextjs-dialog-overlay": true, className: className, ref: onOverlay },
        React.createElement("div", { "data-nextjs-dialog-backdrop": true, "data-nextjs-dialog-backdrop-fixed": fixed ? true : undefined }),
        children));
};
exports.Overlay = Overlay;
//# sourceMappingURL=Overlay.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/body-locker.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/body-locker.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var previousBodyPaddingRight;
var previousBodyOverflowSetting;
var activeLocks = 0;
function lock() {
    setTimeout(function () {
        if (activeLocks++ > 0) {
            return;
        }
        var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;
        if (scrollBarGap > 0) {
            previousBodyPaddingRight = document.body.style.paddingRight;
            document.body.style.paddingRight = scrollBarGap + "px";
        }
        previousBodyOverflowSetting = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
    });
}
exports.lock = lock;
function unlock() {
    setTimeout(function () {
        if (activeLocks === 0 || --activeLocks !== 0) {
            return;
        }
        if (previousBodyPaddingRight !== undefined) {
            document.body.style.paddingRight = previousBodyPaddingRight;
            previousBodyPaddingRight = undefined;
        }
        if (previousBodyOverflowSetting !== undefined) {
            document.body.style.overflow = previousBodyOverflowSetting;
            previousBodyOverflowSetting = undefined;
        }
    });
}
exports.unlock = unlock;
//# sourceMappingURL=body-locker.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Overlay_1 = __webpack_require__(/*! ./Overlay */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/Overlay.js");
exports.Overlay = Overlay_1.Overlay;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/maintain--tab-focus.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/maintain--tab-focus.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable */
// @ts-nocheck
// Copied from https://github.com/medialize/ally.js
// License: MIT
// Copyright (c) 2015 Rodney Rehm
//
// Entrypoint: ally.js/maintain/tab-focus
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var platform_1 = __importDefault(__webpack_require__(/*! platform */ "./node_modules/platform/platform.js"));
var css_escape_1 = __importDefault(__webpack_require__(/*! css.escape */ "./node_modules/css.escape/css.escape.js"));
// input may be undefined, selector-tring, Node, NodeList, HTMLCollection, array of Nodes
// yes, to some extent this is a bad replica of jQuery's constructor function
function nodeArray(input) {
    if (!input) {
        return [];
    }
    if (Array.isArray(input)) {
        return input;
    }
    // instanceof Node - does not work with iframes
    if (input.nodeType !== undefined) {
        return [input];
    }
    if (typeof input === 'string') {
        input = document.querySelectorAll(input);
    }
    if (input.length !== undefined) {
        return [].slice.call(input, 0);
    }
    throw new TypeError('unexpected input ' + String(input));
}
function contextToElement(_ref) {
    var context = _ref.context, _ref$label = _ref.label, label = _ref$label === undefined ? 'context-to-element' : _ref$label, resolveDocument = _ref.resolveDocument, defaultToDocument = _ref.defaultToDocument;
    var element = nodeArray(context)[0];
    if (resolveDocument && element && element.nodeType === Node.DOCUMENT_NODE) {
        element = element.documentElement;
    }
    if (!element && defaultToDocument) {
        return document.documentElement;
    }
    if (!element) {
        throw new TypeError(label + ' requires valid options.context');
    }
    if (element.nodeType !== Node.ELEMENT_NODE &&
        element.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
        throw new TypeError(label + ' requires options.context to be an Element');
    }
    return element;
}
function getShadowHost() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context;
    var element = contextToElement({
        label: 'get/shadow-host',
        context: context
    });
    // walk up to the root
    var container = null;
    while (element) {
        container = element;
        element = element.parentNode;
    }
    // https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType
    // NOTE: Firefox 34 does not expose ShadowRoot.host (but 37 does)
    if (container.nodeType === container.DOCUMENT_FRAGMENT_NODE &&
        container.host) {
        // the root is attached to a fragment node that has a host
        return container.host;
    }
    return null;
}
function getDocument(node) {
    if (!node) {
        return document;
    }
    if (node.nodeType === Node.DOCUMENT_NODE) {
        return node;
    }
    return node.ownerDocument || document;
}
function isActiveElement(context) {
    var element = contextToElement({
        label: 'is/active-element',
        resolveDocument: true,
        context: context
    });
    var _document = getDocument(element);
    if (_document.activeElement === element) {
        return true;
    }
    var shadowHost = getShadowHost({ context: element });
    if (shadowHost && shadowHost.shadowRoot.activeElement === element) {
        return true;
    }
    return false;
}
// [elem, elem.parent, elem.parent.parent, …, html]
// will not contain the shadowRoot (DOCUMENT_FRAGMENT_NODE) and shadowHost
function getParents() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context;
    var list = [];
    var element = contextToElement({
        label: 'get/parents',
        context: context
    });
    while (element) {
        list.push(element);
        // IE does know support parentElement on SVGElement
        element = element.parentNode;
        if (element && element.nodeType !== Node.ELEMENT_NODE) {
            element = null;
        }
    }
    return list;
}
// Element.prototype.matches may be available at a different name
// https://developer.mozilla.org/en/docs/Web/API/Element/matches
var names = [
    'matches',
    'webkitMatchesSelector',
    'mozMatchesSelector',
    'msMatchesSelector',
];
var name = null;
function findMethodName(element) {
    names.some(function (_name) {
        if (!element[_name]) {
            return false;
        }
        name = _name;
        return true;
    });
}
function elementMatches(element, selector) {
    if (!name) {
        findMethodName(element);
    }
    return element[name](selector);
}
// deep clone of original platform
var platform = JSON.parse(JSON.stringify(platform_1["default"]));
// operating system
var os = platform.os.family || '';
var ANDROID = os === 'Android';
var WINDOWS = os.slice(0, 7) === 'Windows';
var OSX = os === 'OS X';
var IOS = os === 'iOS';
// layout
var BLINK = platform.layout === 'Blink';
var GECKO = platform.layout === 'Gecko';
var TRIDENT = platform.layout === 'Trident';
var EDGE = platform.layout === 'EdgeHTML';
var WEBKIT = platform.layout === 'WebKit';
// browser version (not layout engine version!)
var version = parseFloat(platform.version);
var majorVersion = Math.floor(version);
platform.majorVersion = majorVersion;
platform.is = {
    // operating system
    ANDROID: ANDROID,
    WINDOWS: WINDOWS,
    OSX: OSX,
    IOS: IOS,
    // layout
    BLINK: BLINK,
    GECKO: GECKO,
    TRIDENT: TRIDENT,
    EDGE: EDGE,
    WEBKIT: WEBKIT,
    // INTERNET EXPLORERS
    IE9: TRIDENT && majorVersion === 9,
    IE10: TRIDENT && majorVersion === 10,
    IE11: TRIDENT && majorVersion === 11
};
function before() {
    var data = {
        // remember what had focus to restore after test
        activeElement: document.activeElement,
        // remember scroll positions to restore after test
        windowScrollTop: window.scrollTop,
        windowScrollLeft: window.scrollLeft,
        bodyScrollTop: document.body.scrollTop,
        bodyScrollLeft: document.body.scrollLeft
    };
    // wrap tests in an element hidden from screen readers to prevent them
    // from announcing focus, which can be quite irritating to the user
    var iframe = document.createElement('iframe');
    iframe.setAttribute('style', 'position:absolute; position:fixed; top:0; left:-2px; width:1px; height:1px; overflow:hidden;');
    iframe.setAttribute('aria-live', 'off');
    iframe.setAttribute('aria-busy', 'true');
    iframe.setAttribute('aria-hidden', 'true');
    document.body.appendChild(iframe);
    var _window = iframe.contentWindow;
    var _document = _window.document;
    _document.open();
    _document.close();
    var wrapper = _document.createElement('div');
    _document.body.appendChild(wrapper);
    data.iframe = iframe;
    data.wrapper = wrapper;
    data.window = _window;
    data.document = _document;
    return data;
}
// options.element:
//  {string} element name
//  {function} callback(wrapper, document) to generate an element
// options.mutate: (optional)
//  {function} callback(element, wrapper, document) to manipulate element prior to focus-test.
//             Can return DOMElement to define focus target (default: element)
// options.validate: (optional)
//  {function} callback(element, focusTarget, document) to manipulate test-result
function test(data, options) {
    // make sure we operate on a clean slate
    data.wrapper.innerHTML = '';
    // create dummy element to test focusability of
    var element = typeof options.element === 'string'
        ? data.document.createElement(options.element)
        : options.element(data.wrapper, data.document);
    // allow callback to further specify dummy element
    // and optionally define element to focus
    var focus = options.mutate && options.mutate(element, data.wrapper, data.document);
    if (!focus && focus !== false) {
        focus = element;
    }
    // element needs to be part of the DOM to be focusable
    !element.parentNode && data.wrapper.appendChild(element);
    // test if the element with invalid tabindex can be focused
    focus && focus.focus && focus.focus();
    // validate test's result
    return options.validate
        ? options.validate(element, focus, data.document)
        : data.document.activeElement === focus;
}
function after(data) {
    // restore focus to what it was before test and cleanup
    if (data.activeElement === document.body) {
        document.activeElement &&
            document.activeElement.blur &&
            document.activeElement.blur();
        if (platform.is.IE10) {
            // IE10 does not redirect focus to <body> when the activeElement is removed
            document.body.focus();
        }
    }
    else {
        data.activeElement && data.activeElement.focus && data.activeElement.focus();
    }
    document.body.removeChild(data.iframe);
    // restore scroll position
    window.scrollTop = data.windowScrollTop;
    window.scrollLeft = data.windowScrollLeft;
    document.body.scrollTop = data.bodyScrollTop;
    document.body.scrollLeft = data.bodyScrollLeft;
}
function detectFocus(tests) {
    var data = before();
    var results = {};
    Object.keys(tests).map(function (key) {
        results[key] = test(data, tests[key]);
    });
    after(data);
    return results;
}
// this file is overwritten by `npm run build:pre`
var version$1 = '1.4.1';
/*
    Facility to cache test results in localStorage.

    USAGE:
      cache.get('key');
      cache.set('key', 'value');
 */
function readLocalStorage(key) {
    // allow reading from storage to retrieve previous support results
    // even while the document does not have focus
    var data = void 0;
    try {
        data = window.localStorage && window.localStorage.getItem(key);
        data = data ? JSON.parse(data) : {};
    }
    catch (e) {
        data = {};
    }
    return data;
}
function writeLocalStorage(key, value) {
    if (!document.hasFocus()) {
        // if the document does not have focus when tests are executed, focus() may
        // not be handled properly and events may not be dispatched immediately.
        // This can happen when a document is reloaded while Developer Tools have focus.
        try {
            window.localStorage && window.localStorage.removeItem(key);
        }
        catch (e) {
            // ignore
        }
        return;
    }
    try {
        window.localStorage &&
            window.localStorage.setItem(key, JSON.stringify(value));
    }
    catch (e) {
        // ignore
    }
}
var userAgent = (typeof window !== 'undefined' && window.navigator.userAgent) || '';
var cacheKey = 'ally-supports-cache';
var cache = readLocalStorage(cacheKey);
// update the cache if ally or the user agent changed (newer version, etc)
if (cache.userAgent !== userAgent || cache.version !== version$1) {
    cache = {};
}
cache.userAgent = userAgent;
cache.version = version$1;
var cache$1 = {
    get: function get() {
        return cache;
    },
    set: function set(values) {
        Object.keys(values).forEach(function (key) {
            cache[key] = values[key];
        });
        cache.time = new Date().toISOString();
        writeLocalStorage(cacheKey, cache);
    }
};
function cssShadowPiercingDeepCombinator() {
    var combinator = void 0;
    // see https://dev.w3.org/csswg/css-scoping-1/#deep-combinator
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1117572
    // https://code.google.com/p/chromium/issues/detail?id=446051
    try {
        document.querySelector('html >>> :first-child');
        combinator = '>>>';
    }
    catch (noArrowArrowArrow) {
        try {
            // old syntax supported at least up to Chrome 41
            // https://code.google.com/p/chromium/issues/detail?id=446051
            document.querySelector('html /deep/ :first-child');
            combinator = '/deep/';
        }
        catch (noDeep) {
            combinator = '';
        }
    }
    return combinator;
}
var gif = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
var focusAreaImgTabindex = {
    element: 'div',
    mutate: function mutate(element) {
        element.innerHTML =
            '<map name="image-map-tabindex-test">' +
                '<area shape="rect" coords="63,19,144,45"></map>' +
                '<img usemap="#image-map-tabindex-test" tabindex="-1" alt="" src="' +
                gif +
                '">';
        return element.querySelector('area');
    }
};
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
var focusAreaTabindex = {
    element: 'div',
    mutate: function mutate(element) {
        element.innerHTML =
            '<map name="image-map-tabindex-test">' +
                '<area href="#void" tabindex="-1" shape="rect" coords="63,19,144,45"></map>' +
                '<img usemap="#image-map-tabindex-test" alt="" src="' +
                gif +
                '">';
        return false;
    },
    validate: function validate(element, focusTarget, _document) {
        if (platform.is.GECKO) {
            // fixes https://github.com/medialize/ally.js/issues/35
            // Firefox loads the DataURI asynchronously, causing a false-negative
            return true;
        }
        var focus = element.querySelector('area');
        focus.focus();
        return _document.activeElement === focus;
    }
};
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
var focusAreaWithoutHref = {
    element: 'div',
    mutate: function mutate(element) {
        element.innerHTML =
            '<map name="image-map-area-href-test">' +
                '<area shape="rect" coords="63,19,144,45"></map>' +
                '<img usemap="#image-map-area-href-test" alt="" src="' +
                gif +
                '">';
        return element.querySelector('area');
    },
    validate: function validate(element, focusTarget, _document) {
        if (platform.is.GECKO) {
            // fixes https://github.com/medialize/ally.js/issues/35
            // Firefox loads the DataURI asynchronously, causing a false-negative
            return true;
        }
        return _document.activeElement === focusTarget;
    }
};
var focusAudioWithoutControls = {
    name: 'can-focus-audio-without-controls',
    element: 'audio',
    mutate: function mutate(element) {
        try {
            // invalid media file can trigger warning in console, data-uri to prevent HTTP request
            element.setAttribute('src', gif);
        }
        catch (e) {
            // IE9 may throw "Error: Not implemented"
        }
    }
};
var invalidGif = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ';
// NOTE: https://github.com/medialize/ally.js/issues/35
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
var focusBrokenImageMap = {
    element: 'div',
    mutate: function mutate(element) {
        element.innerHTML =
            '<map name="broken-image-map-test"><area href="#void" shape="rect" coords="63,19,144,45"></map>' +
                '<img usemap="#broken-image-map-test" alt="" src="' +
                invalidGif +
                '">';
        return element.querySelector('area');
    }
};
// Children of focusable elements with display:flex are focusable in IE10-11
var focusChildrenOfFocusableFlexbox = {
    element: 'div',
    mutate: function mutate(element) {
        element.setAttribute('tabindex', '-1');
        element.setAttribute('style', 'display: -webkit-flex; display: -ms-flexbox; display: flex;');
        element.innerHTML = '<span style="display: block;">hello</span>';
        return element.querySelector('span');
    }
};
// fieldset[tabindex=0][disabled] should not be focusable, but Blink and WebKit disagree
// @specification https://www.w3.org/TR/html5/disabled-elements.html#concept-element-disabled
// @browser-issue Chromium https://crbug.com/453847
// @browser-issue WebKit https://bugs.webkit.org/show_bug.cgi?id=141086
var focusFieldsetDisabled = {
    element: 'fieldset',
    mutate: function mutate(element) {
        element.setAttribute('tabindex', 0);
        element.setAttribute('disabled', 'disabled');
    }
};
var focusFieldset = {
    element: 'fieldset',
    mutate: function mutate(element) {
        element.innerHTML = '<legend>legend</legend><p>content</p>';
    }
};
// elements with display:flex are focusable in IE10-11
var focusFlexboxContainer = {
    element: 'span',
    mutate: function mutate(element) {
        element.setAttribute('style', 'display: -webkit-flex; display: -ms-flexbox; display: flex;');
        element.innerHTML = '<span style="display: block;">hello</span>';
    }
};
// form[tabindex=0][disabled] should be focusable as the
// specification doesn't know the disabled attribute on the form element
// @specification https://www.w3.org/TR/html5/forms.html#the-form-element
var focusFormDisabled = {
    element: 'form',
    mutate: function mutate(element) {
        element.setAttribute('tabindex', 0);
        element.setAttribute('disabled', 'disabled');
    }
};
// NOTE: https://github.com/medialize/ally.js/issues/35
// fixes https://github.com/medialize/ally.js/issues/20
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-ismap
var focusImgIsmap = {
    element: 'a',
    mutate: function mutate(element) {
        element.href = '#void';
        element.innerHTML = '<img ismap src="' + gif + '" alt="">';
        return element.querySelector('img');
    }
};
// NOTE: https://github.com/medialize/ally.js/issues/35
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
var focusImgUsemapTabindex = {
    element: 'div',
    mutate: function mutate(element) {
        element.innerHTML =
            '<map name="image-map-tabindex-test"><area href="#void" shape="rect" coords="63,19,144,45"></map>' +
                '<img usemap="#image-map-tabindex-test" tabindex="-1" alt="" ' +
                'src="' +
                gif +
                '">';
        return element.querySelector('img');
    }
};
var focusInHiddenIframe = {
    element: function element(wrapper, _document) {
        var iframe = _document.createElement('iframe');
        // iframe must be part of the DOM before accessing the contentWindow is possible
        wrapper.appendChild(iframe);
        // create the iframe's default document (<html><head></head><body></body></html>)
        var iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.close();
        return iframe;
    },
    mutate: function mutate(iframe) {
        iframe.style.visibility = 'hidden';
        var iframeDocument = iframe.contentWindow.document;
        var input = iframeDocument.createElement('input');
        iframeDocument.body.appendChild(input);
        return input;
    },
    validate: function validate(iframe) {
        var iframeDocument = iframe.contentWindow.document;
        var focus = iframeDocument.querySelector('input');
        return iframeDocument.activeElement === focus;
    }
};
var result = !platform.is.WEBKIT;
function focusInZeroDimensionObject() {
    return result;
}
// Firefox allows *any* value and treats invalid values like tabindex="-1"
// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
var focusInvalidTabindex = {
    element: 'div',
    mutate: function mutate(element) {
        element.setAttribute('tabindex', 'invalid-value');
    }
};
var focusLabelTabindex = {
    element: 'label',
    mutate: function mutate(element) {
        element.setAttribute('tabindex', '-1');
    },
    validate: function validate(element, focusTarget, _document) {
        // force layout in Chrome 49, otherwise the element won't be focusable
        /* eslint-disable no-unused-vars */
        var variableToPreventDeadCodeElimination = element.offsetHeight;
        /* eslint-enable no-unused-vars */
        element.focus();
        return _document.activeElement === element;
    }
};
var svg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtb' +
    'G5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0ic3ZnIj48dGV4dCB4PSIxMCIgeT0iMjAiIGlkPSJ' +
    'zdmctbGluay10ZXh0Ij50ZXh0PC90ZXh0Pjwvc3ZnPg==';
// Note: IE10 on BrowserStack does not like this test
var focusObjectSvgHidden = {
    element: 'object',
    mutate: function mutate(element) {
        element.setAttribute('type', 'image/svg+xml');
        element.setAttribute('data', svg);
        element.setAttribute('width', '200');
        element.setAttribute('height', '50');
        element.style.visibility = 'hidden';
    }
};
// Note: IE10 on BrowserStack does not like this test
var focusObjectSvg = {
    name: 'can-focus-object-svg',
    element: 'object',
    mutate: function mutate(element) {
        element.setAttribute('type', 'image/svg+xml');
        element.setAttribute('data', svg);
        element.setAttribute('width', '200');
        element.setAttribute('height', '50');
    },
    validate: function validate(element, focusTarget, _document) {
        if (platform.is.GECKO) {
            // Firefox seems to be handling the object creation asynchronously and thereby produces a false negative test result.
            // Because we know Firefox is able to focus object elements referencing SVGs, we simply cheat by sniffing the user agent string
            return true;
        }
        return _document.activeElement === element;
    }
};
// Every Environment except IE9 considers SWF objects focusable
var result$1 = !platform.is.IE9;
function focusObjectSwf() {
    return result$1;
}
var focusRedirectImgUsemap = {
    element: 'div',
    mutate: function mutate(element) {
        element.innerHTML =
            '<map name="focus-redirect-img-usemap"><area href="#void" shape="rect" coords="63,19,144,45"></map>' +
                '<img usemap="#focus-redirect-img-usemap" alt="" ' +
                'src="' +
                gif +
                '">';
        // focus the <img>, not the <div>
        return element.querySelector('img');
    },
    validate: function validate(element, focusTarget, _document) {
        var target = element.querySelector('area');
        return _document.activeElement === target;
    }
};
// see https://jsbin.com/nenirisage/edit?html,js,console,output
var focusRedirectLegend = {
    element: 'fieldset',
    mutate: function mutate(element) {
        element.innerHTML =
            '<legend>legend</legend><input tabindex="-1"><input tabindex="0">';
        // take care of focus in validate();
        return false;
    },
    validate: function validate(element, focusTarget, _document) {
        var focusable = element.querySelector('input[tabindex="-1"]');
        var tabbable = element.querySelector('input[tabindex="0"]');
        // Firefox requires this test to focus the <fieldset> first, while this is not necessary in
        // https://jsbin.com/nenirisage/edit?html,js,console,output
        element.focus();
        element.querySelector('legend').focus();
        return ((_document.activeElement === focusable && 'focusable') ||
            (_document.activeElement === tabbable && 'tabbable') ||
            '');
    }
};
// https://github.com/medialize/ally.js/issues/21
var focusScrollBody = {
    element: 'div',
    mutate: function mutate(element) {
        element.setAttribute('style', 'width: 100px; height: 50px; overflow: auto;');
        element.innerHTML =
            '<div style="width: 500px; height: 40px;">scrollable content</div>';
        return element.querySelector('div');
    }
};
// https://github.com/medialize/ally.js/issues/21
var focusScrollContainerWithoutOverflow = {
    element: 'div',
    mutate: function mutate(element) {
        element.setAttribute('style', 'width: 100px; height: 50px;');
        element.innerHTML =
            '<div style="width: 500px; height: 40px;">scrollable content</div>';
    }
};
// https://github.com/medialize/ally.js/issues/21
var focusScrollContainer = {
    element: 'div',
    mutate: function mutate(element) {
        element.setAttribute('style', 'width: 100px; height: 50px; overflow: auto;');
        element.innerHTML =
            '<div style="width: 500px; height: 40px;">scrollable content</div>';
    }
};
var focusSummary = {
    element: 'details',
    mutate: function mutate(element) {
        element.innerHTML = '<summary>foo</summary><p>content</p>';
        return element.firstElementChild;
    }
};
function makeFocusableForeignObject() {
    var fragment = document.createElement('div');
    fragment.innerHTML =
        '<svg><foreignObject width="30" height="30">\n      <input type="text"/>\n  </foreignObject></svg>';
    return fragment.firstChild.firstChild;
}
function focusSvgForeignObjectHack(element) {
    // Edge13, Edge14: foreignObject focus hack
    // https://jsbin.com/kunehinugi/edit?html,js,output
    // https://jsbin.com/fajagi/3/edit?html,js,output
    var isSvgElement = element.ownerSVGElement || element.nodeName.toLowerCase() === 'svg';
    if (!isSvgElement) {
        return false;
    }
    // inject and focus an <input> element into the SVG element to receive focus
    var foreignObject = makeFocusableForeignObject();
    element.appendChild(foreignObject);
    var input = foreignObject.querySelector('input');
    input.focus();
    // upon disabling the activeElement, IE and Edge
    // will not shift focus to <body> like all the other
    // browsers, but instead find the first focusable
    // ancestor and shift focus to that
    input.disabled = true;
    // clean up
    element.removeChild(foreignObject);
    return true;
}
function generate(element) {
    return ('<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' +
        element +
        '</svg>');
}
function focus(element) {
    if (element.focus) {
        return;
    }
    try {
        HTMLElement.prototype.focus.call(element);
    }
    catch (e) {
        focusSvgForeignObjectHack(element);
    }
}
function validate(element, focusTarget, _document) {
    focus(focusTarget);
    return _document.activeElement === focusTarget;
}
var focusSvgFocusableAttribute = {
    element: 'div',
    mutate: function mutate(element) {
        element.innerHTML = generate('<text focusable="true">a</text>');
        return element.querySelector('text');
    },
    validate: validate
};
var focusSvgTabindexAttribute = {
    element: 'div',
    mutate: function mutate(element) {
        element.innerHTML = generate('<text tabindex="0">a</text>');
        return element.querySelector('text');
    },
    validate: validate
};
var focusSvgNegativeTabindexAttribute = {
    element: 'div',
    mutate: function mutate(element) {
        element.innerHTML = generate('<text tabindex="-1">a</text>');
        return element.querySelector('text');
    },
    validate: validate
};
var focusSvgUseTabindex = {
    element: 'div',
    mutate: function mutate(element) {
        element.innerHTML = generate([
            '<g id="ally-test-target"><a xlink:href="#void"><text>link</text></a></g>',
            '<use xlink:href="#ally-test-target" x="0" y="0" tabindex="-1" />',
        ].join(''));
        return element.querySelector('use');
    },
    validate: validate
};
var focusSvgForeignobjectTabindex = {
    element: 'div',
    mutate: function mutate(element) {
        element.innerHTML = generate('<foreignObject tabindex="-1"><input type="text" /></foreignObject>');
        // Safari 8's quersSelector() can't identify foreignObject, but getElementyByTagName() can
        return (element.querySelector('foreignObject') ||
            element.getElementsByTagName('foreignObject')[0]);
    },
    validate: validate
};
// Firefox seems to be handling the SVG-document-in-iframe creation asynchronously
// and thereby produces a false negative test result. Thus the test is pointless
// and we resort to UA sniffing once again.
// see http://jsbin.com/vunadohoko/1/edit?js,console,output
var result$2 = Boolean(platform.is.GECKO &&
    typeof SVGElement !== 'undefined' &&
    SVGElement.prototype.focus);
function focusSvgInIframe() {
    return result$2;
}
var focusSvg = {
    element: 'div',
    mutate: function mutate(element) {
        element.innerHTML = generate('');
        return element.firstChild;
    },
    validate: validate
};
// Firefox allows *any* value and treats invalid values like tabindex="-1"
// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
var focusTabindexTrailingCharacters = {
    element: 'div',
    mutate: function mutate(element) {
        element.setAttribute('tabindex', '3x');
    }
};
var focusTable = {
    element: 'table',
    mutate: function mutate(element, wrapper, _document) {
        // IE9 has a problem replacing TBODY contents with innerHTML.
        // https://stackoverflow.com/a/8097055/515124
        // element.innerHTML = '<tr><td>cell</td></tr>';
        var fragment = _document.createDocumentFragment();
        fragment.innerHTML = '<tr><td>cell</td></tr>';
        element.appendChild(fragment);
    }
};
var focusVideoWithoutControls = {
    element: 'video',
    mutate: function mutate(element) {
        try {
            // invalid media file can trigger warning in console, data-uri to prevent HTTP request
            element.setAttribute('src', gif);
        }
        catch (e) {
            // IE9 may throw "Error: Not implemented"
        }
    }
};
// https://jsbin.com/vafaba/3/edit?html,js,console,output
var result$3 = platform.is.GECKO || platform.is.TRIDENT || platform.is.EDGE;
function tabsequenceAreaAtImgPosition() {
    return result$3;
}
var testCallbacks = {
    cssShadowPiercingDeepCombinator: cssShadowPiercingDeepCombinator,
    focusInZeroDimensionObject: focusInZeroDimensionObject,
    focusObjectSwf: focusObjectSwf,
    focusSvgInIframe: focusSvgInIframe,
    tabsequenceAreaAtImgPosition: tabsequenceAreaAtImgPosition
};
var testDescriptions = {
    focusAreaImgTabindex: focusAreaImgTabindex,
    focusAreaTabindex: focusAreaTabindex,
    focusAreaWithoutHref: focusAreaWithoutHref,
    focusAudioWithoutControls: focusAudioWithoutControls,
    focusBrokenImageMap: focusBrokenImageMap,
    focusChildrenOfFocusableFlexbox: focusChildrenOfFocusableFlexbox,
    focusFieldsetDisabled: focusFieldsetDisabled,
    focusFieldset: focusFieldset,
    focusFlexboxContainer: focusFlexboxContainer,
    focusFormDisabled: focusFormDisabled,
    focusImgIsmap: focusImgIsmap,
    focusImgUsemapTabindex: focusImgUsemapTabindex,
    focusInHiddenIframe: focusInHiddenIframe,
    focusInvalidTabindex: focusInvalidTabindex,
    focusLabelTabindex: focusLabelTabindex,
    focusObjectSvg: focusObjectSvg,
    focusObjectSvgHidden: focusObjectSvgHidden,
    focusRedirectImgUsemap: focusRedirectImgUsemap,
    focusRedirectLegend: focusRedirectLegend,
    focusScrollBody: focusScrollBody,
    focusScrollContainerWithoutOverflow: focusScrollContainerWithoutOverflow,
    focusScrollContainer: focusScrollContainer,
    focusSummary: focusSummary,
    focusSvgFocusableAttribute: focusSvgFocusableAttribute,
    focusSvgTabindexAttribute: focusSvgTabindexAttribute,
    focusSvgNegativeTabindexAttribute: focusSvgNegativeTabindexAttribute,
    focusSvgUseTabindex: focusSvgUseTabindex,
    focusSvgForeignobjectTabindex: focusSvgForeignobjectTabindex,
    focusSvg: focusSvg,
    focusTabindexTrailingCharacters: focusTabindexTrailingCharacters,
    focusTable: focusTable,
    focusVideoWithoutControls: focusVideoWithoutControls
};
function executeTests() {
    var results = detectFocus(testDescriptions);
    Object.keys(testCallbacks).forEach(function (key) {
        results[key] = testCallbacks[key]();
    });
    return results;
}
var supportsCache = null;
function _supports() {
    if (supportsCache) {
        return supportsCache;
    }
    supportsCache = cache$1.get();
    if (!supportsCache.time) {
        cache$1.set(executeTests());
        supportsCache = cache$1.get();
    }
    return supportsCache;
}
var supports = void 0;
// https://www.w3.org/TR/html5/infrastructure.html#rules-for-parsing-integers
// NOTE: all browsers agree to allow trailing spaces as well
var validIntegerPatternNoTrailing = /^\s*(-|\+)?[0-9]+\s*$/;
var validIntegerPatternWithTrailing = /^\s*(-|\+)?[0-9]+.*$/;
function isValidTabindex(context) {
    if (!supports) {
        supports = _supports();
    }
    var validIntegerPattern = supports.focusTabindexTrailingCharacters
        ? validIntegerPatternWithTrailing
        : validIntegerPatternNoTrailing;
    var element = contextToElement({
        label: 'is/valid-tabindex',
        resolveDocument: true,
        context: context
    });
    // Edge 14 has a capitalization problem on SVG elements,
    // see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9282058/
    var hasTabindex = element.hasAttribute('tabindex');
    var hasTabIndex = element.hasAttribute('tabIndex');
    if (!hasTabindex && !hasTabIndex) {
        return false;
    }
    // older Firefox and Internet Explorer don't support tabindex on SVG elements
    var isSvgElement = element.ownerSVGElement || element.nodeName.toLowerCase() === 'svg';
    if (isSvgElement && !supports.focusSvgTabindexAttribute) {
        return false;
    }
    // @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
    if (supports.focusInvalidTabindex) {
        return true;
    }
    // an element matches the tabindex selector even if its value is invalid
    var tabindex = element.getAttribute(hasTabindex ? 'tabindex' : 'tabIndex');
    // IE11 parses tabindex="" as the value "-32768"
    // @browser-issue Trident https://connect.microsoft.com/IE/feedback/details/1072965
    if (tabindex === '-32768') {
        return false;
    }
    return Boolean(tabindex && validIntegerPattern.test(tabindex));
}
function tabindexValue(element) {
    if (!isValidTabindex(element)) {
        return null;
    }
    // Edge 14 has a capitalization problem on SVG elements,
    // see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9282058/
    var hasTabindex = element.hasAttribute('tabindex');
    var attributeName = hasTabindex ? 'tabindex' : 'tabIndex';
    // @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
    var tabindex = parseInt(element.getAttribute(attributeName), 10);
    return isNaN(tabindex) ? -1 : tabindex;
}
// this is a shared utility file for focus-relevant.js and tabbable.js
// separate testing of this file's functions is not necessary,
// as they're implicitly tested by way of the consumers
function isUserModifyWritable(style) {
    // https://www.w3.org/TR/1999/WD-css3-userint-19990916#user-modify
    // https://github.com/medialize/ally.js/issues/17
    var userModify = style.webkitUserModify || '';
    return Boolean(userModify && userModify.indexOf('write') !== -1);
}
function hasCssOverflowScroll(style) {
    return [
        style.getPropertyValue('overflow'),
        style.getPropertyValue('overflow-x'),
        style.getPropertyValue('overflow-y'),
    ].some(function (overflow) {
        return overflow === 'auto' || overflow === 'scroll';
    });
}
function hasCssDisplayFlex(style) {
    return style.display.indexOf('flex') > -1;
}
function isScrollableContainer(element, nodeName, parentNodeName, parentStyle) {
    if (nodeName !== 'div' && nodeName !== 'span') {
        // Internet Explorer advances scrollable containers and bodies to focusable
        // only if the scrollable container is <div> or <span> - this does *not*
        // happen for <section>, <article>, …
        return false;
    }
    if (parentNodeName &&
        parentNodeName !== 'div' &&
        parentNodeName !== 'span' &&
        !hasCssOverflowScroll(parentStyle)) {
        return false;
    }
    return (element.offsetHeight < element.scrollHeight ||
        element.offsetWidth < element.scrollWidth);
}
var supports$1 = void 0;
function isFocusRelevantRules() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, _ref$except = _ref.except, except = _ref$except === undefined
        ? {
            flexbox: false,
            scrollable: false,
            shadow: false
        }
        : _ref$except;
    if (!supports$1) {
        supports$1 = _supports();
    }
    var element = contextToElement({
        label: 'is/focus-relevant',
        resolveDocument: true,
        context: context
    });
    if (!except.shadow && element.shadowRoot) {
        // a ShadowDOM host receives focus when the focus moves to its content
        return true;
    }
    var nodeName = element.nodeName.toLowerCase();
    if (nodeName === 'input' && element.type === 'hidden') {
        // input[type="hidden"] supports.cannot be focused
        return false;
    }
    if (nodeName === 'input' ||
        nodeName === 'select' ||
        nodeName === 'button' ||
        nodeName === 'textarea') {
        return true;
    }
    if (nodeName === 'legend' && supports$1.focusRedirectLegend) {
        // specifics filtered in is/focusable
        return true;
    }
    if (nodeName === 'label') {
        // specifics filtered in is/focusable
        return true;
    }
    if (nodeName === 'area') {
        // specifics filtered in is/focusable
        return true;
    }
    if (nodeName === 'a' && element.hasAttribute('href')) {
        return true;
    }
    if (nodeName === 'object' && element.hasAttribute('usemap')) {
        // object[usemap] is not focusable in any browser
        return false;
    }
    if (nodeName === 'object') {
        var svgType = element.getAttribute('type');
        if (!supports$1.focusObjectSvg && svgType === 'image/svg+xml') {
            // object[type="image/svg+xml"] is not focusable in Internet Explorer
            return false;
        }
        else if (!supports$1.focusObjectSwf &&
            svgType === 'application/x-shockwave-flash') {
            // object[type="application/x-shockwave-flash"] is not focusable in Internet Explorer 9
            return false;
        }
    }
    if (nodeName === 'iframe' || nodeName === 'object') {
        // browsing context containers
        return true;
    }
    if (nodeName === 'embed' || nodeName === 'keygen') {
        // embed is considered focus-relevant but not focusable
        // see https://github.com/medialize/ally.js/issues/82
        return true;
    }
    if (element.hasAttribute('contenteditable')) {
        // also see CSS property user-modify below
        return true;
    }
    if (nodeName === 'audio' &&
        (supports$1.focusAudioWithoutControls || element.hasAttribute('controls'))) {
        return true;
    }
    if (nodeName === 'video' &&
        (supports$1.focusVideoWithoutControls || element.hasAttribute('controls'))) {
        return true;
    }
    if (supports$1.focusSummary && nodeName === 'summary') {
        return true;
    }
    var validTabindex = isValidTabindex(element);
    if (nodeName === 'img' && element.hasAttribute('usemap')) {
        // Gecko, Trident and Edge do not allow an image with an image map and tabindex to be focused,
        // it appears the tabindex is overruled so focus is still forwarded to the <map>
        return ((validTabindex && supports$1.focusImgUsemapTabindex) ||
            supports$1.focusRedirectImgUsemap);
    }
    if (supports$1.focusTable && (nodeName === 'table' || nodeName === 'td')) {
        // IE10-11 supports.can focus <table> and <td>
        return true;
    }
    if (supports$1.focusFieldset && nodeName === 'fieldset') {
        // IE10-11 supports.can focus <fieldset>
        return true;
    }
    var isSvgElement = nodeName === 'svg';
    var isSvgContent = element.ownerSVGElement;
    var focusableAttribute = element.getAttribute('focusable');
    var tabindex = tabindexValue(element);
    if (nodeName === 'use' &&
        tabindex !== null &&
        !supports$1.focusSvgUseTabindex) {
        // <use> cannot be made focusable by adding a tabindex attribute anywhere but Blink and WebKit
        return false;
    }
    if (nodeName === 'foreignobject') {
        // <use> can only be made focusable in Blink and WebKit
        return tabindex !== null && supports$1.focusSvgForeignobjectTabindex;
    }
    if (elementMatches(element, 'svg a') && element.hasAttribute('xlink:href')) {
        return true;
    }
    if ((isSvgElement || isSvgContent) &&
        element.focus &&
        !supports$1.focusSvgNegativeTabindexAttribute &&
        tabindex < 0) {
        // Firefox 51 and 52 treat any natively tabbable SVG element with
        // tabindex="-1" as tabbable and everything else as inert
        // see https://bugzilla.mozilla.org/show_bug.cgi?id=1302340
        return false;
    }
    if (isSvgElement) {
        return (validTabindex ||
            supports$1.focusSvg ||
            supports$1.focusSvgInIframe ||
            // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2
            Boolean(supports$1.focusSvgFocusableAttribute &&
                focusableAttribute &&
                focusableAttribute === 'true'));
    }
    if (isSvgContent) {
        if (supports$1.focusSvgTabindexAttribute && validTabindex) {
            return true;
        }
        if (supports$1.focusSvgFocusableAttribute) {
            // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2
            return focusableAttribute === 'true';
        }
    }
    // https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
    if (validTabindex) {
        return true;
    }
    var style = window.getComputedStyle(element, null);
    if (isUserModifyWritable(style)) {
        return true;
    }
    if (supports$1.focusImgIsmap &&
        nodeName === 'img' &&
        element.hasAttribute('ismap')) {
        // IE10-11 considers the <img> in <a href><img ismap> focusable
        // https://github.com/medialize/ally.js/issues/20
        var hasLinkParent = getParents({ context: element }).some(function (parent) {
            return (parent.nodeName.toLowerCase() === 'a' && parent.hasAttribute('href'));
        });
        if (hasLinkParent) {
            return true;
        }
    }
    // https://github.com/medialize/ally.js/issues/21
    if (!except.scrollable && supports$1.focusScrollContainer) {
        if (supports$1.focusScrollContainerWithoutOverflow) {
            // Internet Explorer does will consider the scrollable area focusable
            // if the element is a <div> or a <span> and it is in fact scrollable,
            // regardless of the CSS overflow property
            if (isScrollableContainer(element, nodeName)) {
                return true;
            }
        }
        else if (hasCssOverflowScroll(style)) {
            // Firefox requires proper overflow setting, IE does not necessarily
            // https://developer.mozilla.org/en-US/docs/Web/CSS/overflow
            return true;
        }
    }
    if (!except.flexbox &&
        supports$1.focusFlexboxContainer &&
        hasCssDisplayFlex(style)) {
        // elements with display:flex are focusable in IE10-11
        return true;
    }
    var parent = element.parentElement;
    if (!except.scrollable && parent) {
        var parentNodeName = parent.nodeName.toLowerCase();
        var parentStyle = window.getComputedStyle(parent, null);
        if (supports$1.focusScrollBody &&
            isScrollableContainer(parent, nodeName, parentNodeName, parentStyle)) {
            // scrollable bodies are focusable Internet Explorer
            // https://github.com/medialize/ally.js/issues/21
            return true;
        }
        // Children of focusable elements with display:flex are focusable in IE10-11
        if (supports$1.focusChildrenOfFocusableFlexbox) {
            if (hasCssDisplayFlex(parentStyle)) {
                return true;
            }
        }
    }
    // NOTE: elements marked as inert are not focusable,
    // but that property is not exposed to the DOM
    // https://www.w3.org/TR/html5/editing.html#inert
    return false;
}
// bind exceptions to an iterator callback
isFocusRelevantRules.except = function () {
    var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var isFocusRelevant = function isFocusRelevant(context) {
        return isFocusRelevantRules({
            context: context,
            except: except
        });
    };
    isFocusRelevant.rules = isFocusRelevantRules;
    return isFocusRelevant;
};
// provide isFocusRelevant(context) as default iterator callback
var isFocusRelevant = isFocusRelevantRules.except({});
function findIndex(array, callback) {
    // attempt to use native or polyfilled Array#findIndex first
    if (array.findIndex) {
        return array.findIndex(callback);
    }
    var length = array.length;
    // shortcut if the array is empty
    if (length === 0) {
        return -1;
    }
    // otherwise loop over array
    for (var i = 0; i < length; i++) {
        if (callback(array[i], i, array)) {
            return i;
        }
    }
    return -1;
}
function getContentDocument(node) {
    try {
        // works on <object> and <iframe>
        return (node.contentDocument ||
            // works on <object> and <iframe>
            (node.contentWindow && node.contentWindow.document) ||
            // works on <object> and <iframe> that contain SVG
            (node.getSVGDocument && node.getSVGDocument()) ||
            null);
    }
    catch (e) {
        // SecurityError: Failed to read the 'contentDocument' property from 'HTMLObjectElement'
        // also IE may throw member not found exception e.g. on <object type="image/png">
        return null;
    }
}
function getWindow(node) {
    var _document = getDocument(node);
    return _document.defaultView || window;
}
var shadowPrefix = void 0;
function selectInShadows(selector) {
    if (typeof shadowPrefix !== 'string') {
        var operator = cssShadowPiercingDeepCombinator();
        if (operator) {
            shadowPrefix = ', html ' + operator + ' ';
        }
    }
    if (!shadowPrefix) {
        return selector;
    }
    return (selector +
        shadowPrefix +
        selector
            .replace(/\s*,\s*/g, ',')
            .split(',')
            .join(shadowPrefix));
}
var selector = void 0;
function findDocumentHostElement(_window) {
    if (!selector) {
        selector = selectInShadows('object, iframe');
    }
    if (_window._frameElement !== undefined) {
        return _window._frameElement;
    }
    _window._frameElement = null;
    var potentialHosts = _window.parent.document.querySelectorAll(selector);
    [].some.call(potentialHosts, function (element) {
        var _document = getContentDocument(element);
        if (_document !== _window.document) {
            return false;
        }
        _window._frameElement = element;
        return true;
    });
    return _window._frameElement;
}
function getFrameElement(element) {
    var _window = getWindow(element);
    if (!_window.parent || _window.parent === _window) {
        // if there is no parent browsing context,
        // we're not going to get a frameElement either way
        return null;
    }
    try {
        // see https://developer.mozilla.org/en-US/docs/Web/API/Window/frameElement
        // does not work within <embed> anywhere, and not within in <object> in IE
        return _window.frameElement || findDocumentHostElement(_window);
    }
    catch (e) {
        return null;
    }
}
// https://www.w3.org/TR/html5/rendering.html#being-rendered
// <area> is not rendered, but we *consider* it visible to simplfiy this function's usage
var notRenderedElementsPattern = /^(area)$/;
function computedStyle(element, property) {
    return window.getComputedStyle(element, null).getPropertyValue(property);
}
function notDisplayed(_path) {
    return _path.some(function (element) {
        // display:none is not visible (optimized away at layout)
        return computedStyle(element, 'display') === 'none';
    });
}
function notVisible(_path) {
    // https://github.com/jquery/jquery-ui/blob/master/ui/core.js#L109-L114
    // NOTE: a nested element can reverse visibility:hidden|collapse by explicitly setting visibility:visible
    // NOTE: visibility can be ["", "visible", "hidden", "collapse"]
    var hidden = findIndex(_path, function (element) {
        var visibility = computedStyle(element, 'visibility');
        return visibility === 'hidden' || visibility === 'collapse';
    });
    if (hidden === -1) {
        // there is no hidden element
        return false;
    }
    var visible = findIndex(_path, function (element) {
        return computedStyle(element, 'visibility') === 'visible';
    });
    if (visible === -1) {
        // there is no visible element (but a hidden element)
        return true;
    }
    if (hidden < visible) {
        // there is a hidden element and it's closer than the first visible element
        return true;
    }
    // there may be a hidden element, but the closest element is visible
    return false;
}
function collapsedParent(_path) {
    var offset = 1;
    if (_path[0].nodeName.toLowerCase() === 'summary') {
        offset = 2;
    }
    return _path.slice(offset).some(function (element) {
        // "content children" of a closed details element are not visible
        return (element.nodeName.toLowerCase() === 'details' && element.open === false);
    });
}
function isVisibleRules() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, _ref$except = _ref.except, except = _ref$except === undefined
        ? {
            notRendered: false,
            cssDisplay: false,
            cssVisibility: false,
            detailsElement: false,
            browsingContext: false
        }
        : _ref$except;
    var element = contextToElement({
        label: 'is/visible',
        resolveDocument: true,
        context: context
    });
    var nodeName = element.nodeName.toLowerCase();
    if (!except.notRendered && notRenderedElementsPattern.test(nodeName)) {
        return true;
    }
    var _path = getParents({ context: element });
    // in Internet Explorer <audio> has a default display: none, where others have display: inline
    // but IE allows focusing <audio style="display:none">, but not <div display:none><audio>
    // this is irrelevant to other browsers, as the controls attribute is required to make <audio> focusable
    var isAudioWithoutControls = nodeName === 'audio' && !element.hasAttribute('controls');
    if (!except.cssDisplay &&
        notDisplayed(isAudioWithoutControls ? _path.slice(1) : _path)) {
        return false;
    }
    if (!except.cssVisibility && notVisible(_path)) {
        return false;
    }
    if (!except.detailsElement && collapsedParent(_path)) {
        return false;
    }
    if (!except.browsingContext) {
        // elements within a browsing context are affected by the
        // browsing context host element's visibility and tabindex
        var frameElement = getFrameElement(element);
        var _isVisible = isVisibleRules.except(except);
        if (frameElement && !_isVisible(frameElement)) {
            return false;
        }
    }
    return true;
}
// bind exceptions to an iterator callback
isVisibleRules.except = function () {
    var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var isVisible = function isVisible(context) {
        return isVisibleRules({
            context: context,
            except: except
        });
    };
    isVisible.rules = isVisibleRules;
    return isVisible;
};
// provide isVisible(context) as default iterator callback
var isVisible = isVisibleRules.except({});
function getMapByName(name, _document) {
    // apparently getElementsByName() also considers id attribute in IE & opera
    // https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName
    var map = _document.querySelector('map[name="' + css_escape_1["default"](name) + '"]');
    return map || null;
}
function getImageOfArea(element) {
    var map = element.parentElement;
    if (!map.name || map.nodeName.toLowerCase() !== 'map') {
        return null;
    }
    // NOTE: image maps can also be applied to <object> with image content,
    // but no browser supports this at the moment
    // HTML5 specifies HTMLMapElement.images to be an HTMLCollection of all
    // <img> and <object> referencing the <map> element, but no browser implements this
    //   https://www.w3.org/TR/html5/embedded-content-0.html#the-map-element
    //   https://developer.mozilla.org/en-US/docs/Web/API/HTMLMapElement
    // the image must be valid and loaded for the map to take effect
    var _document = getDocument(element);
    return (_document.querySelector('img[usemap="#' + css_escape_1["default"](map.name) + '"]') ||
        null);
}
var supports$2 = void 0;
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
// https://github.com/jquery/jquery-ui/blob/master/ui/core.js#L88-L107
function isValidArea(context) {
    if (!supports$2) {
        supports$2 = _supports();
    }
    var element = contextToElement({
        label: 'is/valid-area',
        context: context
    });
    var nodeName = element.nodeName.toLowerCase();
    if (nodeName !== 'area') {
        return false;
    }
    var hasTabindex = element.hasAttribute('tabindex');
    if (!supports$2.focusAreaTabindex && hasTabindex) {
        // Blink and WebKit do not consider <area tabindex="-1" href="#void"> focusable
        return false;
    }
    var img = getImageOfArea(element);
    if (!img || !isVisible(img)) {
        return false;
    }
    // Firefox only allows fully loaded images to reference image maps
    // https://stereochro.me/ideas/detecting-broken-images-js
    if (!supports$2.focusBrokenImageMap &&
        (!img.complete ||
            !img.naturalHeight ||
            img.offsetWidth <= 0 ||
            img.offsetHeight <= 0)) {
        return false;
    }
    // Firefox supports.can focus area elements even if they don't have an href attribute
    if (!supports$2.focusAreaWithoutHref && !element.href) {
        // Internet explorer supports.can focus area elements without href if either
        // the area element or the image element has a tabindex attribute
        return ((supports$2.focusAreaTabindex && hasTabindex) ||
            (supports$2.focusAreaImgTabindex && img.hasAttribute('tabindex')));
    }
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
    var childOfInteractive = getParents({ context: img })
        .slice(1)
        .some(function (_element) {
        var name = _element.nodeName.toLowerCase();
        return name === 'button' || name === 'a';
    });
    if (childOfInteractive) {
        return false;
    }
    return true;
}
var supports$3 = void 0;
// https://www.w3.org/TR/html5/disabled-elements.html#concept-element-disabled
var disabledElementsPattern = void 0;
var disabledElements = {
    input: true,
    select: true,
    textarea: true,
    button: true,
    fieldset: true,
    form: true
};
function isNativeDisabledSupported(context) {
    if (!supports$3) {
        supports$3 = _supports();
        if (supports$3.focusFieldsetDisabled) {
            delete disabledElements.fieldset;
        }
        if (supports$3.focusFormDisabled) {
            delete disabledElements.form;
        }
        disabledElementsPattern = new RegExp('^(' + Object.keys(disabledElements).join('|') + ')$');
    }
    var element = contextToElement({
        label: 'is/native-disabled-supported',
        context: context
    });
    var nodeName = element.nodeName.toLowerCase();
    return Boolean(disabledElementsPattern.test(nodeName));
}
var supports$4 = void 0;
function isDisabledFieldset(element) {
    var nodeName = element.nodeName.toLowerCase();
    return nodeName === 'fieldset' && element.disabled;
}
function isDisabledForm(element) {
    var nodeName = element.nodeName.toLowerCase();
    return nodeName === 'form' && element.disabled;
}
function isDisabled(context) {
    if (!supports$4) {
        supports$4 = _supports();
    }
    var element = contextToElement({
        label: 'is/disabled',
        context: context
    });
    if (element.hasAttribute('data-ally-disabled')) {
        // treat ally's element/disabled like the DOM native element.disabled
        return true;
    }
    if (!isNativeDisabledSupported(element)) {
        // non-form elements do not support the disabled attribute
        return false;
    }
    if (element.disabled) {
        // the element itself is disabled
        return true;
    }
    var parents = getParents({ context: element });
    if (parents.some(isDisabledFieldset)) {
        // a parental <fieldset> is disabld and inherits the state onto this element
        return true;
    }
    if (!supports$4.focusFormDisabled && parents.some(isDisabledForm)) {
        // a parental <form> is disabld and inherits the state onto this element
        return true;
    }
    return false;
}
function isOnlyTabbableRules() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, _ref$except = _ref.except, except = _ref$except === undefined
        ? {
            onlyFocusableBrowsingContext: false,
            visible: false
        }
        : _ref$except;
    var element = contextToElement({
        label: 'is/only-tabbable',
        resolveDocument: true,
        context: context
    });
    if (!except.visible && !isVisible(element)) {
        return false;
    }
    if (!except.onlyFocusableBrowsingContext &&
        (platform.is.GECKO || platform.is.TRIDENT || platform.is.EDGE)) {
        var frameElement = getFrameElement(element);
        if (frameElement) {
            if (tabindexValue(frameElement) < 0) {
                // iframe[tabindex="-1"] and object[tabindex="-1"] inherit the
                // tabbable demotion onto elements of their browsing contexts
                return false;
            }
        }
    }
    var nodeName = element.nodeName.toLowerCase();
    var tabindex = tabindexValue(element);
    if (nodeName === 'label' && platform.is.GECKO) {
        // Firefox cannot focus, but tab to: label[tabindex=0]
        return tabindex !== null && tabindex >= 0;
    }
    // SVG Elements were keyboard focusable but not script focusable before Firefox 51.
    // Firefox 51 added the focus management DOM API (.focus and .blur) to SVGElement,
    // see https://bugzilla.mozilla.org/show_bug.cgi?id=778654
    if (platform.is.GECKO && element.ownerSVGElement && !element.focus) {
        if (nodeName === 'a' && element.hasAttribute('xlink:href')) {
            // any focusable child of <svg> cannot be focused, but tabbed to
            if (platform.is.GECKO) {
                return true;
            }
        }
    }
    return false;
}
// bind exceptions to an iterator callback
isOnlyTabbableRules.except = function () {
    var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var isOnlyTabbable = function isOnlyTabbable(context) {
        return isOnlyTabbableRules({
            context: context,
            except: except
        });
    };
    isOnlyTabbable.rules = isOnlyTabbableRules;
    return isOnlyTabbable;
};
// provide isOnlyTabbable(context) as default iterator callback
var isOnlyTabbable = isOnlyTabbableRules.except({});
var supports$5 = void 0;
function isOnlyFocusRelevant(element) {
    var nodeName = element.nodeName.toLowerCase();
    if (nodeName === 'embed' || nodeName === 'keygen') {
        // embed is considered focus-relevant but not focusable
        // see https://github.com/medialize/ally.js/issues/82
        return true;
    }
    var _tabindex = tabindexValue(element);
    if (element.shadowRoot && _tabindex === null) {
        // ShadowDOM host elements *may* receive focus
        // even though they are not considered focuable
        return true;
    }
    if (nodeName === 'label') {
        // <label tabindex="0"> is only tabbable in Firefox, not script-focusable
        // there's no way to make an element focusable other than by adding a tabindex,
        // and focus behavior of the label element seems hard-wired to ignore tabindex
        // in some browsers (like Gecko, Blink and WebKit)
        return !supports$5.focusLabelTabindex || _tabindex === null;
    }
    if (nodeName === 'legend') {
        return _tabindex === null;
    }
    if (supports$5.focusSvgFocusableAttribute &&
        (element.ownerSVGElement || nodeName === 'svg')) {
        // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2
        var focusableAttribute = element.getAttribute('focusable');
        return focusableAttribute && focusableAttribute === 'false';
    }
    if (nodeName === 'img' && element.hasAttribute('usemap')) {
        // Gecko, Trident and Edge do not allow an image with an image map and tabindex to be focused,
        // it appears the tabindex is overruled so focus is still forwarded to the <map>
        return _tabindex === null || !supports$5.focusImgUsemapTabindex;
    }
    if (nodeName === 'area') {
        // all <area>s are considered relevant,
        // but only the valid <area>s are focusable
        return !isValidArea(element);
    }
    return false;
}
function isFocusableRules() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, _ref$except = _ref.except, except = _ref$except === undefined
        ? {
            disabled: false,
            visible: false,
            onlyTabbable: false
        }
        : _ref$except;
    if (!supports$5) {
        supports$5 = _supports();
    }
    var _isOnlyTabbable = isOnlyTabbable.rules.except({
        onlyFocusableBrowsingContext: true,
        visible: except.visible
    });
    var element = contextToElement({
        label: 'is/focusable',
        resolveDocument: true,
        context: context
    });
    var focusRelevant = isFocusRelevant.rules({
        context: element,
        except: except
    });
    if (!focusRelevant || isOnlyFocusRelevant(element)) {
        return false;
    }
    if (!except.disabled && isDisabled(element)) {
        return false;
    }
    if (!except.onlyTabbable && _isOnlyTabbable(element)) {
        // some elements may be keyboard focusable, but not script focusable
        return false;
    }
    // elements that are not rendered, cannot be focused
    if (!except.visible) {
        var visibilityOptions = {
            context: element,
            except: {}
        };
        if (supports$5.focusInHiddenIframe) {
            // WebKit and Blink can focus content in hidden <iframe> and <object>
            visibilityOptions.except.browsingContext = true;
        }
        if (supports$5.focusObjectSvgHidden) {
            // Blink allows focusing the object element, even if it has visibility: hidden;
            // @browser-issue Blink https://code.google.com/p/chromium/issues/detail?id=586191
            var _nodeName2 = element.nodeName.toLowerCase();
            if (_nodeName2 === 'object') {
                visibilityOptions.except.cssVisibility = true;
            }
        }
        if (!isVisible.rules(visibilityOptions)) {
            return false;
        }
    }
    var frameElement = getFrameElement(element);
    if (frameElement) {
        var _nodeName = frameElement.nodeName.toLowerCase();
        if (_nodeName === 'object' && !supports$5.focusInZeroDimensionObject) {
            if (!frameElement.offsetWidth || !frameElement.offsetHeight) {
                // WebKit can not focus content in <object> if it doesn't have dimensions
                return false;
            }
        }
    }
    var nodeName = element.nodeName.toLowerCase();
    if (nodeName === 'svg' &&
        supports$5.focusSvgInIframe &&
        !frameElement &&
        element.getAttribute('tabindex') === null) {
        return false;
    }
    return true;
}
// bind exceptions to an iterator callback
isFocusableRules.except = function () {
    var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var isFocusable = function isFocusable(context) {
        return isFocusableRules({
            context: context,
            except: except
        });
    };
    isFocusable.rules = isFocusableRules;
    return isFocusable;
};
// provide isFocusRelevant(context) as default iterator callback
var isFocusable = isFocusableRules.except({});
function createFilter(condition) {
    // see https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter
    var filter = function filter(node) {
        if (node.shadowRoot) {
            // return ShadowRoot elements regardless of them being focusable,
            // so they can be walked recursively later
            return NodeFilter.FILTER_ACCEPT;
        }
        if (condition(node)) {
            // finds elements that could have been found by document.querySelectorAll()
            return NodeFilter.FILTER_ACCEPT;
        }
        return NodeFilter.FILTER_SKIP;
    };
    // IE requires a function, Browsers require {acceptNode: function}
    // see http://www.bennadel.com/blog/2607-finding-html-comment-nodes-in-the-dom-using-treewalker.htm
    filter.acceptNode = filter;
    return filter;
}
var PossiblyFocusableFilter = createFilter(isFocusRelevant);
function queryFocusableStrict() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, includeContext = _ref.includeContext, includeOnlyTabbable = _ref.includeOnlyTabbable, strategy = _ref.strategy;
    if (!context) {
        context = document.documentElement;
    }
    var _isFocusable = isFocusable.rules.except({
        onlyTabbable: includeOnlyTabbable
    });
    var _document = getDocument(context);
    // see https://developer.mozilla.org/en-US/docs/Web/API/Document/createTreeWalker
    var walker = _document.createTreeWalker(
    // root element to start search in
    context, 
    // element type filter
    NodeFilter.SHOW_ELEMENT, 
    // custom NodeFilter filter
    strategy === 'all' ? PossiblyFocusableFilter : createFilter(_isFocusable), 
    // deprecated, but IE requires it
    false);
    var list = [];
    while (walker.nextNode()) {
        if (walker.currentNode.shadowRoot) {
            if (_isFocusable(walker.currentNode)) {
                list.push(walker.currentNode);
            }
            list = list.concat(queryFocusableStrict({
                context: walker.currentNode.shadowRoot,
                includeOnlyTabbable: includeOnlyTabbable,
                strategy: strategy
            }));
        }
        else {
            list.push(walker.currentNode);
        }
    }
    // add context if requested and focusable
    if (includeContext) {
        if (strategy === 'all') {
            if (isFocusRelevant(context)) {
                list.unshift(context);
            }
        }
        else if (_isFocusable(context)) {
            list.unshift(context);
        }
    }
    return list;
}
// NOTE: this selector MUST *never* be used directly,
var supports$6 = void 0;
var selector$1 = void 0;
function selector$2() {
    if (!supports$6) {
        supports$6 = _supports();
    }
    if (typeof selector$1 === 'string') {
        return selector$1;
    }
    // https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
    selector$1 =
        '' +
            // IE11 supports.can focus <table> and <td>
            (supports$6.focusTable ? 'table, td,' : '') +
            // IE11 supports.can focus <fieldset>
            (supports$6.focusFieldset ? 'fieldset,' : '') +
            // Namespace problems of [xlink:href] explained in https://stackoverflow.com/a/23047888/515124
            // svg a[*|href] does not match in IE9, but since we're filtering
            // through is/focusable we can include all <a> from SVG
            'svg a,' +
            // may behave as 'svg, svg *,' in chrome as *every* svg element with a focus event listener is focusable
            // navigational elements
            'a[href],' +
            // validity determined by is/valid-area.js
            'area[href],' +
            // validity determined by is/disabled.js
            'input, select, textarea, button,' +
            // browsing context containers
            'iframe, object, embed,' +
            // interactive content
            'keygen,' +
            (supports$6.focusAudioWithoutControls ? 'audio,' : 'audio[controls],') +
            (supports$6.focusVideoWithoutControls ? 'video,' : 'video[controls],') +
            (supports$6.focusSummary ? 'summary,' : '') +
            // validity determined by is/valid-tabindex.js
            '[tabindex],' +
            // editing hosts
            '[contenteditable]';
    // where ShadowDOM is supported, we also want the shadowed focusable elements (via ">>>" or "/deep/")
    selector$1 = selectInShadows(selector$1);
    return selector$1;
}
function queryFocusableQuick() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, includeContext = _ref.includeContext, includeOnlyTabbable = _ref.includeOnlyTabbable;
    var _selector = selector$2();
    var elements = context.querySelectorAll(_selector);
    // the selector potentially matches more than really is focusable
    var _isFocusable = isFocusable.rules.except({
        onlyTabbable: includeOnlyTabbable
    });
    var result = [].filter.call(elements, _isFocusable);
    // add context if requested and focusable
    if (includeContext && _isFocusable(context)) {
        result.unshift(context);
    }
    return result;
}
function queryFocusable() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, includeContext = _ref.includeContext, includeOnlyTabbable = _ref.includeOnlyTabbable, _ref$strategy = _ref.strategy, strategy = _ref$strategy === undefined ? 'quick' : _ref$strategy;
    var element = contextToElement({
        label: 'query/focusable',
        resolveDocument: true,
        defaultToDocument: true,
        context: context
    });
    var options = {
        context: element,
        includeContext: includeContext,
        includeOnlyTabbable: includeOnlyTabbable,
        strategy: strategy
    };
    if (strategy === 'quick') {
        return queryFocusableQuick(options);
    }
    else if (strategy === 'strict' || strategy === 'all') {
        return queryFocusableStrict(options);
    }
    throw new TypeError('query/focusable requires option.strategy to be one of ["quick", "strict", "all"]');
}
var supports$7 = void 0;
// Internet Explorer 11 considers fieldset, table, td focusable, but not tabbable
// Internet Explorer 11 considers body to have [tabindex=0], but does not allow tabbing to it
var focusableElementsPattern = /^(fieldset|table|td|body)$/;
function isTabbableRules() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, _ref$except = _ref.except, except = _ref$except === undefined
        ? {
            flexbox: false,
            scrollable: false,
            shadow: false,
            visible: false,
            onlyTabbable: false
        }
        : _ref$except;
    if (!supports$7) {
        supports$7 = _supports();
    }
    var element = contextToElement({
        label: 'is/tabbable',
        resolveDocument: true,
        context: context
    });
    if (platform.is.BLINK && platform.is.ANDROID && platform.majorVersion > 42) {
        // External keyboard support worked fine in CHrome 42, but stopped working in Chrome 45.
        // The on-screen keyboard does not provide a way to focus the next input element (like iOS does).
        // That leaves us with no option to advance focus by keyboard, ergo nothing is tabbable (keyboard focusable).
        return false;
    }
    var frameElement = getFrameElement(element);
    if (frameElement) {
        if (platform.is.WEBKIT && platform.is.IOS) {
            // iOS only does not consider anything from another browsing context keyboard focusable
            return false;
        }
        // iframe[tabindex="-1"] and object[tabindex="-1"] inherit the
        // tabbable demotion onto elements of their browsing contexts
        if (tabindexValue(frameElement) < 0) {
            return false;
        }
        if (!except.visible &&
            (platform.is.BLINK || platform.is.WEBKIT) &&
            !isVisible(frameElement)) {
            // Blink and WebKit consider elements in hidden browsing contexts focusable, but not tabbable
            return false;
        }
        // Webkit and Blink don't consider anything in <object> tabbable
        // Blink fixed that fixed in Chrome 54, Opera 41
        var frameNodeName = frameElement.nodeName.toLowerCase();
        if (frameNodeName === 'object') {
            var isFixedBlink = (platform.name === 'Chrome' && platform.majorVersion >= 54) ||
                (platform.name === 'Opera' && platform.majorVersion >= 41);
            if (platform.is.WEBKIT || (platform.is.BLINK && !isFixedBlink)) {
                return false;
            }
        }
    }
    var nodeName = element.nodeName.toLowerCase();
    var _tabindex = tabindexValue(element);
    var tabindex = _tabindex === null ? null : _tabindex >= 0;
    if (platform.is.EDGE &&
        platform.majorVersion >= 14 &&
        frameElement &&
        element.ownerSVGElement &&
        _tabindex < 0) {
        // Edge 14+ considers <a xlink:href="…" tabindex="-1"> keyboard focusable
        // if the element is in a nested browsing context
        return true;
    }
    var hasTabbableTabindexOrNone = tabindex !== false;
    var hasTabbableTabindex = _tabindex !== null && _tabindex >= 0;
    // NOTE: Firefox 31 considers [contenteditable] to have [tabindex=-1], but allows tabbing to it
    // fixed in Firefox 40 the latest - https://bugzilla.mozilla.org/show_bug.cgi?id=1185657
    if (element.hasAttribute('contenteditable')) {
        // tabbing can still be disabled by explicitly providing [tabindex="-1"]
        return hasTabbableTabindexOrNone;
    }
    if (focusableElementsPattern.test(nodeName) && tabindex !== true) {
        return false;
    }
    if (platform.is.WEBKIT && platform.is.IOS) {
        // iOS only considers a hand full of elements tabbable (keyboard focusable)
        // this holds true even with external keyboards
        var potentiallyTabbable = (nodeName === 'input' && element.type === 'text') ||
            element.type === 'password' ||
            nodeName === 'select' ||
            nodeName === 'textarea' ||
            element.hasAttribute('contenteditable');
        if (!potentiallyTabbable) {
            var style = window.getComputedStyle(element, null);
            potentiallyTabbable = isUserModifyWritable(style);
        }
        if (!potentiallyTabbable) {
            return false;
        }
    }
    if (nodeName === 'use' && _tabindex !== null) {
        if (platform.is.BLINK ||
            (platform.is.WEBKIT && platform.majorVersion === 9)) {
            // In Chrome and Safari 9 the <use> element is keyboard focusable even for tabindex="-1"
            return true;
        }
    }
    if (elementMatches(element, 'svg a') && element.hasAttribute('xlink:href')) {
        if (hasTabbableTabindexOrNone) {
            // in Trident and Gecko SVGElement does not handle the tabIndex property properly
            return true;
        }
        if (element.focus && !supports$7.focusSvgNegativeTabindexAttribute) {
            // Firefox 51 and 52 treat any natively tabbable SVG element with
            // tabindex="-1" as tabbable and everything else as inert
            // see https://bugzilla.mozilla.org/show_bug.cgi?id=1302340
            return true;
        }
    }
    if (nodeName === 'svg' &&
        supports$7.focusSvgInIframe &&
        hasTabbableTabindexOrNone) {
        return true;
    }
    if (platform.is.TRIDENT || platform.is.EDGE) {
        if (nodeName === 'svg') {
            if (supports$7.focusSvg) {
                // older Internet Explorers consider <svg> keyboard focusable
                // unless they have focsable="false", but then they wouldn't
                // be focusable and thus not even reach this filter
                return true;
            }
            // elements that have [focusable] are automatically keyboard focusable regardless of the attribute's value
            return element.hasAttribute('focusable') || hasTabbableTabindex;
        }
        if (element.ownerSVGElement) {
            if (supports$7.focusSvgTabindexAttribute && hasTabbableTabindex) {
                return true;
            }
            // elements that have [focusable] are automatically keyboard focusable regardless of the attribute's value
            return element.hasAttribute('focusable');
        }
    }
    if (element.tabIndex === undefined) {
        return Boolean(except.onlyTabbable);
    }
    if (nodeName === 'audio') {
        if (!element.hasAttribute('controls')) {
            // In Internet Explorer the <audio> element is focusable, but not tabbable, and tabIndex property is wrong
            return false;
        }
        else if (platform.is.BLINK) {
            // In Chrome <audio controls tabindex="-1"> remains keyboard focusable
            return true;
        }
    }
    if (nodeName === 'video') {
        if (!element.hasAttribute('controls')) {
            if (platform.is.TRIDENT || platform.is.EDGE) {
                // In Internet Explorer and Edge the <video> element is focusable, but not tabbable, and tabIndex property is wrong
                return false;
            }
        }
        else if (platform.is.BLINK || platform.is.GECKO) {
            // In Chrome and Firefox <video controls tabindex="-1"> remains keyboard focusable
            return true;
        }
    }
    if (nodeName === 'object') {
        if (platform.is.BLINK || platform.is.WEBKIT) {
            // In all Blink and WebKit based browsers <embed> and <object> are never keyboard focusable, even with tabindex="0" set
            return false;
        }
    }
    if (nodeName === 'iframe') {
        // In Internet Explorer all iframes are only focusable
        // In WebKit, Blink and Gecko iframes may be tabbable depending on content.
        // Since we can't reliably investigate iframe documents because of the
        // SameOriginPolicy, we're declaring everything only focusable.
        return false;
    }
    if (!except.scrollable && platform.is.GECKO) {
        // Firefox considers scrollable containers keyboard focusable,
        // even though their tabIndex property is -1
        var _style = window.getComputedStyle(element, null);
        if (hasCssOverflowScroll(_style)) {
            return hasTabbableTabindexOrNone;
        }
    }
    if (platform.is.TRIDENT || platform.is.EDGE) {
        // IE and Edge degrade <area> to script focusable, if the image
        // using the <map> has been given tabindex="-1"
        if (nodeName === 'area') {
            var img = getImageOfArea(element);
            if (img && tabindexValue(img) < 0) {
                return false;
            }
        }
        var _style2 = window.getComputedStyle(element, null);
        if (isUserModifyWritable(_style2)) {
            // prevent being swallowed by the overzealous isScrollableContainer() below
            return element.tabIndex >= 0;
        }
        if (!except.flexbox && hasCssDisplayFlex(_style2)) {
            if (_tabindex !== null) {
                return hasTabbableTabindex;
            }
            return (isFocusRelevantWithoutFlexbox(element) &&
                isTabbableWithoutFlexbox(element));
        }
        // IE considers scrollable containers script focusable only,
        // even though their tabIndex property is 0
        if (isScrollableContainer(element, nodeName)) {
            return false;
        }
        var parent = element.parentElement;
        if (parent) {
            var parentNodeName = parent.nodeName.toLowerCase();
            var parentStyle = window.getComputedStyle(parent, null);
            // IE considers scrollable bodies script focusable only,
            if (isScrollableContainer(parent, nodeName, parentNodeName, parentStyle)) {
                return false;
            }
            // Children of focusable elements with display:flex are focusable in IE10-11,
            // even though their tabIndex property suggests otherwise
            if (hasCssDisplayFlex(parentStyle)) {
                // value of tabindex takes precedence
                return hasTabbableTabindex;
            }
        }
    }
    // https://www.w3.org/WAI/PF/aria-practices/#focus_tabindex
    return element.tabIndex >= 0;
}
// bind exceptions to an iterator callback
isTabbableRules.except = function () {
    var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var isTabbable = function isTabbable(context) {
        return isTabbableRules({
            context: context,
            except: except
        });
    };
    isTabbable.rules = isTabbableRules;
    return isTabbable;
};
var isFocusRelevantWithoutFlexbox = isFocusRelevant.rules.except({
    flexbox: true
});
var isTabbableWithoutFlexbox = isTabbableRules.except({ flexbox: true });
// provide isTabbable(context) as default iterator callback
var isTabbable = isTabbableRules.except({});
function queryTabbable() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, includeContext = _ref.includeContext, includeOnlyTabbable = _ref.includeOnlyTabbable, strategy = _ref.strategy;
    var _isTabbable = isTabbable.rules.except({
        onlyTabbable: includeOnlyTabbable
    });
    return queryFocusable({
        context: context,
        includeContext: includeContext,
        includeOnlyTabbable: includeOnlyTabbable,
        strategy: strategy
    }).filter(_isTabbable);
}
// sorts a list of elements according to their order in the DOM
function compareDomPosition(a, b) {
    return a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING
        ? -1
        : 1;
}
function sortDomOrder(elements) {
    return elements.sort(compareDomPosition);
}
function getFirstSuccessorOffset(list, target) {
    // find the first element that comes AFTER the target element
    return findIndex(list, function (element) {
        return (target.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_FOLLOWING);
    });
}
function findInsertionOffsets(list, elements, resolveElement) {
    // instead of mutating the elements list directly, remember position and map
    // to inject later, when we can do this more efficiently
    var insertions = [];
    elements.forEach(function (element) {
        var replace = true;
        var offset = list.indexOf(element);
        if (offset === -1) {
            // element is not in target list
            offset = getFirstSuccessorOffset(list, element);
            replace = false;
        }
        if (offset === -1) {
            // there is no successor in the tabsequence,
            // meaning the image must be the last element
            offset = list.length;
        }
        // allow the consumer to replace the injected element
        var injections = nodeArray(resolveElement ? resolveElement(element) : element);
        if (!injections.length) {
            // we can't inject zero elements
            return;
        }
        insertions.push({
            offset: offset,
            replace: replace,
            elements: injections
        });
    });
    return insertions;
}
function insertElementsAtOffsets(list, insertions) {
    // remember the number of elements we have already injected
    // so we account for the caused index offset
    var inserted = 0;
    // make sure that we insert the elements in sequence,
    // otherwise the offset compensation won't work
    insertions.sort(function (a, b) {
        return a.offset - b.offset;
    });
    insertions.forEach(function (insertion) {
        // array.splice has an annoying function signature :(
        var remove = insertion.replace ? 1 : 0;
        var args = [insertion.offset + inserted, remove].concat(insertion.elements);
        list.splice.apply(list, args);
        inserted += insertion.elements.length - remove;
    });
}
function mergeInDomOrder() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, list = _ref.list, elements = _ref.elements, resolveElement = _ref.resolveElement;
    // operate on a copy so we don't mutate the original array
    var _list = list.slice(0);
    // make sure the elements we're injecting are provided in DOM order
    var _elements = nodeArray(elements).slice(0);
    sortDomOrder(_elements);
    // find the offsets within the target array (list) at which to inject
    // each individual element (from elements)
    var insertions = findInsertionOffsets(_list, _elements, resolveElement);
    // actually inject the elements into the target array at the identified positions
    insertElementsAtOffsets(_list, insertions);
    return _list;
}
var _createClass = (function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ('value' in descriptor)
                descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function (Constructor, protoProps, staticProps) {
        if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
            defineProperties(Constructor, staticProps);
        return Constructor;
    };
})();
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
    }
}
var Maps = (function () {
    function Maps(context) {
        _classCallCheck(this, Maps);
        this._document = getDocument(context);
        this.maps = {};
    }
    _createClass(Maps, [
        {
            key: 'getAreasFor',
            value: function getAreasFor(name) {
                if (!this.maps[name]) {
                    // the map is not defined within the context, so we
                    // have to go find it elsewhere in the document
                    this.addMapByName(name);
                }
                return this.maps[name];
            }
        },
        {
            key: 'addMapByName',
            value: function addMapByName(name) {
                var map = getMapByName(name, this._document);
                if (!map) {
                    // if there is no map, the img[usemap] wasn't doing anything anyway
                    return;
                }
                this.maps[map.name] = queryTabbable({ context: map });
            }
        },
        {
            key: 'extractAreasFromList',
            value: function extractAreasFromList(elements) {
                // remove all <area> elements from the elements list,
                // but put them the map for later retrieval
                return elements.filter(function (element) {
                    var nodeName = element.nodeName.toLowerCase();
                    if (nodeName !== 'area') {
                        return true;
                    }
                    var map = element.parentNode;
                    if (!this.maps[map.name]) {
                        this.maps[map.name] = [];
                    }
                    this.maps[map.name].push(element);
                    return false;
                }, this);
            }
        },
    ]);
    return Maps;
})();
function sortArea(elements, context) {
    // images - unless they are focusable themselves, likely not
    // part of the elements list, so we'll have to find them and
    // sort them into the elements list manually
    var usemaps = context.querySelectorAll('img[usemap]');
    var maps = new Maps(context);
    // remove all <area> elements from the elements list,
    // but put them the map for later retrieval
    var _elements = maps.extractAreasFromList(elements);
    if (!usemaps.length) {
        // the context does not contain any <area>s so no need
        // to replace anything, just remove any maps
        return _elements;
    }
    return mergeInDomOrder({
        list: _elements,
        elements: usemaps,
        resolveElement: function resolveElement(image) {
            var name = image.getAttribute('usemap').slice(1);
            return maps.getAreasFor(name);
        }
    });
}
var _createClass$1 = (function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ('value' in descriptor)
                descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function (Constructor, protoProps, staticProps) {
        if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
            defineProperties(Constructor, staticProps);
        return Constructor;
    };
})();
function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
    }
}
var Shadows = (function () {
    function Shadows(context, sortElements) {
        _classCallCheck$1(this, Shadows);
        // document context we're working with
        this.context = context;
        // callback that sorts an array of elements
        this.sortElements = sortElements;
        // reference to create unique IDs for each ShadowHost
        this.hostCounter = 1;
        // reference map for child-ShadowHosts of a ShadowHost
        this.inHost = {};
        // reference map for child-ShadowHost of the document
        this.inDocument = [];
        // reference map for ShadowHosts
        this.hosts = {};
        // reference map for tabbable elements of a ShadowHost
        this.elements = {};
    }
    // remember which hosts we have to sort within later
    _createClass$1(Shadows, [
        {
            key: '_registerHost',
            value: function _registerHost(host) {
                if (host._sortingId) {
                    return;
                }
                // make the ShadowHost identifiable (see cleanup() for undo)
                host._sortingId = 'shadow-' + this.hostCounter++;
                this.hosts[host._sortingId] = host;
                // hosts may contain other hosts
                var parentHost = getShadowHost({ context: host });
                if (parentHost) {
                    this._registerHost(parentHost);
                    this._registerHostParent(host, parentHost);
                }
                else {
                    this.inDocument.push(host);
                }
            }
        },
        {
            key: '_registerHostParent',
            value: function _registerHostParent(host, parent) {
                if (!this.inHost[parent._sortingId]) {
                    this.inHost[parent._sortingId] = [];
                }
                this.inHost[parent._sortingId].push(host);
            }
        },
        {
            key: '_registerElement',
            value: function _registerElement(element, host) {
                if (!this.elements[host._sortingId]) {
                    this.elements[host._sortingId] = [];
                }
                this.elements[host._sortingId].push(element);
            }
        },
        {
            key: 'extractElements',
            value: function extractElements(elements) {
                return elements.filter(function (element) {
                    var host = getShadowHost({ context: element });
                    if (!host) {
                        return true;
                    }
                    this._registerHost(host);
                    this._registerElement(element, host);
                    return false;
                }, this);
            }
        },
        {
            key: 'sort',
            value: function sort(elements) {
                var _elements = this._injectHosts(elements);
                _elements = this._replaceHosts(_elements);
                this._cleanup();
                return _elements;
            }
        },
        {
            key: '_injectHosts',
            value: function _injectHosts(elements) {
                Object.keys(this.hosts).forEach(function (_sortingId) {
                    var _list = this.elements[_sortingId];
                    var _elements = this.inHost[_sortingId];
                    var _context = this.hosts[_sortingId].shadowRoot;
                    this.elements[_sortingId] = this._merge(_list, _elements, _context);
                }, this);
                return this._merge(elements, this.inDocument, this.context);
            }
        },
        {
            key: '_merge',
            value: function _merge(list, elements, context) {
                var merged = mergeInDomOrder({
                    list: list,
                    elements: elements
                });
                return this.sortElements(merged, context);
            }
        },
        {
            key: '_replaceHosts',
            value: function _replaceHosts(elements) {
                return mergeInDomOrder({
                    list: elements,
                    elements: this.inDocument,
                    resolveElement: this._resolveHostElement.bind(this)
                });
            }
        },
        {
            key: '_resolveHostElement',
            value: function _resolveHostElement(host) {
                var merged = mergeInDomOrder({
                    list: this.elements[host._sortingId],
                    elements: this.inHost[host._sortingId],
                    resolveElement: this._resolveHostElement.bind(this)
                });
                var _tabindex = tabindexValue(host);
                if (_tabindex !== null && _tabindex > -1) {
                    return [host].concat(merged);
                }
                return merged;
            }
        },
        {
            key: '_cleanup',
            value: function _cleanup() {
                // remove those identifers we put on the ShadowHost to avoid using Map()
                Object.keys(this.hosts).forEach(function (key) {
                    delete this.hosts[key]._sortingId;
                }, this);
            }
        },
    ]);
    return Shadows;
})();
function sortShadowed(elements, context, sortElements) {
    var shadows = new Shadows(context, sortElements);
    var _elements = shadows.extractElements(elements);
    if (_elements.length === elements.length) {
        // no shadowed content found, no need to continue
        return sortElements(elements);
    }
    return shadows.sort(_elements);
}
function sortTabindex(elements) {
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement.tabIndex
    // elements with tabIndex "0" (including tabbableElements without tabIndex) should be navigated in the order they appear.
    // elements with a positive tabIndex:
    //   Elements that have identical tabIndexes should be navigated in the order they appear.
    //   Navigation proceeds from the lowest tabIndex to the highest tabIndex.
    // NOTE: sort implementation may be unstable and thus mess up DOM order,
    // that's why we build a map that's being sorted instead. If we were able to rely
    // on a stable sorting algorithm, sortTabindex() could be as simple as
    // elements.sort(function(a, b) { return a.tabIndex - b.tabIndex; });
    // at this time Chrome does not use a stable sorting algorithm
    // see http://blog.rodneyrehm.de/archives/14-Sorting-Were-Doing-It-Wrong.html#stability
    // NOTE: compareDocumentPosition seemed like more overhead than just sorting this with buckets
    // https://developer.mozilla.org/en-US/docs/Web/API/Node.compareDocumentPosition
    var map = {};
    var indexes = [];
    var normal = elements.filter(function (element) {
        // in Trident and Gecko SVGElement does not know about the tabIndex property
        var tabIndex = element.tabIndex;
        if (tabIndex === undefined) {
            tabIndex = tabindexValue(element);
        }
        // extract elements that don't need sorting
        if (tabIndex <= 0 || tabIndex === null || tabIndex === undefined) {
            return true;
        }
        if (!map[tabIndex]) {
            // create sortable bucket for dom-order-preservation of elements with the same tabIndex
            map[tabIndex] = [];
            // maintain a list of unique tabIndexes
            indexes.push(tabIndex);
        }
        // sort element into the proper bucket
        map[tabIndex].push(element);
        // element moved to sorting map, so not "normal" anymore
        return false;
    });
    // sort the tabindex ascending,
    // then resolve them to their appropriate buckets,
    // then flatten the array of arrays to an array
    var _elements = indexes
        .sort()
        .map(function (tabIndex) {
        return map[tabIndex];
    })
        .reduceRight(function (previous, current) {
        return current.concat(previous);
    }, normal);
    return _elements;
}
var supports$8 = void 0;
function moveContextToBeginning(elements, context) {
    var pos = elements.indexOf(context);
    if (pos > 0) {
        var tmp = elements.splice(pos, 1);
        return tmp.concat(elements);
    }
    return elements;
}
function sortElements(elements, _context) {
    if (supports$8.tabsequenceAreaAtImgPosition) {
        // Some browsers sort <area> in DOM order, some place the <area>s
        // where the <img> referecing them would've been in DOM order.
        // https://github.com/medialize/ally.js/issues/5
        elements = sortArea(elements, _context);
    }
    elements = sortTabindex(elements);
    return elements;
}
function queryTabsequence() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, context = _ref.context, includeContext = _ref.includeContext, includeOnlyTabbable = _ref.includeOnlyTabbable, strategy = _ref.strategy;
    if (!supports$8) {
        supports$8 = _supports();
    }
    var _context = nodeArray(context)[0] || document.documentElement;
    var elements = queryTabbable({
        context: _context,
        includeContext: includeContext,
        includeOnlyTabbable: includeOnlyTabbable,
        strategy: strategy
    });
    if (document.body.createShadowRoot && platform.is.BLINK) {
        // sort tabindex localized to shadow dom
        // see https://github.com/medialize/ally.js/issues/6
        elements = sortShadowed(elements, _context, sortElements);
    }
    else {
        elements = sortElements(elements, _context);
    }
    if (includeContext) {
        // if we include the context itself, it has to be the first
        // element of the sequence
        elements = moveContextToBeginning(elements, _context);
    }
    return elements;
}
// codes mostly cloned from https://github.com/keithamus/jwerty/blob/master/jwerty.js
// deliberately not exposing characters like <,.-#* because they vary *wildly*
// across keyboard layouts and may cause various problems
// (e.g. "*" is "Shift +" on a German Mac keyboard)
// (e.g. "@" is "Alt L" on a German Mac keyboard)
var keycode = {
    // Element Focus
    tab: 9,
    // Navigation
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    pageUp: 33,
    'page-up': 33,
    pageDown: 34,
    'page-down': 34,
    end: 35,
    home: 36,
    // Action
    enter: 13,
    escape: 27,
    space: 32,
    // Modifier
    shift: 16,
    capsLock: 20,
    'caps-lock': 20,
    ctrl: 17,
    alt: 18,
    meta: 91,
    // in firefox: 224
    // on mac (chrome): meta-left=91, meta-right=93
    // on win (IE11): meta-left=91, meta-right=92
    pause: 19,
    // Content Manipulation
    insert: 45,
    "delete": 46,
    backspace: 8,
    // the same logical key may be identified through different keyCodes
    _alias: {
        91: [92, 93, 224]
    }
};
// Function keys (112 - 137)
// NOTE: not every keyboard knows F13+
for (var n = 1; n < 26; n++) {
    keycode['f' + n] = n + 111;
}
// Number keys (48-57, numpad 96-105)
// NOTE: not every keyboard knows num-0+
for (var _n = 0; _n < 10; _n++) {
    var code = _n + 48;
    var numCode = _n + 96;
    keycode[_n] = code;
    keycode['num-' + _n] = numCode;
    keycode._alias[code] = [numCode];
}
// Latin characters (65 - 90)
for (var _n2 = 0; _n2 < 26; _n2++) {
    var _code = _n2 + 65;
    var name$1 = String.fromCharCode(_code).toLowerCase();
    keycode[name$1] = _code;
}
var modifier = {
    alt: 'altKey',
    ctrl: 'ctrlKey',
    meta: 'metaKey',
    shift: 'shiftKey'
};
var modifierSequence = Object.keys(modifier).map(function (name) {
    return modifier[name];
});
function createExpectedModifiers(ignoreModifiers) {
    var value = ignoreModifiers ? null : false;
    return {
        altKey: value,
        ctrlKey: value,
        metaKey: value,
        shiftKey: value
    };
}
function resolveModifiers(modifiers) {
    var ignoreModifiers = modifiers.indexOf('*') !== -1;
    var expected = createExpectedModifiers(ignoreModifiers);
    modifiers.forEach(function (token) {
        if (token === '*') {
            // we've already covered the all-in operator
            return;
        }
        // we want the modifier pressed
        var value = true;
        var operator = token.slice(0, 1);
        if (operator === '?') {
            // we don't care if the modifier is pressed
            value = null;
        }
        else if (operator === '!') {
            // we do not want the modifier pressed
            value = false;
        }
        if (value !== true) {
            // compensate for the modifier's operator
            token = token.slice(1);
        }
        var propertyName = modifier[token];
        if (!propertyName) {
            throw new TypeError('Unknown modifier "' + token + '"');
        }
        expected[propertyName] = value;
    });
    return expected;
}
function resolveKey(key) {
    var code = keycode[key] || parseInt(key, 10);
    if (!code || typeof code !== 'number' || isNaN(code)) {
        throw new TypeError('Unknown key "' + key + '"');
    }
    return [code].concat(keycode._alias[code] || []);
}
function matchModifiers(expected, event) {
    // returns true on match
    return !modifierSequence.some(function (prop) {
        // returns true on mismatch
        return (typeof expected[prop] === 'boolean' &&
            Boolean(event[prop]) !== expected[prop]);
    });
}
function keyBinding(text) {
    return text.split(/\s+/).map(function (_text) {
        var tokens = _text.split('+');
        var _modifiers = resolveModifiers(tokens.slice(0, -1));
        var _keyCodes = resolveKey(tokens.slice(-1));
        return {
            keyCodes: _keyCodes,
            modifiers: _modifiers,
            matchModifiers: matchModifiers.bind(null, _modifiers)
        };
    });
}
// Node.compareDocumentPosition is available since IE9
// see https://developer.mozilla.org/en-US/docs/Web/API/Node.compareDocumentPosition
// callback returns true when element is contained by parent or is the parent suited for use with Array.some()
/*
  USAGE:
    var isChildOf = getParentComparator({parent: someNode});
    listOfElements.some(isChildOf)
*/
function getParentComparator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, parent = _ref.parent, element = _ref.element, includeSelf = _ref.includeSelf;
    if (parent) {
        return function isChildOf(node) {
            return Boolean((includeSelf && node === parent) ||
                parent.compareDocumentPosition(node) &
                    Node.DOCUMENT_POSITION_CONTAINED_BY);
        };
    }
    else if (element) {
        return function isParentOf(node) {
            return Boolean((includeSelf && element === node) ||
                node.compareDocumentPosition(element) &
                    Node.DOCUMENT_POSITION_CONTAINED_BY);
        };
    }
    throw new TypeError('util/compare-position#getParentComparator required either options.parent or options.element');
}
// Bug 286933 - Key events in the autocomplete popup should be hidden from page scripts
// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=286933
function whenKey() {
    var map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var bindings = {};
    var context = nodeArray(map.context)[0] || document.documentElement;
    delete map.context;
    var filter = nodeArray(map.filter);
    delete map.filter;
    var mapKeys = Object.keys(map);
    if (!mapKeys.length) {
        throw new TypeError('when/key requires at least one option key');
    }
    var registerBinding = function registerBinding(event) {
        event.keyCodes.forEach(function (code) {
            if (!bindings[code]) {
                bindings[code] = [];
            }
            bindings[code].push(event);
        });
    };
    mapKeys.forEach(function (text) {
        if (typeof map[text] !== 'function') {
            throw new TypeError('when/key requires option["' + text + '"] to be a function');
        }
        var addCallback = function addCallback(event) {
            event.callback = map[text];
            return event;
        };
        keyBinding(text).map(addCallback).forEach(registerBinding);
    });
    var handleKeyDown = function handleKeyDown(event) {
        if (event.defaultPrevented) {
            return;
        }
        if (filter.length) {
            // ignore elements within the exempted sub-trees
            var isParentOfElement = getParentComparator({
                element: event.target,
                includeSelf: true
            });
            if (filter.some(isParentOfElement)) {
                return;
            }
        }
        var key = event.keyCode || event.which;
        if (!bindings[key]) {
            return;
        }
        bindings[key].forEach(function (_event) {
            if (!_event.matchModifiers(event)) {
                return;
            }
            _event.callback.call(context, event, disengage);
        });
    };
    context.addEventListener('keydown', handleKeyDown, false);
    var disengage = function disengage() {
        context.removeEventListener('keydown', handleKeyDown, false);
    };
    return { disengage: disengage };
}
function default_1(_a) {
    var context = (_a === void 0 ? {} : _a).context;
    if (!context) {
        context = document.documentElement;
    }
    // Make sure the supports tests are run before intercepting the Tab key,
    // or IE10 and IE11 will fail to process the first Tab key event. Not
    // limiting this warm-up to IE because it may be a problem elsewhere, too.
    queryTabsequence();
    return whenKey({
        // Safari on OSX may require ALT+TAB to reach links,
        // see https://github.com/medialize/ally.js/issues/146
        '?alt+?shift+tab': function altShiftTab(event) {
            // we're completely taking over the Tab key handling
            event.preventDefault();
            var sequence = queryTabsequence({
                context: context
            });
            var backward = event.shiftKey;
            var first = sequence[0];
            var last = sequence[sequence.length - 1];
            // wrap around first to last, last to first
            var source = backward ? first : last;
            var target = backward ? last : first;
            if (isActiveElement(source)) {
                target.focus();
                return;
            }
            // find current position in tabsequence
            var currentIndex = void 0;
            var found = sequence.some(function (element, index) {
                if (!isActiveElement(element)) {
                    return false;
                }
                currentIndex = index;
                return true;
            });
            if (!found) {
                // redirect to first as we're not in our tabsequence
                first.focus();
                return;
            }
            // shift focus to previous/next element in the sequence
            var offset = backward ? -1 : 1;
            sequence[currentIndex + offset].focus();
        }
    });
}
exports["default"] = default_1;
//# sourceMappingURL=maintain--tab-focus.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/styles.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/styles.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-dialog-overlay] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    overflow: auto;\n    z-index: 9000;\n\n    display: flex;\n    align-content: center;\n    align-items: center;\n    flex-direction: column;\n    padding: 10vh 15px 0;\n  }\n\n  @media (max-height: 812px) {\n    [data-nextjs-dialog-overlay] {\n      padding: 15px 15px 0;\n    }\n  }\n\n  [data-nextjs-dialog-backdrop] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: rgba(17, 17, 17, 0.2);\n    pointer-events: all;\n    z-index: -1;\n  }\n\n  [data-nextjs-dialog-backdrop-fixed] {\n    cursor: not-allowed;\n    -webkit-backdrop-filter: blur(8px);\n    backdrop-filter: blur(8px);\n  }\n"], ["\n  [data-nextjs-dialog-overlay] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    overflow: auto;\n    z-index: 9000;\n\n    display: flex;\n    align-content: center;\n    align-items: center;\n    flex-direction: column;\n    padding: 10vh 15px 0;\n  }\n\n  @media (max-height: 812px) {\n    [data-nextjs-dialog-overlay] {\n      padding: 15px 15px 0;\n    }\n  }\n\n  [data-nextjs-dialog-backdrop] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: rgba(17, 17, 17, 0.2);\n    pointer-events: all;\n    z-index: -1;\n  }\n\n  [data-nextjs-dialog-backdrop-fixed] {\n    cursor: not-allowed;\n    -webkit-backdrop-filter: blur(8px);\n    backdrop-filter: blur(8px);\n  }\n"])));
exports.styles = styles;
var templateObject_1;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
var react_dom_1 = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.module.js");
exports.ShadowPortal = function Portal(_a) {
    var children = _a.children;
    var mountNode = React.useRef(null);
    var portalNode = React.useRef(null);
    var shadowNode = React.useRef(null);
    var _b = __read(React.useState(), 2), forceUpdate = _b[1];
    React.useLayoutEffect(function () {
        var ownerDocument = mountNode.current.ownerDocument;
        portalNode.current = ownerDocument.createElement('nextjs-portal');
        shadowNode.current = portalNode.current.attachShadow({ mode: 'open' });
        ownerDocument.body.appendChild(portalNode.current);
        forceUpdate({});
        return function () {
            if (portalNode.current && portalNode.current.ownerDocument) {
                portalNode.current.ownerDocument.body.removeChild(portalNode.current);
            }
        };
    }, []);
    return shadowNode.current ? (react_dom_1.createPortal(children, shadowNode.current)) : (React.createElement("span", { ref: mountNode }));
};
//# sourceMappingURL=ShadowPortal.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/Terminal.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/Terminal.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var anser_1 = __importDefault(__webpack_require__(/*! anser */ "./node_modules/anser/lib/index.js"));
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
exports.Terminal = function Terminal(_a) {
    var content = _a.content;
    var decoded = React.useMemo(function () {
        return anser_1["default"].ansiToJson(content, {
            json: true,
            use_classes: true,
            remove_empty: true
        });
    }, [content]);
    return (React.createElement("div", { "data-nextjs-terminal": true },
        React.createElement("pre", null, decoded.map(function (entry, index) { return (React.createElement("span", { key: "terminal-entry-" + index, style: __assign({ color: entry.fg ? "var(--color-" + entry.fg + ")" : undefined }, (entry.decoration === 'bold'
                ? { fontWeight: 800 }
                : entry.decoration === 'italic'
                    ? { fontStyle: 'italic' }
                    : undefined)) }, entry.content)); }))));
};
//# sourceMappingURL=Terminal.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Terminal_1 = __webpack_require__(/*! ./Terminal */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/Terminal.js");
exports.Terminal = Terminal_1.Terminal;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/styles.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/styles.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-terminal] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-terminal]::selection,\n  [data-nextjs-terminal] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-terminal] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n  [data-nextjs-terminal] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n\n  [data-nextjs-terminal] pre {\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n"], ["\n  [data-nextjs-terminal] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-terminal]::selection,\n  [data-nextjs-terminal] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-terminal] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n  [data-nextjs-terminal] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n\n  [data-nextjs-terminal] pre {\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n"])));
exports.styles = styles;
var templateObject_1;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/Toast.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/Toast.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
exports.Toast = function Toast(_a) {
    var onClick = _a.onClick, children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-toast": true, onClick: onClick, className: className },
        React.createElement("div", { "data-nextjs-toast-wrapper": true }, children)));
};
//# sourceMappingURL=Toast.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var styles_1 = __webpack_require__(/*! ./styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/styles.js");
exports.styles = styles_1.styles;
var Toast_1 = __webpack_require__(/*! ./Toast */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/Toast.js");
exports.Toast = Toast_1.Toast;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/styles.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/styles.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-toast] {\n    position: fixed;\n    bottom: var(--size-gap-double);\n    left: var(--size-gap-double);\n    max-width: 420px;\n    z-index: 9000;\n  }\n\n  @media (max-width: 440px) {\n    [data-nextjs-toast] {\n      max-width: 90vw;\n      left: 5vw;\n    }\n  }\n\n  [data-nextjs-toast-wrapper] {\n    padding: 16px;\n    border-radius: var(--size-gap-half);\n    font-weight: 500;\n    color: var(--color-ansi-bright-white);\n    background-color: var(--color-ansi-red);\n    box-shadow: 0px var(--size-gap-double) var(--size-gap-quad)\n      rgba(0, 0, 0, 0.25);\n  }\n"], ["\n  [data-nextjs-toast] {\n    position: fixed;\n    bottom: var(--size-gap-double);\n    left: var(--size-gap-double);\n    max-width: 420px;\n    z-index: 9000;\n  }\n\n  @media (max-width: 440px) {\n    [data-nextjs-toast] {\n      max-width: 90vw;\n      left: 5vw;\n    }\n  }\n\n  [data-nextjs-toast-wrapper] {\n    padding: 16px;\n    border-radius: var(--size-gap-half);\n    font-weight: 500;\n    color: var(--color-ansi-bright-white);\n    background-color: var(--color-ansi-red);\n    box-shadow: 0px var(--size-gap-double) var(--size-gap-quad)\n      rgba(0, 0, 0, 0.25);\n  }\n"])));
exports.styles = styles;
var templateObject_1;
//# sourceMappingURL=styles.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
var Dialog_1 = __webpack_require__(/*! ../components/Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js");
var Overlay_1 = __webpack_require__(/*! ../components/Overlay */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js");
var Terminal_1 = __webpack_require__(/*! ../components/Terminal */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/index.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
exports.BuildError = function BuildError(_a) {
    var message = _a.message;
    var noop = React.useCallback(function () { }, []);
    return (React.createElement(Overlay_1.Overlay, { fixed: true },
        React.createElement(Dialog_1.Dialog, { type: "error", "aria-labelledby": "nextjs__container_build_error_label", "aria-describedby": "nextjs__container_build_error_desc", onClose: noop },
            React.createElement(Dialog_1.DialogContent, null,
                React.createElement(Dialog_1.DialogHeader, { className: "nextjs-container-build-error-header" },
                    React.createElement("h4", { id: "nextjs__container_build_error_label" }, "Failed to compile")),
                React.createElement(Dialog_1.DialogBody, { className: "nextjs-container-build-error-body" },
                    React.createElement(Terminal_1.Terminal, { content: message }),
                    React.createElement("footer", null,
                        React.createElement("p", { id: "nextjs__container_build_error_desc" },
                            React.createElement("small", null, "This error occurred during the build process and can only be dismissed by fixing the error."))))))));
};
exports.styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  .nextjs-container-build-error-header > h4 {\n    line-height: 1.5;\n    margin: 0;\n    padding: 0;\n  }\n\n  .nextjs-container-build-error-body footer {\n    margin-top: var(--size-gap);\n  }\n  .nextjs-container-build-error-body footer p {\n    margin: 0;\n  }\n\n  .nextjs-container-build-error-body small {\n    color: #757575;\n  }\n"], ["\n  .nextjs-container-build-error-header > h4 {\n    line-height: 1.5;\n    margin: 0;\n    padding: 0;\n  }\n\n  .nextjs-container-build-error-body footer {\n    margin-top: var(--size-gap);\n  }\n  .nextjs-container-build-error-body footer p {\n    margin: 0;\n  }\n\n  .nextjs-container-build-error-body small {\n    color: #757575;\n  }\n"])));
var templateObject_1;
//# sourceMappingURL=BuildError.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
var bus_1 = __webpack_require__(/*! ../bus */ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js");
var Dialog_1 = __webpack_require__(/*! ../components/Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js");
var LeftRightDialogHeader_1 = __webpack_require__(/*! ../components/LeftRightDialogHeader */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/index.js");
var Overlay_1 = __webpack_require__(/*! ../components/Overlay */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js");
var Toast_1 = __webpack_require__(/*! ../components/Toast */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js");
var nodeStackFrames_1 = __webpack_require__(/*! ../helpers/nodeStackFrames */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var stack_frame_1 = __webpack_require__(/*! ../helpers/stack-frame */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js");
var RuntimeError_1 = __webpack_require__(/*! ./RuntimeError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js");
function getErrorSignature(ev) {
    var event = ev.event;
    switch (event.type) {
        case bus_1.TYPE_UNHANDLED_ERROR:
        case bus_1.TYPE_UNHANDLED_REJECTION: {
            return event.reason.name + "::" + event.reason.message + "::" + event.reason.stack;
        }
        default: {
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    var _ = event;
    return '';
}
var HotlinkedText = function HotlinkedText(props) {
    var text = props.text;
    var linkRegex = /https?:\/\/[^\s/$.?#].[^\s"]*/i;
    return (React.createElement(React.Fragment, null, linkRegex.test(text)
        ? text.split(' ').map(function (word, index, array) {
            if (linkRegex.test(word)) {
                return (React.createElement(React.Fragment, { key: "link-" + index },
                    React.createElement("a", { href: word }, word),
                    index === array.length - 1 ? '' : ' '));
            }
            return index === array.length - 1 ? (React.createElement(React.Fragment, { key: "text-" + index }, word)) : (React.createElement(React.Fragment, { key: "text-" + index },
                word,
                " "));
        })
        : text));
};
function getErrorByType(ev) {
    return __awaiter(this, void 0, void 0, function () {
        var id, event, _a, _b, _;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    id = ev.id, event = ev.event;
                    _a = event.type;
                    switch (_a) {
                        case bus_1.TYPE_UNHANDLED_ERROR: return [3 /*break*/, 1];
                        case bus_1.TYPE_UNHANDLED_REJECTION: return [3 /*break*/, 1];
                    }
                    return [3 /*break*/, 3];
                case 1:
                    _b = {
                        id: id,
                        runtime: true,
                        error: event.reason
                    };
                    return [4 /*yield*/, stack_frame_1.getOriginalStackFrames(nodeStackFrames_1.isNodeError(event.reason), event.frames)];
                case 2: return [2 /*return*/, (_b.frames = _c.sent(),
                        _b)];
                case 3:
                    {
                        return [3 /*break*/, 4];
                    }
                    _c.label = 4;
                case 4:
                    _ = event;
                    throw new Error('type system invariant violation');
            }
        });
    });
}
exports.Errors = function Errors(_a) {
    var errors = _a.errors;
    var _b = __read(React.useState({}), 2), lookups = _b[0], setLookups = _b[1];
    var _c = __read(React.useMemo(function () {
        var ready = [];
        var next = null;
        // Ensure errors are displayed in the order they occurred in:
        for (var idx = 0; idx < errors.length; ++idx) {
            var e = errors[idx];
            var id = e.id;
            if (id in lookups) {
                ready.push(lookups[id]);
                continue;
            }
            // Check for duplicate errors
            if (idx > 0) {
                var prev = errors[idx - 1];
                if (getErrorSignature(prev) === getErrorSignature(e)) {
                    continue;
                }
            }
            next = e;
            break;
        }
        return [ready, next];
    }, [errors, lookups]), 2), readyErrors = _c[0], nextError = _c[1];
    var isLoading = React.useMemo(function () {
        return readyErrors.length < 1 && Boolean(errors.length);
    }, [errors.length, readyErrors.length]);
    React.useEffect(function () {
        if (nextError == null) {
            return;
        }
        var mounted = true;
        getErrorByType(nextError).then(function (resolved) {
            // We don't care if the desired error changed while we were resolving,
            // thus we're not tracking it using a ref. Once the work has been done,
            // we'll store it.
            if (mounted) {
                setLookups(function (m) {
                    var _a;
                    return (__assign(__assign({}, m), (_a = {}, _a[resolved.id] = resolved, _a)));
                });
            }
        }, function () {
            // TODO: handle this, though an edge case
        });
        return function () {
            mounted = false;
        };
    }, [nextError]);
    var _d = __read(React.useState(false), 2), isMinimized = _d[0], setMinimized = _d[1];
    var _e = __read(React.useState(0), 2), activeIdx = _e[0], setActiveIndex = _e[1];
    var previous = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setActiveIndex(function (v) { return Math.max(0, v - 1); });
    }, []);
    var next = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setActiveIndex(function (v) {
            return Math.max(0, Math.min(readyErrors.length - 1, v + 1));
        });
    }, [readyErrors.length]);
    var activeError = React.useMemo(function () { var _a; return (_a = readyErrors[activeIdx]) !== null && _a !== void 0 ? _a : null; }, [activeIdx, readyErrors]);
    // Reset component state when there are no errors to be displayed.
    // This should never happen, but lets handle it.
    React.useEffect(function () {
        if (errors.length < 1) {
            setLookups({});
            setMinimized(false);
            setActiveIndex(0);
        }
    }, [errors.length]);
    var minimize = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setMinimized(true);
    }, []);
    var reopen = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setMinimized(false);
    }, []);
    // This component shouldn't be rendered with no errors, but if it is, let's
    // handle it gracefully by rendering nothing.
    if (errors.length < 1 || activeError == null) {
        return null;
    }
    if (isLoading) {
        // TODO: better loading state
        return React.createElement(Overlay_1.Overlay, null);
    }
    if (isMinimized) {
        return (React.createElement(Toast_1.Toast, { className: "nextjs-toast-errors-parent", onClick: reopen },
            React.createElement("div", { className: "nextjs-toast-errors" },
                React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                    React.createElement("circle", { cx: "12", cy: "12", r: "10" }),
                    React.createElement("line", { x1: "12", y1: "8", x2: "12", y2: "12" }),
                    React.createElement("line", { x1: "12", y1: "16", x2: "12.01", y2: "16" })),
                React.createElement("span", null,
                    readyErrors.length,
                    " error",
                    readyErrors.length > 1 ? 's' : ''))));
    }
    var isServerError = nodeStackFrames_1.isNodeError(activeError.error);
    return (React.createElement(Overlay_1.Overlay, null,
        React.createElement(Dialog_1.Dialog, { type: "error", "aria-labelledby": "nextjs__container_errors_label", "aria-describedby": "nextjs__container_errors_desc", onClose: isServerError ? undefined : minimize },
            React.createElement(Dialog_1.DialogContent, null,
                React.createElement(Dialog_1.DialogHeader, { className: "nextjs-container-errors-header" },
                    React.createElement(LeftRightDialogHeader_1.LeftRightDialogHeader, { previous: activeIdx > 0 ? previous : null, next: activeIdx < readyErrors.length - 1 ? next : null, close: isServerError ? undefined : minimize },
                        React.createElement("small", null,
                            React.createElement("span", null, activeIdx + 1),
                            " of",
                            ' ',
                            React.createElement("span", null, readyErrors.length),
                            " unhandled error",
                            readyErrors.length < 2 ? '' : 's')),
                    React.createElement("h1", { id: "nextjs__container_errors_label" }, isServerError ? 'Server Error' : 'Unhandled Runtime Error'),
                    React.createElement("p", { id: "nextjs__container_errors_desc" },
                        activeError.error.name,
                        ":",
                        ' ',
                        React.createElement(HotlinkedText, { text: activeError.error.message })),
                    isServerError ? (React.createElement("div", null,
                        React.createElement("small", null, "This error happened while generating the page. Any console logs will be displayed in the terminal window."))) : undefined),
                React.createElement(Dialog_1.DialogBody, { className: "nextjs-container-errors-body" },
                    React.createElement(RuntimeError_1.RuntimeError, { key: activeError.id.toString(), error: activeError }))))));
};
exports.styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  .nextjs-container-errors-header > h1 {\n    font-size: var(--size-font-big);\n    line-height: var(--size-font-bigger);\n    font-weight: bold;\n    margin: 0;\n    margin-top: calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  .nextjs-container-errors-header small {\n    font-size: var(--size-font-small);\n    color: var(--color-accents-1);\n    margin-left: var(--size-gap-double);\n  }\n  .nextjs-container-errors-header small > span {\n    font-family: var(--font-stack-monospace);\n  }\n  .nextjs-container-errors-header > p {\n    font-family: var(--font-stack-monospace);\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-big);\n    font-weight: bold;\n    margin: 0;\n    margin-top: var(--size-gap-half);\n    color: var(--color-ansi-red);\n    white-space: pre-wrap;\n  }\n  .nextjs-container-errors-header > div > small {\n    margin: 0;\n    margin-top: var(--size-gap-half);\n  }\n  .nextjs-container-errors-header > p > a {\n    color: var(--color-ansi-red);\n  }\n\n  .nextjs-container-errors-body > h5:not(:first-child) {\n    margin-top: calc(var(--size-gap-double) + var(--size-gap));\n  }\n  .nextjs-container-errors-body > h5 {\n    margin-bottom: var(--size-gap);\n  }\n\n  .nextjs-toast-errors-parent {\n    cursor: pointer;\n    transition: transform 0.2s ease;\n  }\n  .nextjs-toast-errors-parent:hover {\n    transform: scale(1.1);\n  }\n  .nextjs-toast-errors {\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n  }\n  .nextjs-toast-errors > svg {\n    margin-right: var(--size-gap);\n  }\n"], ["\n  .nextjs-container-errors-header > h1 {\n    font-size: var(--size-font-big);\n    line-height: var(--size-font-bigger);\n    font-weight: bold;\n    margin: 0;\n    margin-top: calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  .nextjs-container-errors-header small {\n    font-size: var(--size-font-small);\n    color: var(--color-accents-1);\n    margin-left: var(--size-gap-double);\n  }\n  .nextjs-container-errors-header small > span {\n    font-family: var(--font-stack-monospace);\n  }\n  .nextjs-container-errors-header > p {\n    font-family: var(--font-stack-monospace);\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-big);\n    font-weight: bold;\n    margin: 0;\n    margin-top: var(--size-gap-half);\n    color: var(--color-ansi-red);\n    white-space: pre-wrap;\n  }\n  .nextjs-container-errors-header > div > small {\n    margin: 0;\n    margin-top: var(--size-gap-half);\n  }\n  .nextjs-container-errors-header > p > a {\n    color: var(--color-ansi-red);\n  }\n\n  .nextjs-container-errors-body > h5:not(:first-child) {\n    margin-top: calc(var(--size-gap-double) + var(--size-gap));\n  }\n  .nextjs-container-errors-body > h5 {\n    margin-bottom: var(--size-gap);\n  }\n\n  .nextjs-toast-errors-parent {\n    cursor: pointer;\n    transition: transform 0.2s ease;\n  }\n  .nextjs-toast-errors-parent:hover {\n    transform: scale(1.1);\n  }\n  .nextjs-toast-errors {\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n  }\n  .nextjs-toast-errors > svg {\n    margin-right: var(--size-gap);\n  }\n"])));
var templateObject_1;
//# sourceMappingURL=Errors.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
var CodeFrame_1 = __webpack_require__(/*! ../components/CodeFrame */ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var stack_frame_1 = __webpack_require__(/*! ../helpers/stack-frame */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js");
var CallStackFrame = function CallStackFrame(_a) {
    // TODO: ability to expand resolved frames
    // TODO: render error or external indicator
    var frame = _a.frame;
    var _b;
    var f = (_b = frame.originalStackFrame) !== null && _b !== void 0 ? _b : frame.sourceStackFrame;
    var hasSource = Boolean(frame.originalCodeFrame);
    var open = React.useCallback(function () {
        var _a;
        if (!hasSource)
            return;
        var params = new URLSearchParams();
        for (var key in f) {
            params.append(key, ((_a = f[key]) !== null && _a !== void 0 ? _a : '').toString());
        }
        self
            .fetch(( false || '') + "/__nextjs_launch-editor?" + params.toString())
            .then(function () { }, function () {
            // TODO: report error
        });
    }, [hasSource, f]);
    return (React.createElement("div", { "data-nextjs-call-stack-frame": true },
        React.createElement("h6", { "data-nextjs-frame-expanded": Boolean(frame.expanded) }, f.methodName),
        React.createElement("div", { "data-has-source": hasSource ? 'true' : undefined, tabIndex: hasSource ? 10 : undefined, role: hasSource ? 'link' : undefined, onClick: open, title: hasSource ? 'Click to open in your editor' : undefined },
            React.createElement("span", null, stack_frame_1.getFrameSource(f)),
            React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                React.createElement("path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }),
                React.createElement("polyline", { points: "15 3 21 3 21 9" }),
                React.createElement("line", { x1: "10", y1: "14", x2: "21", y2: "3" })))));
};
var RuntimeError = function RuntimeError(_a) {
    var error = _a.error;
    var firstFirstPartyFrameIndex = React.useMemo(function () {
        return error.frames.findIndex(function (entry) {
            return entry.expanded &&
                Boolean(entry.originalCodeFrame) &&
                Boolean(entry.originalStackFrame);
        });
    }, [error.frames]);
    var firstFrame = React.useMemo(function () {
        var _a;
        return (_a = error.frames[firstFirstPartyFrameIndex]) !== null && _a !== void 0 ? _a : null;
    }, [error.frames, firstFirstPartyFrameIndex]);
    var allLeadingFrames = React.useMemo(function () {
        return firstFirstPartyFrameIndex < 0
            ? []
            : error.frames.slice(0, firstFirstPartyFrameIndex);
    }, [error.frames, firstFirstPartyFrameIndex]);
    var _b = __read(React.useState(firstFrame == null), 2), all = _b[0], setAll = _b[1];
    var toggleAll = React.useCallback(function () {
        setAll(function (v) { return !v; });
    }, []);
    var leadingFrames = React.useMemo(function () { return allLeadingFrames.filter(function (f) { return f.expanded || all; }); }, [all, allLeadingFrames]);
    var allCallStackFrames = React.useMemo(function () { return error.frames.slice(firstFirstPartyFrameIndex + 1); }, [error.frames, firstFirstPartyFrameIndex]);
    var visibleCallStackFrames = React.useMemo(function () { return allCallStackFrames.filter(function (f) { return f.expanded || all; }); }, [all, allCallStackFrames]);
    var canShowMore = React.useMemo(function () {
        return (allCallStackFrames.length !== visibleCallStackFrames.length ||
            (all && firstFrame != null));
    }, [
        all,
        allCallStackFrames.length,
        firstFrame,
        visibleCallStackFrames.length,
    ]);
    return (React.createElement(React.Fragment, null,
        firstFrame ? (React.createElement(React.Fragment, null,
            React.createElement("h5", null, "Source"),
            leadingFrames.map(function (frame, index) { return (React.createElement(CallStackFrame, { key: "leading-frame-" + index + "-" + all, frame: frame })); }),
            React.createElement(CodeFrame_1.CodeFrame, { stackFrame: firstFrame.originalStackFrame, codeFrame: firstFrame.originalCodeFrame }))) : undefined,
        visibleCallStackFrames.length ? (React.createElement(React.Fragment, null,
            React.createElement("h5", null, "Call Stack"),
            visibleCallStackFrames.map(function (frame, index) { return (React.createElement(CallStackFrame, { key: "call-stack-" + index + "-" + all, frame: frame })); }))) : undefined,
        canShowMore ? (React.createElement(React.Fragment, null,
            React.createElement("button", { tabIndex: 10, "data-nextjs-data-runtime-error-collapsed-action": true, type: "button", onClick: toggleAll },
                all ? 'Hide' : 'Show',
                " collapsed frames"))) : undefined));
};
exports.RuntimeError = RuntimeError;
exports.styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  button[data-nextjs-data-runtime-error-collapsed-action] {\n    background: none;\n    border: none;\n    padding: 0;\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-bigger);\n    color: var(--color-accents-3);\n  }\n\n  [data-nextjs-call-stack-frame]:not(:last-child) {\n    margin-bottom: var(--size-gap-double);\n  }\n\n  [data-nextjs-call-stack-frame] > h6 {\n    margin-top: 0;\n    margin-bottom: var(--size-gap);\n    font-family: var(--font-stack-monospace);\n    color: #222;\n  }\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\n    color: #666;\n  }\n  [data-nextjs-call-stack-frame] > div {\n    display: flex;\n    align-items: center;\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\n    font-size: var(--size-font-small);\n    color: #999;\n  }\n  [data-nextjs-call-stack-frame] > div > svg {\n    width: auto;\n    height: var(--size-font-small);\n    margin-left: var(--size-gap);\n\n    display: none;\n  }\n\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\n    cursor: pointer;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\n    display: unset;\n  }\n"], ["\n  button[data-nextjs-data-runtime-error-collapsed-action] {\n    background: none;\n    border: none;\n    padding: 0;\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-bigger);\n    color: var(--color-accents-3);\n  }\n\n  [data-nextjs-call-stack-frame]:not(:last-child) {\n    margin-bottom: var(--size-gap-double);\n  }\n\n  [data-nextjs-call-stack-frame] > h6 {\n    margin-top: 0;\n    margin-bottom: var(--size-gap);\n    font-family: var(--font-stack-monospace);\n    color: #222;\n  }\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\n    color: #666;\n  }\n  [data-nextjs-call-stack-frame] > div {\n    display: flex;\n    align-items: center;\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\n    font-size: var(--size-font-small);\n    color: #999;\n  }\n  [data-nextjs-call-stack-frame] > div > svg {\n    width: auto;\n    height: var(--size-font-small);\n    margin-left: var(--size-gap);\n\n    display: none;\n  }\n\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\n    cursor: pointer;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\n    display: unset;\n  }\n"])));
var templateObject_1;
//# sourceMappingURL=RuntimeError.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var stacktrace_parser_1 = __webpack_require__(/*! stacktrace-parser */ "./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js");
function getFilesystemFrame(frame) {
    var f = __assign({}, frame);
    if (typeof f.file === 'string') {
        if (
        // Posix:
        f.file.startsWith('/') ||
            // Win32:
            /^[a-z]:\\/i.test(f.file) ||
            // Win32 UNC:
            f.file.startsWith('\\\\')) {
            f.file = "file://" + f.file;
        }
    }
    return f;
}
exports.getFilesystemFrame = getFilesystemFrame;
var symbolNodeError = Symbol('NextjsNodeError');
function isNodeError(error) {
    return symbolNodeError in error;
}
exports.isNodeError = isNodeError;
function getNodeError(error) {
    var n;
    try {
        throw new Error(error.message);
    }
    catch (e) {
        n = e;
    }
    n.name = error.name;
    try {
        n.stack = stacktrace_parser_1.parse(error.stack)
            .map(getFilesystemFrame)
            .map(function (f) {
            var str = "    at " + f.methodName;
            if (f.file) {
                var loc = f.file;
                if (f.lineNumber) {
                    loc += ":" + f.lineNumber;
                    if (f.column) {
                        loc += ":" + f.column;
                    }
                }
                str += " (" + loc + ")";
            }
            return str;
        })
            .join('\n');
    }
    catch (_a) {
        n.stack = error.stack;
    }
    Object.defineProperty(n, symbolNodeError, {
        writable: false,
        enumerable: false,
        configurable: false
    });
    return n;
}
exports.getNodeError = getNodeError;
//# sourceMappingURL=nodeStackFrames.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
function noop(strings) {
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    var lastIndex = strings.length - 1;
    return (strings.slice(0, lastIndex).reduce(function (p, s, i) { return p + s + keys[i]; }, '') +
        strings[lastIndex]);
}
exports.noop = noop;
//# sourceMappingURL=noop-template.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var stacktrace_parser_1 = __webpack_require__(/*! stacktrace-parser */ "./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js");
var regexNextStatic = /\/_next(\/static\/.+)/g;
function parseStack(stack) {
    var frames = stacktrace_parser_1.parse(stack);
    return frames.map(function (frame) {
        var _a, _b;
        try {
            var url = new URL(frame.file);
            var res = regexNextStatic.exec(url.pathname);
            if (res) {
                var distDir = (_b = (_a = "C:\\Users\\Steve\\git\\Meishicorp\\www\\.next") === null || _a === void 0 ? void 0 : _a.replace(/\\/g, '/')) === null || _b === void 0 ? void 0 : _b.replace(/\/$/, '');
                if (distDir) {
                    frame.file = 'file://' + distDir.concat(res.pop());
                }
            }
        }
        catch (_c) { }
        return frame;
    });
}
exports.parseStack = parseStack;
//# sourceMappingURL=parseStack.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
function getOriginalStackFrames(isServerSide, frames) {
    return Promise.all(frames.map(function (frame) { return getOriginalStackFrame(isServerSide, frame); }));
}
exports.getOriginalStackFrames = getOriginalStackFrames;
function getOriginalStackFrame(isServerSide, source) {
    var _a, _b;
    function _getOriginalStackFrame() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function () {
            var params, key, controller, tm, res, _e, _f, _g, body;
            return __generator(this, function (_h) {
                switch (_h.label) {
                    case 0:
                        params = new URLSearchParams();
                        params.append('isServerSide', String(isServerSide));
                        for (key in source) {
                            params.append(key, ((_a = source[key]) !== null && _a !== void 0 ? _a : '').toString());
                        }
                        controller = new AbortController();
                        tm = setTimeout(function () { return controller.abort(); }, 3000);
                        return [4 /*yield*/, self
                                .fetch(( false || '') + "/__nextjs_original-stack-frame?" + params.toString(), {
                                signal: controller.signal
                            })["finally"](function () {
                                clearTimeout(tm);
                            })];
                    case 1:
                        res = _h.sent();
                        if (!(!res.ok || res.status === 204)) return [3 /*break*/, 3];
                        _f = (_e = Promise).reject;
                        _g = Error.bind;
                        return [4 /*yield*/, res.text()];
                    case 2: return [2 /*return*/, _f.apply(_e, [new (_g.apply(Error, [void 0, _h.sent()]))()])];
                    case 3: return [4 /*yield*/, res.json()];
                    case 4:
                        body = _h.sent();
                        return [2 /*return*/, {
                                error: false,
                                reason: null,
                                external: false,
                                expanded: !Boolean((_d = (_c = (_b = 
                                /* collapsed */
                                body.originalStackFrame) === null || _b === void 0 ? void 0 : _b.file) === null || _c === void 0 ? void 0 : _c.includes('node_modules')) !== null && _d !== void 0 ? _d : true),
                                sourceStackFrame: source,
                                originalStackFrame: body.originalStackFrame,
                                originalCodeFrame: body.originalCodeFrame || null
                            }];
                }
            });
        });
    }
    if (!(((_a = source.file) === null || _a === void 0 ? void 0 : _a.startsWith('webpack-internal:')) || ((_b = source.file) === null || _b === void 0 ? void 0 : _b.startsWith('file:')))) {
        return Promise.resolve({
            error: false,
            reason: null,
            external: true,
            expanded: false,
            sourceStackFrame: source,
            originalStackFrame: null,
            originalCodeFrame: null
        });
    }
    return _getOriginalStackFrame()["catch"](function (err) {
        var _a, _b;
        return ({
            error: true,
            reason: (_b = (_a = err === null || err === void 0 ? void 0 : err.message) !== null && _a !== void 0 ? _a : err === null || err === void 0 ? void 0 : err.toString()) !== null && _b !== void 0 ? _b : 'Unknown Error',
            external: false,
            expanded: false,
            sourceStackFrame: source,
            originalStackFrame: null,
            originalCodeFrame: null
        });
    });
}
exports.getOriginalStackFrame = getOriginalStackFrame;
function getFrameSource(frame) {
    var _a;
    var str = '';
    try {
        var u = new URL(frame.file);
        // Strip the origin for same-origin scripts.
        if (typeof globalThis !== 'undefined' &&
            ((_a = globalThis.location) === null || _a === void 0 ? void 0 : _a.origin) !== u.origin) {
            // URLs can be valid without an `origin`, so long as they have a
            // `protocol`. However, `origin` is preferred.
            if (u.origin === 'null') {
                str += u.protocol;
            }
            else {
                str += u.origin;
            }
        }
        // Strip query string information as it's typically too verbose to be
        // meaningful.
        str += u.pathname;
        str += ' ';
    }
    catch (_b) {
        str += (frame.file || '(unknown)') + ' ';
    }
    if (frame.lineNumber != null) {
        if (frame.column != null) {
            str += "(" + frame.lineNumber + ":" + frame.column + ") ";
        }
        else {
            str += "(" + frame.lineNumber + ") ";
        }
    }
    return str.slice(0, -1);
}
exports.getFrameSource = getFrameSource;
//# sourceMappingURL=stack-frame.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/hooks/use-on-click-outside.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/hooks/use-on-click-outside.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
function useOnClickOutside(el, handler) {
    React.useEffect(function () {
        if (el == null || handler == null) {
            return;
        }
        var listener = function (e) {
            // Do nothing if clicking ref's element or descendent elements
            if (!el || el.contains(e.target)) {
                return;
            }
            handler(e);
        };
        var root = el.getRootNode();
        root.addEventListener('mousedown', listener);
        root.addEventListener('touchstart', listener);
        return function () {
            root.removeEventListener('mousedown', listener);
            root.removeEventListener('touchstart', listener);
        };
    }, [handler, el]);
}
exports.useOnClickOutside = useOnClickOutside;
//# sourceMappingURL=use-on-click-outside.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
function Base() {
    return (React.createElement("style", { dangerouslySetInnerHTML: {
            __html: noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          :host {\n            --size-gap-half: 4px;\n            --size-gap: 8px;\n            --size-gap-double: 16px;\n            --size-gap-quad: 32px;\n\n            --size-font-small: 14px;\n            --size-font: 16px;\n            --size-font-big: 20px;\n            --size-font-bigger: 24px;\n\n            --color-accents-1: #808080;\n            --color-accents-2: #222222;\n            --color-accents-3: #404040;\n\n            --font-stack-monospace: 'SFMono-Regular', Consolas,\n              'Liberation Mono', Menlo, Courier, monospace;\n\n            --color-ansi-selection: rgba(95, 126, 151, 0.48);\n            --color-ansi-bg: #111111;\n            --color-ansi-fg: #cccccc;\n\n            --color-ansi-white: #777777;\n            --color-ansi-black: #141414;\n            --color-ansi-blue: #00aaff;\n            --color-ansi-cyan: #88ddff;\n            --color-ansi-green: #98ec65;\n            --color-ansi-magenta: #aa88ff;\n            --color-ansi-red: #ff5555;\n            --color-ansi-yellow: #ffcc33;\n            --color-ansi-bright-white: #ffffff;\n            --color-ansi-bright-black: #777777;\n            --color-ansi-bright-blue: #33bbff;\n            --color-ansi-bright-cyan: #bbecff;\n            --color-ansi-bright-green: #b6f292;\n            --color-ansi-bright-magenta: #cebbff;\n            --color-ansi-bright-red: #ff8888;\n            --color-ansi-bright-yellow: #ffd966;\n          }\n\n          .mono {\n            font-family: var(--font-stack-monospace);\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-bottom: var(--size-gap);\n            font-weight: 500;\n            line-height: 1.5;\n          }\n\n          h1 {\n            font-size: 40px;\n          }\n          h2 {\n            font-size: 32px;\n          }\n          h3 {\n            font-size: 28px;\n          }\n          h4 {\n            font-size: 24px;\n          }\n          h5 {\n            font-size: 20px;\n          }\n          h6 {\n            font-size: 16px;\n          }\n        "], ["\n          :host {\n            --size-gap-half: 4px;\n            --size-gap: 8px;\n            --size-gap-double: 16px;\n            --size-gap-quad: 32px;\n\n            --size-font-small: 14px;\n            --size-font: 16px;\n            --size-font-big: 20px;\n            --size-font-bigger: 24px;\n\n            --color-accents-1: #808080;\n            --color-accents-2: #222222;\n            --color-accents-3: #404040;\n\n            --font-stack-monospace: 'SFMono-Regular', Consolas,\n              'Liberation Mono', Menlo, Courier, monospace;\n\n            --color-ansi-selection: rgba(95, 126, 151, 0.48);\n            --color-ansi-bg: #111111;\n            --color-ansi-fg: #cccccc;\n\n            --color-ansi-white: #777777;\n            --color-ansi-black: #141414;\n            --color-ansi-blue: #00aaff;\n            --color-ansi-cyan: #88ddff;\n            --color-ansi-green: #98ec65;\n            --color-ansi-magenta: #aa88ff;\n            --color-ansi-red: #ff5555;\n            --color-ansi-yellow: #ffcc33;\n            --color-ansi-bright-white: #ffffff;\n            --color-ansi-bright-black: #777777;\n            --color-ansi-bright-blue: #33bbff;\n            --color-ansi-bright-cyan: #bbecff;\n            --color-ansi-bright-green: #b6f292;\n            --color-ansi-bright-magenta: #cebbff;\n            --color-ansi-bright-red: #ff8888;\n            --color-ansi-bright-yellow: #ffd966;\n          }\n\n          .mono {\n            font-family: var(--font-stack-monospace);\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-bottom: var(--size-gap);\n            font-weight: 500;\n            line-height: 1.5;\n          }\n\n          h1 {\n            font-size: 40px;\n          }\n          h2 {\n            font-size: 32px;\n          }\n          h3 {\n            font-size: 28px;\n          }\n          h4 {\n            font-size: 24px;\n          }\n          h5 {\n            font-size: 20px;\n          }\n          h6 {\n            font-size: 16px;\n          }\n        "])))
        } }));
}
exports.Base = Base;
var templateObject_1;
//# sourceMappingURL=Base.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
var styles_1 = __webpack_require__(/*! ../components/CodeFrame/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/styles.js");
var Dialog_1 = __webpack_require__(/*! ../components/Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js");
var styles_2 = __webpack_require__(/*! ../components/LeftRightDialogHeader/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js");
var styles_3 = __webpack_require__(/*! ../components/Overlay/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/styles.js");
var styles_4 = __webpack_require__(/*! ../components/Terminal/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/styles.js");
var Toast_1 = __webpack_require__(/*! ../components/Toast */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js");
var BuildError_1 = __webpack_require__(/*! ../container/BuildError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js");
var Errors_1 = __webpack_require__(/*! ../container/Errors */ "./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js");
var RuntimeError_1 = __webpack_require__(/*! ../container/RuntimeError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
function ComponentStyles() {
    return (React.createElement("style", { dangerouslySetInnerHTML: {
            __html: noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n\n          ", "\n          ", "\n          ", "\n        "], ["\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n\n          ", "\n          ", "\n          ", "\n        "])), styles_3.styles, Toast_1.styles, Dialog_1.styles, styles_2.styles, styles_1.styles, styles_4.styles, BuildError_1.styles, Errors_1.styles, RuntimeError_1.styles)
        } }));
}
exports.ComponentStyles = ComponentStyles;
var templateObject_1;
//# sourceMappingURL=ComponentStyles.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
function CssReset() {
    return (React.createElement("style", { dangerouslySetInnerHTML: {
            __html: noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          :host {\n            all: initial;\n\n            /* the direction property is not reset by 'all' */\n            direction: ltr;\n          }\n\n          /*!\n           * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\n           * Copyright 2011-2019 The Bootstrap Authors\n           * Copyright 2011-2019 Twitter, Inc.\n           * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n           * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\n           */\n          *,\n          *::before,\n          *::after {\n            box-sizing: border-box;\n          }\n\n          :host {\n            font-family: sans-serif;\n            line-height: 1.15;\n            -webkit-text-size-adjust: 100%;\n            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n          }\n\n          article,\n          aside,\n          figcaption,\n          figure,\n          footer,\n          header,\n          hgroup,\n          main,\n          nav,\n          section {\n            display: block;\n          }\n\n          :host {\n            margin: 0;\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n              'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\n              'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n              'Noto Color Emoji';\n            font-size: 16px;\n            font-weight: 400;\n            line-height: 1.5;\n            color: #212529;\n            text-align: left;\n            background-color: #fff;\n          }\n\n          [tabindex='-1']:focus:not(:focus-visible) {\n            outline: 0 !important;\n          }\n\n          hr {\n            box-sizing: content-box;\n            height: 0;\n            overflow: visible;\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-top: 0;\n            margin-bottom: 8px;\n          }\n\n          p {\n            margin-top: 0;\n            margin-bottom: 16px;\n          }\n\n          abbr[title],\n          abbr[data-original-title] {\n            text-decoration: underline;\n            -webkit-text-decoration: underline dotted;\n            text-decoration: underline dotted;\n            cursor: help;\n            border-bottom: 0;\n            -webkit-text-decoration-skip-ink: none;\n            text-decoration-skip-ink: none;\n          }\n\n          address {\n            margin-bottom: 16px;\n            font-style: normal;\n            line-height: inherit;\n          }\n\n          ol,\n          ul,\n          dl {\n            margin-top: 0;\n            margin-bottom: 16px;\n          }\n\n          ol ol,\n          ul ul,\n          ol ul,\n          ul ol {\n            margin-bottom: 0;\n          }\n\n          dt {\n            font-weight: 700;\n          }\n\n          dd {\n            margin-bottom: 8px;\n            margin-left: 0;\n          }\n\n          blockquote {\n            margin: 0 0 16px;\n          }\n\n          b,\n          strong {\n            font-weight: bolder;\n          }\n\n          small {\n            font-size: 80%;\n          }\n\n          sub,\n          sup {\n            position: relative;\n            font-size: 75%;\n            line-height: 0;\n            vertical-align: baseline;\n          }\n\n          sub {\n            bottom: -0.25em;\n          }\n\n          sup {\n            top: -0.5em;\n          }\n\n          a {\n            color: #007bff;\n            text-decoration: none;\n            background-color: transparent;\n          }\n\n          a:hover {\n            color: #0056b3;\n            text-decoration: underline;\n          }\n\n          a:not([href]) {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          a:not([href]):hover {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          pre,\n          code,\n          kbd,\n          samp {\n            font-family: SFMono-Regular, Menlo, Monaco, Consolas,\n              'Liberation Mono', 'Courier New', monospace;\n            font-size: 1em;\n          }\n\n          pre {\n            margin-top: 0;\n            margin-bottom: 16px;\n            overflow: auto;\n          }\n\n          figure {\n            margin: 0 0 16px;\n          }\n\n          img {\n            vertical-align: middle;\n            border-style: none;\n          }\n\n          svg {\n            overflow: hidden;\n            vertical-align: middle;\n          }\n\n          table {\n            border-collapse: collapse;\n          }\n\n          caption {\n            padding-top: 12px;\n            padding-bottom: 12px;\n            color: #6c757d;\n            text-align: left;\n            caption-side: bottom;\n          }\n\n          th {\n            text-align: inherit;\n          }\n\n          label {\n            display: inline-block;\n            margin-bottom: 8px;\n          }\n\n          button {\n            border-radius: 0;\n          }\n\n          button:focus {\n            outline: 1px dotted;\n            outline: 5px auto -webkit-focus-ring-color;\n          }\n\n          input,\n          button,\n          select,\n          optgroup,\n          textarea {\n            margin: 0;\n            font-family: inherit;\n            font-size: inherit;\n            line-height: inherit;\n          }\n\n          button,\n          input {\n            overflow: visible;\n          }\n\n          button,\n          select {\n            text-transform: none;\n          }\n\n          select {\n            word-wrap: normal;\n          }\n\n          button,\n          [type='button'],\n          [type='reset'],\n          [type='submit'] {\n            -webkit-appearance: button;\n          }\n\n          button:not(:disabled),\n          [type='button']:not(:disabled),\n          [type='reset']:not(:disabled),\n          [type='submit']:not(:disabled) {\n            cursor: pointer;\n          }\n\n          button::-moz-focus-inner,\n          [type='button']::-moz-focus-inner,\n          [type='reset']::-moz-focus-inner,\n          [type='submit']::-moz-focus-inner {\n            padding: 0;\n            border-style: none;\n          }\n\n          input[type='radio'],\n          input[type='checkbox'] {\n            box-sizing: border-box;\n            padding: 0;\n          }\n\n          input[type='date'],\n          input[type='time'],\n          input[type='datetime-local'],\n          input[type='month'] {\n            -webkit-appearance: listbox;\n          }\n\n          textarea {\n            overflow: auto;\n            resize: vertical;\n          }\n\n          fieldset {\n            min-width: 0;\n            padding: 0;\n            margin: 0;\n            border: 0;\n          }\n\n          legend {\n            display: block;\n            width: 100%;\n            max-width: 100%;\n            padding: 0;\n            margin-bottom: 8px;\n            font-size: 24px;\n            line-height: inherit;\n            color: inherit;\n            white-space: normal;\n          }\n\n          progress {\n            vertical-align: baseline;\n          }\n\n          [type='number']::-webkit-inner-spin-button,\n          [type='number']::-webkit-outer-spin-button {\n            height: auto;\n          }\n\n          [type='search'] {\n            outline-offset: -2px;\n            -webkit-appearance: none;\n          }\n\n          [type='search']::-webkit-search-decoration {\n            -webkit-appearance: none;\n          }\n\n          ::-webkit-file-upload-button {\n            font: inherit;\n            -webkit-appearance: button;\n          }\n\n          output {\n            display: inline-block;\n          }\n\n          summary {\n            display: list-item;\n            cursor: pointer;\n          }\n\n          template {\n            display: none;\n          }\n\n          [hidden] {\n            display: none !important;\n          }\n        "], ["\n          :host {\n            all: initial;\n\n            /* the direction property is not reset by 'all' */\n            direction: ltr;\n          }\n\n          /*!\n           * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\n           * Copyright 2011-2019 The Bootstrap Authors\n           * Copyright 2011-2019 Twitter, Inc.\n           * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n           * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\n           */\n          *,\n          *::before,\n          *::after {\n            box-sizing: border-box;\n          }\n\n          :host {\n            font-family: sans-serif;\n            line-height: 1.15;\n            -webkit-text-size-adjust: 100%;\n            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n          }\n\n          article,\n          aside,\n          figcaption,\n          figure,\n          footer,\n          header,\n          hgroup,\n          main,\n          nav,\n          section {\n            display: block;\n          }\n\n          :host {\n            margin: 0;\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n              'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\n              'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n              'Noto Color Emoji';\n            font-size: 16px;\n            font-weight: 400;\n            line-height: 1.5;\n            color: #212529;\n            text-align: left;\n            background-color: #fff;\n          }\n\n          [tabindex='-1']:focus:not(:focus-visible) {\n            outline: 0 !important;\n          }\n\n          hr {\n            box-sizing: content-box;\n            height: 0;\n            overflow: visible;\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-top: 0;\n            margin-bottom: 8px;\n          }\n\n          p {\n            margin-top: 0;\n            margin-bottom: 16px;\n          }\n\n          abbr[title],\n          abbr[data-original-title] {\n            text-decoration: underline;\n            -webkit-text-decoration: underline dotted;\n            text-decoration: underline dotted;\n            cursor: help;\n            border-bottom: 0;\n            -webkit-text-decoration-skip-ink: none;\n            text-decoration-skip-ink: none;\n          }\n\n          address {\n            margin-bottom: 16px;\n            font-style: normal;\n            line-height: inherit;\n          }\n\n          ol,\n          ul,\n          dl {\n            margin-top: 0;\n            margin-bottom: 16px;\n          }\n\n          ol ol,\n          ul ul,\n          ol ul,\n          ul ol {\n            margin-bottom: 0;\n          }\n\n          dt {\n            font-weight: 700;\n          }\n\n          dd {\n            margin-bottom: 8px;\n            margin-left: 0;\n          }\n\n          blockquote {\n            margin: 0 0 16px;\n          }\n\n          b,\n          strong {\n            font-weight: bolder;\n          }\n\n          small {\n            font-size: 80%;\n          }\n\n          sub,\n          sup {\n            position: relative;\n            font-size: 75%;\n            line-height: 0;\n            vertical-align: baseline;\n          }\n\n          sub {\n            bottom: -0.25em;\n          }\n\n          sup {\n            top: -0.5em;\n          }\n\n          a {\n            color: #007bff;\n            text-decoration: none;\n            background-color: transparent;\n          }\n\n          a:hover {\n            color: #0056b3;\n            text-decoration: underline;\n          }\n\n          a:not([href]) {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          a:not([href]):hover {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          pre,\n          code,\n          kbd,\n          samp {\n            font-family: SFMono-Regular, Menlo, Monaco, Consolas,\n              'Liberation Mono', 'Courier New', monospace;\n            font-size: 1em;\n          }\n\n          pre {\n            margin-top: 0;\n            margin-bottom: 16px;\n            overflow: auto;\n          }\n\n          figure {\n            margin: 0 0 16px;\n          }\n\n          img {\n            vertical-align: middle;\n            border-style: none;\n          }\n\n          svg {\n            overflow: hidden;\n            vertical-align: middle;\n          }\n\n          table {\n            border-collapse: collapse;\n          }\n\n          caption {\n            padding-top: 12px;\n            padding-bottom: 12px;\n            color: #6c757d;\n            text-align: left;\n            caption-side: bottom;\n          }\n\n          th {\n            text-align: inherit;\n          }\n\n          label {\n            display: inline-block;\n            margin-bottom: 8px;\n          }\n\n          button {\n            border-radius: 0;\n          }\n\n          button:focus {\n            outline: 1px dotted;\n            outline: 5px auto -webkit-focus-ring-color;\n          }\n\n          input,\n          button,\n          select,\n          optgroup,\n          textarea {\n            margin: 0;\n            font-family: inherit;\n            font-size: inherit;\n            line-height: inherit;\n          }\n\n          button,\n          input {\n            overflow: visible;\n          }\n\n          button,\n          select {\n            text-transform: none;\n          }\n\n          select {\n            word-wrap: normal;\n          }\n\n          button,\n          [type='button'],\n          [type='reset'],\n          [type='submit'] {\n            -webkit-appearance: button;\n          }\n\n          button:not(:disabled),\n          [type='button']:not(:disabled),\n          [type='reset']:not(:disabled),\n          [type='submit']:not(:disabled) {\n            cursor: pointer;\n          }\n\n          button::-moz-focus-inner,\n          [type='button']::-moz-focus-inner,\n          [type='reset']::-moz-focus-inner,\n          [type='submit']::-moz-focus-inner {\n            padding: 0;\n            border-style: none;\n          }\n\n          input[type='radio'],\n          input[type='checkbox'] {\n            box-sizing: border-box;\n            padding: 0;\n          }\n\n          input[type='date'],\n          input[type='time'],\n          input[type='datetime-local'],\n          input[type='month'] {\n            -webkit-appearance: listbox;\n          }\n\n          textarea {\n            overflow: auto;\n            resize: vertical;\n          }\n\n          fieldset {\n            min-width: 0;\n            padding: 0;\n            margin: 0;\n            border: 0;\n          }\n\n          legend {\n            display: block;\n            width: 100%;\n            max-width: 100%;\n            padding: 0;\n            margin-bottom: 8px;\n            font-size: 24px;\n            line-height: inherit;\n            color: inherit;\n            white-space: normal;\n          }\n\n          progress {\n            vertical-align: baseline;\n          }\n\n          [type='number']::-webkit-inner-spin-button,\n          [type='number']::-webkit-outer-spin-button {\n            height: auto;\n          }\n\n          [type='search'] {\n            outline-offset: -2px;\n            -webkit-appearance: none;\n          }\n\n          [type='search']::-webkit-search-decoration {\n            -webkit-appearance: none;\n          }\n\n          ::-webkit-file-upload-button {\n            font: inherit;\n            -webkit-appearance: button;\n          }\n\n          output {\n            display: inline-block;\n          }\n\n          summary {\n            display: list-item;\n            cursor: pointer;\n          }\n\n          template {\n            display: none;\n          }\n\n          [hidden] {\n            display: none !important;\n          }\n        "])))
        } }));
}
exports.CssReset = CssReset;
var templateObject_1;
//# sourceMappingURL=CssReset.js.map

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/node_modules/ansi-regex/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/node_modules/ansi-regex/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

module.exports = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$onlyFirst = _ref.onlyFirst,
      onlyFirst = _ref$onlyFirst === void 0 ? false : _ref$onlyFirst;

  var pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
  return new RegExp(pattern, onlyFirst ? undefined : 'g');
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/node_modules/strip-ansi/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/node_modules/strip-ansi/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var ansiRegex = __webpack_require__(/*! ansi-regex */ "./node_modules/@next/react-dev-overlay/node_modules/ansi-regex/index.js");

module.exports = function (string) {
  return typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/anser/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/anser/lib/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This file was originally written by @drudru (https://github.com/drudru/ansi_up), MIT, 2011

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ANSI_COLORS = [[{ color: "0, 0, 0", "class": "ansi-black" }, { color: "187, 0, 0", "class": "ansi-red" }, { color: "0, 187, 0", "class": "ansi-green" }, { color: "187, 187, 0", "class": "ansi-yellow" }, { color: "0, 0, 187", "class": "ansi-blue" }, { color: "187, 0, 187", "class": "ansi-magenta" }, { color: "0, 187, 187", "class": "ansi-cyan" }, { color: "255,255,255", "class": "ansi-white" }], [{ color: "85, 85, 85", "class": "ansi-bright-black" }, { color: "255, 85, 85", "class": "ansi-bright-red" }, { color: "0, 255, 0", "class": "ansi-bright-green" }, { color: "255, 255, 85", "class": "ansi-bright-yellow" }, { color: "85, 85, 255", "class": "ansi-bright-blue" }, { color: "255, 85, 255", "class": "ansi-bright-magenta" }, { color: "85, 255, 255", "class": "ansi-bright-cyan" }, { color: "255, 255, 255", "class": "ansi-bright-white" }]];

var Anser = function () {
    _createClass(Anser, null, [{
        key: "escapeForHtml",


        /**
         * Anser.escapeForHtml
         * Escape the input HTML.
         *
         * This does the minimum escaping of text to make it compliant with HTML.
         * In particular, the '&','<', and '>' characters are escaped. This should
         * be run prior to `ansiToHtml`.
         *
         * @name Anser.escapeForHtml
         * @function
         * @param {String} txt The input text (containing the ANSI snippets).
         * @returns {String} The escaped html.
         */
        value: function escapeForHtml(txt) {
            return new Anser().escapeForHtml(txt);
        }

        /**
         * Anser.linkify
         * Adds the links in the HTML.
         *
         * This replaces any links in the text with anchor tags that display the
         * link. The links should have at least one whitespace character
         * surrounding it. Also, you should apply this after you have run
         * `ansiToHtml` on the text.
         *
         * @name Anser.linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML containing the <a> tags (unescaped).
         */

    }, {
        key: "linkify",
        value: function linkify(txt) {
            return new Anser().linkify(txt);
        }

        /**
         * Anser.ansiToHtml
         * This replaces ANSI terminal escape codes with SPAN tags that wrap the
         * content.
         *
         * This function only interprets ANSI SGR (Select Graphic Rendition) codes
         * that can be represented in HTML.
         * For example, cursor movement codes are ignored and hidden from output.
         * The default style uses colors that are very close to the prescribed
         * standard. The standard assumes that the text will have a black
         * background. These colors are set as inline styles on the SPAN tags.
         *
         * Another option is to set `use_classes: true` in the options argument.
         * This will instead set classes on the spans so the colors can be set via
         * CSS. The class names used are of the format `ansi-*-fg/bg` and
         * `ansi-bright-*-fg/bg` where `*` is the color name,
         * i.e black/red/green/yellow/blue/magenta/cyan/white.
         *
         * @name Anser.ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
            return new Anser().ansiToHtml(txt, options);
        }

        /**
         * Anser.ansiToJson
         * Converts ANSI input into JSON output.
         *
         * @name Anser.ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
            return new Anser().ansiToJson(txt, options);
        }

        /**
         * Anser.ansiToText
         * Converts ANSI input into text output.
         *
         * @name Anser.ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */

    }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
            return new Anser().ansiToText(txt);
        }

        /**
         * Anser
         * The `Anser` class.
         *
         * @name Anser
         * @function
         * @returns {Anser}
         */

    }]);

    function Anser() {
        _classCallCheck(this, Anser);

        this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;
        this.bright = 0;
    }

    /**
     * setupPalette
     * Sets up the palette.
     *
     * @name setupPalette
     * @function
     */


    _createClass(Anser, [{
        key: "setupPalette",
        value: function setupPalette() {
            this.PALETTE_COLORS = [];

            // Index 0..15 : System color
            for (var i = 0; i < 2; ++i) {
                for (var j = 0; j < 8; ++j) {
                    this.PALETTE_COLORS.push(ANSI_COLORS[i][j].color);
                }
            }

            // Index 16..231 : RGB 6x6x6
            // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml
            var levels = [0, 95, 135, 175, 215, 255];
            var format = function format(r, g, b) {
                return levels[r] + ", " + levels[g] + ", " + levels[b];
            };
            var r = void 0,
                g = void 0,
                b = void 0;
            for (var _r = 0; _r < 6; ++_r) {
                for (var _g = 0; _g < 6; ++_g) {
                    for (var _b = 0; _b < 6; ++_b) {
                        this.PALETTE_COLORS.push(format(_r, _g, _b));
                    }
                }
            }

            // Index 232..255 : Grayscale
            var level = 8;
            for (var _i = 0; _i < 24; ++_i, level += 10) {
                this.PALETTE_COLORS.push(format(level, level, level));
            }
        }

        /**
         * escapeForHtml
         * Escapes the input text.
         *
         * @name escapeForHtml
         * @function
         * @param {String} txt The input text.
         * @returns {String} The escpaed HTML output.
         */

    }, {
        key: "escapeForHtml",
        value: function escapeForHtml(txt) {
            return txt.replace(/[&<>]/gm, function (str) {
                return str == "&" ? "&amp;" : str == "<" ? "&lt;" : str == ">" ? "&gt;" : "";
            });
        }

        /**
         * linkify
         * Adds HTML link elements.
         *
         * @name linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML output containing link elements.
         */

    }, {
        key: "linkify",
        value: function linkify(txt) {
            return txt.replace(/(https?:\/\/[^\s]+)/gm, function (str) {
                return "<a href=\"" + str + "\">" + str + "</a>";
            });
        }

        /**
         * ansiToHtml
         * Converts ANSI input into HTML output.
         *
         * @name ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
            return this.process(txt, options, true);
        }

        /**
         * ansiToJson
         * Converts ANSI input into HTML output.
         *
         * @name ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The JSON output.
         */

    }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
            options = options || {};
            options.json = true;
            options.clearLine = false;
            return this.process(txt, options, true);
        }

        /**
         * ansiToText
         * Converts ANSI input into HTML output.
         *
         * @name ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */

    }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
            return this.process(txt, {}, false);
        }

        /**
         * process
         * Processes the input.
         *
         * @name process
         * @function
         * @param {String} txt The input text.
         * @param {Object} options An object passed to `processChunk` method, extended with:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup
         */

    }, {
        key: "process",
        value: function process(txt, options, markup) {
            var _this = this;

            var self = this;
            var raw_text_chunks = txt.split(/\033\[/);
            var first_chunk = raw_text_chunks.shift(); // the first chunk is not the result of the split

            if (options === undefined || options === null) {
                options = {};
            }
            options.clearLine = /\r/.test(txt); // check for Carriage Return
            var color_chunks = raw_text_chunks.map(function (chunk) {
                return _this.processChunk(chunk, options, markup);
            });

            if (options && options.json) {
                var first = self.processChunkJson("");
                first.content = first_chunk;
                first.clearLine = options.clearLine;
                color_chunks.unshift(first);
                if (options.remove_empty) {
                    color_chunks = color_chunks.filter(function (c) {
                        return !c.isEmpty();
                    });
                }
                return color_chunks;
            } else {
                color_chunks.unshift(first_chunk);
            }

            return color_chunks.join("");
        }

        /**
         * processChunkJson
         * Processes the current chunk into json output.
         *
         * @name processChunkJson
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object} The result object:
         *
         *  - `content` (String): The text.
         *  - `fg` (String|null): The foreground color.
         *  - `bg` (String|null): The background color.
         *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).
         *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).
         *  - `clearLine` (Boolean): `true` if a carriageReturn \r was fount at end of line.
         *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.
         *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.
         *
         */

    }, {
        key: "processChunkJson",
        value: function processChunkJson(text, options, markup) {

            // Are we using classes or styles?
            options = typeof options == "undefined" ? {} : options;
            var use_classes = options.use_classes = typeof options.use_classes != "undefined" && options.use_classes;
            var key = options.key = use_classes ? "class" : "color";

            var result = {
                content: text,
                fg: null,
                bg: null,
                fg_truecolor: null,
                bg_truecolor: null,
                clearLine: options.clearLine,
                decoration: null,
                was_processed: false,
                isEmpty: function isEmpty() {
                    return !result.content;
                }
            };

            // Each "chunk" is the text after the CSI (ESC + "[") and before the next CSI/EOF.
            //
            // This regex matches four groups within a chunk.
            //
            // The first and third groups match code type.
            // We supported only SGR command. It has empty first group and "m" in third.
            //
            // The second group matches all of the number+semicolon command sequences
            // before the "m" (or other trailing) character.
            // These are the graphics or SGR commands.
            //
            // The last group is the text (including newlines) that is colored by
            // the other group"s commands.
            var matches = text.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);

            if (!matches) return result;

            var orig_txt = result.content = matches[4];
            var nums = matches[2].split(";");

            // We currently support only "SGR" (Select Graphic Rendition)
            // Simply ignore if not a SGR command.
            if (matches[1] !== "" || matches[3] !== "m") {
                return result;
            }

            if (!markup) {
                return result;
            }

            var self = this;

            self.decoration = null;

            while (nums.length > 0) {
                var num_str = nums.shift();
                var num = parseInt(num_str);

                if (isNaN(num) || num === 0) {
                    self.fg = self.bg = self.decoration = null;
                } else if (num === 1) {
                    self.decoration = "bold";
                } else if (num === 2) {
                    self.decoration = "dim";
                    // Enable code 2 to get string
                } else if (num == 3) {
                    self.decoration = "italic";
                } else if (num == 4) {
                    self.decoration = "underline";
                } else if (num == 5) {
                    self.decoration = "blink";
                } else if (num === 7) {
                    self.decoration = "reverse";
                } else if (num === 8) {
                    self.decoration = "hidden";
                    // Enable code 9 to get strikethrough
                } else if (num === 9) {
                    self.decoration = "strikethrough";
                } else if (num == 39) {
                    self.fg = null;
                } else if (num == 49) {
                    self.bg = null;
                    // Foreground color
                } else if (num >= 30 && num < 38) {
                    self.fg = ANSI_COLORS[0][num % 10][key];
                    // Foreground bright color
                } else if (num >= 90 && num < 98) {
                    self.fg = ANSI_COLORS[1][num % 10][key];
                    // Background color
                } else if (num >= 40 && num < 48) {
                    self.bg = ANSI_COLORS[0][num % 10][key];
                    // Background bright color
                } else if (num >= 100 && num < 108) {
                    self.bg = ANSI_COLORS[1][num % 10][key];
                } else if (num === 38 || num === 48) {
                    // extend color (38=fg, 48=bg)
                    var is_foreground = num === 38;
                    if (nums.length >= 1) {
                        var mode = nums.shift();
                        if (mode === "5" && nums.length >= 1) {
                            // palette color
                            var palette_index = parseInt(nums.shift());
                            if (palette_index >= 0 && palette_index <= 255) {
                                if (!use_classes) {
                                    if (!this.PALETTE_COLORS) {
                                        self.setupPalette();
                                    }
                                    if (is_foreground) {
                                        self.fg = this.PALETTE_COLORS[palette_index];
                                    } else {
                                        self.bg = this.PALETTE_COLORS[palette_index];
                                    }
                                } else {
                                    var klass = palette_index >= 16 ? "ansi-palette-" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8]["class"];
                                    if (is_foreground) {
                                        self.fg = klass;
                                    } else {
                                        self.bg = klass;
                                    }
                                }
                            }
                        } else if (mode === "2" && nums.length >= 3) {
                            // true color
                            var r = parseInt(nums.shift());
                            var g = parseInt(nums.shift());
                            var b = parseInt(nums.shift());
                            if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
                                var color = r + ", " + g + ", " + b;
                                if (!use_classes) {
                                    if (is_foreground) {
                                        self.fg = color;
                                    } else {
                                        self.bg = color;
                                    }
                                } else {
                                    if (is_foreground) {
                                        self.fg = "ansi-truecolor";
                                        self.fg_truecolor = color;
                                    } else {
                                        self.bg = "ansi-truecolor";
                                        self.bg_truecolor = color;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (self.fg === null && self.bg === null && self.decoration === null) {
                return result;
            } else {
                var styles = [];
                var classes = [];
                var data = {};

                result.fg = self.fg;
                result.bg = self.bg;
                result.fg_truecolor = self.fg_truecolor;
                result.bg_truecolor = self.bg_truecolor;
                result.decoration = self.decoration;
                result.was_processed = true;

                return result;
            }
        }

        /**
         * processChunk
         * Processes the current chunk of text.
         *
         * @name processChunk
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object|String} The result (object if `json` is wanted back or string otherwise).
         */

    }, {
        key: "processChunk",
        value: function processChunk(text, options, markup) {
            var _this2 = this;

            var self = this;
            options = options || {};
            var jsonChunk = this.processChunkJson(text, options, markup);

            if (options.json) {
                return jsonChunk;
            }
            if (jsonChunk.isEmpty()) {
                return "";
            }
            if (!jsonChunk.was_processed) {
                return jsonChunk.content;
            }

            var use_classes = options.use_classes;

            var styles = [];
            var classes = [];
            var data = {};
            var render_data = function render_data(data) {
                var fragments = [];
                var key = void 0;
                for (key in data) {
                    if (data.hasOwnProperty(key)) {
                        fragments.push("data-" + key + "=\"" + _this2.escapeForHtml(data[key]) + "\"");
                    }
                }
                return fragments.length > 0 ? " " + fragments.join(" ") : "";
            };

            if (jsonChunk.fg) {
                if (use_classes) {
                    classes.push(jsonChunk.fg + "-fg");
                    if (jsonChunk.fg_truecolor !== null) {
                        data["ansi-truecolor-fg"] = jsonChunk.fg_truecolor;
                        jsonChunk.fg_truecolor = null;
                    }
                } else {
                    styles.push("color:rgb(" + jsonChunk.fg + ")");
                }
            }

            if (jsonChunk.bg) {
                if (use_classes) {
                    classes.push(jsonChunk.bg + "-bg");
                    if (jsonChunk.bg_truecolor !== null) {
                        data["ansi-truecolor-bg"] = jsonChunk.bg_truecolor;
                        jsonChunk.bg_truecolor = null;
                    }
                } else {
                    styles.push("background-color:rgb(" + jsonChunk.bg + ")");
                }
            }

            if (jsonChunk.decoration) {
                if (use_classes) {
                    classes.push("ansi-" + jsonChunk.decoration);
                } else if (jsonChunk.decoration === "bold") {
                    styles.push("font-weight:bold");
                } else if (jsonChunk.decoration === "dim") {
                    styles.push("opacity:0.5");
                } else if (jsonChunk.decoration === "italic") {
                    styles.push("font-style:italic");
                    // underline and blink are treated bellow
                } else if (jsonChunk.decoration === "reverse") {
                    styles.push("filter:invert(100%)");
                } else if (jsonChunk.decoration === "hidden") {
                    styles.push("visibility:hidden");
                } else if (jsonChunk.decoration === "strikethrough") {
                    styles.push("text-decoration:line-through");
                } else {
                    styles.push("text-decoration:" + jsonChunk.decoration);
                }
            }

            if (use_classes) {
                return "<span class=\"" + classes.join(" ") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
            } else {
                return "<span style=\"" + styles.join(";") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
            }
        }
    }]);

    return Anser;
}();

;

module.exports = Anser;

/***/ }),

/***/ "./node_modules/css.escape/css.escape.js":
/*!***********************************************!*\
  !*** ./node_modules/css.escape/css.escape.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */
;(function(root, factory) {
	// https://github.com/umdjs/umd/blob/master/returnExports.js
	if (true) {
		// For Node.js.
		module.exports = factory(root);
	} else {}
}(typeof global != 'undefined' ? global : this, function(root) {

	if (root.CSS && root.CSS.escape) {
		return root.CSS.escape;
	}

	// https://drafts.csswg.org/cssom/#serialize-an-identifier
	var cssEscape = function(value) {
		if (arguments.length == 0) {
			throw new TypeError('`CSS.escape` requires an argument.');
		}
		var string = String(value);
		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = '';
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);
			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += '\uFFFD';
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += '\\' + codeUnit.toString(16) + ' ';
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += '\\' + string.charAt(index);
				continue;
			}

			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += '\\' + string.charAt(index);

		}
		return result;
	};

	if (!root.CSS) {
		root.CSS = {};
	}

	root.CSS.escape = cssEscape;
	return cssEscape;

}));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/next-pwa/register.js":
/*!*******************************************!*\
  !*** ./node_modules/next-pwa/register.js ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var workbox_window__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! workbox-window */ "./node_modules/workbox-window/build/workbox-window.prod.es5.mjs");


if (typeof window !== 'undefined' && 'serviceWorker' in navigator) {
  window.workbox = new workbox_window__WEBPACK_IMPORTED_MODULE_0__["Workbox"]('/sw.js', { scope: '/' })
  
  window.workbox.addEventListener('activated', function(event) {
    if (!event.isUpdate) {
      caches.keys().then(function(c) {
        if (!c.includes('start-url')) {
          fetch('/')
        }
      })
    }
  })

  if(true) {
    window.workbox.register()
  }
}


/***/ }),

/***/ "./node_modules/next/dist/client/dev/dev-build-watcher.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/dev-build-watcher.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = initializeBuildWatcher;

var _eventsource = __webpack_require__(/*! ./error-overlay/eventsource */ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js");

function initializeBuildWatcher(toggleCallback) {
  var shadowHost = document.createElement('div');
  shadowHost.id = '__next-build-watcher'; // Make sure container is fixed and on a high zIndex so it shows

  shadowHost.style.position = 'fixed';
  shadowHost.style.bottom = '10px';
  shadowHost.style.right = '20px';
  shadowHost.style.width = 0;
  shadowHost.style.height = 0;
  shadowHost.style.zIndex = 99999;
  document.body.appendChild(shadowHost);
  var shadowRoot;
  var prefix = '';

  if (shadowHost.attachShadow) {
    shadowRoot = shadowHost.attachShadow({
      mode: 'open'
    });
  } else {
    // If attachShadow is undefined then the browser does not support
    // the Shadow DOM, we need to prefix all the names so there
    // will be no conflicts
    shadowRoot = shadowHost;
    prefix = '__next-build-watcher-';
  } // Container


  var container = createContainer(prefix);
  shadowRoot.appendChild(container); // CSS

  var css = createCss(prefix);
  shadowRoot.appendChild(css); // State

  var isVisible = false;
  var isBuilding = false;
  var timeoutId = null; // Handle events

  var evtSource = (0, _eventsource.getEventSourceWrapper)({
    path: '/_next/webpack-hmr'
  });
  evtSource.addMessageListener(function (event) {
    // This is the heartbeat event
    if (event.data === "\uD83D\uDC93") {
      return;
    }

    try {
      handleMessage(event);
    } catch (_unused) {}
  });

  function handleMessage(event) {
    var obj = typeof event === 'string' ? {
      action: event
    } : JSON.parse(event.data); // eslint-disable-next-line default-case

    switch (obj.action) {
      case 'building':
        timeoutId && clearTimeout(timeoutId);
        isVisible = true;
        isBuilding = true;
        updateContainer();
        break;

      case 'built':
      case 'sync':
        isBuilding = false; // Wait for the fade out transtion to complete

        timeoutId = setTimeout(function () {
          isVisible = false;
          updateContainer();
        }, 100);
        updateContainer();
        break;
    }
  }

  toggleCallback(handleMessage);

  function updateContainer() {
    if (isBuilding) {
      container.classList.add("".concat(prefix, "building"));
    } else {
      container.classList.remove("".concat(prefix, "building"));
    }

    if (isVisible) {
      container.classList.add("".concat(prefix, "visible"));
    } else {
      container.classList.remove("".concat(prefix, "visible"));
    }
  }
}

function createContainer(prefix) {
  var container = document.createElement('div');
  container.id = "".concat(prefix, "container");
  container.innerHTML = "\n    <div id=\"".concat(prefix, "icon-wrapper\">\n      <svg viewBox=\"0 0 226 200\">\n        <defs>\n          <linearGradient\n            x1=\"114.720775%\"\n            y1=\"181.283245%\"\n            x2=\"39.5399306%\"\n            y2=\"100%\"\n            id=\"").concat(prefix, "linear-gradient\"\n          >\n            <stop stop-color=\"#000000\" offset=\"0%\" />\n            <stop stop-color=\"#FFFFFF\" offset=\"100%\" />\n          </linearGradient>\n        </defs>\n        <g id=\"").concat(prefix, "icon-group\" fill=\"none\" stroke=\"url(#").concat(prefix, "linear-gradient)\" stroke-width=\"18\">\n          <path d=\"M113,5.08219117 L4.28393801,197.5 L221.716062,197.5 L113,5.08219117 Z\" />\n        </g>\n      </svg>\n    </div>\n  ");
  return container;
}

function createCss(prefix) {
  var css = document.createElement('style');
  css.textContent = "\n    #".concat(prefix, "container {\n      position: absolute;\n      bottom: 10px;\n      right: 30px;\n\n      border-radius: 3px;\n      background: #000;\n      color: #fff;\n      font: initial;\n      cursor: initial;\n      letter-spacing: initial;\n      text-shadow: initial;\n      text-transform: initial;\n      visibility: initial;\n\n      padding: 7px 10px 8px 10px;\n      align-items: center;\n      box-shadow: 0 11px 40px 0 rgba(0, 0, 0, 0.25), 0 2px 10px 0 rgba(0, 0, 0, 0.12);\n\n      display: none;\n      opacity: 0;\n      transition: opacity 0.1s ease, bottom 0.1s ease;\n      animation: ").concat(prefix, "fade-in 0.1s ease-in-out;\n    }\n\n    #").concat(prefix, "container.").concat(prefix, "visible {\n      display: flex;\n    }\n\n    #").concat(prefix, "container.").concat(prefix, "building {\n      bottom: 20px;\n      opacity: 1;\n    }\n\n    #").concat(prefix, "icon-wrapper {\n      width: 16px;\n      height: 16px;\n    }\n\n    #").concat(prefix, "icon-wrapper > svg {\n      width: 100%;\n      height: 100%;\n    }\n\n    #").concat(prefix, "icon-group {\n      animation: ").concat(prefix, "strokedash 1s ease-in-out both infinite;\n    }\n\n    @keyframes ").concat(prefix, "fade-in {\n      from {\n        bottom: 10px;\n        opacity: 0;\n      }\n      to {\n        bottom: 20px;\n        opacity: 1;\n      }\n    }\n\n    @keyframes ").concat(prefix, "strokedash {\n      0% {\n        stroke-dasharray: 0 226;\n      }\n      80%,\n      100% {\n        stroke-dasharray: 659 226;\n      }\n    }\n  ");
  return css;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/eventsource.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getEventSourceWrapper = getEventSourceWrapper;
var eventCallbacks = [];

function EventSourceWrapper(options) {
  var source;
  var lastActivity = new Date();
  var listeners = [];

  if (!options.timeout) {
    options.timeout = 20 * 1000;
  }

  init();
  var timer = setInterval(function () {
    if (new Date() - lastActivity > options.timeout) {
      handleDisconnect();
    }
  }, options.timeout / 2);

  function init() {
    source = new window.EventSource(options.path);
    source.onopen = handleOnline;
    source.onerror = handleDisconnect;
    source.onmessage = handleMessage;
  }

  function handleOnline() {
    if (options.log) console.log('[HMR] connected');
    lastActivity = new Date();
  }

  function handleMessage(event) {
    lastActivity = new Date();

    for (var i = 0; i < listeners.length; i++) {
      listeners[i](event);
    }

    eventCallbacks.forEach(function (cb) {
      if (!cb.unfiltered && event.data.indexOf('action') === -1) return;
      cb(event);
    });
  }

  function handleDisconnect() {
    clearInterval(timer);
    source.close();
    setTimeout(init, options.timeout);
  }

  return {
    close: function close() {
      clearInterval(timer);
      source.close();
    },
    addMessageListener: function addMessageListener(fn) {
      listeners.push(fn);
    }
  };
}

_c = EventSourceWrapper;

function getEventSourceWrapper(options) {
  if (!options.ondemand) {
    return {
      addMessageListener: function addMessageListener(cb) {
        eventCallbacks.push(cb);
      }
    };
  }

  return EventSourceWrapper(options);
}

var _c;

$RefreshReg$(_c, "EventSourceWrapper");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
/**
MIT License
Copyright (c) 2015-present, Facebook, Inc.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
// This file is based on https://github.com/facebook/create-react-app/blob/7b1a32be6ec9f99a6c9a3c66813f3ac09c4736b9/packages/react-dev-utils/formatWebpackMessages.js
// It's been edited to remove chalk and CRA-specific logic

var _toConsumableArray = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var friendlySyntaxErrorLabel = 'Syntax error:';

function isLikelyASyntaxError(message) {
  return message.indexOf(friendlySyntaxErrorLabel) !== -1;
} // Cleans up webpack error messages.


function formatMessage(message) {
  // TODO: Replace this once webpack 5 is stable
  if (typeof message === 'object' && message.message) {
    message = (message.moduleName ? message.moduleName + '\n' : '') + (message.file ? message.file + '\n' : '') + message.message;
  }

  var lines = message.split('\n'); // Strip Webpack-added headers off errors/warnings
  // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js

  lines = lines.filter(function (line) {
    return !/Module [A-z ]+\(from/.test(line);
  }); // Transform parsing error into syntax error
  // TODO: move this to our ESLint formatter?

  lines = lines.map(function (line) {
    var parsingError = /Line (\d+):(?:(\d+):)?\s*Parsing error: (.+)$/.exec(line);

    if (!parsingError) {
      return line;
    }

    var _parsingError = _slicedToArray(parsingError, 4),
        errorLine = _parsingError[1],
        errorColumn = _parsingError[2],
        errorMessage = _parsingError[3];

    return "".concat(friendlySyntaxErrorLabel, " ").concat(errorMessage, " (").concat(errorLine, ":").concat(errorColumn, ")");
  });
  message = lines.join('\n'); // Smoosh syntax errors (commonly found in CSS)

  message = message.replace(/SyntaxError\s+\((\d+):(\d+)\)\s*(.+?)\n/g, "".concat(friendlySyntaxErrorLabel, " $3 ($1:$2)\n")); // Clean up export errors

  message = message.replace(/^.*export '(.+?)' was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$2'.");
  message = message.replace(/^.*export 'default' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$2' does not contain a default export (imported as '$1').");
  message = message.replace(/^.*export '(.+?)' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$3' (imported as '$2').");
  lines = message.split('\n'); // Remove leading newline

  if (lines.length > 2 && lines[1].trim() === '') {
    lines.splice(1, 1);
  } // Clean up file name


  lines[0] = lines[0].replace(/^(.*) \d+:\d+-\d+$/, '$1'); // Cleans up verbose "module not found" messages for files and packages.

  if (lines[1] && lines[1].indexOf('Module not found: ') === 0) {
    lines = [lines[0], lines[1].replace('Error: ', '').replace('Module not found: Cannot find file:', 'Cannot find file:')].concat(_toConsumableArray(lines.slice(2).filter(function (line) {
      return line.indexOf(' @ ') !== 0;
    })));
  } // Add helpful message for users trying to use Sass for the first time


  if (lines[1] && lines[1].match(/Cannot find module.+node-sass/)) {
    // ./file.module.scss (<<loader info>>) => ./file.module.scss
    lines[0] = lines[0].replace(/(.+) \(.+?(?=\?\?).+?\)/, '$1');
    lines[1] = "To use Next.js' built-in Sass support, you first need to install `sass`.\n";
    lines[1] += 'Run `npm i sass` or `yarn add sass` inside your workspace.\n';
    lines[1] += '\nLearn more: https://err.sh/next.js/install-sass';
  }

  message = lines.join('\n'); // Internal stacks are generally useless so we strip them... with the
  // exception of stacks containing `webpack:` because they're normally
  // from user code generated by Webpack. For more information see
  // https://github.com/facebook/create-react-app/pull/1050

  message = message.replace(/^\s*at\s((?!webpack:).)*:\d+:\d+[\s)]*(\n|$)/gm, ''); // at ... ...:x:y

  message = message.replace(/^\s*at\s<anonymous>(\n|$)/gm, ''); // at <anonymous>

  lines = message.split('\n'); // Remove duplicated newlines

  lines = lines.filter(function (line, index, arr) {
    return index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim();
  }); // Reassemble the message

  message = lines.join('\n');
  return message.trim();
}

function formatWebpackMessages(json) {
  var formattedErrors = json.errors.map(function (message) {
    return formatMessage(message, true);
  });
  var formattedWarnings = json.warnings.map(function (message) {
    return formatMessage(message, false);
  });
  var result = {
    errors: formattedErrors,
    warnings: formattedWarnings
  };

  if (result.errors.some(isLikelyASyntaxError)) {
    // If there are any syntax errors, show just them.
    result.errors = result.errors.filter(isLikelyASyntaxError);
  }

  return result;
}

module.exports = formatWebpackMessages;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports["default"] = connect;

var DevOverlay = _interopRequireWildcard(__webpack_require__(/*! @next/react-dev-overlay/lib/client */ "./node_modules/@next/react-dev-overlay/lib/client.js"));

var _stripAnsi = _interopRequireDefault(__webpack_require__(/*! next/dist/compiled/strip-ansi */ "./node_modules/next/dist/compiled/strip-ansi/index.js"));

var _eventsource = __webpack_require__(/*! ./eventsource */ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js");

var _formatWebpackMessages = _interopRequireDefault(__webpack_require__(/*! ./format-webpack-messages */ "./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js"));
/**
* MIT License
*
* Copyright (c) 2013-present, Facebook, Inc.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/
// This file is a modified version of the Create React App HMR dev client that
// can be found here:
// https://github.com/facebook/create-react-app/blob/v3.4.1/packages/react-dev-utils/webpackHotDevClient.js
// This alternative WebpackDevServer combines the functionality of:
// https://github.com/webpack/webpack-dev-server/blob/webpack-1/client/index.js
// https://github.com/webpack/webpack/blob/webpack-1/hot/dev-server.js
// It only supports their simplest configuration (hot updates on same server).
// It makes some opinionated choices on top, like adding a syntax error overlay
// that looks similar to our console output. The error overlay is inspired by:
// https://github.com/glenjamin/webpack-hot-middleware


var hadRuntimeError = false;
var customHmrEventHandler;

function connect(options) {
  DevOverlay.register();
  (0, _eventsource.getEventSourceWrapper)(options).addMessageListener(function (event) {
    // This is the heartbeat event
    if (event.data === "\uD83D\uDC93") {
      return;
    }

    try {
      processMessage(event);
    } catch (ex) {
      console.warn('Invalid HMR message: ' + event.data + '\n' + ex);
    }
  });
  return {
    subscribeToHmrEvent: function subscribeToHmrEvent(handler) {
      customHmrEventHandler = handler;
    },
    onUnrecoverableError: function onUnrecoverableError() {
      hadRuntimeError = true;
    }
  };
} // Remember some state related to hot module replacement.


var isFirstCompilation = true;
var mostRecentCompilationHash = null;
var hasCompileErrors = false;

function clearOutdatedErrors() {
  // Clean up outdated compile errors, if any.
  if (typeof console !== 'undefined' && typeof console.clear === 'function') {
    if (hasCompileErrors) {
      console.clear();
    }
  }
} // Successful compilation.


function handleSuccess() {
  clearOutdatedErrors();
  var isHotUpdate = !isFirstCompilation;
  isFirstCompilation = false;
  hasCompileErrors = false; // Attempt to apply hot updates or reload.

  if (isHotUpdate) {
    tryApplyUpdates(function onSuccessfulHotUpdate(hasUpdates) {
      // Only dismiss it when we're sure it's a hot update.
      // Otherwise it would flicker right before the reload.
      onFastRefresh(hasUpdates);
    });
  }
} // Compilation with warnings (e.g. ESLint).


function handleWarnings(warnings) {
  clearOutdatedErrors();
  var isHotUpdate = !isFirstCompilation;
  isFirstCompilation = false;
  hasCompileErrors = false;

  function printWarnings() {
    // Print warnings to the console.
    var formatted = (0, _formatWebpackMessages["default"])({
      warnings: warnings,
      errors: []
    });

    if (typeof console !== 'undefined' && typeof console.warn === 'function') {
      for (var i = 0; i < formatted.warnings.length; i++) {
        if (i === 5) {
          console.warn('There were more warnings in other files.\n' + 'You can find a complete log in the terminal.');
          break;
        }

        console.warn((0, _stripAnsi["default"])(formatted.warnings[i]));
      }
    }
  }

  printWarnings(); // Attempt to apply hot updates or reload.

  if (isHotUpdate) {
    tryApplyUpdates(function onSuccessfulHotUpdate(hasUpdates) {
      // Only dismiss it when we're sure it's a hot update.
      // Otherwise it would flicker right before the reload.
      onFastRefresh(hasUpdates);
    });
  }
} // Compilation with errors (e.g. syntax error or missing modules).


function handleErrors(errors) {
  clearOutdatedErrors();
  isFirstCompilation = false;
  hasCompileErrors = true; // "Massage" webpack messages.

  var formatted = (0, _formatWebpackMessages["default"])({
    errors: errors,
    warnings: []
  }); // Only show the first error.

  DevOverlay.onBuildError(formatted.errors[0]); // Also log them to the console.

  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    for (var i = 0; i < formatted.errors.length; i++) {
      console.error((0, _stripAnsi["default"])(formatted.errors[i]));
    }
  } // Do not attempt to reload now.
  // We will reload on next success instead.


  if (undefined) {
    if (self.__NEXT_HMR_CB) {
      self.__NEXT_HMR_CB(formatted.errors[0]);

      self.__NEXT_HMR_CB = null;
    }
  }
}

function onFastRefresh(hasUpdates) {
  DevOverlay.onBuildOk();

  if (hasUpdates) {
    DevOverlay.onRefresh();
  }

  console.log('[Fast Refresh] done');
} // There is a newer version of the code available.


function handleAvailableHash(hash) {
  // Update last known compilation hash.
  mostRecentCompilationHash = hash;
} // Handle messages from the server.


function processMessage(e) {
  var obj = JSON.parse(e.data);

  switch (obj.action) {
    case 'building':
      {
        console.log('[Fast Refresh] rebuilding');
        break;
      }

    case 'built':
    case 'sync':
      {
        if (obj.hash) {
          handleAvailableHash(obj.hash);
        }

        var errors = obj.errors,
            warnings = obj.warnings;
        var hasErrors = Boolean(errors && errors.length);

        if (hasErrors) {
          return handleErrors(errors);
        }

        var hasWarnings = Boolean(warnings && warnings.length);

        if (hasWarnings) {
          return handleWarnings(warnings);
        }

        return handleSuccess();
      }

    default:
      {
        if (customHmrEventHandler) {
          customHmrEventHandler(obj);
          break;
        }

        break;
      }
  }
} // Is there a newer version of this code available?


function isUpdateAvailable() {
  /* globals __webpack_hash__ */
  // __webpack_hash__ is the hash of the current compilation.
  // It's a global variable injected by Webpack.
  return mostRecentCompilationHash !== __webpack_require__.h();
} // Webpack disallows updates in other states.


function canApplyUpdates() {
  return module.hot.status() === 'idle';
}

function afterApplyUpdates(fn) {
  if (canApplyUpdates()) {
    fn();
  } else {
    var handler = function handler(status) {
      if (status === 'idle') {
        module.hot.removeStatusHandler(handler);
        fn();
      }
    };

    module.hot.addStatusHandler(handler);
  }
} // Attempt to update code on the fly, fall back to a hard reload.


function tryApplyUpdates(onHotUpdateSuccess) {
  if (false) {}

  if (!isUpdateAvailable() || !canApplyUpdates()) {
    return;
  }

  function handleApplyUpdates(err, updatedModules) {
    if (err || hadRuntimeError || !updatedModules) {
      if (err) {
        console.warn('[Fast Refresh] performing full reload\n\n' + "Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.\n" + 'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.\n' + 'Consider migrating the non-React component export to a separate file and importing it into both files.\n\n' + 'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.\n' + 'Fast Refresh requires at least one parent function component in your React tree.');
      } else if (hadRuntimeError) {
        console.warn('[Fast Refresh] performing full reload because your application had an unrecoverable error');
      }

      window.location.reload();
      return;
    }

    var hasUpdates = Boolean(updatedModules.length);

    if (typeof onHotUpdateSuccess === 'function') {
      // Maybe we want to do something.
      onHotUpdateSuccess(hasUpdates);
    }

    if (isUpdateAvailable()) {
      // While we were updating, there was a new update! Do it again.
      tryApplyUpdates(hasUpdates ? undefined : onHotUpdateSuccess);
    } else {
      if (undefined) {
        afterApplyUpdates(function () {
          if (self.__NEXT_HMR_CB) {
            self.__NEXT_HMR_CB();

            self.__NEXT_HMR_CB = null;
          }
        });
      }
    }
  } // https://webpack.js.org/api/hot-module-replacement/#check


  module.hot.check(
  /* autoApply */
  true).then(function (updatedModules) {
    handleApplyUpdates(null, updatedModules);
  }, function (err) {
    handleApplyUpdates(err, null);
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/event-source-polyfill.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/event-source-polyfill.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = void 0;
/* eslint-disable */
// Improved version of https://github.com/Yaffle/EventSource/
// Available under MIT License (MIT)
// Only tries to support IE11 and nothing below

var document = window.document;
var Response = window.Response;
var TextDecoder = window.TextDecoder;
var TextEncoder = window.TextEncoder;
var AbortController = window.AbortController;

if (AbortController == undefined) {
  AbortController = function AbortController() {
    this.signal = null;

    this.abort = function () {};
  };
}

function TextDecoderPolyfill() {
  this.bitsNeeded = 0;
  this.codePoint = 0;
}

_c = TextDecoderPolyfill;

TextDecoderPolyfill.prototype.decode = function (octets) {
  function valid(codePoint, shift, octetsCount) {
    if (octetsCount === 1) {
      return codePoint >= 0x0080 >> shift && codePoint << shift <= 0x07ff;
    }

    if (octetsCount === 2) {
      return codePoint >= 0x0800 >> shift && codePoint << shift <= 0xd7ff || codePoint >= 0xe000 >> shift && codePoint << shift <= 0xffff;
    }

    if (octetsCount === 3) {
      return codePoint >= 0x010000 >> shift && codePoint << shift <= 0x10ffff;
    }

    throw new Error();
  }

  function octetsCount(bitsNeeded, codePoint) {
    if (bitsNeeded === 6 * 1) {
      return codePoint >> 6 > 15 ? 3 : codePoint > 31 ? 2 : 1;
    }

    if (bitsNeeded === 6 * 2) {
      return codePoint > 15 ? 3 : 2;
    }

    if (bitsNeeded === 6 * 3) {
      return 3;
    }

    throw new Error();
  }

  var REPLACER = 0xfffd;
  var string = '';
  var bitsNeeded = this.bitsNeeded;
  var codePoint = this.codePoint;

  for (var i = 0; i < octets.length; i += 1) {
    var octet = octets[i];

    if (bitsNeeded !== 0) {
      if (octet < 128 || octet > 191 || !valid(codePoint << 6 | octet & 63, bitsNeeded - 6, octetsCount(bitsNeeded, codePoint))) {
        bitsNeeded = 0;
        codePoint = REPLACER;
        string += String.fromCharCode(codePoint);
      }
    }

    if (bitsNeeded === 0) {
      if (octet >= 0 && octet <= 127) {
        bitsNeeded = 0;
        codePoint = octet;
      } else if (octet >= 192 && octet <= 223) {
        bitsNeeded = 6 * 1;
        codePoint = octet & 31;
      } else if (octet >= 224 && octet <= 239) {
        bitsNeeded = 6 * 2;
        codePoint = octet & 15;
      } else if (octet >= 240 && octet <= 247) {
        bitsNeeded = 6 * 3;
        codePoint = octet & 7;
      } else {
        bitsNeeded = 0;
        codePoint = REPLACER;
      }

      if (bitsNeeded !== 0 && !valid(codePoint, bitsNeeded, octetsCount(bitsNeeded, codePoint))) {
        bitsNeeded = 0;
        codePoint = REPLACER;
      }
    } else {
      bitsNeeded -= 6;
      codePoint = codePoint << 6 | octet & 63;
    }

    if (bitsNeeded === 0) {
      if (codePoint <= 0xffff) {
        string += String.fromCharCode(codePoint);
      } else {
        string += String.fromCharCode(0xd800 + (codePoint - 0xffff - 1 >> 10));
        string += String.fromCharCode(0xdc00 + (codePoint - 0xffff - 1 & 0x3ff));
      }
    }
  }

  this.bitsNeeded = bitsNeeded;
  this.codePoint = codePoint;
  return string;
}; // Firefox < 38 throws an error with stream option


var supportsStreamOption = function supportsStreamOption() {
  try {
    return new TextDecoder().decode(new TextEncoder().encode('test'), {
      stream: true
    }) === 'test';
  } catch (error) {
    console.log(error);
  }

  return false;
}; // IE, Edge


if (TextDecoder == undefined || TextEncoder == undefined || !supportsStreamOption()) {
  TextDecoder = TextDecoderPolyfill;
}

var k = function k() {};

function XHRWrapper(xhr) {
  this.withCredentials = false;
  this.responseType = '';
  this.readyState = 0;
  this.status = 0;
  this.statusText = '';
  this.responseText = '';
  this.onprogress = k;
  this.onreadystatechange = k;
  this._contentType = '';
  this._xhr = xhr;
  this._sendTimeout = 0;
  this._abort = k;
}

_c2 = XHRWrapper;

XHRWrapper.prototype.open = function (method, url) {
  this._abort(true);

  var that = this;
  var xhr = this._xhr;
  var state = 1;
  var timeout = 0;

  this._abort = function (silent) {
    if (that._sendTimeout !== 0) {
      clearTimeout(that._sendTimeout);
      that._sendTimeout = 0;
    }

    if (state === 1 || state === 2 || state === 3) {
      state = 4;
      xhr.onload = k;
      xhr.onerror = k;
      xhr.onabort = k;
      xhr.onprogress = k;
      xhr.onreadystatechange = k; // IE 8 - 9: XDomainRequest#abort() does not fire any event
      // Opera < 10: XMLHttpRequest#abort() does not fire any event

      xhr.abort();

      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }

      if (!silent) {
        that.readyState = 4;
        that.onreadystatechange();
      }
    }

    state = 0;
  };

  var onStart = function onStart() {
    if (state === 1) {
      // state = 2;
      var status = 0;
      var statusText = '';
      var contentType = undefined;

      if (!('contentType' in xhr)) {
        try {
          status = xhr.status;
          statusText = xhr.statusText;
          contentType = xhr.getResponseHeader('Content-Type');
        } catch (error) {
          // IE < 10 throws exception for `xhr.status` when xhr.readyState === 2 || xhr.readyState === 3
          // Opera < 11 throws exception for `xhr.status` when xhr.readyState === 2
          // https://bugs.webkit.org/show_bug.cgi?id=29121
          status = 0;
          statusText = '';
          contentType = undefined; // Firefox < 14, Chrome ?, Safari ?
          // https://bugs.webkit.org/show_bug.cgi?id=29658
          // https://bugs.webkit.org/show_bug.cgi?id=77854
        }
      } else {
        status = 200;
        statusText = 'OK';
        contentType = xhr.contentType;
      }

      if (status !== 0) {
        state = 2;
        that.readyState = 2;
        that.status = status;
        that.statusText = statusText;
        that._contentType = contentType;
        that.onreadystatechange();
      }
    }
  };

  var onProgress = function onProgress() {
    onStart();

    if (state === 2 || state === 3) {
      state = 3;
      var responseText = '';

      try {
        responseText = xhr.responseText;
      } catch (error) {// IE 8 - 9 with XMLHttpRequest
      }

      that.readyState = 3;
      that.responseText = responseText;
      that.onprogress();
    }
  };

  var onFinish = function onFinish() {
    // Firefox 52 fires "readystatechange" (xhr.readyState === 4) without final "readystatechange" (xhr.readyState === 3)
    // IE 8 fires "onload" without "onprogress"
    onProgress();

    if (state === 1 || state === 2 || state === 3) {
      state = 4;

      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }

      that.readyState = 4;
      that.onreadystatechange();
    }
  };

  var onReadyStateChange = function onReadyStateChange() {
    if (xhr != undefined) {
      // Opera 12
      if (xhr.readyState === 4) {
        onFinish();
      } else if (xhr.readyState === 3) {
        onProgress();
      } else if (xhr.readyState === 2) {
        onStart();
      }
    }
  };

  var onTimeout = function onTimeout() {
    timeout = setTimeout(function () {
      onTimeout();
    }, 500);

    if (xhr.readyState === 3) {
      onProgress();
    }
  }; // XDomainRequest#abort removes onprogress, onerror, onload


  xhr.onload = onFinish;
  xhr.onerror = onFinish; // improper fix to match Firefox behavior, but it is better than just ignore abort
  // see https://bugzilla.mozilla.org/show_bug.cgi?id=768596
  // https://bugzilla.mozilla.org/show_bug.cgi?id=880200
  // https://code.google.com/p/chromium/issues/detail?id=153570
  // IE 8 fires "onload" without "onprogress

  xhr.onabort = onFinish; // https://bugzilla.mozilla.org/show_bug.cgi?id=736723

  if (!('sendAsBinary' in XMLHttpRequest.prototype) && !('mozAnon' in XMLHttpRequest.prototype)) {
    xhr.onprogress = onProgress;
  } // IE 8 - 9 (XMLHTTPRequest)
  // Opera < 12
  // Firefox < 3.5
  // Firefox 3.5 - 3.6 - ? < 9.0
  // onprogress is not fired sometimes or delayed
  // see also #64


  xhr.onreadystatechange = onReadyStateChange;

  if ('contentType' in xhr) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + 'padding=true';
  }

  xhr.open(method, url, true);

  if ('readyState' in xhr) {
    // workaround for Opera 12 issue with "progress" events
    // #91
    timeout = setTimeout(function () {
      onTimeout();
    }, 0);
  }
};

XHRWrapper.prototype.abort = function () {
  this._abort(false);
};

XHRWrapper.prototype.getResponseHeader = function (name) {
  return this._contentType;
};

XHRWrapper.prototype.setRequestHeader = function (name, value) {
  var xhr = this._xhr;

  if ('setRequestHeader' in xhr) {
    xhr.setRequestHeader(name, value);
  }
};

XHRWrapper.prototype.getAllResponseHeaders = function () {
  return this._xhr.getAllResponseHeaders != undefined ? this._xhr.getAllResponseHeaders() : '';
};

XHRWrapper.prototype.send = function () {
  // loading indicator in Safari < ? (6), Chrome < 14, Firefox
  if (!('ontimeout' in XMLHttpRequest.prototype) && document != undefined && document.readyState != undefined && document.readyState !== 'complete') {
    var that = this;
    that._sendTimeout = setTimeout(function () {
      that._sendTimeout = 0;
      that.send();
    }, 4);
    return;
  }

  var xhr = this._xhr; // withCredentials should be set after "open" for Safari and Chrome (< 19 ?)

  xhr.withCredentials = this.withCredentials;
  xhr.responseType = this.responseType;

  try {
    // xhr.send(); throws "Not enough arguments" in Firefox 3.0
    xhr.send(undefined);
  } catch (error1) {
    // Safari 5.1.7, Opera 12
    throw error1;
  }
};

function toLowerCase(name) {
  return name.replace(/[A-Z]/g, function (c) {
    return String.fromCharCode(c.charCodeAt(0) + 0x20);
  });
}

function HeadersPolyfill(all) {
  // Get headers: implemented according to mozilla's example code: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders#Example
  var map = Object.create(null);
  var array = all.split('\r\n');

  for (var i = 0; i < array.length; i += 1) {
    var line = array[i];
    var parts = line.split(': ');
    var name = parts.shift();
    var value = parts.join(': ');
    map[toLowerCase(name)] = value;
  }

  this._map = map;
}

_c3 = HeadersPolyfill;

HeadersPolyfill.prototype.get = function (name) {
  return this._map[toLowerCase(name)];
};

function XHRTransport() {}

_c4 = XHRTransport;

XHRTransport.prototype.open = function (xhr, onStartCallback, onProgressCallback, onFinishCallback, url, withCredentials, headers) {
  xhr.open('GET', url);
  var offset = 0;

  xhr.onprogress = function () {
    var responseText = xhr.responseText;
    var chunk = responseText.slice(offset);
    offset += chunk.length;
    onProgressCallback(chunk);
  };

  xhr.onreadystatechange = function () {
    if (xhr.readyState === 2) {
      var status = xhr.status;
      var statusText = xhr.statusText;
      var contentType = xhr.getResponseHeader('Content-Type');
      var headers = xhr.getAllResponseHeaders();
      onStartCallback(status, statusText, contentType, new HeadersPolyfill(headers), function () {
        xhr.abort();
      });
    } else if (xhr.readyState === 4) {
      onFinishCallback();
    }
  };

  xhr.withCredentials = withCredentials;
  xhr.responseType = 'text';

  for (var name in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, name)) {
      xhr.setRequestHeader(name, headers[name]);
    }
  }

  xhr.send();
};

function HeadersWrapper(headers) {
  this._headers = headers;
}

_c5 = HeadersWrapper;

HeadersWrapper.prototype.get = function (name) {
  return this._headers.get(name);
};

function FetchTransport() {}

_c6 = FetchTransport;

FetchTransport.prototype.open = function (xhr, onStartCallback, onProgressCallback, onFinishCallback, url, withCredentials, headers) {
  var controller = new AbortController();
  var signal = controller.signal; // see #120

  var textDecoder = new TextDecoder();
  fetch(url, {
    headers: headers,
    credentials: withCredentials ? 'include' : 'same-origin',
    signal: signal,
    cache: 'no-store'
  }).then(function (response) {
    var reader = response.body.getReader();
    onStartCallback(response.status, response.statusText, response.headers.get('Content-Type'), new HeadersWrapper(response.headers), function () {
      controller.abort();
      reader.cancel();
    });
    return new Promise(function (resolve, reject) {
      var readNextChunk = function readNextChunk() {
        reader.read().then(function (result) {
          if (result.done) {
            // Note: bytes in textDecoder are ignored
            resolve(undefined);
          } else {
            var chunk = textDecoder.decode(result.value, {
              stream: true
            });
            onProgressCallback(chunk);
            readNextChunk();
          }
        })['catch'](function (error) {
          reject(error);
        });
      };

      readNextChunk();
    });
  }).then(function (result) {
    onFinishCallback();
    return result;
  }, function (error) {
    onFinishCallback();
    return Promise.reject(error);
  });
};

function EventTarget() {
  this._listeners = Object.create(null);
}

_c7 = EventTarget;

function throwError(e) {
  setTimeout(function () {
    throw e;
  }, 0);
}

EventTarget.prototype.dispatchEvent = function (event) {
  event.target = this;
  var typeListeners = this._listeners[event.type];

  if (typeListeners != undefined) {
    var length = typeListeners.length;

    for (var i = 0; i < length; i += 1) {
      var listener = typeListeners[i];

      try {
        if (typeof listener.handleEvent === 'function') {
          listener.handleEvent(event);
        } else {
          listener.call(this, event);
        }
      } catch (e) {
        throwError(e);
      }
    }
  }
};

EventTarget.prototype.addEventListener = function (type, listener) {
  type = String(type);
  var listeners = this._listeners;
  var typeListeners = listeners[type];

  if (typeListeners == undefined) {
    typeListeners = [];
    listeners[type] = typeListeners;
  }

  var found = false;

  for (var i = 0; i < typeListeners.length; i += 1) {
    if (typeListeners[i] === listener) {
      found = true;
    }
  }

  if (!found) {
    typeListeners.push(listener);
  }
};

EventTarget.prototype.removeEventListener = function (type, listener) {
  type = String(type);
  var listeners = this._listeners;
  var typeListeners = listeners[type];

  if (typeListeners != undefined) {
    var filtered = [];

    for (var i = 0; i < typeListeners.length; i += 1) {
      if (typeListeners[i] !== listener) {
        filtered.push(typeListeners[i]);
      }
    }

    if (filtered.length === 0) {
      delete listeners[type];
    } else {
      listeners[type] = filtered;
    }
  }
};

function Event(type) {
  this.type = type;
  this.target = undefined;
}

_c8 = Event;

function MessageEvent(type, options) {
  Event.call(this, type);
  this.data = options.data;
  this.lastEventId = options.lastEventId;
}

_c9 = MessageEvent;
MessageEvent.prototype = Object.create(Event.prototype);

function ConnectionEvent(type, options) {
  Event.call(this, type);
  this.status = options.status;
  this.statusText = options.statusText;
  this.headers = options.headers;
}

_c10 = ConnectionEvent;
ConnectionEvent.prototype = Object.create(Event.prototype);
var WAITING = -1;
var CONNECTING = 0;
var OPEN = 1;
var CLOSED = 2;
var AFTER_CR = -1;
var FIELD_START = 0;
var FIELD = 1;
var VALUE_START = 2;
var VALUE = 3;
var contentTypeRegExp = /^text\/event\-stream;?(\s*charset\=utf\-8)?$/i;
var MINIMUM_DURATION = 1000;
var MAXIMUM_DURATION = 18000000;

var parseDuration = function parseDuration(value, def) {
  var n = parseInt(value, 10);

  if (n !== n) {
    n = def;
  }

  return clampDuration(n);
};

var clampDuration = function clampDuration(n) {
  return Math.min(Math.max(n, MINIMUM_DURATION), MAXIMUM_DURATION);
};

var fire = function fire(that, f, event) {
  try {
    if (typeof f === 'function') {
      f.call(that, event);
    }
  } catch (e) {
    throwError(e);
  }
};

function EventSourcePolyfill(url, options) {
  EventTarget.call(this);
  this.onopen = undefined;
  this.onmessage = undefined;
  this.onerror = undefined;
  this.url = undefined;
  this.readyState = undefined;
  this.withCredentials = undefined;
  this._close = undefined;
  start(this, url, options);
}

_c11 = EventSourcePolyfill;
var isFetchSupported = fetch != undefined && Response != undefined && 'body' in Response.prototype;

function start(es, url, options) {
  url = String(url);
  var withCredentials = options != undefined && Boolean(options.withCredentials);
  var initialRetry = clampDuration(1000);
  var heartbeatTimeout = options != undefined && options.heartbeatTimeout != undefined ? parseDuration(options.heartbeatTimeout, 45000) : clampDuration(45000);
  var lastEventId = '';
  var retry = initialRetry;
  var wasActivity = false;
  var headers = options != undefined && options.headers != undefined ? JSON.parse(JSON.stringify(options.headers)) : undefined;
  var CurrentTransport = options != undefined && options.Transport != undefined ? options.Transport : XMLHttpRequest;
  var xhr = isFetchSupported && !(options != undefined && options.Transport != undefined) ? undefined : new XHRWrapper(new CurrentTransport());
  var transport = xhr == undefined ? new FetchTransport() : new XHRTransport();
  var cancelFunction = undefined;
  var timeout = 0;
  var currentState = WAITING;
  var dataBuffer = '';
  var lastEventIdBuffer = '';
  var eventTypeBuffer = '';
  var textBuffer = '';
  var state = FIELD_START;
  var fieldStart = 0;
  var valueStart = 0;

  var onStart = function onStart(status, statusText, contentType, headers, cancel) {
    if (currentState === CONNECTING) {
      cancelFunction = cancel;

      if (status === 200 && contentType != undefined && contentTypeRegExp.test(contentType)) {
        currentState = OPEN;
        wasActivity = true;
        retry = initialRetry;
        es.readyState = OPEN;
        var event = new ConnectionEvent('open', {
          status: status,
          statusText: statusText,
          headers: headers
        });
        es.dispatchEvent(event);
        fire(es, es.onopen, event);
      } else {
        var message = '';

        if (status !== 200) {
          if (statusText) {
            statusText = statusText.replace(/\s+/g, ' ');
          }

          message = "EventSource's response has a status " + status + ' ' + statusText + ' that is not 200. Aborting the connection.';
        } else {
          message = "EventSource's response has a Content-Type specifying an unsupported type: " + (contentType == undefined ? '-' : contentType.replace(/\s+/g, ' ')) + '. Aborting the connection.';
        }

        throwError(new Error(message));
        close();
        var event = new ConnectionEvent('error', {
          status: status,
          statusText: statusText,
          headers: headers
        });
        es.dispatchEvent(event);
        fire(es, es.onerror, event);
      }
    }
  };

  var onProgress = function onProgress(textChunk) {
    if (currentState === OPEN) {
      var n = -1;

      for (var i = 0; i < textChunk.length; i += 1) {
        var c = textChunk.charCodeAt(i);

        if (c === '\n'.charCodeAt(0) || c === '\r'.charCodeAt(0)) {
          n = i;
        }
      }

      var chunk = (n !== -1 ? textBuffer : '') + textChunk.slice(0, n + 1);
      textBuffer = (n === -1 ? textBuffer : '') + textChunk.slice(n + 1);

      if (chunk !== '') {
        wasActivity = true;
      }

      for (var position = 0; position < chunk.length; position += 1) {
        var c = chunk.charCodeAt(position);

        if (state === AFTER_CR && c === '\n'.charCodeAt(0)) {
          state = FIELD_START;
        } else {
          if (state === AFTER_CR) {
            state = FIELD_START;
          }

          if (c === '\r'.charCodeAt(0) || c === '\n'.charCodeAt(0)) {
            if (state !== FIELD_START) {
              if (state === FIELD) {
                valueStart = position + 1;
              }

              var field = chunk.slice(fieldStart, valueStart - 1);
              var value = chunk.slice(valueStart + (valueStart < position && chunk.charCodeAt(valueStart) === ' '.charCodeAt(0) ? 1 : 0), position);

              if (field === 'data') {
                dataBuffer += '\n';
                dataBuffer += value;
              } else if (field === 'id') {
                lastEventIdBuffer = value;
              } else if (field === 'event') {
                eventTypeBuffer = value;
              } else if (field === 'retry') {
                initialRetry = parseDuration(value, initialRetry);
                retry = initialRetry;
              } else if (field === 'heartbeatTimeout') {
                heartbeatTimeout = parseDuration(value, heartbeatTimeout);

                if (timeout !== 0) {
                  clearTimeout(timeout);
                  timeout = setTimeout(function () {
                    onTimeout();
                  }, heartbeatTimeout);
                }
              }
            }

            if (state === FIELD_START) {
              if (dataBuffer !== '') {
                lastEventId = lastEventIdBuffer;

                if (eventTypeBuffer === '') {
                  eventTypeBuffer = 'message';
                }

                var event = new MessageEvent(eventTypeBuffer, {
                  data: dataBuffer.slice(1),
                  lastEventId: lastEventIdBuffer
                });
                es.dispatchEvent(event);

                if (eventTypeBuffer === 'message') {
                  fire(es, es.onmessage, event);
                }

                if (currentState === CLOSED) {
                  return;
                }
              }

              dataBuffer = '';
              eventTypeBuffer = '';
            }

            state = c === '\r'.charCodeAt(0) ? AFTER_CR : FIELD_START;
          } else {
            if (state === FIELD_START) {
              fieldStart = position;
              state = FIELD;
            }

            if (state === FIELD) {
              if (c === ':'.charCodeAt(0)) {
                valueStart = position + 1;
                state = VALUE_START;
              }
            } else if (state === VALUE_START) {
              state = VALUE;
            }
          }
        }
      }
    }
  };

  var onFinish = function onFinish() {
    if (currentState === OPEN || currentState === CONNECTING) {
      currentState = WAITING;

      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }

      timeout = setTimeout(function () {
        onTimeout();
      }, retry);
      retry = clampDuration(Math.min(initialRetry * 16, retry * 2));
      es.readyState = CONNECTING;
      var event = new Event('error');
      es.dispatchEvent(event);
      fire(es, es.onerror, event);
    }
  };

  var close = function close() {
    currentState = CLOSED;

    if (cancelFunction != undefined) {
      cancelFunction();
      cancelFunction = undefined;
    }

    if (timeout !== 0) {
      clearTimeout(timeout);
      timeout = 0;
    }

    es.readyState = CLOSED;
  };

  var onTimeout = function onTimeout() {
    timeout = 0;

    if (currentState !== WAITING) {
      if (!wasActivity && cancelFunction != undefined) {
        throwError(new Error('No activity within ' + heartbeatTimeout + ' milliseconds. Reconnecting.'));
        cancelFunction();
        cancelFunction = undefined;
      } else {
        wasActivity = false;
        timeout = setTimeout(function () {
          onTimeout();
        }, heartbeatTimeout);
      }

      return;
    }

    wasActivity = false;
    timeout = setTimeout(function () {
      onTimeout();
    }, heartbeatTimeout);
    currentState = CONNECTING;
    dataBuffer = '';
    eventTypeBuffer = '';
    lastEventIdBuffer = lastEventId;
    textBuffer = '';
    fieldStart = 0;
    valueStart = 0;
    state = FIELD_START; // https://bugzilla.mozilla.org/show_bug.cgi?id=428916
    // Request header field Last-Event-ID is not allowed by Access-Control-Allow-Headers.

    var requestURL = url;

    if (url.slice(0, 5) !== 'data:' && url.slice(0, 5) !== 'blob:') {
      if (lastEventId !== '') {
        requestURL += (url.indexOf('?') === -1 ? '?' : '&') + 'lastEventId=' + encodeURIComponent(lastEventId);
      }
    }

    var requestHeaders = {};
    requestHeaders['Accept'] = 'text/event-stream';

    if (headers != undefined) {
      for (var name in headers) {
        if (Object.prototype.hasOwnProperty.call(headers, name)) {
          requestHeaders[name] = headers[name];
        }
      }
    }

    try {
      transport.open(xhr, onStart, onProgress, onFinish, requestURL, withCredentials, requestHeaders);
    } catch (error) {
      close();
      throw error;
    }
  };

  es.url = url;
  es.readyState = CONNECTING;
  es.withCredentials = withCredentials;
  es._close = close;
  onTimeout();
}

EventSourcePolyfill.prototype = Object.create(EventTarget.prototype);
EventSourcePolyfill.prototype.CONNECTING = CONNECTING;
EventSourcePolyfill.prototype.OPEN = OPEN;
EventSourcePolyfill.prototype.CLOSED = CLOSED;

EventSourcePolyfill.prototype.close = function () {
  this._close();
};

EventSourcePolyfill.CONNECTING = CONNECTING;
EventSourcePolyfill.OPEN = OPEN;
EventSourcePolyfill.CLOSED = CLOSED;
EventSourcePolyfill.prototype.withCredentials = undefined;
var _default = EventSourcePolyfill;
exports["default"] = _default;

var _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11;

$RefreshReg$(_c, "TextDecoderPolyfill");
$RefreshReg$(_c2, "XHRWrapper");
$RefreshReg$(_c3, "HeadersPolyfill");
$RefreshReg$(_c4, "XHRTransport");
$RefreshReg$(_c5, "HeadersWrapper");
$RefreshReg$(_c6, "FetchTransport");
$RefreshReg$(_c7, "EventTarget");
$RefreshReg$(_c8, "Event");
$RefreshReg$(_c9, "MessageEvent");
$RefreshReg$(_c10, "ConnectionEvent");
$RefreshReg$(_c11, "EventSourcePolyfill");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/fouc.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/dev/fouc.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.displayContent = displayContent; // This function is used to remove Next.js' no-FOUC styles workaround for using
// `style-loader` in development. It must be called before hydration, or else
// rendering won't have the correct computed values in effects.

function displayContent(callback) {
  ;
  (window.requestAnimationFrame || setTimeout)(function () {
    for (var x = document.querySelectorAll('[data-next-hide-fouc]'), i = x.length; i--;) {
      x[i].parentNode.removeChild(x[i]);
    }

    if (callback) {
      callback();
    }
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/on-demand-entries-client.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/on-demand-entries-client.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _router = _interopRequireDefault(__webpack_require__(/*! next/router */ "./node_modules/next/router.js"));

var _onDemandEntriesUtils = __webpack_require__(/*! ./on-demand-entries-utils */ "./node_modules/next/dist/client/dev/on-demand-entries-utils.js");

var _default = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {
    var assetPrefix;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            assetPrefix = _ref.assetPrefix;

            _router["default"].ready(function () {
              _router["default"].events.on('routeChangeComplete', _onDemandEntriesUtils.setupPing.bind(void 0, assetPrefix, function () {
                return _router["default"].pathname;
              }));
            });

            (0, _onDemandEntriesUtils.setupPing)(assetPrefix, function () {
              return _router["default"].pathname;
            }, _onDemandEntriesUtils.currentPage); // prevent HMR connection from being closed when running tests

            if (!undefined) {
              document.addEventListener('visibilitychange', function (_event) {
                var state = document.visibilityState;

                if (state === 'visible') {
                  (0, _onDemandEntriesUtils.setupPing)(assetPrefix, function () {
                    return _router["default"].pathname;
                  }, true);
                } else {
                  (0, _onDemandEntriesUtils.closePing)();
                }
              });
              window.addEventListener('beforeunload', function () {
                (0, _onDemandEntriesUtils.closePing)();
              });
            }

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function _default(_x) {
    return _ref2.apply(this, arguments);
  };
}();

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/on-demand-entries-utils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/on-demand-entries-utils.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.closePing = closePing;
exports.setupPing = setupPing;
exports.currentPage = void 0;

var _eventsource = __webpack_require__(/*! ./error-overlay/eventsource */ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js");
/* global location */


var evtSource;
var currentPage;
exports.currentPage = currentPage;

function closePing() {
  if (evtSource) evtSource.close();
  evtSource = null;
}

function setupPing(assetPrefix, pathnameFn, retry) {
  var pathname = pathnameFn(); // Make sure to only create new EventSource request if page has changed

  if (pathname === currentPage && !retry) return;
  exports.currentPage = currentPage = pathname; // close current EventSource connection

  closePing();
  var url = "".concat(assetPrefix, "/_next/webpack-hmr?page=").concat(currentPage);
  evtSource = (0, _eventsource.getEventSourceWrapper)({
    path: url,
    timeout: 5000,
    ondemand: 1
  });
  evtSource.addMessageListener(function (event) {
    if (event.data.indexOf('{') === -1) return;

    try {
      var payload = JSON.parse(event.data);

      if (payload.invalid) {
        // Payload can be invalid even if the page does not exist.
        // So, we need to make sure it exists before reloading.
        fetch(location.href, {
          credentials: 'same-origin'
        }).then(function (pageRes) {
          if (pageRes.status === 200) {
            location.reload();
          }
        });
      }
    } catch (err) {
      console.error('on-demand-entries failed to parse response', err);
    }
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _hotDevClient = _interopRequireDefault(__webpack_require__(/*! ./error-overlay/hot-dev-client */ "./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js"));

var _default = function _default(_ref) {
  var assetPrefix = _ref.assetPrefix;
  var options = {
    path: "".concat(assetPrefix, "/_next/webpack-hmr")
  };
  var devClient = (0, _hotDevClient["default"])(options);
  devClient.subscribeToHmrEvent(function (obj) {
    if (obj.action === 'reloadPage') {
      return window.location.reload();
    }

    if (obj.action === 'removedPage') {
      var _obj$data = _slicedToArray(obj.data, 1),
          page = _obj$data[0];

      if (page === window.next.router.pathname) {
        return window.location.reload();
      }

      return;
    }

    if (obj.action === 'addedPage') {
      var _obj$data2 = _slicedToArray(obj.data, 1),
          _page = _obj$data2[0];

      if (_page === window.next.router.pathname && typeof window.next.router.components[_page] === 'undefined') {
        return window.location.reload();
      }

      return;
    }

    throw new Error('Unexpected action ' + obj.action);
  });
  return devClient;
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/head-manager.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/head-manager.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = initHeadManager;
exports.DOMAttributeNames = void 0;
var DOMAttributeNames = {
  acceptCharset: 'accept-charset',
  className: 'class',
  htmlFor: 'for',
  httpEquiv: 'http-equiv',
  noModule: 'noModule'
};
exports.DOMAttributeNames = DOMAttributeNames;

function reactElementToDOM(_ref) {
  var type = _ref.type,
      props = _ref.props;
  var el = document.createElement(type);

  for (var p in props) {
    if (!props.hasOwnProperty(p)) continue;
    if (p === 'children' || p === 'dangerouslySetInnerHTML') continue; // we don't render undefined props to the DOM

    if (props[p] === undefined) continue;
    var attr = DOMAttributeNames[p] || p.toLowerCase();

    if (type === 'script' && (attr === 'async' || attr === 'defer' || attr === 'noModule')) {
      ;
      el[attr] = !!props[p];
    } else {
      el.setAttribute(attr, props[p]);
    }
  }

  var children = props.children,
      dangerouslySetInnerHTML = props.dangerouslySetInnerHTML;

  if (dangerouslySetInnerHTML) {
    el.innerHTML = dangerouslySetInnerHTML.__html || '';
  } else if (children) {
    el.textContent = typeof children === 'string' ? children : Array.isArray(children) ? children.join('') : '';
  }

  return el;
}

function updateElements(type, components) {
  var headEl = document.getElementsByTagName('head')[0];
  var headCountEl = headEl.querySelector('meta[name=next-head-count]');

  if (true) {
    if (!headCountEl) {
      console.error('Warning: next-head-count is missing. https://err.sh/next.js/next-head-count-missing');
      return;
    }
  }

  var headCount = Number(headCountEl.content);
  var oldTags = [];

  for (var i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = j.previousElementSibling) {
    if (j.tagName.toLowerCase() === type) {
      oldTags.push(j);
    }
  }

  var newTags = components.map(reactElementToDOM).filter(function (newTag) {
    for (var k = 0, len = oldTags.length; k < len; k++) {
      var oldTag = oldTags[k];

      if (oldTag.isEqualNode(newTag)) {
        oldTags.splice(k, 1);
        return false;
      }
    }

    return true;
  });
  oldTags.forEach(function (t) {
    return t.parentNode.removeChild(t);
  });
  newTags.forEach(function (t) {
    return headEl.insertBefore(t, headCountEl);
  });
  headCountEl.content = (headCount - oldTags.length + newTags.length).toString();
}

function initHeadManager() {
  var updatePromise = null;
  return {
    mountedInstances: new Set(),
    updateHead: function updateHead(head) {
      var promise = updatePromise = Promise.resolve().then(function () {
        if (promise !== updatePromise) return;
        updatePromise = null;
        var tags = {};
        head.forEach(function (h) {
          var components = tags[h.type] || [];
          components.push(h);
          tags[h.type] = components;
        });
        var titleComponent = tags.title ? tags.title[0] : null;
        var title = '';

        if (titleComponent) {
          var children = titleComponent.props.children;
          title = typeof children === 'string' ? children : Array.isArray(children) ? children.join('') : '';
        }

        if (title !== document.title) document.title = title;
        ['meta', 'base', 'link', 'style', 'script'].forEach(function (type) {
          updateElements(type, tags[type] || []);
        });
      });
    }
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _inherits = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");

var _possibleConstructorReturn = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");

var _getPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _s = $RefreshSig$(),
    _s2 = $RefreshSig$();

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var _interopRequireWildcard3 = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.render = render;
exports.renderError = renderError;
exports["default"] = exports.emitter = exports.router = exports.version = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js"));

var _interopRequireWildcard2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js"));

__webpack_require__(/*! @next/polyfill-module */ "./node_modules/@next/polyfill-module/dist/polyfill-module.js");

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));

var _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.module.js"));

var _headManagerContext = __webpack_require__(/*! ../next-server/lib/head-manager-context */ "./node_modules/next/dist/next-server/lib/head-manager-context.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _router = __webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

var _isDynamic = __webpack_require__(/*! ../next-server/lib/router/utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var querystring = _interopRequireWildcard3(__webpack_require__(/*! ../next-server/lib/router/utils/querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js"));

var envConfig = _interopRequireWildcard3(__webpack_require__(/*! ../next-server/lib/runtime-config */ "./node_modules/next/dist/next-server/lib/runtime-config.js"));

var _utils = __webpack_require__(/*! ../next-server/lib/utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _headManager = _interopRequireDefault(__webpack_require__(/*! ./head-manager */ "./node_modules/next/dist/client/head-manager.js"));

var _pageLoader = _interopRequireDefault(__webpack_require__(/*! ./page-loader */ "./node_modules/next/dist/client/page-loader.js"));

var _performanceRelayer = _interopRequireDefault(__webpack_require__(/*! ./performance-relayer */ "./node_modules/next/dist/client/performance-relayer.js"));

var _router2 = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");
/* global location */


var data = JSON.parse(document.getElementById('__NEXT_DATA__').textContent);
window.__NEXT_DATA__ = data;
var version = "10.0.5";
exports.version = version;

var looseToArray = function looseToArray(input) {
  return [].slice.call(input);
};

var hydrateProps = data.props,
    hydrateErr = data.err,
    page = data.page,
    query = data.query,
    buildId = data.buildId,
    assetPrefix = data.assetPrefix,
    runtimeConfig = data.runtimeConfig,
    dynamicIds = data.dynamicIds,
    isFallback = data.isFallback,
    locales = data.locales,
    domainLocales = data.domainLocales;
var locale = data.locale,
    defaultLocale = data.defaultLocale;
var prefix = assetPrefix || ''; // With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time
// So, this is how we do it in the client side at runtime

__webpack_require__.p = "".concat(prefix, "/_next/"); //eslint-disable-line
// Initialize next/config with the environment configuration

envConfig.setConfig({
  serverRuntimeConfig: {},
  publicRuntimeConfig: runtimeConfig || {}
});
var asPath = (0, _utils.getURL)(); // make sure not to attempt stripping basePath for 404s

if ((0, _router.hasBasePath)(asPath)) {
  asPath = (0, _router.delBasePath)(asPath);
}

if (false) { var detectedDomain, localePathResult, parsedAs, _require4, formatUrl, _require3, parseRelativeUrl, _require2, detectDomainLocale, _require, normalizeLocalePath; }

var pageLoader = new _pageLoader["default"](buildId, prefix);

var register = function register(_ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      r = _ref2[0],
      f = _ref2[1];

  return pageLoader.routeLoader.onEntrypoint(r, f);
};

if (window.__NEXT_P) {
  // Defer page registration for another tick. This will increase the overall
  // latency in hydrating the page, but reduce the total blocking time.
  window.__NEXT_P.map(function (p) {
    return setTimeout(function () {
      return register(p);
    }, 0);
  });
}

window.__NEXT_P = [];
window.__NEXT_P.push = register;
var headManager = (0, _headManager["default"])();
var appElement = document.getElementById('__next');
var lastAppProps;

var _lastRenderReject;

var webpackHMR;
var router;
exports.router = router;
var CachedComponent;
var CachedApp, onPerfEntry;

var Container = /*#__PURE__*/function (_react$default$Compon) {
  _inherits(Container, _react$default$Compon);

  var _super = _createSuper(Container);

  function Container() {
    _classCallCheck(this, Container);

    return _super.apply(this, arguments);
  }

  _createClass(Container, [{
    key: "componentDidCatch",
    value: function componentDidCatch(componentErr, info) {
      this.props.fn(componentErr, info);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.scrollToHash(); // We need to replace the router state if:
      // - the page was (auto) exported and has a query string or search (hash)
      // - it was auto exported and is a dynamic route (to provide params)
      // - if it is a client-side skeleton (fallback render)

      if (router.isSsr && (isFallback || data.nextExport && ((0, _isDynamic.isDynamicRoute)(router.pathname) || location.search) || hydrateProps && hydrateProps.__N_SSG && location.search)) {
        // update query on mount for exported pages
        router.replace(router.pathname + '?' + String(querystring.assign(querystring.urlQueryToSearchParams(router.query), new URLSearchParams(location.search))), asPath, {
          // @ts-ignore
          // WARNING: `_h` is an internal option for handing Next.js
          // client-side hydration. Your app should _never_ use this property.
          // It may change at any time without notice.
          _h: 1,
          // Fallback pages must trigger the data fetch, so the transition is
          // not shallow.
          // Other pages (strictly updating query) happens shallowly, as data
          // requirements would already be present.
          shallow: !isFallback
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.scrollToHash();
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash() {
      var _location = location,
          hash = _location.hash;
      hash = hash && hash.substring(1);
      if (!hash) return;
      var el = document.getElementById(hash);
      if (!el) return; // If we call scrollIntoView() in here without a setTimeout
      // it won't scroll properly.

      setTimeout(function () {
        return el.scrollIntoView();
      }, 0);
    }
  }, {
    key: "render",
    value: function render() {
      if (false) {} else {
        var _require5 = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ "./node_modules/@next/react-dev-overlay/lib/client.js"),
            ReactDevOverlay = _require5.ReactDevOverlay;

        return /*#__PURE__*/_react["default"].createElement(ReactDevOverlay, null, this.props.children);
      }
    }
  }]);

  return Container;
}(_react["default"].Component);

var emitter = (0, _mitt["default"])();
exports.emitter = emitter;

var _default = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var opts,
        appEntrypoint,
        app,
        mod,
        initialErr,
        pageEntrypoint,
        _require6,
        isValidElementType,
        _require7,
        getNodeError,
        renderCtx,
        _args = arguments;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            opts = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};

            // This makes sure this specific lines are removed in production
            if (true) {
              webpackHMR = opts.webpackHMR;
            }

            _context.next = 4;
            return pageLoader.routeLoader.whenEntrypoint('/_app');

          case 4:
            appEntrypoint = _context.sent;

            if (!('error' in appEntrypoint)) {
              _context.next = 7;
              break;
            }

            throw appEntrypoint.error;

          case 7:
            app = appEntrypoint.component, mod = appEntrypoint.exports;
            CachedApp = app;

            if (mod && mod.reportWebVitals) {
              onPerfEntry = function onPerfEntry(_ref4) {
                var id = _ref4.id,
                    name = _ref4.name,
                    startTime = _ref4.startTime,
                    value = _ref4.value,
                    duration = _ref4.duration,
                    entryType = _ref4.entryType,
                    entries = _ref4.entries;
                // Combines timestamp with random number for unique ID
                var uniqueID = "".concat(Date.now(), "-").concat(Math.floor(Math.random() * (9e12 - 1)) + 1e12);
                var perfStartEntry;

                if (entries && entries.length) {
                  perfStartEntry = entries[0].startTime;
                }

                mod.reportWebVitals({
                  id: id || uniqueID,
                  name: name,
                  startTime: startTime || perfStartEntry,
                  value: value == null ? duration : value,
                  label: entryType === 'mark' || entryType === 'measure' ? 'custom' : 'web-vital'
                });
              };
            }

            initialErr = hydrateErr;
            _context.prev = 11;

            if (!( true && hydrateErr)) {
              _context.next = 16;
              break;
            }

            _context.t0 = {
              error: hydrateErr
            };
            _context.next = 19;
            break;

          case 16:
            _context.next = 18;
            return pageLoader.routeLoader.whenEntrypoint(page);

          case 18:
            _context.t0 = _context.sent;

          case 19:
            pageEntrypoint = _context.t0;

            if (!('error' in pageEntrypoint)) {
              _context.next = 22;
              break;
            }

            throw pageEntrypoint.error;

          case 22:
            CachedComponent = pageEntrypoint.component;

            if (false) {}

            _require6 = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"), isValidElementType = _require6.isValidElementType;

            if (isValidElementType(CachedComponent)) {
              _context.next = 27;
              break;
            }

            throw new Error("The default export is not a React Component in page: \"".concat(page, "\""));

          case 27:
            _context.next = 32;
            break;

          case 29:
            _context.prev = 29;
            _context.t1 = _context["catch"](11);
            // This catches errors like throwing in the top level of a module
            initialErr = _context.t1;

          case 32:
            if (true) {
              _require7 = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ "./node_modules/@next/react-dev-overlay/lib/client.js"), getNodeError = _require7.getNodeError; // Server-side runtime errors need to be re-thrown on the client-side so
              // that the overlay is rendered.

              if (initialErr) {
                if (initialErr === hydrateErr) {
                  setTimeout(function () {
                    var error;

                    try {
                      // Generate a new error object. We `throw` it because some browsers
                      // will set the `stack` when thrown, and we want to ensure ours is
                      // not overridden when we re-throw it below.
                      throw new Error(initialErr.message);
                    } catch (e) {
                      error = e;
                    }

                    error.name = initialErr.name;
                    error.stack = initialErr.stack;
                    var node = getNodeError(error);
                    throw node;
                  });
                } // We replaced the server-side error with a client-side error, and should
                // no longer rewrite the stack trace to a Node error.
                else {
                    setTimeout(function () {
                      throw initialErr;
                    });
                  }
              }
            }

            if (!window.__NEXT_PRELOADREADY) {
              _context.next = 36;
              break;
            }

            _context.next = 36;
            return window.__NEXT_PRELOADREADY(dynamicIds);

          case 36:
            exports.router = router = (0, _router2.createRouter)(page, query, asPath, {
              initialProps: hydrateProps,
              pageLoader: pageLoader,
              App: CachedApp,
              Component: CachedComponent,
              wrapApp: wrapApp,
              err: initialErr,
              isFallback: Boolean(isFallback),
              subscription: function subscription(info, App, scroll) {
                return render(Object.assign({}, info, {
                  App: App,
                  scroll: scroll
                }));
              },
              locale: locale,
              locales: locales,
              defaultLocale: defaultLocale,
              domainLocales: domainLocales
            }); // call init-client middleware

            if (false) {}

            renderCtx = {
              App: CachedApp,
              initial: true,
              Component: CachedComponent,
              props: hydrateProps,
              err: initialErr
            };

            if (true) {
              _context.next = 44;
              break;
            }

            render(renderCtx);
            return _context.abrupt("return", emitter);

          case 44:
            return _context.abrupt("return", {
              emitter: emitter,
              render: render,
              renderCtx: renderCtx
            });

          case 45:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[11, 29]]);
  }));

  return function _default() {
    return _ref3.apply(this, arguments);
  };
}();

exports["default"] = _default;

function render(_x) {
  return _render.apply(this, arguments);
} // This method handles all runtime and debug errors.
// 404 and 500 errors are special kind of errors
// and they are still handle via the main render method.


function _render() {
  _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(renderingProps) {
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!renderingProps.err) {
              _context2.next = 4;
              break;
            }

            _context2.next = 3;
            return renderError(renderingProps);

          case 3:
            return _context2.abrupt("return");

          case 4:
            _context2.prev = 4;
            _context2.next = 7;
            return doRender(renderingProps);

          case 7:
            _context2.next = 16;
            break;

          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](4);

            if (!_context2.t0.cancelled) {
              _context2.next = 13;
              break;
            }

            throw _context2.t0;

          case 13:
            if (true) {
              // Ensure this error is displayed in the overlay in development
              setTimeout(function () {
                throw _context2.t0;
              });
            }

            _context2.next = 16;
            return renderError((0, _extends2["default"])({}, renderingProps, {
              err: _context2.t0
            }));

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[4, 9]]);
  }));
  return _render.apply(this, arguments);
}

function renderError(renderErrorProps) {
  var App = renderErrorProps.App,
      err = renderErrorProps.err; // In development runtime errors are caught by our overlay
  // In production we catch runtime errors using componentDidCatch which will trigger renderError

  if (true) {
    // A Next.js rendering runtime error is always unrecoverable
    // FIXME: let's make this recoverable (error in GIP client-transition)
    webpackHMR.onUnrecoverableError(); // We need to render an empty <App> so that the `<ReactDevOverlay>` can
    // render itself.

    return doRender({
      App: function App() {
        return null;
      },
      props: {},
      Component: function Component() {
        return null;
      },
      styleSheets: []
    });
  }

  if (false) {} // Make sure we log the error to the console, otherwise users can't track down issues.


  console.error(err);
  return pageLoader.loadPage('/_error').then(function (_ref5) {
    var ErrorComponent = _ref5.page,
        styleSheets = _ref5.styleSheets;
    // In production we do a normal render with the `ErrorComponent` as component.
    // If we've gotten here upon initial render, we can use the props from the server.
    // Otherwise, we need to call `getInitialProps` on `App` before mounting.
    var AppTree = wrapApp(App);
    var appCtx = {
      Component: ErrorComponent,
      AppTree: AppTree,
      router: router,
      ctx: {
        err: err,
        pathname: page,
        query: query,
        asPath: asPath,
        AppTree: AppTree
      }
    };
    return Promise.resolve(renderErrorProps.props ? renderErrorProps.props : (0, _utils.loadGetInitialProps)(App, appCtx)).then(function (initProps) {
      return doRender((0, _extends2["default"])({}, renderErrorProps, {
        err: err,
        Component: ErrorComponent,
        styleSheets: styleSheets,
        props: initProps
      }));
    });
  });
}

var reactRoot = null;
var shouldUseHydrate = typeof _reactDom["default"].hydrate === 'function';

function renderReactElement(reactEl, domEl) {
  if (false) { var opts; } else {
    // mark start of hydrate/render
    if (_utils.ST) {
      performance.mark('beforeRender');
    } // The check for `.hydrate` is there to support React alternatives like preact


    if (shouldUseHydrate) {
      _reactDom["default"].hydrate(reactEl, domEl, markHydrateComplete);

      shouldUseHydrate = false;
    } else {
      _reactDom["default"].render(reactEl, domEl, markRenderComplete);
    }
  }
}

function markHydrateComplete() {
  if (!_utils.ST) return;
  performance.mark('afterHydrate'); // mark end of hydration

  performance.measure('Next.js-before-hydration', 'navigationStart', 'beforeRender');
  performance.measure('Next.js-hydration', 'beforeRender', 'afterHydrate');

  if (onPerfEntry) {
    performance.getEntriesByName('Next.js-hydration').forEach(onPerfEntry);
  }

  clearMarks();
}

function markRenderComplete() {
  if (!_utils.ST) return;
  performance.mark('afterRender'); // mark end of render

  var navStartEntries = performance.getEntriesByName('routeChange', 'mark');

  if (!navStartEntries.length) {
    return;
  }

  performance.measure('Next.js-route-change-to-render', navStartEntries[0].name, 'beforeRender');
  performance.measure('Next.js-render', 'beforeRender', 'afterRender');

  if (onPerfEntry) {
    performance.getEntriesByName('Next.js-render').forEach(onPerfEntry);
    performance.getEntriesByName('Next.js-route-change-to-render').forEach(onPerfEntry);
  }

  clearMarks();
  ['Next.js-route-change-to-render', 'Next.js-render'].forEach(function (measure) {
    return performance.clearMeasures(measure);
  });
}

function clearMarks() {
  ;
  ['beforeRender', 'afterHydrate', 'afterRender', 'routeChange'].forEach(function (mark) {
    return performance.clearMarks(mark);
  });
}

function AppContainer(_ref6) {
  var children = _ref6.children;
  return /*#__PURE__*/_react["default"].createElement(Container, {
    fn: function fn(error) {
      return renderError({
        App: CachedApp,
        err: error
      })["catch"](function (err) {
        return console.error('Error rendering page: ', err);
      });
    }
  }, /*#__PURE__*/_react["default"].createElement(_routerContext.RouterContext.Provider, {
    value: (0, _router2.makePublicRouterInstance)(router)
  }, /*#__PURE__*/_react["default"].createElement(_headManagerContext.HeadManagerContext.Provider, {
    value: headManager
  }, children)));
}

_c = AppContainer;

var wrapApp = function wrapApp(App) {
  return function (wrappedAppProps) {
    var appProps = (0, _extends2["default"])({}, wrappedAppProps, {
      Component: CachedComponent,
      err: hydrateErr,
      router: router
    });
    return /*#__PURE__*/_react["default"].createElement(AppContainer, null, /*#__PURE__*/_react["default"].createElement(App, appProps));
  };
};

function doRender(input) {
  var App = input.App,
      Component = input.Component,
      props = input.props,
      err = input.err;
  var styleSheets = 'initial' in input ? undefined : input.styleSheets;
  Component = Component || lastAppProps.Component;
  props = props || lastAppProps.props;
  var appProps = (0, _extends2["default"])({}, props, {
    Component: Component,
    err: err,
    router: router
  }); // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.

  lastAppProps = appProps;
  var canceled = false;
  var resolvePromise;
  var renderPromise = new Promise(function (resolve, reject) {
    if (_lastRenderReject) {
      _lastRenderReject();
    }

    resolvePromise = function resolvePromise() {
      _lastRenderReject = null;
      resolve();
    };

    _lastRenderReject = function lastRenderReject() {
      canceled = true;
      _lastRenderReject = null;
      var error = new Error('Cancel rendering route');
      error.cancelled = true;
      reject(error);
    };
  }); // This function has a return type to ensure it doesn't start returning a
  // Promise. It should remain synchronous.

  function onStart() {
    if (!styleSheets || // We use `style-loader` in development, so we don't need to do anything
    // unless we're in production:
    true) {
      return false;
    }

    var currentStyleTags = looseToArray(document.querySelectorAll('style[data-n-href]'));
    var currentHrefs = new Set(currentStyleTags.map(function (tag) {
      return tag.getAttribute('data-n-href');
    }));
    var noscript = document.querySelector('noscript[data-n-css]');
    var nonce = noscript == null ? void 0 : noscript.getAttribute('data-n-css');
    styleSheets.forEach(function (_ref7) {
      var href = _ref7.href,
          text = _ref7.text;

      if (!currentHrefs.has(href)) {
        var styleTag = document.createElement('style');
        styleTag.setAttribute('data-n-href', href);
        styleTag.setAttribute('media', 'x');

        if (nonce) {
          styleTag.setAttribute('nonce', nonce);
        }

        document.head.appendChild(styleTag);
        styleTag.appendChild(document.createTextNode(text));
      }
    });
    return true;
  }

  function onHeadCommit() {
    if ( // We use `style-loader` in development, so we don't need to do anything
    // unless we're in production:
    false) { var referenceNode, idx, currentHrefs, currentStyleTags, desiredHrefs; }

    if (input.scroll) {
      window.scrollTo(input.scroll.x, input.scroll.y);
    }
  }

  function onRootCommit() {
    resolvePromise();
  }

  var elem = /*#__PURE__*/_react["default"].createElement(Root, {
    callback: onRootCommit
  }, /*#__PURE__*/_react["default"].createElement(Head, {
    callback: onHeadCommit
  }), /*#__PURE__*/_react["default"].createElement(AppContainer, null, /*#__PURE__*/_react["default"].createElement(App, appProps)));

  onStart(); // We catch runtime errors using componentDidCatch which will trigger renderError

  renderReactElement( false ? /*#__PURE__*/undefined : elem, appElement);
  return renderPromise;
}

function Root(_ref9) {
  _s();

  var callback = _ref9.callback,
      children = _ref9.children;

  // We use `useLayoutEffect` to guarantee the callback is executed
  // as soon as React flushes the update.
  _react["default"].useLayoutEffect(function () {
    return callback();
  }, [callback]);

  if (undefined) {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    _react["default"].useEffect(function () {
      window.__NEXT_HYDRATED = true;

      if (window.__NEXT_HYDRATED_CB) {
        window.__NEXT_HYDRATED_CB();
      }
    }, []);
  } // We should ask to measure the Web Vitals after rendering completes so we
  // don't cause any hydration delay:


  _react["default"].useEffect(function () {
    (0, _performanceRelayer["default"])(onPerfEntry);
  }, []);

  return children;
} // Dummy component that we render as a child of Root so that we can
// toggle the correct styles before the page is rendered.


_s(Root, "KDoBXdlwSU+O+uFsByO25XxhKDU=");

_c2 = Root;

function Head(_ref10) {
  _s2();

  var callback = _ref10.callback;

  // We use `useLayoutEffect` to guarantee the callback is executed
  // as soon as React flushes the update.
  _react["default"].useLayoutEffect(function () {
    return callback();
  }, [callback]);

  return null;
}

_s2(Head, "n7/vCynhJvM+pLkyL2DMQUF0odM=");

_c3 = Head;

var _c, _c2, _c3;

$RefreshReg$(_c, "AppContainer");
$RefreshReg$(_c2, "Root");
$RefreshReg$(_c3, "Head");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/next-dev.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/next-dev.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var next = _interopRequireWildcard(__webpack_require__(/*! ./ */ "./node_modules/next/dist/client/index.js"));

var _eventSourcePolyfill = _interopRequireDefault(__webpack_require__(/*! ./dev/event-source-polyfill */ "./node_modules/next/dist/client/dev/event-source-polyfill.js"));

var _onDemandEntriesClient = _interopRequireDefault(__webpack_require__(/*! ./dev/on-demand-entries-client */ "./node_modules/next/dist/client/dev/on-demand-entries-client.js"));

var _webpackHotMiddlewareClient = _interopRequireDefault(__webpack_require__(/*! ./dev/webpack-hot-middleware-client */ "./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js"));

var _devBuildWatcher = _interopRequireDefault(__webpack_require__(/*! ./dev/dev-build-watcher */ "./node_modules/next/dist/client/dev/dev-build-watcher.js"));

var _fouc = __webpack_require__(/*! ./dev/fouc */ "./node_modules/next/dist/client/dev/fouc.js");

var _eventsource = __webpack_require__(/*! ./dev/error-overlay/eventsource */ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js");

var querystring = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/utils/querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js"));
/* globals import('./dev/noop'); */
// Temporary workaround for the issue described here:
// https://github.com/vercel/next.js/issues/3775#issuecomment-407438123
// The runtimeChunk doesn't have dynamic import handling code when there hasn't been a dynamic import
// The runtimeChunk can't hot reload itself currently to correct it when adding pages using on-demand-entries
// eslint-disable-next-line no-unused-expressions


__webpack_require__.e(/*! import() */ 0).then(__webpack_require__.t.bind(null, /*! ./dev/noop */ "./node_modules/next/dist/client/dev/noop.js", 7));
; // Support EventSource on Internet Explorer 11

if (!window.EventSource) {
  window.EventSource = _eventSourcePolyfill["default"];
}

var _window = window,
    assetPrefix = _window.__NEXT_DATA__.assetPrefix;
var prefix = assetPrefix || '';
var webpackHMR = (0, _webpackHotMiddlewareClient["default"])({
  assetPrefix: prefix
});
window.next = next;
(0, next["default"])({
  webpackHMR: webpackHMR
}).then(function (_ref) {
  var renderCtx = _ref.renderCtx,
      render = _ref.render;
  (0, _onDemandEntriesClient["default"])({
    assetPrefix: prefix
  });

  var buildIndicatorHandler = function buildIndicatorHandler() {};

  function devPagesManifestListener(event) {
    if (event.data.indexOf('devPagesManifest') !== -1) {
      fetch("".concat(prefix, "/_next/static/development/_devPagesManifest.json")).then(function (res) {
        return res.json();
      }).then(function (manifest) {
        window.__DEV_PAGES_MANIFEST = manifest;
      })["catch"](function (err) {
        console.log("Failed to fetch devPagesManifest", err);
      });
    } else if (event.data.indexOf('serverOnlyChanges') !== -1) {
      var _JSON$parse = JSON.parse(event.data),
          pages = _JSON$parse.pages;

      var router = window.next.router;

      if (pages.includes(router.pathname)) {
        console.log('Refreshing page data due to server-side change');
        buildIndicatorHandler('building');

        var clearIndicator = function clearIndicator() {
          return buildIndicatorHandler('built');
        };

        router.replace(router.pathname + '?' + String(querystring.assign(querystring.urlQueryToSearchParams(router.query), new URLSearchParams(location.search))), router.asPath)["finally"](clearIndicator);
      }
    }
  }

  devPagesManifestListener.unfiltered = true;
  (0, _eventsource.getEventSourceWrapper)({}).addMessageListener(devPagesManifestListener);

  if (true) {
    (0, _devBuildWatcher["default"])(function (handler) {
      buildIndicatorHandler = handler;
    });
  } // delay rendering until after styles have been applied in development


  (0, _fouc.displayContent)(function () {
    render(renderCtx);
  });
})["catch"](function (err) {
  console.error('Error was not caught', err);
});

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.removePathTrailingSlash = removePathTrailingSlash;
exports.normalizePathTrailingSlash = void 0;
/**
* Removes the trailing slash of a path if there is one. Preserves the root path `/`.
*/

function removePathTrailingSlash(path) {
  return path.endsWith('/') && path !== '/' ? path.slice(0, -1) : path;
}
/**
* Normalizes the trailing slash of a path according to the `trailingSlash` option
* in `next.config.js`.
*/


var normalizePathTrailingSlash =  false ? undefined : removePathTrailingSlash;
exports.normalizePathTrailingSlash = normalizePathTrailingSlash;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/page-loader.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/page-loader.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _router = __webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

var _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/router/utils/get-asset-path-from-route */ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js"));

var _isDynamic = __webpack_require__(/*! ../next-server/lib/router/utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _parseRelativeUrl = __webpack_require__(/*! ../next-server/lib/router/utils/parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var _routeLoader = _interopRequireWildcard(__webpack_require__(/*! ./route-loader */ "./node_modules/next/dist/client/route-loader.js"));

function normalizeRoute(route) {
  if (route[0] !== '/') {
    throw new Error("Route name should start with a \"/\", got \"".concat(route, "\""));
  }

  if (route === '/') return route;
  return route.replace(/\/$/, '');
}

var PageLoader = /*#__PURE__*/function () {
  function PageLoader(buildId, assetPrefix) {
    _classCallCheck(this, PageLoader);

    this.buildId = void 0;
    this.assetPrefix = void 0;
    this.promisedSsgManifest = void 0;
    this.promisedDevPagesManifest = void 0;
    this.routeLoader = void 0;
    this.routeLoader = (0, _routeLoader["default"])(assetPrefix);
    this.buildId = buildId;
    this.assetPrefix = assetPrefix;
    /** @type {Promise<Set<string>>} */

    this.promisedSsgManifest = new Promise(function (resolve) {
      if (window.__SSG_MANIFEST) {
        resolve(window.__SSG_MANIFEST);
      } else {
        ;

        window.__SSG_MANIFEST_CB = function () {
          resolve(window.__SSG_MANIFEST);
        };
      }
    });
  }

  _createClass(PageLoader, [{
    key: "getPageList",
    value: function getPageList() {
      if (false) {} else {
        if (window.__DEV_PAGES_MANIFEST) {
          return window.__DEV_PAGES_MANIFEST.pages;
        } else {
          if (!this.promisedDevPagesManifest) {
            this.promisedDevPagesManifest = fetch("".concat(this.assetPrefix, "/_next/static/development/_devPagesManifest.json")).then(function (res) {
              return res.json();
            }).then(function (manifest) {
              ;
              window.__DEV_PAGES_MANIFEST = manifest;
              return manifest.pages;
            })["catch"](function (err) {
              console.log("Failed to fetch devPagesManifest", err);
            });
          }

          return this.promisedDevPagesManifest;
        }
      }
    }
    /**
    * @param {string} href the route href (file-system path)
    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes
    * @returns {string}
    */

  }, {
    key: "getDataHref",
    value: function getDataHref(href, asPath, ssg, locale) {
      var _this = this;

      var _ref = (0, _parseRelativeUrl.parseRelativeUrl)(href),
          hrefPathname = _ref.pathname,
          query = _ref.query,
          search = _ref.search;

      var _ref2 = (0, _parseRelativeUrl.parseRelativeUrl)(asPath),
          asPathname = _ref2.pathname;

      var route = normalizeRoute(hrefPathname);

      var getHrefForSlug = function getHrefForSlug(path) {
        var dataRoute = (0, _getAssetPathFromRoute["default"])((0, _router.addLocale)(path, locale), '.json');
        return (0, _router.addBasePath)("/_next/data/".concat(_this.buildId).concat(dataRoute).concat(ssg ? '' : search));
      };

      var isDynamic = (0, _isDynamic.isDynamicRoute)(route);
      var interpolatedRoute = isDynamic ? (0, _router.interpolateAs)(hrefPathname, asPathname, query).result : '';
      return isDynamic ? interpolatedRoute && getHrefForSlug(interpolatedRoute) : getHrefForSlug(route);
    }
    /**
    * @param {string} href the route href (file-system path)
    */

  }, {
    key: "_isSsg",
    value: function _isSsg(href) {
      var _ref3 = (0, _parseRelativeUrl.parseRelativeUrl)(href),
          hrefPathname = _ref3.pathname;

      var route = normalizeRoute(hrefPathname);
      return this.promisedSsgManifest.then(function (s) {
        return s.has(route);
      });
    }
  }, {
    key: "loadPage",
    value: function loadPage(route) {
      return this.routeLoader.loadRoute(route).then(function (res) {
        if ('component' in res) {
          return {
            page: res.component,
            mod: res.exports,
            styleSheets: res.styles.map(function (o) {
              return {
                href: o.href,
                text: o.content
              };
            })
          };
        }

        throw res.error;
      });
    }
  }, {
    key: "prefetch",
    value: function prefetch(route) {
      return this.routeLoader.prefetch(route);
    }
  }]);

  return PageLoader;
}();

exports["default"] = PageLoader;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/performance-relayer.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/client/performance-relayer.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = void 0;

var _webVitals = __webpack_require__(/*! next/dist/compiled/web-vitals */ "./node_modules/next/dist/compiled/web-vitals/web-vitals.es5.umd.min.js");

var initialHref = location.href;
var isRegistered = false;
var userReportHandler;

function onReport(metric) {
  if (userReportHandler) {
    userReportHandler(metric);
  } // This code is not shipped, executed, or present in the client-side
  // JavaScript bundle unless explicitly enabled in your application.
  //
  // When this feature is enabled, we'll make it very clear by printing a
  // message during the build (`next build`).


  if (false) { var vitalsUrl, blob, body; }
}

var _default = function _default(onPerfEntry) {
  // Update function if it changes:
  userReportHandler = onPerfEntry; // Only register listeners once:

  if (isRegistered) {
    return;
  }

  isRegistered = true;
  (0, _webVitals.getCLS)(onReport);
  (0, _webVitals.getFID)(onReport);
  (0, _webVitals.getFCP)(onReport);
  (0, _webVitals.getLCP)(onReport);
  (0, _webVitals.getTTFB)(onReport);
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/request-idle-callback.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/request-idle-callback.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = void 0;

var requestIdleCallback = typeof self !== 'undefined' && self.requestIdleCallback || function (cb) {
  var start = Date.now();
  return setTimeout(function () {
    cb({
      didTimeout: false,
      timeRemaining: function timeRemaining() {
        return Math.max(0, 50 - (Date.now() - start));
      }
    });
  }, 1);
};

var _default = requestIdleCallback;
exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.markAssetError = markAssetError;
exports.isAssetError = isAssetError;
exports.getClientBuildManifest = getClientBuildManifest;
exports["default"] = void 0;

var _getAssetPathFromRoute = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/router/utils/get-asset-path-from-route */ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js"));

var _requestIdleCallback = _interopRequireDefault(__webpack_require__(/*! ./request-idle-callback */ "./node_modules/next/dist/client/request-idle-callback.js")); // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive
// considers as "Good" time-to-interactive. We must assume something went
// wrong beyond this point, and then fall-back to a full page transition to
// show the user something of value.


var MS_MAX_IDLE_DELAY = 3800;

function withFuture(key, map, generator) {
  var entry = map.get(key);

  if (entry) {
    if ('future' in entry) {
      return entry.future;
    }

    return Promise.resolve(entry);
  }

  var resolver;
  var prom = new Promise(function (resolve) {
    resolver = resolve;
  });
  map.set(key, entry = {
    resolve: resolver,
    future: prom
  });
  return generator ? // eslint-disable-next-line no-sequences
  generator().then(function (value) {
    return resolver(value), value;
  }) : prom;
}

function hasPrefetch(link) {
  try {
    link = document.createElement('link');
    return (// detect IE11 since it supports prefetch but isn't detected
      // with relList.support
      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')
    );
  } catch (_unused) {
    return false;
  }
}

var canPrefetch = hasPrefetch();

function prefetchViaDom(href, as, link) {
  return new Promise(function (res, rej) {
    if (document.querySelector("link[rel=\"prefetch\"][href^=\"".concat(href, "\"]"))) {
      return res();
    }

    link = document.createElement('link'); // The order of property assignment here is intentional:

    if (as) link.as = as;
    link.rel = "prefetch";
    link.crossOrigin = undefined;
    link.onload = res;
    link.onerror = rej; // `href` should always be last:

    link.href = href;
    document.head.appendChild(link);
  });
}

var ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR'); // TODO: unexport

function markAssetError(err) {
  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});
}

function isAssetError(err) {
  return err && ASSET_LOAD_ERROR in err;
}

function appendScript(src, script) {
  return new Promise(function (resolve, reject) {
    script = document.createElement('script'); // The order of property assignment here is intentional.
    // 1. Setup success/failure hooks in case the browser synchronously
    //    executes when `src` is set.

    script.onload = resolve;

    script.onerror = function () {
      return reject(markAssetError(new Error("Failed to load script: ".concat(src))));
    }; // 2. Configure the cross-origin attribute before setting `src` in case the
    //    browser begins to fetch.


    script.crossOrigin = undefined; // 3. Finally, set the source and inject into the DOM in case the child
    //    must be appended for fetching to start.

    script.src = src;
    document.body.appendChild(script);
  });
}

function idleTimeout(ms, err) {
  return new Promise(function (_resolve, reject) {
    return (0, _requestIdleCallback["default"])(function () {
      return setTimeout(function () {
        return reject(err);
      }, ms);
    });
  });
} // TODO: stop exporting or cache the failure
// It'd be best to stop exporting this. It's an implementation detail. We're
// only exporting it for backwards compatibilty with the `page-loader`.
// Only cache this response as a last resort if we cannot eliminate all other
// code branches that use the Build Manifest Callback and push them through
// the Route Loader interface.


function getClientBuildManifest() {
  if (self.__BUILD_MANIFEST) {
    return Promise.resolve(self.__BUILD_MANIFEST);
  }

  var onBuildManifest = new Promise(function (resolve) {
    // Mandatory because this is not concurrent safe:
    var cb = self.__BUILD_MANIFEST_CB;

    self.__BUILD_MANIFEST_CB = function () {
      resolve(self.__BUILD_MANIFEST);
      cb && cb();
    };
  });
  return Promise.race([onBuildManifest, idleTimeout(MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')))]);
}

function getFilesForRoute(assetPrefix, route) {
  if (true) {
    return Promise.resolve({
      scripts: [assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute["default"])(route, '.js'))],
      // Styles are handled by `style-loader` in development:
      css: []
    });
  }

  return getClientBuildManifest().then(function (manifest) {
    if (!(route in manifest)) {
      throw markAssetError(new Error("Failed to lookup route: ".concat(route)));
    }

    var allFiles = manifest[route].map(function (entry) {
      return assetPrefix + '/_next/' + encodeURI(entry);
    });
    return {
      scripts: allFiles.filter(function (v) {
        return v.endsWith('.js');
      }),
      css: allFiles.filter(function (v) {
        return v.endsWith('.css');
      })
    };
  });
}

function createRouteLoader(assetPrefix) {
  var entrypoints = new Map();
  var loadedScripts = new Map();
  var styleSheets = new Map();
  var routes = new Map();

  function maybeExecuteScript(src) {
    var prom = loadedScripts.get(src);

    if (prom) {
      return prom;
    } // Skip executing script if it's already in the DOM:


    if (document.querySelector("script[src^=\"".concat(src, "\"]"))) {
      return Promise.resolve();
    }

    loadedScripts.set(src, prom = appendScript(src));
    return prom;
  }

  function fetchStyleSheet(href) {
    var prom = styleSheets.get(href);

    if (prom) {
      return prom;
    }

    styleSheets.set(href, prom = fetch(href).then(function (res) {
      if (!res.ok) {
        throw new Error("Failed to load stylesheet: ".concat(href));
      }

      return res.text().then(function (text) {
        return {
          href: href,
          content: text
        };
      });
    })["catch"](function (err) {
      throw markAssetError(err);
    }));
    return prom;
  }

  return {
    whenEntrypoint: function whenEntrypoint(route) {
      return withFuture(route, entrypoints);
    },
    onEntrypoint: function onEntrypoint(route, execute) {
      Promise.resolve(execute).then(function (fn) {
        return fn();
      }).then(function (exports) {
        return {
          component: exports && exports["default"] || exports,
          exports: exports
        };
      }, function (err) {
        return {
          error: err
        };
      }).then(function (input) {
        var old = entrypoints.get(route);
        entrypoints.set(route, input);
        if (old && 'resolve' in old) old.resolve(input);
      });
    },
    loadRoute: function loadRoute(route) {
      var _this = this;

      return withFuture(route, routes, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _yield$getFilesForRou, scripts, css, _yield$Promise$all, _yield$Promise$all2, styles, entrypoint, res;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.prev = 0;
                _context.next = 3;
                return getFilesForRoute(assetPrefix, route);

              case 3:
                _yield$getFilesForRou = _context.sent;
                scripts = _yield$getFilesForRou.scripts;
                css = _yield$getFilesForRou.css;
                _context.next = 8;
                return Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);

              case 8:
                _yield$Promise$all = _context.sent;
                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
                styles = _yield$Promise$all2[1];
                _context.next = 13;
                return Promise.race([_this.whenEntrypoint(route), idleTimeout(MS_MAX_IDLE_DELAY, markAssetError(new Error("Route did not complete loading: ".concat(route))))]);

              case 13:
                entrypoint = _context.sent;
                res = Object.assign({
                  styles: styles
                }, entrypoint);
                return _context.abrupt("return", 'error' in entrypoint ? entrypoint : res);

              case 18:
                _context.prev = 18;
                _context.t0 = _context["catch"](0);
                return _context.abrupt("return", {
                  error: _context.t0
                });

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[0, 18]]);
      })));
    },
    prefetch: function prefetch(route) {
      var _this2 = this;

      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118
      // License: Apache 2.0
      var cn;

      if (cn = navigator.connection) {
        // Don't prefetch if using 2G or if Save-Data is enabled.
        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
      }

      return getFilesForRoute(assetPrefix, route).then(function (output) {
        return Promise.all(canPrefetch ? output.scripts.map(function (script) {
          return prefetchViaDom(script, 'script');
        }) : []);
      }).then(function () {
        (0, _requestIdleCallback["default"])(function () {
          return _this2.loadRoute(route);
        });
      })["catch"]( // swallow prefetch errors
      function () {});
    }
  };
}

var _default = createRouteLoader;
exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _construct = __webpack_require__(/*! @babel/runtime/helpers/construct */ "./node_modules/@babel/runtime/helpers/construct.js");

var _s = $RefreshSig$();

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2["default"];
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter["default"];
/* global window */

var singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],
  ready: function ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }
}; // Create public properties and methods of the router in the singletonRouter

var urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath', 'locale', 'locales', 'defaultLocale', 'isReady'];
var routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
var coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get: function get() {
    return _router2["default"].events;
  }
});
urlPropertyFields.forEach(function (field) {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get: function get() {
      var router = getRouter();
      return router[field];
    }
  });
});
coreMethodFields.forEach(function (field) {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = function () {
    var router = getRouter();
    return router[field].apply(router, arguments);
  };
});
routerEvents.forEach(function (event) {
  singletonRouter.ready(function () {
    _router2["default"].events.on(event, function () {
      var eventField = "on".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));
      var _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField].apply(_singletonRouter, arguments);
        } catch (err) {
          console.error("Error when running the Router event: ".concat(eventField));
          console.error("".concat(err.message, "\n").concat(err.stack));
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    var message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports["default"] = _default;

function useRouter() {
  _s();

  return _react["default"].useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

var createRouter = function createRouter() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  singletonRouter.router = _construct(_router2["default"], args);
  singletonRouter.readyCallbacks.forEach(function (cb) {
    return cb();
  });
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  var _router = router;
  var instance = {};

  var _iterator = _createForOfIteratorHelper(urlPropertyFields),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var property = _step.value;

      if (typeof _router[property] === 'object') {
        instance[property] = Object.assign(Array.isArray(_router[property]) ? [] : {}, _router[property]); // makes sure query is not stateful

        continue;
      }

      instance[property] = _router[property];
    } // Events is a static property on the router, the router doesn't have to be initialized to use it

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  instance.events = _router2["default"].events;
  coreMethodFields.forEach(function (field) {
    instance[field] = function () {
      return _router[field].apply(_router, arguments);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react["default"].createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    var name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(".concat(name, ")");
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-to-regexp/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-to-regexp/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Tokenize input string.
 */
function lexer(str) {
    var tokens = [];
    var i = 0;
    while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
            continue;
        }
        if (char === "\\") {
            tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
            continue;
        }
        if (char === "{") {
            tokens.push({ type: "OPEN", index: i, value: str[i++] });
            continue;
        }
        if (char === "}") {
            tokens.push({ type: "CLOSE", index: i, value: str[i++] });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i + 1;
            while (j < str.length) {
                var code = str.charCodeAt(j);
                if (
                // `0-9`
                (code >= 48 && code <= 57) ||
                    // `A-Z`
                    (code >= 65 && code <= 90) ||
                    // `a-z`
                    (code >= 97 && code <= 122) ||
                    // `_`
                    code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name)
                throw new TypeError("Missing parameter name at " + i);
            tokens.push({ type: "NAME", index: i, value: name });
            i = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i + 1;
            if (str[j] === "?") {
                throw new TypeError("Pattern cannot start with \"?\" at " + j);
            }
            while (j < str.length) {
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                }
                else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at " + j);
                    }
                }
                pattern += str[j++];
            }
            if (count)
                throw new TypeError("Unbalanced pattern at " + i);
            if (!pattern)
                throw new TypeError("Missing pattern at " + i);
            tokens.push({ type: "PATTERN", index: i, value: pattern });
            i = j;
            continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
    }
    tokens.push({ type: "END", index: i, value: "" });
    return tokens;
}
/**
 * Parse a string for the raw tokens.
 */
function parse(str, options) {
    if (options === void 0) { options = {}; }
    var tokens = lexer(str);
    var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
    var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
    var result = [];
    var key = 0;
    var i = 0;
    var path = "";
    var tryConsume = function (type) {
        if (i < tokens.length && tokens[i].type === type)
            return tokens[i++].value;
    };
    var mustConsume = function (type) {
        var value = tryConsume(type);
        if (value !== undefined)
            return value;
        var _a = tokens[i], nextType = _a.type, index = _a.index;
        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
    };
    var consumeText = function () {
        var result = "";
        var value;
        // tslint:disable-next-line
        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
            result += value;
        }
        return result;
    };
    while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix: prefix,
                suffix: "",
                pattern: pattern || defaultPattern,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                prefix: prefix,
                suffix: suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
exports.parse = parse;
/**
 * Compile a string to a template function for the path.
 */
function compile(str, options) {
    return tokensToFunction(parse(str, options), options);
}
exports.compile = compile;
/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens, options) {
    if (options === void 0) { options = {}; }
    var reFlags = flags(options);
    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
    // Compile all the tokens into regexps.
    var matches = tokens.map(function (token) {
        if (typeof token === "object") {
            return new RegExp("^(?:" + token.pattern + ")$", reFlags);
        }
    });
    return function (data) {
        var path = "";
        for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            if (typeof token === "string") {
                path += token;
                continue;
            }
            var value = data ? data[token.name] : undefined;
            var optional = token.modifier === "?" || token.modifier === "*";
            var repeat = token.modifier === "*" || token.modifier === "+";
            if (Array.isArray(value)) {
                if (!repeat) {
                    throw new TypeError("Expected \"" + token.name + "\" to not repeat, but got an array");
                }
                if (value.length === 0) {
                    if (optional)
                        continue;
                    throw new TypeError("Expected \"" + token.name + "\" to not be empty");
                }
                for (var j = 0; j < value.length; j++) {
                    var segment = encode(value[j], token);
                    if (validate && !matches[i].test(segment)) {
                        throw new TypeError("Expected all \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                    }
                    path += token.prefix + segment + token.suffix;
                }
                continue;
            }
            if (typeof value === "string" || typeof value === "number") {
                var segment = encode(String(value), token);
                if (validate && !matches[i].test(segment)) {
                    throw new TypeError("Expected \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                }
                path += token.prefix + segment + token.suffix;
                continue;
            }
            if (optional)
                continue;
            var typeOfMessage = repeat ? "an array" : "a string";
            throw new TypeError("Expected \"" + token.name + "\" to be " + typeOfMessage);
        }
        return path;
    };
}
exports.tokensToFunction = tokensToFunction;
/**
 * Create path match function from `path-to-regexp` spec.
 */
function match(str, options) {
    var keys = [];
    var re = pathToRegexp(str, keys, options);
    return regexpToFunction(re, keys, options);
}
exports.match = match;
/**
 * Create a path match function from `path-to-regexp` output.
 */
function regexpToFunction(re, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;
    return function (pathname) {
        var m = re.exec(pathname);
        if (!m)
            return false;
        var path = m[0], index = m.index;
        var params = Object.create(null);
        var _loop_1 = function (i) {
            // tslint:disable-next-line
            if (m[i] === undefined)
                return "continue";
            var key = keys[i - 1];
            if (key.modifier === "*" || key.modifier === "+") {
                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {
                    return decode(value, key);
                });
            }
            else {
                params[key.name] = decode(m[i], key);
            }
        };
        for (var i = 1; i < m.length; i++) {
            _loop_1(i);
        }
        return { path: path, index: index, params: params };
    };
}
exports.regexpToFunction = regexpToFunction;
/**
 * Escape a regular expression string.
 */
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
/**
 * Get the flags for a regexp from the options.
 */
function flags(options) {
    return options && options.sensitive ? "" : "i";
}
/**
 * Pull out keys from a regexp.
 */
function regexpToRegexp(path, keys) {
    if (!keys)
        return path;
    // Use a negative lookahead to match only capturing groups.
    var groups = path.source.match(/\((?!\?)/g);
    if (groups) {
        for (var i = 0; i < groups.length; i++) {
            keys.push({
                name: i,
                prefix: "",
                suffix: "",
                modifier: "",
                pattern: ""
            });
        }
    }
    return path;
}
/**
 * Transform an array into a regexp.
 */
function arrayToRegexp(paths, keys, options) {
    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
    return new RegExp("(?:" + parts.join("|") + ")", flags(options));
}
/**
 * Create a path regexp from string input.
 */
function stringToRegexp(path, keys, options) {
    return tokensToRegexp(parse(path, options), keys, options);
}
/**
 * Expose a function for taking tokens and returning a RegExp.
 */
function tokensToRegexp(tokens, keys, options) {
    if (options === void 0) { options = {}; }
    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;
    var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
    var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
    var route = start ? "^" : "";
    // Iterate over the tokens and create our regexp string.
    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
            route += escapeString(encode(token));
        }
        else {
            var prefix = escapeString(encode(token.prefix));
            var suffix = escapeString(encode(token.suffix));
            if (token.pattern) {
                if (keys)
                    keys.push(token);
                if (prefix || suffix) {
                    if (token.modifier === "+" || token.modifier === "*") {
                        var mod = token.modifier === "*" ? "?" : "";
                        route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
                    }
                    else {
                        route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
                    }
                }
                else {
                    route += "(" + token.pattern + ")" + token.modifier;
                }
            }
            else {
                route += "(?:" + prefix + suffix + ")" + token.modifier;
            }
        }
    }
    if (end) {
        if (!strict)
            route += delimiter + "?";
        route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
    }
    else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string"
            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
            : // tslint:disable-next-line
                endToken === undefined;
        if (!strict) {
            route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }
        if (!isEndDelimited) {
            route += "(?=" + delimiter + "|" + endsWith + ")";
        }
    }
    return new RegExp(route, flags(options));
}
exports.tokensToRegexp = tokensToRegexp;
/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 */
function pathToRegexp(path, keys, options) {
    if (path instanceof RegExp)
        return regexpToRegexp(path, keys);
    if (Array.isArray(path))
        return arrayToRegexp(path, keys, options);
    return stringToRegexp(path, keys, options);
}
exports.pathToRegexp = pathToRegexp;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/next/dist/compiled/strip-ansi/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/strip-ansi/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__dirname, module) {module.exports = function () {
  "use strict";

  var e = {
    301: function _(e, r, t) {
      var _ = t(979);

      e.exports = function (e) {
        return typeof e === "string" ? e.replace(_(), "") : e;
      };
    },
    979: function _(e) {
      e.exports = function () {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$onlyFirst = _ref.onlyFirst,
            e = _ref$onlyFirst === void 0 ? false : _ref$onlyFirst;

        var r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
        return new RegExp(r, e ? undefined : "g");
      };
    }
  };
  var r = {};

  function __webpack_require__(t) {
    if (r[t]) {
      return r[t].exports;
    }

    var _ = r[t] = {
      exports: {}
    };

    var n = true;

    try {
      e[t](_, _.exports, __webpack_require__);
      n = false;
    } finally {
      if (n) delete r[t];
    }

    return _.exports;
  }

  __webpack_require__.ab = __dirname + "/";
  return __webpack_require__(301);
}();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, "/", __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/compiled/web-vitals/web-vitals.es5.umd.min.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/web-vitals/web-vitals.es5.umd.min.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports=function(){var t={599:function(t,e){!function(t,n){true?n(e):undefined}(this,function(t){"use strict";var e,n,i=function(){return"".concat(Date.now(),"-").concat(Math.floor(8999999999999*Math.random())+1e12)},a=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return{name:t,value:e,delta:0,entries:[],id:i(),isFinal:!1}},r=function(t,e){try{if(PerformanceObserver.supportedEntryTypes.includes(t)){var n=new PerformanceObserver(function(t){return t.getEntries().map(e)});return n.observe({type:t,buffered:!0}),n}}catch(t){}},o=!1,u=!1,s=function(t){o=!t.persisted},c=function(){addEventListener("pagehide",s),addEventListener("beforeunload",function(){})},p=function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];u||(c(),u=!0),addEventListener("visibilitychange",function(e){var n=e.timeStamp;"hidden"===document.visibilityState&&t({timeStamp:n,isUnloading:o})},{capture:!0,once:e})},l=function(t,e,n,i){var a;return function(){n&&e.isFinal&&n.disconnect(),e.value>=0&&(i||e.isFinal||"hidden"===document.visibilityState)&&(e.delta=e.value-(a||0),(e.delta||e.isFinal||void 0===a)&&(t(e),a=e.value))}},f=function(){return void 0===e&&(e="hidden"===document.visibilityState?0:1/0,p(function(t){var n=t.timeStamp;return e=n},!0)),{get timeStamp(){return e}}},d=function(){return n||(n=new Promise(function(t){return["scroll","keydown","pointerdown"].map(function(e){addEventListener(e,t,{once:!0,passive:!0,capture:!0})})})),n};t.getCLS=function(t){var e,n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=a("CLS",0),o=function(t){t.hadRecentInput||(i.value+=t.value,i.entries.push(t),e())},u=r("layout-shift",o);u&&(e=l(t,i,u,n),p(function(t){var n=t.isUnloading;u.takeRecords().map(o),n&&(i.isFinal=!0),e()}))},t.getFCP=function(t){var e,n=a("FCP"),i=f(),o=r("paint",function(t){"first-contentful-paint"===t.name&&t.startTime<i.timeStamp&&(n.value=t.startTime,n.isFinal=!0,n.entries.push(t),e())});o&&(e=l(t,n,o))},t.getFID=function(t){var e=a("FID"),n=f(),i=function(t){t.startTime<n.timeStamp&&(e.value=t.processingStart-t.startTime,e.entries.push(t),e.isFinal=!0,u())},o=r("first-input",i),u=l(t,e,o);o?p(function(){o.takeRecords().map(i),o.disconnect()},!0):window.perfMetrics&&window.perfMetrics.onFirstInputDelay&&window.perfMetrics.onFirstInputDelay(function(t,i){i.timeStamp<n.timeStamp&&(e.value=t,e.isFinal=!0,e.entries=[{entryType:"first-input",name:i.type,target:i.target,cancelable:i.cancelable,startTime:i.timeStamp,processingStart:i.timeStamp+t}],u())})},t.getLCP=function(t){var e,n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=a("LCP"),o=f(),u=function(t){var n=t.startTime;n<o.timeStamp?(i.value=n,i.entries.push(t)):i.isFinal=!0,e()},s=r("largest-contentful-paint",u);if(s){e=l(t,i,s,n);var c=function(){i.isFinal||(s.takeRecords().map(u),i.isFinal=!0,e())};d().then(c),p(c,!0)}},t.getTTFB=function(t){var e,n=a("TTFB");e=function(){try{var e=performance.getEntriesByType("navigation")[0]||function(){var t=performance.timing,e={entryType:"navigation",startTime:0};for(var n in t)"navigationStart"!==n&&"toJSON"!==n&&(e[n]=Math.max(t[n]-t.navigationStart,0));return e}();n.value=n.delta=e.responseStart,n.entries=[e],n.isFinal=!0,t(n)}catch(t){}},"complete"===document.readyState?setTimeout(e,0):addEventListener("pageshow",e)},Object.defineProperty(t,"__esModule",{value:!0})})}};var e={};function __webpack_require__(n){if(e[n]){return e[n].exports}var i=e[n]={exports:{}};var a=true;try{t[n].call(i.exports,i,i.exports,__webpack_require__);a=false}finally{if(a)delete e[n]}return i.exports}__webpack_require__.ab=__dirname+"/";return __webpack_require__(599)}();
/* WEBPACK VAR INJECTION */}.call(this, "/"))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head-manager-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head-manager-context.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.HeadManagerContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var HeadManagerContext = /*#__PURE__*/_react["default"].createContext({});

exports.HeadManagerContext = HeadManagerContext;

if (true) {
  HeadManagerContext.displayName = 'HeadManagerContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.normalizeLocalePath = normalizeLocalePath;

function normalizeLocalePath(pathname, locales) {
  var detectedLocale; // first item will be empty string from splitting at first char

  var pathnameParts = pathname.split('/');
  (locales || []).some(function (locale) {
    if (pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
      detectedLocale = locale;
      pathnameParts.splice(1, 1);
      pathname = pathnameParts.join('/') || '/';
      return true;
    }

    return false;
  });
  return {
    pathname: pathname,
    detectedLocale: detectedLocale
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = mitt;
/*
MIT License
Copyright (c) Jason Miller (https://jasonformat.com/)
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file

function mitt() {
  var all = Object.create(null);
  return {
    on: function on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },
    off: function off(type, handler) {
      if (all[type]) {
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit(type) {
      for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        evts[_key - 1] = arguments[_key];
      }

      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(function (handler) {
        handler.apply(void 0, evts);
      });
    }
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router-context.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.RouterContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.module.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var RouterContext = /*#__PURE__*/_react["default"].createContext(null);

exports.RouterContext = RouterContext;

if (true) {
  RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.getDomainLocale = getDomainLocale;
exports.addLocale = addLocale;
exports.delLocale = delLocale;
exports.hasBasePath = hasBasePath;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports.isLocalURL = isLocalURL;
exports.interpolateAs = interpolateAs;
exports.resolveHref = resolveHref;
exports["default"] = void 0;

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

var _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ "./node_modules/next/dist/client/route-loader.js");

var _denormalizePagePath = __webpack_require__(/*! ../../server/denormalize-page-path */ "./node_modules/next/dist/next-server/server/denormalize-page-path.js");

var _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var _querystring = __webpack_require__(/*! ./utils/querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _resolveRewrites = _interopRequireDefault(__webpack_require__(/*! ./utils/resolve-rewrites */ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js"));

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* global __NEXT_DATA__ */
// tslint:disable:no-console


var detectDomainLocale;

if (false) {}

var basePath =  false || '';

function buildCancellationError() {
  return Object.assign(new Error('Route Cancelled'), {
    cancelled: true
  });
}

function addPathPrefix(path, prefix) {
  return prefix && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(prefix) : "".concat(prefix).concat(pathNoQueryHash(path) === '/' ? path.substring(1) : path) : path;
}

function getDomainLocale(path, locale, locales, domainLocales) {
  if (false) { var detectedDomain; }

  return false;
}

function addLocale(path, locale, defaultLocale) {
  if (false) {}

  return path;
}

function delLocale(path, locale) {
  if (false) {}

  return path;
}

function pathNoQueryHash(path) {
  var queryIndex = path.indexOf('?');
  var hashIndex = path.indexOf('#');

  if (queryIndex > -1 || hashIndex > -1) {
    path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);
  }

  return path;
}

function hasBasePath(path) {
  path = pathNoQueryHash(path);
  return path === basePath || path.startsWith(basePath + '/');
}

function addBasePath(path) {
  // we only add the basepath on relative urls
  return addPathPrefix(path, basePath);
}

function delBasePath(path) {
  path = path.slice(basePath.length);
  if (!path.startsWith('/')) path = "/".concat(path);
  return path;
}
/**
* Detects whether a given url is routable by the Next.js router (browser only).
*/


function isLocalURL(url) {
  if (url.startsWith('/')) return true;

  try {
    // absolute urls can be local if they are on the same origin
    var locationOrigin = (0, _utils.getLocationOrigin)();
    var resolved = new URL(url, locationOrigin);
    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);
  } catch (_) {
    return false;
  }
}

function interpolateAs(route, asPathname, query) {
  var interpolatedRoute = '';
  var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);
  var dynamicGroups = dynamicRegex.groups;
  var dynamicMatches = // Try to match the dynamic route against the asPath
  (asPathname !== route ? (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href
  // TODO: should this take priority; also need to change in the router.
  query;
  interpolatedRoute = route;
  var params = Object.keys(dynamicGroups);

  if (!params.every(function (param) {
    var value = dynamicMatches[param] || '';
    var _dynamicGroups$param = dynamicGroups[param],
        repeat = _dynamicGroups$param.repeat,
        optional = _dynamicGroups$param.optional; // support single-level catch-all
    // TODO: more robust handling for user-error (passing `/`)

    var replaced = "[".concat(repeat ? '...' : '').concat(param, "]");

    if (optional) {
      replaced = "".concat(!value ? '/' : '', "[").concat(replaced, "]");
    }

    if (repeat && !Array.isArray(value)) value = [value];
    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present
    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map( // these values should be fully encoded instead of just
    // path delimiter escaped since they are being inserted
    // into the URL and we expect URL encoded segments
    // when parsing dynamic route params
    function (segment) {
      return encodeURIComponent(segment);
    }).join('/') : encodeURIComponent(value)) || '/');
  })) {
    interpolatedRoute = ''; // did not satisfy all requirements
    // n.b. We ignore this error because we handle warning for this case in
    // development in the `<Link>` component directly.
  }

  return {
    params: params,
    result: interpolatedRoute
  };
}

function omitParmsFromQuery(query, params) {
  var filteredQuery = {};
  Object.keys(query).forEach(function (key) {
    if (!params.includes(key)) {
      filteredQuery[key] = query[key];
    }
  });
  return filteredQuery;
}
/**
* Resolves a given hyperlink with a certain router state (basePath not included).
* Preserves absolute urls.
*/


function resolveHref(currentPath, href, resolveAs) {
  // we use a dummy base url for relative urls
  var base = new URL(currentPath, 'http://n');
  var urlAsString = typeof href === 'string' ? href : (0, _utils.formatWithValidation)(href); // Return because it cannot be routed by the Next.js router

  if (!isLocalURL(urlAsString)) {
    return resolveAs ? [urlAsString] : urlAsString;
  }

  try {
    var finalUrl = new URL(urlAsString, base);
    finalUrl.pathname = (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(finalUrl.pathname);
    var interpolatedAs = '';

    if ((0, _isDynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
      var query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);

      var _interpolateAs = interpolateAs(finalUrl.pathname, finalUrl.pathname, query),
          result = _interpolateAs.result,
          params = _interpolateAs.params;

      if (result) {
        interpolatedAs = (0, _utils.formatWithValidation)({
          pathname: result,
          hash: finalUrl.hash,
          query: omitParmsFromQuery(query, params)
        });
      }
    } // if the origin didn't change, it means we received a relative href


    var resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;
  } catch (_) {
    return resolveAs ? [urlAsString] : urlAsString;
  }
}

function stripOrigin(url) {
  var origin = (0, _utils.getLocationOrigin)();
  return url.startsWith(origin) ? url.substring(origin.length) : url;
}

function prepareUrlAs(router, url, as) {
  // If url and as provided as an object representation,
  // we'll format them into the string version here.
  var _resolveHref = resolveHref(router.pathname, url, true),
      _resolveHref2 = _slicedToArray(_resolveHref, 2),
      resolvedHref = _resolveHref2[0],
      resolvedAs = _resolveHref2[1];

  var origin = (0, _utils.getLocationOrigin)();
  var hrefHadOrigin = resolvedHref.startsWith(origin);
  var asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);
  resolvedHref = stripOrigin(resolvedHref);
  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;
  var preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);
  var preparedAs = as ? stripOrigin(resolveHref(router.pathname, as)) : resolvedAs || resolvedHref;
  return {
    url: preparedUrl,
    as: asHadOrigin ? preparedAs : addBasePath(preparedAs)
  };
}

var manualScrollRestoration =  false && false;
var SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');

function fetchRetry(url, attempts) {
  return fetch(url, {
    // Cookies are required to be present for Next.js' SSG "Preview Mode".
    // Cookies may also be required for `getServerSideProps`.
    //
    // > `fetch` won’t send cookies, unless you set the credentials init
    // > option.
    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
    //
    // > For maximum browser compatibility when it comes to sending &
    // > receiving cookies, always supply the `credentials: 'same-origin'`
    // > option instead of relying on the default.
    // https://github.com/github/fetch#caveats
    credentials: 'same-origin'
  }).then(function (res) {
    if (!res.ok) {
      if (attempts > 1 && res.status >= 500) {
        return fetchRetry(url, attempts - 1);
      }

      if (res.status === 404) {
        return res.json().then(function (data) {
          if (data.notFound) {
            return {
              notFound: SSG_DATA_NOT_FOUND
            };
          }

          throw new Error("Failed to load static props");
        });
      }

      throw new Error("Failed to load static props");
    }

    return res.json();
  });
}

function fetchNextData(dataHref, isServerRender) {
  return fetchRetry(dataHref, isServerRender ? 3 : 1)["catch"](function (err) {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      (0, _routeLoader.markAssetError)(err);
    }

    throw err;
  });
}

var Router = /*#__PURE__*/function () {
  /**
  * Map of all components loaded in `Router`
  */
  // Static Data Cache
  function Router(_pathname, _query, _as, _ref) {
    var _this = this;

    var initialProps = _ref.initialProps,
        pageLoader = _ref.pageLoader,
        App = _ref.App,
        wrapApp = _ref.wrapApp,
        Component = _ref.Component,
        err = _ref.err,
        subscription = _ref.subscription,
        isFallback = _ref.isFallback,
        locale = _ref.locale,
        locales = _ref.locales,
        defaultLocale = _ref.defaultLocale,
        domainLocales = _ref.domainLocales;

    _classCallCheck(this, Router);

    this.route = void 0;
    this.pathname = void 0;
    this.query = void 0;
    this.asPath = void 0;
    this.basePath = void 0;
    this.components = void 0;
    this.sdc = {};
    this.sub = void 0;
    this.clc = void 0;
    this.pageLoader = void 0;
    this._bps = void 0;
    this.events = void 0;
    this._wrapApp = void 0;
    this.isSsr = void 0;
    this.isFallback = void 0;
    this._inFlightRoute = void 0;
    this._shallow = void 0;
    this.locale = void 0;
    this.locales = void 0;
    this.defaultLocale = void 0;
    this.domainLocales = void 0;
    this.isReady = void 0;
    this._idx = 0;

    this.onPopState = function (e) {
      var state = e.state;

      if (!state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        var _pathname2 = _this.pathname,
            query = _this.query;

        _this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname2),
          query: query
        }), (0, _utils.getURL)());

        return;
      }

      if (!state.__N) {
        return;
      }

      var forcedScroll;
      var url = state.url,
          as = state.as,
          options = state.options,
          idx = state.idx;

      if (false) { var v; }

      _this._idx = idx;

      var _ref2 = (0, _parseRelativeUrl.parseRelativeUrl)(url),
          pathname = _ref2.pathname; // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site


      if (_this.isSsr && as === _this.asPath && pathname === _this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (_this._bps && !_this._bps(state)) {
        return;
      }

      _this.change('replaceState', url, as, Object.assign({}, options, {
        shallow: options.shallow && _this._shallow,
        locale: options.locale || _this.defaultLocale
      }), forcedScroll);
    }; // represents the current component key


    this.route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(_pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (_pathname !== '/_error') {
      this.components[this.route] = {
        Component: Component,
        initial: true,
        props: initialProps,
        err: err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App,
      styleSheets: [
        /* /_app does not need its stylesheets managed */
      ]
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = _pathname;
    this.query = _query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    var autoExportDynamic = (0, _isDynamic.isDynamicRoute)(_pathname) && self.__NEXT_DATA__.autoExport;

    this.asPath = autoExportDynamic ? _pathname : _as;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;
    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || !autoExportDynamic && !self.location.search);

    if (false) {}

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (_as.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: addBasePath(_pathname),
          query: _query
        }), (0, _utils.getURL)(), {
          locale: locale
        });
      }

      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available
      // otherwise fallback to browser's default handling

      if (false) {}
    }
  }

  _createClass(Router, [{
    key: "reload",
    value: function reload() {
      window.location.reload();
    }
    /**
    * Go back in history
    */

  }, {
    key: "back",
    value: function back() {
      window.history.back();
    }
    /**
    * Performs a `pushState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "push",
    value: function push(url, as) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (false) {}

      ;

      var _prepareUrlAs = prepareUrlAs(this, url, as);

      url = _prepareUrlAs.url;
      as = _prepareUrlAs.as;
      return this.change('pushState', url, as, options);
    }
    /**
    * Performs a `replaceState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "replace",
    value: function replace(url, as) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      ;

      var _prepareUrlAs2 = prepareUrlAs(this, url, as);

      url = _prepareUrlAs2.url;
      as = _prepareUrlAs2.as;
      return this.change('replaceState', url, as, options);
    }
  }, {
    key: "change",
    value: function () {
      var _change = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(method, url, as, options, forcedScroll) {
        var _this2 = this;

        var _options$scroll, localeChange, parsedAs, localePathResult, didNavigate, _this$locales, detectedDomain, asNoBasePath, _options$shallow, shallow, routeProps, cleanedAs, parsed, _parsed, pathname, query, pages, rewrites, _yield, route, resolvedAs, potentialHref, _parsedAs, asPathname, routeRegex, routeMatch, shouldInterpolate, interpolatedAs, missingParams, routeInfo, _routeInfo, error, props, __N_SSG, __N_SSP, destination, parsedHref, _prepareUrlAs3, newUrl, newAs, notFoundRoute, appComp;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (isLocalURL(url)) {
                  _context.next = 3;
                  break;
                }

                window.location.href = url;
                return _context.abrupt("return", false);

              case 3:
                // for static pages with query params in the URL we delay
                // marking the router ready until after the query is updated
                if (options._h) {
                  this.isReady = true;
                } // Default to scroll reset behavior unless explicitly specified to be
                // `false`! This makes the behavior between using `Router#push` and a
                // `<Link />` consistent.


                options.scroll = !!((_options$scroll = options.scroll) != null ? _options$scroll : true);
                localeChange = options.locale !== this.locale;

                if (true) {
                  _context.next = 18;
                  break;
                }

                this.locale = options.locale === false ? this.defaultLocale : options.locale || this.locale;

                if (typeof options.locale === 'undefined') {
                  options.locale = this.locale;
                }

                parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(hasBasePath(as) ? delBasePath(as) : as);
                localePathResult = (0, _normalizeLocalePath.normalizeLocalePath)(parsedAs.pathname, this.locales);

                if (localePathResult.detectedLocale) {
                  this.locale = localePathResult.detectedLocale;
                  parsedAs.pathname = addBasePath(parsedAs.pathname);
                  as = (0, _utils.formatWithValidation)(parsedAs);
                  url = addBasePath((0, _normalizeLocalePath.normalizeLocalePath)(hasBasePath(url) ? delBasePath(url) : url, this.locales).pathname);
                }

                didNavigate = false; // we need to wrap this in the env check again since regenerator runtime
                // moves this on its own due to the return

                if (false) {}

                detectedDomain = detectDomainLocale(this.domainLocales, undefined, this.locale); // we need to wrap this in the env check again since regenerator runtime
                // moves this on its own due to the return

                if (false) {}

                if (!didNavigate) {
                  _context.next = 18;
                  break;
                }

                return _context.abrupt("return", new Promise(function () {}));

              case 18:
                if (!options._h) {
                  this.isSsr = false;
                } // marking route changes as a navigation start entry


                if (_utils.ST) {
                  performance.mark('routeChange');
                }

                _options$shallow = options.shallow, shallow = _options$shallow === void 0 ? false : _options$shallow;
                routeProps = {
                  shallow: shallow
                };

                if (this._inFlightRoute) {
                  this.abortComponentLoad(this._inFlightRoute, routeProps);
                }

                as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));
                cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);
                this._inFlightRoute = as; // If the url change is only related to a hash change
                // We should not proceed. We should only change the state.
                // WARNING: `_h` is an internal option for handing Next.js client-side
                // hydration. Your app should _never_ use this property. It may change at
                // any time without notice.

                if (!(!options._h && this.onlyAHashChange(cleanedAs))) {
                  _context.next = 34;
                  break;
                }

                this.asPath = cleanedAs;
                Router.events.emit('hashChangeStart', as, routeProps); // TODO: do we need the resolved href when only a hash change?

                this.changeState(method, url, as, options);
                this.scrollToHash(cleanedAs);
                this.notify(this.components[this.route], null);
                Router.events.emit('hashChangeComplete', as, routeProps);
                return _context.abrupt("return", true);

              case 34:
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                _parsed = parsed, pathname = _parsed.pathname, query = _parsed.query; // The build manifest needs to be loaded before auto-static dynamic pages
                // get their query parameters to allow ensuring they can be parsed properly
                // when rewritten to

                _context.prev = 36;
                _context.next = 39;
                return this.pageLoader.getPageList();

              case 39:
                pages = _context.sent;
                _context.next = 42;
                return (0, _routeLoader.getClientBuildManifest)();

              case 42:
                _yield = _context.sent;
                rewrites = _yield.__rewrites;
                _context.next = 50;
                break;

              case 46:
                _context.prev = 46;
                _context.t0 = _context["catch"](36);
                // If we fail to resolve the page list or client-build manifest, we must
                // do a server-side transition:
                window.location.href = as;
                return _context.abrupt("return", false);

              case 50:
                parsed = this._resolveHref(parsed, pages);

                if (parsed.pathname !== pathname) {
                  pathname = parsed.pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                } // url and as should always be prefixed with basePath by this
                // point by either next/link or router.push/replace so strip the
                // basePath from the pathname to match the pages dir 1-to-1


                pathname = pathname ? (0, _normalizeTrailingSlash.removePathTrailingSlash)(delBasePath(pathname)) : pathname; // If asked to change the current URL we should reload the current page
                // (not location.reload() but reload getInitialProps and other Next.js stuffs)
                // We also need to set the method = replaceState always
                // as this should not go into the history (That's how browsers work)
                // We should compare the new asPath to the current asPath, not the url

                if (!this.urlIsNew(cleanedAs) && !localeChange) {
                  method = 'replaceState';
                }

                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname); // we need to resolve the as value using rewrites for dynamic SSG
                // pages to allow building the data URL correctly

                resolvedAs = as;

                if ( true && as.startsWith('/')) {
                  resolvedAs = (0, _resolveRewrites["default"])(addBasePath(addLocale(delBasePath((0, _parseRelativeUrl.parseRelativeUrl)(as).pathname), this.locale)), pages, rewrites, query, function (p) {
                    return _this2._resolveHref({
                      pathname: p
                    }, pages).pathname;
                  }, this.locales);

                  if (resolvedAs !== as) {
                    potentialHref = (0, _normalizeTrailingSlash.removePathTrailingSlash)(this._resolveHref(Object.assign({}, parsed, {
                      pathname: (0, _normalizeLocalePath.normalizeLocalePath)(hasBasePath(resolvedAs) ? delBasePath(resolvedAs) : resolvedAs, this.locales).pathname
                    }), pages, false).pathname); // if this directly matches a page we need to update the href to
                    // allow the correct page chunk to be loaded

                    if (pages.includes(potentialHref)) {
                      route = potentialHref;
                      pathname = potentialHref;
                      parsed.pathname = pathname;
                      url = (0, _utils.formatWithValidation)(parsed);
                    }
                  }
                }

                if (isLocalURL(as)) {
                  _context.next = 62;
                  break;
                }

                if (false) {}

                throw new Error("Invalid href: \"".concat(url, "\" and as: \"").concat(as, "\", received relative href and external as") + "\nSee more info: https://err.sh/next.js/invalid-relative-url-external-as");

              case 60:
                window.location.href = as;
                return _context.abrupt("return", false);

              case 62:
                resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);

                if (!(0, _isDynamic.isDynamicRoute)(route)) {
                  _context.next = 78;
                  break;
                }

                _parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(resolvedAs);
                asPathname = _parsedAs.pathname;
                routeRegex = (0, _routeRegex.getRouteRegex)(route);
                routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);
                shouldInterpolate = route === asPathname;
                interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};

                if (!(!routeMatch || shouldInterpolate && !interpolatedAs.result)) {
                  _context.next = 77;
                  break;
                }

                missingParams = Object.keys(routeRegex.groups).filter(function (param) {
                  return !query[param];
                });

                if (!(missingParams.length > 0)) {
                  _context.next = 75;
                  break;
                }

                if (true) {
                  console.warn("".concat(shouldInterpolate ? "Interpolating href" : "Mismatching `as` and `href`", " failed to manually provide ") + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
                }

                throw new Error((shouldInterpolate ? "The provided `href` (".concat(url, ") value is missing query values (").concat(missingParams.join(', '), ") to be interpolated properly. ") : "The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ")) + "Read more: https://err.sh/vercel/next.js/".concat(shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'));

              case 75:
                _context.next = 78;
                break;

              case 77:
                if (shouldInterpolate) {
                  as = (0, _utils.formatWithValidation)(Object.assign({}, _parsedAs, {
                    pathname: interpolatedAs.result,
                    query: omitParmsFromQuery(query, interpolatedAs.params)
                  }));
                } else {
                  // Merge params into `query`, overwriting any specified in search
                  Object.assign(query, routeMatch);
                }

              case 78:
                Router.events.emit('routeChangeStart', as, routeProps);
                _context.prev = 79;
                _context.next = 82;
                return this.getRouteInfo(route, pathname, query, addBasePath(addLocale(resolvedAs, this.locale)), routeProps);

              case 82:
                routeInfo = _context.sent;
                _routeInfo = routeInfo, error = _routeInfo.error, props = _routeInfo.props, __N_SSG = _routeInfo.__N_SSG, __N_SSP = _routeInfo.__N_SSP; // handle redirect on client-transition

                if (!((__N_SSG || __N_SSP) && props)) {
                  _context.next = 108;
                  break;
                }

                if (!(props.pageProps && props.pageProps.__N_REDIRECT)) {
                  _context.next = 95;
                  break;
                }

                destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt
                // client-navigation if it is falling back to hard navigation if
                // it's not

                if (!destination.startsWith('/')) {
                  _context.next = 93;
                  break;
                }

                parsedHref = (0, _parseRelativeUrl.parseRelativeUrl)(destination);

                this._resolveHref(parsedHref, pages, false);

                if (!pages.includes(parsedHref.pathname)) {
                  _context.next = 93;
                  break;
                }

                _prepareUrlAs3 = prepareUrlAs(this, destination, destination), newUrl = _prepareUrlAs3.url, newAs = _prepareUrlAs3.as;
                return _context.abrupt("return", this.change(method, newUrl, newAs, options));

              case 93:
                window.location.href = destination;
                return _context.abrupt("return", new Promise(function () {}));

              case 95:
                if (!(props.notFound === SSG_DATA_NOT_FOUND)) {
                  _context.next = 108;
                  break;
                }

                _context.prev = 96;
                _context.next = 99;
                return this.fetchComponent('/404');

              case 99:
                notFoundRoute = '/404';
                _context.next = 105;
                break;

              case 102:
                _context.prev = 102;
                _context.t1 = _context["catch"](96);
                notFoundRoute = '/_error';

              case 105:
                _context.next = 107;
                return this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, {
                  shallow: false
                });

              case 107:
                routeInfo = _context.sent;

              case 108:
                Router.events.emit('beforeHistoryChange', as, routeProps);
                this.changeState(method, url, as, options);

                if (true) {
                  appComp = this.components['/_app'].Component;
                  window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
                }

                _context.next = 113;
                return this.set(route, pathname, query, cleanedAs, routeInfo, forcedScroll || (options.scroll ? {
                  x: 0,
                  y: 0
                } : null))["catch"](function (e) {
                  if (e.cancelled) error = error || e;else throw e;
                });

              case 113:
                if (!error) {
                  _context.next = 116;
                  break;
                }

                Router.events.emit('routeChangeError', error, cleanedAs, routeProps);
                throw error;

              case 116:
                if (false) {}

                Router.events.emit('routeChangeComplete', as, routeProps);
                return _context.abrupt("return", true);

              case 121:
                _context.prev = 121;
                _context.t2 = _context["catch"](79);

                if (!_context.t2.cancelled) {
                  _context.next = 125;
                  break;
                }

                return _context.abrupt("return", false);

              case 125:
                throw _context.t2;

              case 126:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[36, 46], [79, 121], [96, 102]]);
      }));

      function change(_x, _x2, _x3, _x4, _x5) {
        return _change.apply(this, arguments);
      }

      return change;
    }()
  }, {
    key: "changeState",
    value: function changeState(method, url, as) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (true) {
        if (typeof window.history === 'undefined') {
          console.error("Warning: window.history is not available.");
          return;
        }

        if (typeof window.history[method] === 'undefined') {
          console.error("Warning: window.history.".concat(method, " is not available"));
          return;
        }
      }

      if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
        this._shallow = options.shallow;
        window.history[method]({
          url: url,
          as: as,
          options: options,
          __N: true,
          idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1
        }, // Most browsers currently ignores this parameter, although they may use it in the future.
        // Passing the empty string here should be safe against future changes to the method.
        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
        '', as);
      }
    }
  }, {
    key: "handleRouteInfoError",
    value: function () {
      var _handleRouteInfoError = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(err, pathname, query, as, routeProps, loadErrorFail) {
        var Component, styleSheets, props, _yield$this$fetchComp, routeInfo;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!err.cancelled) {
                  _context2.next = 2;
                  break;
                }

                throw err;

              case 2:
                if (!((0, _routeLoader.isAssetError)(err) || loadErrorFail)) {
                  _context2.next = 6;
                  break;
                }

                Router.events.emit('routeChangeError', err, as, routeProps); // If we can't load the page it could be one of following reasons
                //  1. Page doesn't exists
                //  2. Page does exist in a different zone
                //  3. Internal error while loading the page
                // So, doing a hard reload is the proper way to deal with this.

                window.location.href = as; // Changing the URL doesn't block executing the current code path.
                // So let's throw a cancellation error stop the routing logic.

                throw buildCancellationError();

              case 6:
                _context2.prev = 6;

                if (!(typeof Component === 'undefined' || typeof styleSheets === 'undefined')) {
                  _context2.next = 14;
                  break;
                }

                ;
                _context2.next = 11;
                return this.fetchComponent('/_error');

              case 11:
                _yield$this$fetchComp = _context2.sent;
                Component = _yield$this$fetchComp.page;
                styleSheets = _yield$this$fetchComp.styleSheets;

              case 14:
                routeInfo = {
                  props: props,
                  Component: Component,
                  styleSheets: styleSheets,
                  err: err,
                  error: err
                };

                if (routeInfo.props) {
                  _context2.next = 26;
                  break;
                }

                _context2.prev = 16;
                _context2.next = 19;
                return this.getInitialProps(Component, {
                  err: err,
                  pathname: pathname,
                  query: query
                });

              case 19:
                routeInfo.props = _context2.sent;
                _context2.next = 26;
                break;

              case 22:
                _context2.prev = 22;
                _context2.t0 = _context2["catch"](16);
                console.error('Error in error page `getInitialProps`: ', _context2.t0);
                routeInfo.props = {};

              case 26:
                return _context2.abrupt("return", routeInfo);

              case 29:
                _context2.prev = 29;
                _context2.t1 = _context2["catch"](6);
                return _context2.abrupt("return", this.handleRouteInfoError(_context2.t1, pathname, query, as, routeProps, true));

              case 32:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 29], [16, 22]]);
      }));

      function handleRouteInfoError(_x6, _x7, _x8, _x9, _x10, _x11) {
        return _handleRouteInfoError.apply(this, arguments);
      }

      return handleRouteInfoError;
    }()
  }, {
    key: "getRouteInfo",
    value: function () {
      var _getRouteInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(route, pathname, query, as, routeProps) {
        var _this3 = this;

        var existingRouteInfo, cachedRouteInfo, routeInfo, Component, __N_SSG, __N_SSP, _require, isValidElementType, dataHref, props;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                existingRouteInfo = this.components[route];

                if (!(routeProps.shallow && existingRouteInfo && this.route === route)) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return", existingRouteInfo);

              case 4:
                cachedRouteInfo = existingRouteInfo && 'initial' in existingRouteInfo ? undefined : existingRouteInfo;

                if (!cachedRouteInfo) {
                  _context3.next = 9;
                  break;
                }

                _context3.t0 = cachedRouteInfo;
                _context3.next = 12;
                break;

              case 9:
                _context3.next = 11;
                return this.fetchComponent(route).then(function (res) {
                  return {
                    Component: res.page,
                    styleSheets: res.styleSheets,
                    __N_SSG: res.mod.__N_SSG,
                    __N_SSP: res.mod.__N_SSP
                  };
                });

              case 11:
                _context3.t0 = _context3.sent;

              case 12:
                routeInfo = _context3.t0;
                Component = routeInfo.Component, __N_SSG = routeInfo.__N_SSG, __N_SSP = routeInfo.__N_SSP;

                if (false) {}

                _require = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"), isValidElementType = _require.isValidElementType;

                if (isValidElementType(Component)) {
                  _context3.next = 18;
                  break;
                }

                throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));

              case 18:
                if (__N_SSG || __N_SSP) {
                  dataHref = this.pageLoader.getDataHref((0, _utils.formatWithValidation)({
                    pathname: pathname,
                    query: query
                  }), delBasePath(as), __N_SSG, this.locale);
                }

                _context3.next = 21;
                return this._getData(function () {
                  return __N_SSG ? _this3._getStaticData(dataHref) : __N_SSP ? _this3._getServerData(dataHref) : _this3.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
                  {
                    pathname: pathname,
                    query: query,
                    asPath: as
                  });
                });

              case 21:
                props = _context3.sent;
                routeInfo.props = props;
                this.components[route] = routeInfo;
                return _context3.abrupt("return", routeInfo);

              case 27:
                _context3.prev = 27;
                _context3.t1 = _context3["catch"](0);
                return _context3.abrupt("return", this.handleRouteInfoError(_context3.t1, pathname, query, as, routeProps));

              case 30:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[0, 27]]);
      }));

      function getRouteInfo(_x12, _x13, _x14, _x15, _x16) {
        return _getRouteInfo.apply(this, arguments);
      }

      return getRouteInfo;
    }()
  }, {
    key: "set",
    value: function set(route, pathname, query, as, data, resetScroll) {
      this.isFallback = false;
      this.route = route;
      this.pathname = pathname;
      this.query = query;
      this.asPath = as;
      return this.notify(data, resetScroll);
    }
    /**
    * Callback to execute before replacing router state
    * @param cb callback to be executed
    */

  }, {
    key: "beforePopState",
    value: function beforePopState(cb) {
      this._bps = cb;
    }
  }, {
    key: "onlyAHashChange",
    value: function onlyAHashChange(as) {
      if (!this.asPath) return false;

      var _this$asPath$split = this.asPath.split('#'),
          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),
          oldUrlNoHash = _this$asPath$split2[0],
          oldHash = _this$asPath$split2[1];

      var _as$split = as.split('#'),
          _as$split2 = _slicedToArray(_as$split, 2),
          newUrlNoHash = _as$split2[0],
          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same


      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
        return true;
      } // If the urls are change, there's more than a hash change


      if (oldUrlNoHash !== newUrlNoHash) {
        return false;
      } // If the hash has changed, then it's a hash only change.
      // This check is necessary to handle both the enter and
      // leave hash === '' cases. The identity case falls through
      // and is treated as a next reload.


      return oldHash !== newHash;
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash(as) {
      var _as$split3 = as.split('#'),
          _as$split4 = _slicedToArray(_as$split3, 2),
          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value


      if (hash === '') {
        window.scrollTo(0, 0);
        return;
      } // First we check if the element by id is found


      var idEl = document.getElementById(hash);

      if (idEl) {
        idEl.scrollIntoView();
        return;
      } // If there's no element with the id, we check the `name` property
      // To mirror browsers


      var nameEl = document.getElementsByName(hash)[0];

      if (nameEl) {
        nameEl.scrollIntoView();
      }
    }
  }, {
    key: "urlIsNew",
    value: function urlIsNew(asPath) {
      return this.asPath !== asPath;
    }
  }, {
    key: "_resolveHref",
    value: function _resolveHref(parsedHref, pages) {
      var applyBasePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var pathname = parsedHref.pathname;
      var cleanPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _denormalizePagePath.denormalizePagePath)(applyBasePath ? delBasePath(pathname) : pathname));

      if (cleanPathname === '/404' || cleanPathname === '/_error') {
        return parsedHref;
      } // handle resolving href for dynamic routes


      if (!pages.includes(cleanPathname)) {
        // eslint-disable-next-line array-callback-return
        pages.some(function (page) {
          if ((0, _isDynamic.isDynamicRoute)(page) && (0, _routeRegex.getRouteRegex)(page).re.test(cleanPathname)) {
            parsedHref.pathname = applyBasePath ? addBasePath(page) : page;
            return true;
          }
        });
      }

      parsedHref.pathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)(parsedHref.pathname);
      return parsedHref;
    }
    /**
    * Prefetch page code, you may wait for the data during page rendering.
    * This feature only works in production!
    * @param url the href of prefetched page
    * @param asPath the as path of the prefetched page
    */

  }, {
    key: "prefetch",
    value: function () {
      var _prefetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(url) {
        var _this4 = this;

        var asPath,
            options,
            parsed,
            _parsed2,
            pathname,
            parsedAs,
            localePathResult,
            pages,
            route,
            _args4 = arguments;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                asPath = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : url;
                options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
                parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);
                _parsed2 = parsed, pathname = _parsed2.pathname;

                if (false) {}

                _context4.next = 7;
                return this.pageLoader.getPageList();

              case 7:
                pages = _context4.sent;
                parsed = this._resolveHref(parsed, pages, false);

                if (parsed.pathname !== pathname) {
                  pathname = parsed.pathname;
                  url = (0, _utils.formatWithValidation)(parsed);
                } // Prefetch is not supported in development mode because it would trigger on-demand-entries


                if (false) {}

                return _context4.abrupt("return");

              case 12:
                route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);
                _context4.next = 15;
                return Promise.all([this.pageLoader._isSsg(url).then(function (isSsg) {
                  return isSsg ? _this4._getStaticData(_this4.pageLoader.getDataHref(url, asPath, true, typeof options.locale !== 'undefined' ? options.locale : _this4.locale)) : false;
                }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);

              case 15:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function prefetch(_x17) {
        return _prefetch.apply(this, arguments);
      }

      return prefetch;
    }()
  }, {
    key: "fetchComponent",
    value: function () {
      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(route) {
        var cancelled, cancel, componentResult, error;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                cancelled = false;

                cancel = this.clc = function () {
                  cancelled = true;
                };

                _context5.next = 4;
                return this.pageLoader.loadPage(route);

              case 4:
                componentResult = _context5.sent;

                if (!cancelled) {
                  _context5.next = 9;
                  break;
                }

                error = new Error("Abort fetching component for route: \"".concat(route, "\""));
                error.cancelled = true;
                throw error;

              case 9:
                if (cancel === this.clc) {
                  this.clc = null;
                }

                return _context5.abrupt("return", componentResult);

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function fetchComponent(_x18) {
        return _fetchComponent.apply(this, arguments);
      }

      return fetchComponent;
    }()
  }, {
    key: "_getData",
    value: function _getData(fn) {
      var _this5 = this;

      var cancelled = false;

      var cancel = function cancel() {
        cancelled = true;
      };

      this.clc = cancel;
      return fn().then(function (data) {
        if (cancel === _this5.clc) {
          _this5.clc = null;
        }

        if (cancelled) {
          var err = new Error('Loading initial props cancelled');
          err.cancelled = true;
          throw err;
        }

        return data;
      });
    }
  }, {
    key: "_getStaticData",
    value: function _getStaticData(dataHref) {
      var _this6 = this;

      var _URL = new URL(dataHref, window.location.href),
          cacheKey = _URL.href;

      if (false) {}

      return fetchNextData(dataHref, this.isSsr).then(function (data) {
        _this6.sdc[cacheKey] = data;
        return data;
      });
    }
  }, {
    key: "_getServerData",
    value: function _getServerData(dataHref) {
      return fetchNextData(dataHref, this.isSsr);
    }
  }, {
    key: "getInitialProps",
    value: function getInitialProps(Component, ctx) {
      var App = this.components['/_app'].Component;

      var AppTree = this._wrapApp(App);

      ctx.AppTree = AppTree;
      return (0, _utils.loadGetInitialProps)(App, {
        AppTree: AppTree,
        Component: Component,
        router: this,
        ctx: ctx
      });
    }
  }, {
    key: "abortComponentLoad",
    value: function abortComponentLoad(as, routeProps) {
      if (this.clc) {
        Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);
        this.clc();
        this.clc = null;
      }
    }
  }, {
    key: "notify",
    value: function notify(data, resetScroll) {
      return this.sub(data, this.components['/_app'].Component, resetScroll);
    }
  }]);

  return Router;
}();

exports["default"] = Router;
Router.events = (0, _mitt["default"])();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/format-url.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.formatUrl = formatUrl;

var querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
} // Format function modified from nodejs
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var slashedProtocols = /https?|ftp|gopher|file/;

function formatUrl(urlObj) {
  var auth = urlObj.auth,
      hostname = urlObj.hostname;
  var protocol = urlObj.protocol || '';
  var pathname = urlObj.pathname || '';
  var hash = urlObj.hash || '';
  var query = urlObj.query || '';
  var host = false;
  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';

  if (urlObj.host) {
    host = auth + urlObj.host;
  } else if (hostname) {
    host = auth + (~hostname.indexOf(':') ? "[".concat(hostname, "]") : hostname);

    if (urlObj.port) {
      host += ':' + urlObj.port;
    }
  }

  if (query && typeof query === 'object') {
    query = String(querystring.urlQueryToSearchParams(query));
  }

  var search = urlObj.search || query && "?".concat(query) || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash[0] !== '#') hash = '#' + hash;
  if (search && search[0] !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, encodeURIComponent);
  search = search.replace('#', '%23');
  return "".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/get-asset-path-from-route.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = getAssetPathFromRoute; // Translates a logical route into its pages asset path (relative from a common prefix)
// "asset path" being its javascript file, data file, prerendered html,...

function getAssetPathFromRoute(route) {
  var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var path = route === '/' ? '/index' : /^\/index(\/|$)/.test(route) ? "/index".concat(route) : "".concat(route);
  return path + ext;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string

var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.parseRelativeUrl = parseRelativeUrl;

var _utils = __webpack_require__(/*! ../../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");
/**
* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative
* (e.g. `./hello`) then at least base must be.
* Absolute urls are rejected with one exception, in the browser, absolute urls that are on
* the current origin will be parsed as relative
*/


function parseRelativeUrl(url, base) {
  var globalBase = new URL(false ? undefined : (0, _utils.getLocationOrigin)());
  var resolvedBase = base ? new URL(base, globalBase) : globalBase;

  var _URL = new URL(url, resolvedBase),
      pathname = _URL.pathname,
      searchParams = _URL.searchParams,
      search = _URL.search,
      hash = _URL.hash,
      href = _URL.href,
      origin = _URL.origin;

  if (origin !== globalBase.origin) {
    throw new Error("invariant: invalid relative URL, router received ".concat(url));
  }

  return {
    pathname: pathname,
    query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
    search: search,
    hash: hash,
    href: href.slice(globalBase.origin.length)
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/path-match.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

exports.__esModule = true;
exports.pathToRegexp = exports["default"] = exports.customRouteMatcherOptions = exports.matcherOptions = void 0;

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./node_modules/next/dist/compiled/path-to-regexp/index.js"));

exports.pathToRegexp = pathToRegexp;

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var matcherOptions = {
  sensitive: false,
  delimiter: '/'
};
exports.matcherOptions = matcherOptions;

var customRouteMatcherOptions = _objectSpread(_objectSpread({}, matcherOptions), {}, {
  strict: true
});

exports.customRouteMatcherOptions = customRouteMatcherOptions;

var _default = function _default() {
  var customRoute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return function (path) {
    var keys = [];
    var matcherRegex = pathToRegexp.pathToRegexp(path, keys, customRoute ? customRouteMatcherOptions : matcherOptions);
    var matcher = pathToRegexp.regexpToFunction(matcherRegex, keys);
    return function (pathname, params) {
      var res = pathname == null ? false : matcher(pathname);

      if (!res) {
        return false;
      }

      if (customRoute) {
        var _iterator = _createForOfIteratorHelper(keys),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var key = _step.value;

            // unnamed params should be removed as they
            // are not allowed to be used in the destination
            if (typeof key.name === 'number') {
              delete res.params[key.name];
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return _objectSpread(_objectSpread({}, params), res.params);
    };
  };
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

exports.__esModule = true;
exports.compileNonPath = compileNonPath;
exports["default"] = prepareDestination;

var _querystring = __webpack_require__(/*! ./querystring */ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js");

var _parseRelativeUrl = __webpack_require__(/*! ./parse-relative-url */ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js");

var pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ "./node_modules/next/dist/compiled/path-to-regexp/index.js"));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function compileNonPath(value, params) {
  if (!value.includes(':')) {
    return value;
  }

  for (var _i = 0, _Object$keys = Object.keys(params); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];

    if (value.includes(":".concat(key))) {
      value = value.replace(new RegExp(":".concat(key, "\\*"), 'g'), ":".concat(key, "--ESCAPED_PARAM_ASTERISKS")).replace(new RegExp(":".concat(key, "\\?"), 'g'), ":".concat(key, "--ESCAPED_PARAM_QUESTION")).replace(new RegExp(":".concat(key, "\\+"), 'g'), ":".concat(key, "--ESCAPED_PARAM_PLUS")).replace(new RegExp(":".concat(key, "(?!\\w)"), 'g'), "--ESCAPED_PARAM_COLON".concat(key));
    }
  }

  value = value.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g, '\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*'); // the value needs to start with a forward-slash to be compiled
  // correctly

  return pathToRegexp.compile("/".concat(value), {
    validate: false
  })(params).substr(1);
}

function prepareDestination(destination, params, query, appendParamsToQuery) {
  var parsedDestination = {}; // clone query so we don't modify the original

  query = Object.assign({}, query);
  var hadLocale = query.__nextLocale;
  delete query.__nextLocale;
  delete query.__nextDefaultLocale;

  if (destination.startsWith('/')) {
    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);
  } else {
    var _URL = new URL(destination),
        pathname = _URL.pathname,
        searchParams = _URL.searchParams,
        hash = _URL.hash,
        hostname = _URL.hostname,
        port = _URL.port,
        protocol = _URL.protocol,
        search = _URL.search,
        href = _URL.href;

    parsedDestination = {
      pathname: pathname,
      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),
      hash: hash,
      protocol: protocol,
      hostname: hostname,
      port: port,
      search: search,
      href: href
    };
  }

  var destQuery = parsedDestination.query;
  var destPath = "".concat(parsedDestination.pathname).concat(parsedDestination.hash || '');
  var destPathParamKeys = [];
  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);
  var destPathParams = destPathParamKeys.map(function (key) {
    return key.name;
  });
  var destinationCompiler = pathToRegexp.compile(destPath, // we don't validate while compiling the destination since we should
  // have already validated before we got to this point and validating
  // breaks compiling destinations with named pattern params from the source
  // e.g. /something:hello(.*) -> /another/:hello is broken with validation
  // since compile validation is meant for reversing and not for inserting
  // params from a separate path-regex into another
  {
    validate: false
  });
  var newUrl; // update any params in query values

  for (var _i2 = 0, _Object$entries = Object.entries(destQuery); _i2 < _Object$entries.length; _i2++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
        key = _Object$entries$_i[0],
        strOrArray = _Object$entries$_i[1];

    var value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;

    if (value) {
      // the value needs to start with a forward-slash to be compiled
      // correctly
      value = compileNonPath(value, params);
    }

    destQuery[key] = value;
  } // add path params to query if it's not a redirect and not
  // already defined in destination query or path


  var paramKeys = Object.keys(params); // remove internal param for i18n

  if (hadLocale) {
    paramKeys = paramKeys.filter(function (name) {
      return name !== 'nextInternalLocale';
    });
  }

  if (appendParamsToQuery && !paramKeys.some(function (key) {
    return destPathParams.includes(key);
  })) {
    var _iterator = _createForOfIteratorHelper(paramKeys),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _key = _step.value;

        if (!(_key in destQuery)) {
          destQuery[_key] = params[_key];
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  try {
    newUrl = destinationCompiler(params);

    var _newUrl$split = newUrl.split('#'),
        _newUrl$split2 = _slicedToArray(_newUrl$split, 2),
        _pathname = _newUrl$split2[0],
        _hash = _newUrl$split2[1];

    parsedDestination.pathname = _pathname;
    parsedDestination.hash = "".concat(_hash ? '#' : '').concat(_hash || '');
    delete parsedDestination.search;
  } catch (err) {
    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {
      throw new Error("To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match");
    }

    throw err;
  } // Query merge order lowest priority to highest
  // 1. initial URL query values
  // 2. path segment values
  // 3. destination specified query values


  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);
  return {
    newUrl: newUrl,
    parsedDestination: parsedDestination
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/querystring.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

exports.__esModule = true;
exports.searchParamsToUrlQuery = searchParamsToUrlQuery;
exports.urlQueryToSearchParams = urlQueryToSearchParams;
exports.assign = assign;

function searchParamsToUrlQuery(searchParams) {
  var query = {};
  searchParams.forEach(function (value, key) {
    if (typeof query[key] === 'undefined') {
      query[key] = value;
    } else if (Array.isArray(query[key])) {
      ;
      query[key].push(value);
    } else {
      query[key] = [query[key], value];
    }
  });
  return query;
}

function stringifyUrlQueryParam(param) {
  if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {
    return String(param);
  } else {
    return '';
  }
}

function urlQueryToSearchParams(urlQuery) {
  var result = new URLSearchParams();
  Object.entries(urlQuery).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    if (Array.isArray(value)) {
      value.forEach(function (item) {
        return result.append(key, stringifyUrlQueryParam(item));
      });
    } else {
      result.set(key, stringifyUrlQueryParam(value));
    }
  });
  return result;
}

function assign(target) {
  for (var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    searchParamsList[_key - 1] = arguments[_key];
  }

  searchParamsList.forEach(function (searchParams) {
    Array.from(searchParams.keys()).forEach(function (key) {
      return target["delete"](key);
    });
    searchParams.forEach(function (value, key) {
      return target.append(key, value);
    });
  });
  return target;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

exports.__esModule = true;
exports["default"] = resolveRewrites;

var _pathMatch = _interopRequireDefault(__webpack_require__(/*! ./path-match */ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js"));

var _prepareDestination = _interopRequireDefault(__webpack_require__(/*! ./prepare-destination */ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js"));

var _normalizeTrailingSlash = __webpack_require__(/*! ../../../../client/normalize-trailing-slash */ "./node_modules/next/dist/client/normalize-trailing-slash.js");

var _normalizeLocalePath = __webpack_require__(/*! ../../i18n/normalize-locale-path */ "./node_modules/next/dist/next-server/lib/i18n/normalize-locale-path.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var customRouteMatcher = (0, _pathMatch["default"])(true);

function resolveRewrites(asPath, pages, rewrites, query, resolveHref, locales) {
  if (!pages.includes((0, _normalizeLocalePath.normalizeLocalePath)(asPath, locales).pathname)) {
    var _iterator = _createForOfIteratorHelper(rewrites),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var rewrite = _step.value;
        var matcher = customRouteMatcher(rewrite.source);
        var params = matcher(asPath);

        if (params) {
          if (!rewrite.destination) {
            // this is a proxied rewrite which isn't handled on the client
            break;
          }

          var destRes = (0, _prepareDestination["default"])(rewrite.destination, params, query, true);
          asPath = destRes.parsedDestination.pathname;
          Object.assign(query, destRes.parsedDestination.query);
          var fsPathname = (0, _normalizeLocalePath.normalizeLocalePath)((0, _normalizeTrailingSlash.removePathTrailingSlash)(asPath), locales).pathname;

          if (pages.includes(fsPathname)) {
            asPath = fsPathname; // check if we now match a page as this means we are done
            // resolving the rewrites

            break;
          } // check if we match a dynamic-route, if so we break the rewrites chain


          var resolvedHref = resolveHref(fsPathname);

          if (resolvedHref !== asPath && pages.includes(resolvedHref)) {
            asPath = fsPathname;
            break;
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  return asPath;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteMatcher = getRouteMatcher;

function getRouteMatcher(routeRegex) {
  var re = routeRegex.re,
      groups = routeRegex.groups;
  return function (pathname) {
    var routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    var decode = function decode(param) {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        var err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    var params = {};
    Object.keys(groups).forEach(function (slugName) {
      var g = groups[slugName];
      var m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(function (entry) {
          return decode(entry);
        }) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function parseParameter(param) {
  var optional = param.startsWith('[') && param.endsWith(']');

  if (optional) {
    param = param.slice(1, -1);
  }

  var repeat = param.startsWith('...');

  if (repeat) {
    param = param.slice(3);
  }

  return {
    key: param,
    repeat: repeat,
    optional: optional
  };
}

function getRouteRegex(normalizedRoute) {
  var segments = (normalizedRoute.replace(/\/$/, '') || '/').slice(1).split('/');
  var groups = {};
  var groupIndex = 1;
  var parameterizedRoute = segments.map(function (segment) {
    if (segment.startsWith('[') && segment.endsWith(']')) {
      var _parseParameter = parseParameter(segment.slice(1, -1)),
          key = _parseParameter.key,
          optional = _parseParameter.optional,
          repeat = _parseParameter.repeat;

      groups[key] = {
        pos: groupIndex++,
        repeat: repeat,
        optional: optional
      };
      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
    } else {
      return "/".concat(escapeRegex(segment));
    }
  }).join(''); // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) { var namedParameterizedRoute, routeKeys, getSafeRouteKey, routeKeyCharLength, routeKeyCharCode; }

  return {
    re: new RegExp("^".concat(parameterizedRoute, "(?:/)?$")),
    groups: groups
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/runtime-config.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/runtime-config.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.setConfig = setConfig;
exports["default"] = void 0;
var runtimeConfig;

var _default = function _default() {
  return runtimeConfig;
};

exports["default"] = _default;

function setConfig(configValue) {
  runtimeConfig = configValue;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

exports.__esModule = true;
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.loadGetInitialProps = loadGetInitialProps;
exports.formatWithValidation = formatWithValidation;
exports.ST = exports.SP = exports.urlObjectKeys = void 0;

var _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js");
/**
* Utils
*/


function execOnce(fn) {
  var used = false;
  var result;
  return function () {
    if (!used) {
      used = true;
      result = fn.apply(void 0, arguments);
    }

    return result;
  };
}

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

function getURL() {
  var href = window.location.href;
  var origin = getLocationOrigin();
  return href.substring(origin.length);
}

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

function loadGetInitialProps(_x, _x2) {
  return _loadGetInitialProps.apply(this, arguments);
}

function _loadGetInitialProps() {
  _loadGetInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(App, ctx) {
    var _App$prototype, message, res, props, _message;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (false) {}

            if (!((_App$prototype = App.prototype) != null && _App$prototype.getInitialProps)) {
              _context.next = 4;
              break;
            }

            message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://err.sh/vercel/next.js/get-initial-props-as-an-instance-method for more information.");
            throw new Error(message);

          case 4:
            // when called from _app `ctx` is nested in `ctx`
            res = ctx.res || ctx.ctx && ctx.ctx.res;

            if (App.getInitialProps) {
              _context.next = 12;
              break;
            }

            if (!(ctx.ctx && ctx.Component)) {
              _context.next = 11;
              break;
            }

            _context.next = 9;
            return loadGetInitialProps(ctx.Component, ctx.ctx);

          case 9:
            _context.t0 = _context.sent;
            return _context.abrupt("return", {
              pageProps: _context.t0
            });

          case 11:
            return _context.abrupt("return", {});

          case 12:
            _context.next = 14;
            return App.getInitialProps(ctx);

          case 14:
            props = _context.sent;

            if (!(res && isResSent(res))) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", props);

          case 17:
            if (props) {
              _context.next = 20;
              break;
            }

            _message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
            throw new Error(_message);

          case 20:
            if (true) {
              if (Object.keys(props).length === 0 && !ctx.ctx) {
                console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://err.sh/vercel/next.js/empty-object-getInitialProps"));
              }
            }

            return _context.abrupt("return", props);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadGetInitialProps.apply(this, arguments);
}

var urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];
exports.urlObjectKeys = urlObjectKeys;

function formatWithValidation(url) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(function (key) {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return (0, _formatUrl.formatUrl)(url);
}

var SP = typeof performance !== 'undefined';
exports.SP = SP;
var ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';
exports.ST = ST;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/server/denormalize-page-path.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/server/denormalize-page-path.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
exports.__esModule=true;exports.normalizePathSep=normalizePathSep;exports.denormalizePagePath=denormalizePagePath;function normalizePathSep(path){return path.replace(/\\/g,'/');}function denormalizePagePath(page){page=normalizePathSep(page);if(page.startsWith('/index/')){page=page.slice(6);}else if(page==='/index'){page='/';}return page;}
//# sourceMappingURL=denormalize-page-path.js.map

/***/ }),

/***/ "./node_modules/next/router.js":
/*!*************************************!*\
  !*** ./node_modules/next/router.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/client/router */ "./node_modules/next/dist/client/router.js")


/***/ }),

/***/ "./node_modules/platform/platform.js":
/*!*******************************************!*\
  !*** ./node_modules/platform/platform.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Platform.js v1.3.6
 * Copyright 2014-2020 Benjamin Tan
 * Copyright 2011-2013 John-David Dalton
 * Available under MIT license
 */
;(function() {
  'use strict';

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used as a reference to the global object. */
  var root = (objectTypes[typeof window] && window) || this;

  /** Backup possible global object. */
  var oldRoot = root;

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  /**
   * Used as the maximum length of an array-like object.
   * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
   * for more details.
   */
  var maxSafeInteger = Math.pow(2, 53) - 1;

  /** Regular expression to detect Opera. */
  var reOpera = /\bOpera/;

  /** Possible global object. */
  var thisBinding = this;

  /** Used for native method references. */
  var objectProto = Object.prototype;

  /** Used to check for own properties of an object. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to resolve the internal `[[Class]]` of values. */
  var toString = objectProto.toString;

  /*--------------------------------------------------------------------------*/

  /**
   * Capitalizes a string value.
   *
   * @private
   * @param {string} string The string to capitalize.
   * @returns {string} The capitalized string.
   */
  function capitalize(string) {
    string = String(string);
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  /**
   * A utility function to clean up the OS name.
   *
   * @private
   * @param {string} os The OS name to clean up.
   * @param {string} [pattern] A `RegExp` pattern matching the OS name.
   * @param {string} [label] A label for the OS.
   */
  function cleanupOS(os, pattern, label) {
    // Platform tokens are defined at:
    // http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    // http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    var data = {
      '10.0': '10',
      '6.4':  '10 Technical Preview',
      '6.3':  '8.1',
      '6.2':  '8',
      '6.1':  'Server 2008 R2 / 7',
      '6.0':  'Server 2008 / Vista',
      '5.2':  'Server 2003 / XP 64-bit',
      '5.1':  'XP',
      '5.01': '2000 SP1',
      '5.0':  '2000',
      '4.0':  'NT',
      '4.90': 'ME'
    };
    // Detect Windows version from platform tokens.
    if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) &&
        (data = data[/[\d.]+$/.exec(os)])) {
      os = 'Windows ' + data;
    }
    // Correct character case and cleanup string.
    os = String(os);

    if (pattern && label) {
      os = os.replace(RegExp(pattern, 'i'), label);
    }

    os = format(
      os.replace(/ ce$/i, ' CE')
        .replace(/\bhpw/i, 'web')
        .replace(/\bMacintosh\b/, 'Mac OS')
        .replace(/_PowerPC\b/i, ' OS')
        .replace(/\b(OS X) [^ \d]+/i, '$1')
        .replace(/\bMac (OS X)\b/, '$1')
        .replace(/\/(\d)/, ' $1')
        .replace(/_/g, '.')
        .replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '')
        .replace(/\bx86\.64\b/gi, 'x86_64')
        .replace(/\b(Windows Phone) OS\b/, '$1')
        .replace(/\b(Chrome OS \w+) [\d.]+\b/, '$1')
        .split(' on ')[0]
    );

    return os;
  }

  /**
   * An iteration utility for arrays and objects.
   *
   * @private
   * @param {Array|Object} object The object to iterate over.
   * @param {Function} callback The function called per iteration.
   */
  function each(object, callback) {
    var index = -1,
        length = object ? object.length : 0;

    if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {
      while (++index < length) {
        callback(object[index], index, object);
      }
    } else {
      forOwn(object, callback);
    }
  }

  /**
   * Trim and conditionally capitalize string values.
   *
   * @private
   * @param {string} string The string to format.
   * @returns {string} The formatted string.
   */
  function format(string) {
    string = trim(string);
    return /^(?:webOS|i(?:OS|P))/.test(string)
      ? string
      : capitalize(string);
  }

  /**
   * Iterates over an object's own properties, executing the `callback` for each.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} callback The function executed per own property.
   */
  function forOwn(object, callback) {
    for (var key in object) {
      if (hasOwnProperty.call(object, key)) {
        callback(object[key], key, object);
      }
    }
  }

  /**
   * Gets the internal `[[Class]]` of a value.
   *
   * @private
   * @param {*} value The value.
   * @returns {string} The `[[Class]]`.
   */
  function getClassOf(value) {
    return value == null
      ? capitalize(value)
      : toString.call(value).slice(8, -1);
  }

  /**
   * Host objects can return type values that are different from their actual
   * data type. The objects we are concerned with usually return non-primitive
   * types of "object", "function", or "unknown".
   *
   * @private
   * @param {*} object The owner of the property.
   * @param {string} property The property to check.
   * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
   */
  function isHostType(object, property) {
    var type = object != null ? typeof object[property] : 'number';
    return !/^(?:boolean|number|string|undefined)$/.test(type) &&
      (type == 'object' ? !!object[property] : true);
  }

  /**
   * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.
   *
   * @private
   * @param {string} string The string to qualify.
   * @returns {string} The qualified string.
   */
  function qualify(string) {
    return String(string).replace(/([ -])(?!$)/g, '$1?');
  }

  /**
   * A bare-bones `Array#reduce` like utility function.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function called per iteration.
   * @returns {*} The accumulated result.
   */
  function reduce(array, callback) {
    var accumulator = null;
    each(array, function(value, index) {
      accumulator = callback(accumulator, value, index, array);
    });
    return accumulator;
  }

  /**
   * Removes leading and trailing whitespace from a string.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} The trimmed string.
   */
  function trim(string) {
    return String(string).replace(/^ +| +$/g, '');
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a new platform object.
   *
   * @memberOf platform
   * @param {Object|string} [ua=navigator.userAgent] The user agent string or
   *  context object.
   * @returns {Object} A platform object.
   */
  function parse(ua) {

    /** The environment context object. */
    var context = root;

    /** Used to flag when a custom context is provided. */
    var isCustomContext = ua && typeof ua == 'object' && getClassOf(ua) != 'String';

    // Juggle arguments.
    if (isCustomContext) {
      context = ua;
      ua = null;
    }

    /** Browser navigator object. */
    var nav = context.navigator || {};

    /** Browser user agent string. */
    var userAgent = nav.userAgent || '';

    ua || (ua = userAgent);

    /** Used to flag when `thisBinding` is the [ModuleScope]. */
    var isModuleScope = isCustomContext || thisBinding == oldRoot;

    /** Used to detect if browser is like Chrome. */
    var likeChrome = isCustomContext
      ? !!nav.likeChrome
      : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());

    /** Internal `[[Class]]` value shortcuts. */
    var objectClass = 'Object',
        airRuntimeClass = isCustomContext ? objectClass : 'ScriptBridgingProxyObject',
        enviroClass = isCustomContext ? objectClass : 'Environment',
        javaClass = (isCustomContext && context.java) ? 'JavaPackage' : getClassOf(context.java),
        phantomClass = isCustomContext ? objectClass : 'RuntimeObject';

    /** Detect Java environments. */
    var java = /\bJava/.test(javaClass) && context.java;

    /** Detect Rhino. */
    var rhino = java && getClassOf(context.environment) == enviroClass;

    /** A character to represent alpha. */
    var alpha = java ? 'a' : '\u03b1';

    /** A character to represent beta. */
    var beta = java ? 'b' : '\u03b2';

    /** Browser document object. */
    var doc = context.document || {};

    /**
     * Detect Opera browser (Presto-based).
     * http://www.howtocreate.co.uk/operaStuff/operaObject.html
     * http://dev.opera.com/articles/view/opera-mini-web-content-authoring-guidelines/#operamini
     */
    var opera = context.operamini || context.opera;

    /** Opera `[[Class]]`. */
    var operaClass = reOpera.test(operaClass = (isCustomContext && opera) ? opera['[[Class]]'] : getClassOf(opera))
      ? operaClass
      : (opera = null);

    /*------------------------------------------------------------------------*/

    /** Temporary variable used over the script's lifetime. */
    var data;

    /** The CPU architecture. */
    var arch = ua;

    /** Platform description array. */
    var description = [];

    /** Platform alpha/beta indicator. */
    var prerelease = null;

    /** A flag to indicate that environment features should be used to resolve the platform. */
    var useFeatures = ua == userAgent;

    /** The browser/environment version. */
    var version = useFeatures && opera && typeof opera.version == 'function' && opera.version();

    /** A flag to indicate if the OS ends with "/ Version" */
    var isSpecialCasedOS;

    /* Detectable layout engines (order is important). */
    var layout = getLayout([
      { 'label': 'EdgeHTML', 'pattern': 'Edge' },
      'Trident',
      { 'label': 'WebKit', 'pattern': 'AppleWebKit' },
      'iCab',
      'Presto',
      'NetFront',
      'Tasman',
      'KHTML',
      'Gecko'
    ]);

    /* Detectable browser names (order is important). */
    var name = getName([
      'Adobe AIR',
      'Arora',
      'Avant Browser',
      'Breach',
      'Camino',
      'Electron',
      'Epiphany',
      'Fennec',
      'Flock',
      'Galeon',
      'GreenBrowser',
      'iCab',
      'Iceweasel',
      'K-Meleon',
      'Konqueror',
      'Lunascape',
      'Maxthon',
      { 'label': 'Microsoft Edge', 'pattern': '(?:Edge|Edg|EdgA|EdgiOS)' },
      'Midori',
      'Nook Browser',
      'PaleMoon',
      'PhantomJS',
      'Raven',
      'Rekonq',
      'RockMelt',
      { 'label': 'Samsung Internet', 'pattern': 'SamsungBrowser' },
      'SeaMonkey',
      { 'label': 'Silk', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Sleipnir',
      'SlimBrowser',
      { 'label': 'SRWare Iron', 'pattern': 'Iron' },
      'Sunrise',
      'Swiftfox',
      'Vivaldi',
      'Waterfox',
      'WebPositive',
      { 'label': 'Yandex Browser', 'pattern': 'YaBrowser' },
      { 'label': 'UC Browser', 'pattern': 'UCBrowser' },
      'Opera Mini',
      { 'label': 'Opera Mini', 'pattern': 'OPiOS' },
      'Opera',
      { 'label': 'Opera', 'pattern': 'OPR' },
      'Chromium',
      'Chrome',
      { 'label': 'Chrome', 'pattern': '(?:HeadlessChrome)' },
      { 'label': 'Chrome Mobile', 'pattern': '(?:CriOS|CrMo)' },
      { 'label': 'Firefox', 'pattern': '(?:Firefox|Minefield)' },
      { 'label': 'Firefox for iOS', 'pattern': 'FxiOS' },
      { 'label': 'IE', 'pattern': 'IEMobile' },
      { 'label': 'IE', 'pattern': 'MSIE' },
      'Safari'
    ]);

    /* Detectable products (order is important). */
    var product = getProduct([
      { 'label': 'BlackBerry', 'pattern': 'BB10' },
      'BlackBerry',
      { 'label': 'Galaxy S', 'pattern': 'GT-I9000' },
      { 'label': 'Galaxy S2', 'pattern': 'GT-I9100' },
      { 'label': 'Galaxy S3', 'pattern': 'GT-I9300' },
      { 'label': 'Galaxy S4', 'pattern': 'GT-I9500' },
      { 'label': 'Galaxy S5', 'pattern': 'SM-G900' },
      { 'label': 'Galaxy S6', 'pattern': 'SM-G920' },
      { 'label': 'Galaxy S6 Edge', 'pattern': 'SM-G925' },
      { 'label': 'Galaxy S7', 'pattern': 'SM-G930' },
      { 'label': 'Galaxy S7 Edge', 'pattern': 'SM-G935' },
      'Google TV',
      'Lumia',
      'iPad',
      'iPod',
      'iPhone',
      'Kindle',
      { 'label': 'Kindle Fire', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Nexus',
      'Nook',
      'PlayBook',
      'PlayStation Vita',
      'PlayStation',
      'TouchPad',
      'Transformer',
      { 'label': 'Wii U', 'pattern': 'WiiU' },
      'Wii',
      'Xbox One',
      { 'label': 'Xbox 360', 'pattern': 'Xbox' },
      'Xoom'
    ]);

    /* Detectable manufacturers. */
    var manufacturer = getManufacturer({
      'Apple': { 'iPad': 1, 'iPhone': 1, 'iPod': 1 },
      'Alcatel': {},
      'Archos': {},
      'Amazon': { 'Kindle': 1, 'Kindle Fire': 1 },
      'Asus': { 'Transformer': 1 },
      'Barnes & Noble': { 'Nook': 1 },
      'BlackBerry': { 'PlayBook': 1 },
      'Google': { 'Google TV': 1, 'Nexus': 1 },
      'HP': { 'TouchPad': 1 },
      'HTC': {},
      'Huawei': {},
      'Lenovo': {},
      'LG': {},
      'Microsoft': { 'Xbox': 1, 'Xbox One': 1 },
      'Motorola': { 'Xoom': 1 },
      'Nintendo': { 'Wii U': 1,  'Wii': 1 },
      'Nokia': { 'Lumia': 1 },
      'Oppo': {},
      'Samsung': { 'Galaxy S': 1, 'Galaxy S2': 1, 'Galaxy S3': 1, 'Galaxy S4': 1 },
      'Sony': { 'PlayStation': 1, 'PlayStation Vita': 1 },
      'Xiaomi': { 'Mi': 1, 'Redmi': 1 }
    });

    /* Detectable operating systems (order is important). */
    var os = getOS([
      'Windows Phone',
      'KaiOS',
      'Android',
      'CentOS',
      { 'label': 'Chrome OS', 'pattern': 'CrOS' },
      'Debian',
      { 'label': 'DragonFly BSD', 'pattern': 'DragonFly' },
      'Fedora',
      'FreeBSD',
      'Gentoo',
      'Haiku',
      'Kubuntu',
      'Linux Mint',
      'OpenBSD',
      'Red Hat',
      'SuSE',
      'Ubuntu',
      'Xubuntu',
      'Cygwin',
      'Symbian OS',
      'hpwOS',
      'webOS ',
      'webOS',
      'Tablet OS',
      'Tizen',
      'Linux',
      'Mac OS X',
      'Macintosh',
      'Mac',
      'Windows 98;',
      'Windows '
    ]);

    /*------------------------------------------------------------------------*/

    /**
     * Picks the layout engine from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected layout engine.
     */
    function getLayout(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the manufacturer from an array of guesses.
     *
     * @private
     * @param {Array} guesses An object of guesses.
     * @returns {null|string} The detected manufacturer.
     */
    function getManufacturer(guesses) {
      return reduce(guesses, function(result, value, key) {
        // Lookup the manufacturer by product or scan the UA for the manufacturer.
        return result || (
          value[product] ||
          value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] ||
          RegExp('\\b' + qualify(key) + '(?:\\b|\\w*\\d)', 'i').exec(ua)
        ) && key;
      });
    }

    /**
     * Picks the browser name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected browser name.
     */
    function getName(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the OS name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected OS name.
     */
    function getOS(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua)
            )) {
          result = cleanupOS(result, pattern, guess.label || guess);
        }
        return result;
      });
    }

    /**
     * Picks the product name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected product name.
     */
    function getProduct(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + ' *\\d+[.\\w_]*', 'i').exec(ua) ||
              RegExp('\\b' + pattern + ' *\\w+-[\\w]*', 'i').exec(ua) ||
              RegExp('\\b' + pattern + '(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)', 'i').exec(ua)
            )) {
          // Split by forward slash and append product version if needed.
          if ((result = String((guess.label && !RegExp(pattern, 'i').test(guess.label)) ? guess.label : result).split('/'))[1] && !/[\d.]+/.test(result[0])) {
            result[0] += ' ' + result[1];
          }
          // Correct character case and cleanup string.
          guess = guess.label || guess;
          result = format(result[0]
            .replace(RegExp(pattern, 'i'), guess)
            .replace(RegExp('; *(?:' + guess + '[_-])?', 'i'), ' ')
            .replace(RegExp('(' + guess + ')[-_.]?(\\w)', 'i'), '$1 $2'));
        }
        return result;
      });
    }

    /**
     * Resolves the version using an array of UA patterns.
     *
     * @private
     * @param {Array} patterns An array of UA patterns.
     * @returns {null|string} The detected version.
     */
    function getVersion(patterns) {
      return reduce(patterns, function(result, pattern) {
        return result || (RegExp(pattern +
          '(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;
      });
    }

    /**
     * Returns `platform.description` when the platform object is coerced to a string.
     *
     * @name toString
     * @memberOf platform
     * @returns {string} Returns `platform.description` if available, else an empty string.
     */
    function toStringPlatform() {
      return this.description || '';
    }

    /*------------------------------------------------------------------------*/

    // Convert layout to an array so we can add extra details.
    layout && (layout = [layout]);

    // Detect Android products.
    // Browsers on Android devices typically provide their product IDS after "Android;"
    // up to "Build" or ") AppleWebKit".
    // Example:
    // "Mozilla/5.0 (Linux; Android 8.1.0; Moto G (5) Plus) AppleWebKit/537.36
    // (KHTML, like Gecko) Chrome/70.0.3538.80 Mobile Safari/537.36"
    if (/\bAndroid\b/.test(os) && !product &&
        (data = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(ua))) {
      product = trim(data[1])
        // Replace any language codes (eg. "en-US").
        .replace(/^[a-z]{2}-[a-z]{2};\s*/i, '')
        || null;
    }
    // Detect product names that contain their manufacturer's name.
    if (manufacturer && !product) {
      product = getProduct([manufacturer]);
    } else if (manufacturer && product) {
      product = product
        .replace(RegExp('^(' + qualify(manufacturer) + ')[-_.\\s]', 'i'), manufacturer + ' ')
        .replace(RegExp('^(' + qualify(manufacturer) + ')[-_.]?(\\w)', 'i'), manufacturer + ' $2');
    }
    // Clean up Google TV.
    if ((data = /\bGoogle TV\b/.exec(product))) {
      product = data[0];
    }
    // Detect simulators.
    if (/\bSimulator\b/i.test(ua)) {
      product = (product ? product + ' ' : '') + 'Simulator';
    }
    // Detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS.
    if (name == 'Opera Mini' && /\bOPiOS\b/.test(ua)) {
      description.push('running in Turbo/Uncompressed mode');
    }
    // Detect IE Mobile 11.
    if (name == 'IE' && /\blike iPhone OS\b/.test(ua)) {
      data = parse(ua.replace(/like iPhone OS/, ''));
      manufacturer = data.manufacturer;
      product = data.product;
    }
    // Detect iOS.
    else if (/^iP/.test(product)) {
      name || (name = 'Safari');
      os = 'iOS' + ((data = / OS ([\d_]+)/i.exec(ua))
        ? ' ' + data[1].replace(/_/g, '.')
        : '');
    }
    // Detect Kubuntu.
    else if (name == 'Konqueror' && /^Linux\b/i.test(os)) {
      os = 'Kubuntu';
    }
    // Detect Android browsers.
    else if ((manufacturer && manufacturer != 'Google' &&
        ((/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua)) || /\bVita\b/.test(product))) ||
        (/\bAndroid\b/.test(os) && /^Chrome/.test(name) && /\bVersion\//i.test(ua))) {
      name = 'Android Browser';
      os = /\bAndroid\b/.test(os) ? os : 'Android';
    }
    // Detect Silk desktop/accelerated modes.
    else if (name == 'Silk') {
      if (!/\bMobi/i.test(ua)) {
        os = 'Android';
        description.unshift('desktop mode');
      }
      if (/Accelerated *= *true/i.test(ua)) {
        description.unshift('accelerated');
      }
    }
    // Detect UC Browser speed mode.
    else if (name == 'UC Browser' && /\bUCWEB\b/.test(ua)) {
      description.push('speed mode');
    }
    // Detect PaleMoon identifying as Firefox.
    else if (name == 'PaleMoon' && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
      description.push('identifying as Firefox ' + data[1]);
    }
    // Detect Firefox OS and products running Firefox.
    else if (name == 'Firefox' && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
      os || (os = 'Firefox OS');
      product || (product = data[1]);
    }
    // Detect false positives for Firefox/Safari.
    else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
      // Escape the `/` for Firefox 1.
      if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + '/') + 8))) {
        // Clear name of false positives.
        name = null;
      }
      // Reassign a generic name.
      if ((data = product || manufacturer || os) &&
          (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
        name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + ' Browser';
      }
    }
    // Add Chrome version to description for Electron.
    else if (name == 'Electron' && (data = (/\bChrome\/([\d.]+)\b/.exec(ua) || 0)[1])) {
      description.push('Chromium ' + data);
    }
    // Detect non-Opera (Presto-based) versions (order is important).
    if (!version) {
      version = getVersion([
        '(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)',
        'Version',
        qualify(name),
        '(?:Firefox|Minefield|NetFront)'
      ]);
    }
    // Detect stubborn layout engines.
    if ((data =
          layout == 'iCab' && parseFloat(version) > 3 && 'WebKit' ||
          /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? 'Blink' : 'Presto') ||
          /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && 'WebKit' ||
          !layout && /\bMSIE\b/i.test(ua) && (os == 'Mac OS' ? 'Tasman' : 'Trident') ||
          layout == 'WebKit' && /\bPlayStation\b(?! Vita\b)/i.test(name) && 'NetFront'
        )) {
      layout = [data];
    }
    // Detect Windows Phone 7 desktop mode.
    if (name == 'IE' && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
      name += ' Mobile';
      os = 'Windows Phone ' + (/\+$/.test(data) ? data : data + '.x');
      description.unshift('desktop mode');
    }
    // Detect Windows Phone 8.x desktop mode.
    else if (/\bWPDesktop\b/i.test(ua)) {
      name = 'IE Mobile';
      os = 'Windows Phone 8.x';
      description.unshift('desktop mode');
      version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
    }
    // Detect IE 11 identifying as other browsers.
    else if (name != 'IE' && layout == 'Trident' && (data = /\brv:([\d.]+)/.exec(ua))) {
      if (name) {
        description.push('identifying as ' + name + (version ? ' ' + version : ''));
      }
      name = 'IE';
      version = data[1];
    }
    // Leverage environment features.
    if (useFeatures) {
      // Detect server-side environments.
      // Rhino has a global function while others have a global object.
      if (isHostType(context, 'global')) {
        if (java) {
          data = java.lang.System;
          arch = data.getProperty('os.arch');
          os = os || data.getProperty('os.name') + ' ' + data.getProperty('os.version');
        }
        if (rhino) {
          try {
            version = context.require('ringo/engine').version.join('.');
            name = 'RingoJS';
          } catch(e) {
            if ((data = context.system) && data.global.system == context.system) {
              name = 'Narwhal';
              os || (os = data[0].os || null);
            }
          }
          if (!name) {
            name = 'Rhino';
          }
        }
        else if (
          typeof context.process == 'object' && !context.process.browser &&
          (data = context.process)
        ) {
          if (typeof data.versions == 'object') {
            if (typeof data.versions.electron == 'string') {
              description.push('Node ' + data.versions.node);
              name = 'Electron';
              version = data.versions.electron;
            } else if (typeof data.versions.nw == 'string') {
              description.push('Chromium ' + version, 'Node ' + data.versions.node);
              name = 'NW.js';
              version = data.versions.nw;
            }
          }
          if (!name) {
            name = 'Node.js';
            arch = data.arch;
            os = data.platform;
            version = /[\d.]+/.exec(data.version);
            version = version ? version[0] : null;
          }
        }
      }
      // Detect Adobe AIR.
      else if (getClassOf((data = context.runtime)) == airRuntimeClass) {
        name = 'Adobe AIR';
        os = data.flash.system.Capabilities.os;
      }
      // Detect PhantomJS.
      else if (getClassOf((data = context.phantom)) == phantomClass) {
        name = 'PhantomJS';
        version = (data = data.version || null) && (data.major + '.' + data.minor + '.' + data.patch);
      }
      // Detect IE compatibility modes.
      else if (typeof doc.documentMode == 'number' && (data = /\bTrident\/(\d+)/i.exec(ua))) {
        // We're in compatibility mode when the Trident version + 4 doesn't
        // equal the document mode.
        version = [version, doc.documentMode];
        if ((data = +data[1] + 4) != version[1]) {
          description.push('IE ' + version[1] + ' mode');
          layout && (layout[1] = '');
          version[1] = data;
        }
        version = name == 'IE' ? String(version[1].toFixed(1)) : version[0];
      }
      // Detect IE 11 masking as other browsers.
      else if (typeof doc.documentMode == 'number' && /^(?:Chrome|Firefox)\b/.test(name)) {
        description.push('masking as ' + name + ' ' + version);
        name = 'IE';
        version = '11.0';
        layout = ['Trident'];
        os = 'Windows';
      }
      os = os && format(os);
    }
    // Detect prerelease phases.
    if (version && (data =
          /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) ||
          /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ';' + (useFeatures && nav.appMinorVersion)) ||
          /\bMinefield\b/i.test(ua) && 'a'
        )) {
      prerelease = /b/i.test(data) ? 'beta' : 'alpha';
      version = version.replace(RegExp(data + '\\+?$'), '') +
        (prerelease == 'beta' ? beta : alpha) + (/\d+\+?/.exec(data) || '');
    }
    // Detect Firefox Mobile.
    if (name == 'Fennec' || name == 'Firefox' && /\b(?:Android|Firefox OS|KaiOS)\b/.test(os)) {
      name = 'Firefox Mobile';
    }
    // Obscure Maxthon's unreliable version.
    else if (name == 'Maxthon' && version) {
      version = version.replace(/\.[\d.]+/, '.x');
    }
    // Detect Xbox 360 and Xbox One.
    else if (/\bXbox\b/i.test(product)) {
      if (product == 'Xbox 360') {
        os = null;
      }
      if (product == 'Xbox 360' && /\bIEMobile\b/.test(ua)) {
        description.unshift('mobile mode');
      }
    }
    // Add mobile postfix.
    else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) &&
        (os == 'Windows CE' || /Mobi/i.test(ua))) {
      name += ' Mobile';
    }
    // Detect IE platform preview.
    else if (name == 'IE' && useFeatures) {
      try {
        if (context.external === null) {
          description.unshift('platform preview');
        }
      } catch(e) {
        description.unshift('embedded');
      }
    }
    // Detect BlackBerry OS version.
    // http://docs.blackberry.com/en/developers/deliverables/18169/HTTP_headers_sent_by_BB_Browser_1234911_11.jsp
    else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data =
          (RegExp(product.replace(/ +/g, ' *') + '/([.\\d]+)', 'i').exec(ua) || 0)[1] ||
          version
        )) {
      data = [data, /BB10/.test(ua)];
      os = (data[1] ? (product = null, manufacturer = 'BlackBerry') : 'Device Software') + ' ' + data[0];
      version = null;
    }
    // Detect Opera identifying/masking itself as another browser.
    // http://www.opera.com/support/kb/view/843/
    else if (this != forOwn && product != 'Wii' && (
          (useFeatures && opera) ||
          (/Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua)) ||
          (name == 'Firefox' && /\bOS X (?:\d+\.){2,}/.test(os)) ||
          (name == 'IE' && (
            (os && !/^Win/.test(os) && version > 5.5) ||
            /\bWindows XP\b/.test(os) && version > 8 ||
            version == 8 && !/\bTrident\b/.test(ua)
          ))
        ) && !reOpera.test((data = parse.call(forOwn, ua.replace(reOpera, '') + ';'))) && data.name) {
      // When "identifying", the UA contains both Opera and the other browser's name.
      data = 'ing as ' + data.name + ((data = data.version) ? ' ' + data : '');
      if (reOpera.test(name)) {
        if (/\bIE\b/.test(data) && os == 'Mac OS') {
          os = null;
        }
        data = 'identify' + data;
      }
      // When "masking", the UA contains only the other browser's name.
      else {
        data = 'mask' + data;
        if (operaClass) {
          name = format(operaClass.replace(/([a-z])([A-Z])/g, '$1 $2'));
        } else {
          name = 'Opera';
        }
        if (/\bIE\b/.test(data)) {
          os = null;
        }
        if (!useFeatures) {
          version = null;
        }
      }
      layout = ['Presto'];
      description.push(data);
    }
    // Detect WebKit Nightly and approximate Chrome/Safari versions.
    if ((data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
      // Correct build number for numeric comparison.
      // (e.g. "532.5" becomes "532.05")
      data = [parseFloat(data.replace(/\.(\d)$/, '.0$1')), data];
      // Nightly builds are postfixed with a "+".
      if (name == 'Safari' && data[1].slice(-1) == '+') {
        name = 'WebKit Nightly';
        prerelease = 'alpha';
        version = data[1].slice(0, -1);
      }
      // Clear incorrect browser versions.
      else if (version == data[1] ||
          version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
        version = null;
      }
      // Use the full Chrome version when available.
      data[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(ua) || 0)[1];
      // Detect Blink layout engine.
      if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == 'WebKit') {
        layout = ['Blink'];
      }
      // Detect JavaScriptCore.
      // http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi
      if (!useFeatures || (!likeChrome && !data[1])) {
        layout && (layout[1] = 'like Safari');
        data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? '4+' : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : data < 602 ? 9 : data < 604 ? 10 : data < 606 ? 11 : data < 608 ? 12 : '12');
      } else {
        layout && (layout[1] = 'like Chrome');
        data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.10 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.30 ? 11 : data < 535.01 ? 12 : data < 535.02 ? '13+' : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.10 ? 19 : data < 537.01 ? 20 : data < 537.11 ? '21+' : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != 'Blink' ? '27' : '28');
      }
      // Add the postfix of ".x" or "+" for approximate versions.
      layout && (layout[1] += ' ' + (data += typeof data == 'number' ? '.x' : /[.+]/.test(data) ? '' : '+'));
      // Obscure version for some Safari 1-2 releases.
      if (name == 'Safari' && (!version || parseInt(version) > 45)) {
        version = data;
      } else if (name == 'Chrome' && /\bHeadlessChrome/i.test(ua)) {
        description.unshift('headless');
      }
    }
    // Detect Opera desktop modes.
    if (name == 'Opera' &&  (data = /\bzbov|zvav$/.exec(os))) {
      name += ' ';
      description.unshift('desktop mode');
      if (data == 'zvav') {
        name += 'Mini';
        version = null;
      } else {
        name += 'Mobile';
      }
      os = os.replace(RegExp(' *' + data + '$'), '');
    }
    // Detect Chrome desktop mode.
    else if (name == 'Safari' && /\bChrome\b/.exec(layout && layout[1])) {
      description.unshift('desktop mode');
      name = 'Chrome Mobile';
      version = null;

      if (/\bOS X\b/.test(os)) {
        manufacturer = 'Apple';
        os = 'iOS 4.3+';
      } else {
        os = null;
      }
    }
    // Newer versions of SRWare Iron uses the Chrome tag to indicate its version number.
    else if (/\bSRWare Iron\b/.test(name) && !version) {
      version = getVersion('Chrome');
    }
    // Strip incorrect OS versions.
    if (version && version.indexOf((data = /[\d.]+$/.exec(os))) == 0 &&
        ua.indexOf('/' + data + '-') > -1) {
      os = trim(os.replace(data, ''));
    }
    // Ensure OS does not include the browser name.
    if (os && os.indexOf(name) != -1 && !RegExp(name + ' OS').test(os)) {
      os = os.replace(RegExp(' *' + qualify(name) + ' *'), '');
    }
    // Add layout engine.
    if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (
        /Browser|Lunascape|Maxthon/.test(name) ||
        name != 'Safari' && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) ||
        /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(name) && layout[1])) {
      // Don't add layout details to description if they are falsey.
      (data = layout[layout.length - 1]) && description.push(data);
    }
    // Combine contextual information.
    if (description.length) {
      description = ['(' + description.join('; ') + ')'];
    }
    // Append manufacturer to description.
    if (manufacturer && product && product.indexOf(manufacturer) < 0) {
      description.push('on ' + manufacturer);
    }
    // Append product to description.
    if (product) {
      description.push((/^on /.test(description[description.length - 1]) ? '' : 'on ') + product);
    }
    // Parse the OS into an object.
    if (os) {
      data = / ([\d.+]+)$/.exec(os);
      isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == '/';
      os = {
        'architecture': 32,
        'family': (data && !isSpecialCasedOS) ? os.replace(data[0], '') : os,
        'version': data ? data[1] : null,
        'toString': function() {
          var version = this.version;
          return this.family + ((version && !isSpecialCasedOS) ? ' ' + version : '') + (this.architecture == 64 ? ' 64-bit' : '');
        }
      };
    }
    // Add browser/OS architecture.
    if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
      if (os) {
        os.architecture = 64;
        os.family = os.family.replace(RegExp(' *' + data), '');
      }
      if (
          name && (/\bWOW64\b/i.test(ua) ||
          (useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua)))
      ) {
        description.unshift('32-bit');
      }
    }
    // Chrome 39 and above on OS X is always 64-bit.
    else if (
        os && /^OS X/.test(os.family) &&
        name == 'Chrome' && parseFloat(version) >= 39
    ) {
      os.architecture = 64;
    }

    ua || (ua = null);

    /*------------------------------------------------------------------------*/

    /**
     * The platform object.
     *
     * @name platform
     * @type Object
     */
    var platform = {};

    /**
     * The platform description.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.description = ua;

    /**
     * The name of the browser's layout engine.
     *
     * The list of common layout engines include:
     * "Blink", "EdgeHTML", "Gecko", "Trident" and "WebKit"
     *
     * @memberOf platform
     * @type string|null
     */
    platform.layout = layout && layout[0];

    /**
     * The name of the product's manufacturer.
     *
     * The list of manufacturers include:
     * "Apple", "Archos", "Amazon", "Asus", "Barnes & Noble", "BlackBerry",
     * "Google", "HP", "HTC", "LG", "Microsoft", "Motorola", "Nintendo",
     * "Nokia", "Samsung" and "Sony"
     *
     * @memberOf platform
     * @type string|null
     */
    platform.manufacturer = manufacturer;

    /**
     * The name of the browser/environment.
     *
     * The list of common browser names include:
     * "Chrome", "Electron", "Firefox", "Firefox for iOS", "IE",
     * "Microsoft Edge", "PhantomJS", "Safari", "SeaMonkey", "Silk",
     * "Opera Mini" and "Opera"
     *
     * Mobile versions of some browsers have "Mobile" appended to their name:
     * eg. "Chrome Mobile", "Firefox Mobile", "IE Mobile" and "Opera Mobile"
     *
     * @memberOf platform
     * @type string|null
     */
    platform.name = name;

    /**
     * The alpha/beta release indicator.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.prerelease = prerelease;

    /**
     * The name of the product hosting the browser.
     *
     * The list of common products include:
     *
     * "BlackBerry", "Galaxy S4", "Lumia", "iPad", "iPod", "iPhone", "Kindle",
     * "Kindle Fire", "Nexus", "Nook", "PlayBook", "TouchPad" and "Transformer"
     *
     * @memberOf platform
     * @type string|null
     */
    platform.product = product;

    /**
     * The browser's user agent string.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.ua = ua;

    /**
     * The browser/environment version.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.version = name && version;

    /**
     * The name of the operating system.
     *
     * @memberOf platform
     * @type Object
     */
    platform.os = os || {

      /**
       * The CPU architecture the OS is built for.
       *
       * @memberOf platform.os
       * @type number|null
       */
      'architecture': null,

      /**
       * The family of the OS.
       *
       * Common values include:
       * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
       * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
       * "SuSE", "Android", "iOS" and "Windows Phone"
       *
       * @memberOf platform.os
       * @type string|null
       */
      'family': null,

      /**
       * The version of the OS.
       *
       * @memberOf platform.os
       * @type string|null
       */
      'version': null,

      /**
       * Returns the OS string.
       *
       * @memberOf platform.os
       * @returns {string} The OS string.
       */
      'toString': function() { return 'null'; }
    };

    platform.parse = parse;
    platform.toString = toStringPlatform;

    if (platform.version) {
      description.unshift(version);
    }
    if (platform.name) {
      description.unshift(name);
    }
    if (os && name && !(os == String(os).split(' ')[0] && (os == name.split(' ')[0] || product))) {
      description.push(product ? '(' + os + ')' : 'on ' + os);
    }
    if (description.length) {
      platform.description = description.join(' ');
    }
    return platform;
  }

  /*--------------------------------------------------------------------------*/

  // Export platform.
  var platform = parse();

  // Some AMD build optimizers, like r.js, check for condition patterns like the following:
  if (true) {
    // Expose platform on the global object to prevent errors when platform is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    root.platform = platform;

    // Define as an anonymous module so platform can be aliased through path mapping.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return platform;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else {}
}.call(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/preact/compat/dist/compat.module.js":
/*!**********************************************************!*\
  !*** ./node_modules/preact/compat/dist/compat.module.js ***!
  \**********************************************************/
/*! exports provided: useState, useReducer, useEffect, useLayoutEffect, useRef, useImperativeHandle, useMemo, useCallback, useContext, useDebugValue, useErrorBoundary, createElement, createContext, createRef, Fragment, Component, default, version, Children, render, hydrate, unmountComponentAtNode, createPortal, createFactory, cloneElement, isValidElement, findDOMNode, PureComponent, memo, forwardRef, unstable_batchedUpdates, StrictMode, Suspense, SuspenseList, lazy, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, unstable_ImmediatePriority, unstable_UserBlockingPriority, unstable_NormalPriority, unstable_LowPriority, unstable_IdlePriority, unstable_runWithPriority, unstable_now */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return un; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Children", function() { return k; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return z; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hydrate", function() { return B; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unmountComponentAtNode", function() { return an; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPortal", function() { return j; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createFactory", function() { return fn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneElement", function() { return ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidElement", function() { return cn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findDOMNode", function() { return sn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PureComponent", function() { return E; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "memo", function() { return g; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forwardRef", function() { return x; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_batchedUpdates", function() { return hn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StrictMode", function() { return pn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Suspense", function() { return O; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SuspenseList", function() { return D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lazy", function() { return U; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED", function() { return K; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_ImmediatePriority", function() { return Q; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_UserBlockingPriority", function() { return X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_NormalPriority", function() { return nn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_LowPriority", function() { return tn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_IdlePriority", function() { return en; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_runWithPriority", function() { return rn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unstable_now", function() { return on; });
/* harmony import */ var preact_hooks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact/hooks */ "./node_modules/preact/hooks/dist/hooks.module.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useState", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useReducer", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useReducer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useEffect", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useEffect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useLayoutEffect", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useLayoutEffect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useRef", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useImperativeHandle", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useImperativeHandle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useMemo", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useMemo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useCallback", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useCallback"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useContext", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useDebugValue", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useDebugValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useErrorBoundary", function() { return preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useErrorBoundary"]; });

/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return preact__WEBPACK_IMPORTED_MODULE_1__["createElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createContext", function() { return preact__WEBPACK_IMPORTED_MODULE_1__["createContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createRef", function() { return preact__WEBPACK_IMPORTED_MODULE_1__["createRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return preact__WEBPACK_IMPORTED_MODULE_1__["Fragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return preact__WEBPACK_IMPORTED_MODULE_1__["Component"]; });

function C(n,t){for(var e in t)n[e]=t[e];return n}function S(n,t){for(var e in n)if("__source"!==e&&!(e in t))return!0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return!0;return!1}function E(n){this.props=n}function g(n,t){function e(n){var e=this.props.ref,r=e==n.ref;return!r&&e&&(e.call?e(null):e.current=null),t?!t(this.props,n)||!r:S(this.props,n)}function r(t){return this.shouldComponentUpdate=e,Object(preact__WEBPACK_IMPORTED_MODULE_1__["createElement"])(n,t)}return r.displayName="Memo("+(n.displayName||n.name)+")",r.prototype.isReactComponent=!0,r.__f=!0,r}(E.prototype=new preact__WEBPACK_IMPORTED_MODULE_1__["Component"]).isPureReactComponent=!0,E.prototype.shouldComponentUpdate=function(n,t){return S(this.props,n)||S(this.state,t)};var w=preact__WEBPACK_IMPORTED_MODULE_1__["options"].__b;preact__WEBPACK_IMPORTED_MODULE_1__["options"].__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),w&&w(n)};var R="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.forward_ref")||3911;function x(n){function t(t,e){var r=C({},t);return delete r.ref,n(r,(e=t.ref||e)&&("object"!=typeof e||"current"in e)?e:null)}return t.$$typeof=R,t.render=t,t.prototype.isReactComponent=t.__f=!0,t.displayName="ForwardRef("+(n.displayName||n.name)+")",t}var N=function(n,t){return null==n?null:Object(preact__WEBPACK_IMPORTED_MODULE_1__["toChildArray"])(Object(preact__WEBPACK_IMPORTED_MODULE_1__["toChildArray"])(n).map(t))},k={map:N,forEach:N,count:function(n){return n?Object(preact__WEBPACK_IMPORTED_MODULE_1__["toChildArray"])(n).length:0},only:function(n){var t=Object(preact__WEBPACK_IMPORTED_MODULE_1__["toChildArray"])(n);if(1!==t.length)throw"Children.only";return t[0]},toArray:preact__WEBPACK_IMPORTED_MODULE_1__["toChildArray"]},A=preact__WEBPACK_IMPORTED_MODULE_1__["options"].__e;function O(){this.__u=0,this.t=null,this.__b=null}function L(n){var t=n.__.__c;return t&&t.__e&&t.__e(n)}function U(n){var t,e,r;function o(o){if(t||(t=n()).then(function(n){e=n.default||n},function(n){r=n}),r)throw r;if(!e)throw t;return Object(preact__WEBPACK_IMPORTED_MODULE_1__["createElement"])(e,o)}return o.displayName="Lazy",o.__f=!0,o}function D(){this.o=null,this.u=null}preact__WEBPACK_IMPORTED_MODULE_1__["options"].__e=function(n,t,e){if(n.then)for(var r,o=t;o=o.__;)if((r=o.__c)&&r.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),r.__c(n,t);A(n,t,e)},(O.prototype=new preact__WEBPACK_IMPORTED_MODULE_1__["Component"]).__c=function(n,t){var e=t.__c,r=this;null==r.t&&(r.t=[]),r.t.push(e);var o=L(r.__v),u=!1,i=function(){u||(u=!0,e.componentWillUnmount=e.__c,o?o(f):f())};e.__c=e.componentWillUnmount,e.componentWillUnmount=function(){i(),e.__c&&e.__c()};var f=function(){if(!--r.__u){if(r.state.__e){var n=r.state.__e;r.__v.__k[0]=function n(t,e,r){return t&&(t.__v=null,t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)}),t.__c&&t.__c.__P===e&&(t.__e&&r.insertBefore(t.__e,t.__d),t.__c.__e=!0,t.__c.__P=r)),t}(n,n.__c.__P,n.__c.__O)}var t;for(r.setState({__e:r.__b=null});t=r.t.pop();)t.forceUpdate()}},c=!0===t.__h;r.__u++||c||r.setState({__e:r.__b=r.__v.__k[0]}),n.then(i,i)},O.prototype.componentWillUnmount=function(){this.t=[]},O.prototype.render=function(n,t){if(this.__b){if(this.__v.__k){var e=document.createElement("div"),r=this.__v.__k[0].__c;this.__v.__k[0]=function n(t,e,r){return t&&(t.__c&&t.__c.__H&&(t.__c.__H.__.forEach(function(n){"function"==typeof n.__c&&n.__c()}),t.__c.__H=null),null!=(t=C({},t)).__c&&(t.__c.__P===r&&(t.__c.__P=e),t.__c=null),t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)})),t}(this.__b,e,r.__O=r.__P)}this.__b=null}var o=t.__e&&Object(preact__WEBPACK_IMPORTED_MODULE_1__["createElement"])(preact__WEBPACK_IMPORTED_MODULE_1__["Fragment"],null,n.fallback);return o&&(o.__h=null),[Object(preact__WEBPACK_IMPORTED_MODULE_1__["createElement"])(preact__WEBPACK_IMPORTED_MODULE_1__["Fragment"],null,t.__e?null:n.children),o]};var F=function(n,t,e){if(++e[1]===e[0]&&n.u.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.u.size))for(e=n.o;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.o=e=e[2]}};function M(n){return this.getChildContext=function(){return n.context},n.children}function T(n){var t=this,e=n.i;t.componentWillUnmount=function(){Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(null,t.l),t.l=null,t.i=null},t.i&&t.i!==e&&t.componentWillUnmount(),n.__v?(t.l||(t.i=e,t.l={nodeType:1,parentNode:e,childNodes:[],appendChild:function(n){this.childNodes.push(n),t.i.appendChild(n)},insertBefore:function(n,e){this.childNodes.push(n),t.i.appendChild(n)},removeChild:function(n){this.childNodes.splice(this.childNodes.indexOf(n)>>>1,1),t.i.removeChild(n)}}),Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(Object(preact__WEBPACK_IMPORTED_MODULE_1__["createElement"])(M,{context:t.context},n.__v),t.l)):t.l&&t.componentWillUnmount()}function j(n,t){return Object(preact__WEBPACK_IMPORTED_MODULE_1__["createElement"])(T,{__v:n,i:t})}(D.prototype=new preact__WEBPACK_IMPORTED_MODULE_1__["Component"]).__e=function(n){var t=this,e=L(t.__v),r=t.u.get(n);return r[0]++,function(o){var u=function(){t.props.revealOrder?(r.push(o),F(t,n,r)):o()};e?e(u):u()}},D.prototype.render=function(n){this.o=null,this.u=new Map;var t=Object(preact__WEBPACK_IMPORTED_MODULE_1__["toChildArray"])(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.u.set(t[e],this.o=[1,0,this.o]);return n.children},D.prototype.componentDidUpdate=D.prototype.componentDidMount=function(){var n=this;this.u.forEach(function(t,e){F(n,e,t)})};var I="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,W=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,P=function(n){return("undefined"!=typeof Symbol&&"symbol"==typeof Symbol()?/fil|che|rad/i:/fil|che|ra/i).test(n)};function z(n,t,e){return null==t.__k&&(t.textContent=""),Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(n,t),"function"==typeof e&&e(),n?n.__c:null}function B(n,t,e){return Object(preact__WEBPACK_IMPORTED_MODULE_1__["hydrate"])(n,t),"function"==typeof e&&e(),n?n.__c:null}preact__WEBPACK_IMPORTED_MODULE_1__["Component"].prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(n){Object.defineProperty(preact__WEBPACK_IMPORTED_MODULE_1__["Component"].prototype,n,{configurable:!0,get:function(){return this["UNSAFE_"+n]},set:function(t){Object.defineProperty(this,n,{configurable:!0,writable:!0,value:t})}})});var V=preact__WEBPACK_IMPORTED_MODULE_1__["options"].event;function H(){}function Z(){return this.cancelBubble}function Y(){return this.defaultPrevented}preact__WEBPACK_IMPORTED_MODULE_1__["options"].event=function(n){return V&&(n=V(n)),n.persist=H,n.isPropagationStopped=Z,n.isDefaultPrevented=Y,n.nativeEvent=n};var $,q={configurable:!0,get:function(){return this.class}},G=preact__WEBPACK_IMPORTED_MODULE_1__["options"].vnode;preact__WEBPACK_IMPORTED_MODULE_1__["options"].vnode=function(n){var t=n.type,e=n.props,r=e;if("string"==typeof t){for(var o in r={},e){var u=e[o];"defaultValue"===o&&"value"in e&&null==e.value?o="value":"download"===o&&!0===u?u="":/ondoubleclick/i.test(o)?o="ondblclick":/^onchange(textarea|input)/i.test(o+t)&&!P(e.type)?o="oninput":/^on(Ani|Tra|Tou|BeforeInp)/.test(o)?o=o.toLowerCase():W.test(o)?o=o.replace(/[A-Z0-9]/,"-$&").toLowerCase():null===u&&(u=void 0),r[o]=u}"select"==t&&r.multiple&&Array.isArray(r.value)&&(r.value=Object(preact__WEBPACK_IMPORTED_MODULE_1__["toChildArray"])(e.children).forEach(function(n){n.props.selected=-1!=r.value.indexOf(n.props.value)})),"select"==t&&null!=r.defaultValue&&(r.value=Object(preact__WEBPACK_IMPORTED_MODULE_1__["toChildArray"])(e.children).forEach(function(n){n.props.selected=r.multiple?-1!=r.defaultValue.indexOf(n.props.value):r.defaultValue==n.props.value})),n.props=r}t&&e.class!=e.className&&(q.enumerable="className"in e,null!=e.className&&(r.class=e.className),Object.defineProperty(r,"className",q)),n.$$typeof=I,G&&G(n)};var J=preact__WEBPACK_IMPORTED_MODULE_1__["options"].__r;preact__WEBPACK_IMPORTED_MODULE_1__["options"].__r=function(n){J&&J(n),$=n.__c};var K={ReactCurrentDispatcher:{current:{readContext:function(n){return $.__n[n.__c].props.value}}}},Q=1,X=2,nn=3,tn=4,en=5;function rn(n,t){return t()}var on="object"==typeof performance&&"function"==typeof performance.now?performance.now.bind(performance):function(){return Date.now()},un="16.8.0";function fn(n){return preact__WEBPACK_IMPORTED_MODULE_1__["createElement"].bind(null,n)}function cn(n){return!!n&&n.$$typeof===I}function ln(n){return cn(n)?preact__WEBPACK_IMPORTED_MODULE_1__["cloneElement"].apply(null,arguments):n}function an(n){return!!n.__k&&(Object(preact__WEBPACK_IMPORTED_MODULE_1__["render"])(null,n),!0)}function sn(n){return n&&(n.base||1===n.nodeType&&n)||null}var hn=function(n,t){return n(t)},pn=preact__WEBPACK_IMPORTED_MODULE_1__["Fragment"];/* harmony default export */ __webpack_exports__["default"] = ({useState:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useState"],useReducer:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useReducer"],useEffect:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useEffect"],useLayoutEffect:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useLayoutEffect"],useRef:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useRef"],useImperativeHandle:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useImperativeHandle"],useMemo:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useMemo"],useCallback:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useCallback"],useContext:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useContext"],useDebugValue:preact_hooks__WEBPACK_IMPORTED_MODULE_0__["useDebugValue"],version:"16.8.0",Children:k,render:z,hydrate:B,unmountComponentAtNode:an,createPortal:j,createElement:preact__WEBPACK_IMPORTED_MODULE_1__["createElement"],createContext:preact__WEBPACK_IMPORTED_MODULE_1__["createContext"],createFactory:fn,cloneElement:ln,createRef:preact__WEBPACK_IMPORTED_MODULE_1__["createRef"],Fragment:preact__WEBPACK_IMPORTED_MODULE_1__["Fragment"],isValidElement:cn,findDOMNode:sn,Component:preact__WEBPACK_IMPORTED_MODULE_1__["Component"],PureComponent:E,memo:g,forwardRef:x,unstable_batchedUpdates:hn,StrictMode:preact__WEBPACK_IMPORTED_MODULE_1__["Fragment"],Suspense:O,SuspenseList:D,lazy:U,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:K});
//# sourceMappingURL=compat.module.js.map


/***/ }),

/***/ "./node_modules/preact/dist/preact.module.js":
/*!***************************************************!*\
  !*** ./node_modules/preact/dist/preact.module.js ***!
  \***************************************************/
/*! exports provided: render, hydrate, createElement, h, Fragment, createRef, isValidElement, Component, cloneElement, createContext, toChildArray, options */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "render", function() { return N; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hydrate", function() { return O; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return a; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return a; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createRef", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidElement", function() { return l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneElement", function() { return S; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createContext", function() { return q; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toChildArray", function() { return w; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "options", function() { return n; });
var n,l,u,i,t,r,o={},f=[],e=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function c(n,l){for(var u in l)n[u]=l[u];return n}function s(n){var l=n.parentNode;l&&l.removeChild(n)}function a(n,l,u){var i,t,r,o=arguments,f={};for(r in l)"key"==r?i=l[r]:"ref"==r?t=l[r]:f[r]=l[r];if(arguments.length>3)for(u=[u],r=3;r<arguments.length;r++)u.push(o[r]);if(null!=u&&(f.children=u),"function"==typeof n&&null!=n.defaultProps)for(r in n.defaultProps)void 0===f[r]&&(f[r]=n.defaultProps[r]);return v(n,f,i,t,null)}function v(l,u,i,t,r){var o={type:l,props:u,key:i,ref:t,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==r?++n.__v:r};return null!=n.vnode&&n.vnode(o),o}function h(){return{current:null}}function y(n){return n.children}function p(n,l){this.props=n,this.context=l}function d(n,l){if(null==l)return n.__?d(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?d(n):null}function _(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return _(n)}}function k(l){(!l.__d&&(l.__d=!0)&&u.push(l)&&!m.__r++||t!==n.debounceRendering)&&((t=n.debounceRendering)||i)(m)}function m(){for(var n;m.__r=u.length;)n=u.sort(function(n,l){return n.__v.__b-l.__v.__b}),u=[],n.some(function(n){var l,u,i,t,r,o;n.__d&&(r=(t=(l=n).__v).__e,(o=l.__P)&&(u=[],(i=c({},t)).__v=t.__v+1,T(o,t,i,l.__n,void 0!==o.ownerSVGElement,null!=t.__h?[r]:null,u,null==r?d(t):r,t.__h),j(u,t),t.__e!=r&&_(t)))})}function b(n,l,u,i,t,r,e,c,s,a){var h,p,_,k,m,b,w,A=i&&i.__k||f,P=A.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(k=u.__k[h]=null==(k=l[h])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k?v(null,k,null,null,k):Array.isArray(k)?v(y,{children:k},null,null,null):k.__b>0?v(k.type,k.props,k.key,null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(_=A[h])||_&&k.key==_.key&&k.type===_.type)A[h]=void 0;else for(p=0;p<P;p++){if((_=A[p])&&k.key==_.key&&k.type===_.type){A[p]=void 0;break}_=null}T(n,k,_=_||o,t,r,e,c,s,a),m=k.__e,(p=k.ref)&&_.ref!=p&&(w||(w=[]),_.ref&&w.push(_.ref,null,k),w.push(p,k.__c||m,k)),null!=m?(null==b&&(b=m),"function"==typeof k.type&&null!=k.__k&&k.__k===_.__k?k.__d=s=g(k,s,n):s=x(n,k,_,A,m,s),a||"option"!==u.type?"function"==typeof u.type&&(u.__d=s):n.value=""):s&&_.__e==s&&s.parentNode!=n&&(s=d(_))}for(u.__e=b,h=P;h--;)null!=A[h]&&("function"==typeof u.type&&null!=A[h].__e&&A[h].__e==u.__d&&(u.__d=d(i,h+1)),L(A[h],A[h]));if(w)for(h=0;h<w.length;h++)I(w[h],w[++h],w[++h])}function g(n,l,u){var i,t;for(i=0;i<n.__k.length;i++)(t=n.__k[i])&&(t.__=n,l="function"==typeof t.type?g(t,l,u):x(u,t,t,n.__k,t.__e,l));return l}function w(n,l){return l=l||[],null==n||"boolean"==typeof n||(Array.isArray(n)?n.some(function(n){w(n,l)}):l.push(n)),l}function x(n,l,u,i,t,r){var o,f,e;if(void 0!==l.__d)o=l.__d,l.__d=void 0;else if(null==u||t!=r||null==t.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(t),o=null;else{for(f=r,e=0;(f=f.nextSibling)&&e<i.length;e+=2)if(f==t)break n;n.insertBefore(t,r),o=r}return void 0!==o?o:t.nextSibling}function A(n,l,u,i,t){var r;for(r in u)"children"===r||"key"===r||r in l||C(n,r,null,u[r],i);for(r in l)t&&"function"!=typeof l[r]||"children"===r||"key"===r||"value"===r||"checked"===r||u[r]===l[r]||C(n,r,l[r],u[r],i)}function P(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||e.test(l)?u:u+"px"}function C(n,l,u,i,t){var r;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else{if("string"==typeof i&&(n.style.cssText=i=""),i)for(l in i)u&&l in u||P(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||P(n.style,l,u[l])}else if("o"===l[0]&&"n"===l[1])r=l!==(l=l.replace(/Capture$/,"")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+r]=u,u?i||n.addEventListener(l,r?H:$,r):n.removeEventListener(l,r?H:$,r);else if("dangerouslySetInnerHTML"!==l){if(t)l=l.replace(/xlink[H:h]/,"h").replace(/sName$/,"s");else if("href"!==l&&"list"!==l&&"form"!==l&&"download"!==l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null!=u&&(!1!==u||"a"===l[0]&&"r"===l[1])?n.setAttribute(l,u):n.removeAttribute(l))}}function $(l){this.l[l.type+!1](n.event?n.event(l):l)}function H(l){this.l[l.type+!0](n.event?n.event(l):l)}function T(l,u,i,t,r,o,f,e,s){var a,v,h,d,_,k,m,g,w,x,A,P=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(s=i.__h,e=u.__e=i.__e,u.__h=null,o=[e]),(a=n.__b)&&a(u);try{n:if("function"==typeof P){if(g=u.props,w=(a=P.contextType)&&t[a.__c],x=a?w?w.props.value:a.__:t,i.__c?m=(v=u.__c=i.__c).__=v.__E:("prototype"in P&&P.prototype.render?u.__c=v=new P(g,x):(u.__c=v=new p(g,x),v.constructor=P,v.render=M),w&&w.sub(v),v.props=g,v.state||(v.state={}),v.context=x,v.__n=t,h=v.__d=!0,v.__h=[]),null==v.__s&&(v.__s=v.state),null!=P.getDerivedStateFromProps&&(v.__s==v.state&&(v.__s=c({},v.__s)),c(v.__s,P.getDerivedStateFromProps(g,v.__s))),d=v.props,_=v.state,h)null==P.getDerivedStateFromProps&&null!=v.componentWillMount&&v.componentWillMount(),null!=v.componentDidMount&&v.__h.push(v.componentDidMount);else{if(null==P.getDerivedStateFromProps&&g!==d&&null!=v.componentWillReceiveProps&&v.componentWillReceiveProps(g,x),!v.__e&&null!=v.shouldComponentUpdate&&!1===v.shouldComponentUpdate(g,v.__s,x)||u.__v===i.__v){v.props=g,v.state=v.__s,u.__v!==i.__v&&(v.__d=!1),v.__v=u,u.__e=i.__e,u.__k=i.__k,v.__h.length&&f.push(v);break n}null!=v.componentWillUpdate&&v.componentWillUpdate(g,v.__s,x),null!=v.componentDidUpdate&&v.__h.push(function(){v.componentDidUpdate(d,_,k)})}v.context=x,v.props=g,v.state=v.__s,(a=n.__r)&&a(u),v.__d=!1,v.__v=u,v.__P=l,a=v.render(v.props,v.state,v.context),v.state=v.__s,null!=v.getChildContext&&(t=c(c({},t),v.getChildContext())),h||null==v.getSnapshotBeforeUpdate||(k=v.getSnapshotBeforeUpdate(d,_)),A=null!=a&&a.type===y&&null==a.key?a.props.children:a,b(l,Array.isArray(A)?A:[A],u,i,t,r,o,f,e,s),v.base=u.__e,u.__h=null,v.__h.length&&f.push(v),m&&(v.__E=v.__=null),v.__e=!1}else null==o&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=z(i.__e,u,i,t,r,o,f,s);(a=n.diffed)&&a(u)}catch(l){u.__v=null,(s||null!=o)&&(u.__e=e,u.__h=!!s,o[o.indexOf(e)]=null),n.__e(l,u,i)}}function j(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function z(n,l,u,i,t,r,e,c){var a,v,h,y,p,d=u.props,_=l.props,k=l.type;if("svg"===k&&(t=!0),null!=r)for(a=0;a<r.length;a++)if(null!=(v=r[a])&&(n==v||v.localName==k)){n=v,r[a]=null;break}if(null==n){if(null===k)return document.createTextNode(_);n=t?document.createElementNS("http://www.w3.org/2000/svg",k):document.createElement(k,_.is&&_),r=null,c=!1}if(null===k)d===_||c&&n.data===_||(n.data=_);else{if(null!=r&&(r=f.slice.call(n.childNodes)),h=(d=u.props||o).dangerouslySetInnerHTML,y=_.dangerouslySetInnerHTML,!c){if(null!=r)for(d={},p=0;p<n.attributes.length;p++)d[n.attributes[p].name]=n.attributes[p].value;(y||h)&&(y&&(h&&y.__html==h.__html||y.__html===n.innerHTML)||(n.innerHTML=y&&y.__html||""))}if(A(n,_,d,t,c),y)l.__k=[];else if(a=l.props.children,b(n,Array.isArray(a)?a:[a],l,u,i,t&&"foreignObject"!==k,r,e,n.firstChild,c),null!=r)for(a=r.length;a--;)null!=r[a]&&s(r[a]);c||("value"in _&&void 0!==(a=_.value)&&(a!==n.value||"progress"===k&&!a)&&C(n,"value",a,d.value,!1),"checked"in _&&void 0!==(a=_.checked)&&a!==n.checked&&C(n,"checked",a,d.checked,!1))}return n}function I(l,u,i){try{"function"==typeof l?l(u):l.current=u}catch(l){n.__e(l,i)}}function L(l,u,i){var t,r,o;if(n.unmount&&n.unmount(l),(t=l.ref)&&(t.current&&t.current!==l.__e||I(t,null,u)),i||"function"==typeof l.type||(i=null!=(r=l.__e)),l.__e=l.__d=void 0,null!=(t=l.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(l){n.__e(l,u)}t.base=t.__P=null}if(t=l.__k)for(o=0;o<t.length;o++)t[o]&&L(t[o],u,i);null!=r&&s(r)}function M(n,l,u){return this.constructor(n,u)}function N(l,u,i){var t,r,e;n.__&&n.__(l,u),r=(t="function"==typeof i)?null:i&&i.__k||u.__k,e=[],T(u,l=(!t&&i||u).__k=a(y,null,[l]),r||o,o,void 0!==u.ownerSVGElement,!t&&i?[i]:r?null:u.firstChild?f.slice.call(u.childNodes):null,e,!t&&i?i:r?r.__e:u.firstChild,t),j(e,l)}function O(n,l){N(n,l,O)}function S(n,l,u){var i,t,r,o=arguments,f=c({},n.props);for(r in l)"key"==r?i=l[r]:"ref"==r?t=l[r]:f[r]=l[r];if(arguments.length>3)for(u=[u],r=3;r<arguments.length;r++)u.push(o[r]);return null!=u&&(f.children=u),v(n.type,f,i||n.key,t||n.ref,null)}function q(n,l){var u={__c:l="__cC"+r++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(k)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n={__e:function(n,l){for(var u,i,t;l=l.__;)if((u=l.__c)&&!u.__)try{if((i=u.constructor)&&null!=i.getDerivedStateFromError&&(u.setState(i.getDerivedStateFromError(n)),t=u.__d),null!=u.componentDidCatch&&(u.componentDidCatch(n),t=u.__d),t)return u.__E=u}catch(l){n=l}throw n},__v:0},l=function(n){return null!=n&&void 0===n.constructor},p.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=c({},this.state),"function"==typeof n&&(n=n(c({},u),this.props)),n&&c(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),k(this))},p.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),k(this))},p.prototype.render=y,u=[],i="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,m.__r=0,r=0;
//# sourceMappingURL=preact.module.js.map


/***/ }),

/***/ "./node_modules/preact/hooks/dist/hooks.module.js":
/*!********************************************************!*\
  !*** ./node_modules/preact/hooks/dist/hooks.module.js ***!
  \********************************************************/
/*! exports provided: useState, useReducer, useEffect, useLayoutEffect, useRef, useImperativeHandle, useMemo, useCallback, useContext, useDebugValue, useErrorBoundary */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useState", function() { return l; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useReducer", function() { return p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useEffect", function() { return y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useLayoutEffect", function() { return h; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useRef", function() { return s; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useImperativeHandle", function() { return _; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useMemo", function() { return d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useCallback", function() { return A; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useContext", function() { return F; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useDebugValue", function() { return T; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useErrorBoundary", function() { return q; });
/* harmony import */ var preact__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact */ "./node_modules/preact/dist/preact.module.js");
var t,u,r,o=0,i=[],c=preact__WEBPACK_IMPORTED_MODULE_0__["options"].__b,f=preact__WEBPACK_IMPORTED_MODULE_0__["options"].__r,e=preact__WEBPACK_IMPORTED_MODULE_0__["options"].diffed,a=preact__WEBPACK_IMPORTED_MODULE_0__["options"].__c,v=preact__WEBPACK_IMPORTED_MODULE_0__["options"].unmount;function m(t,r){preact__WEBPACK_IMPORTED_MODULE_0__["options"].__h&&preact__WEBPACK_IMPORTED_MODULE_0__["options"].__h(u,t,o||r),o=0;var i=u.__H||(u.__H={__:[],__h:[]});return t>=i.__.length&&i.__.push({}),i.__[t]}function l(n){return o=1,p(w,n)}function p(n,r,o){var i=m(t++,2);return i.t=n,i.__c||(i.__=[o?o(r):w(void 0,r),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}))}],i.__c=u),i.__}function y(r,o){var i=m(t++,3);!preact__WEBPACK_IMPORTED_MODULE_0__["options"].__s&&k(i.__H,o)&&(i.__=r,i.__H=o,u.__H.__h.push(i))}function h(r,o){var i=m(t++,4);!preact__WEBPACK_IMPORTED_MODULE_0__["options"].__s&&k(i.__H,o)&&(i.__=r,i.__H=o,u.__h.push(i))}function s(n){return o=5,d(function(){return{current:n}},[])}function _(n,t,u){o=6,h(function(){"function"==typeof n?n(t()):n&&(n.current=t())},null==u?u:u.concat(n))}function d(n,u){var r=m(t++,7);return k(r.__H,u)&&(r.__=n(),r.__H=u,r.__h=n),r.__}function A(n,t){return o=8,d(function(){return n},t)}function F(n){var r=u.context[n.__c],o=m(t++,9);return o.__c=n,r?(null==o.__&&(o.__=!0,r.sub(u)),r.props.value):n.__}function T(t,u){preact__WEBPACK_IMPORTED_MODULE_0__["options"].useDebugValue&&preact__WEBPACK_IMPORTED_MODULE_0__["options"].useDebugValue(u?u(t):t)}function q(n){var r=m(t++,10),o=l();return r.__=n,u.componentDidCatch||(u.componentDidCatch=function(n){r.__&&r.__(n),o[1](n)}),[o[0],function(){o[1](void 0)}]}function x(){i.forEach(function(t){if(t.__P)try{t.__H.__h.forEach(g),t.__H.__h.forEach(j),t.__H.__h=[]}catch(u){t.__H.__h=[],preact__WEBPACK_IMPORTED_MODULE_0__["options"].__e(u,t.__v)}}),i=[]}preact__WEBPACK_IMPORTED_MODULE_0__["options"].__b=function(n){u=null,c&&c(n)},preact__WEBPACK_IMPORTED_MODULE_0__["options"].__r=function(n){f&&f(n),t=0;var r=(u=n.__c).__H;r&&(r.__h.forEach(g),r.__h.forEach(j),r.__h=[])},preact__WEBPACK_IMPORTED_MODULE_0__["options"].diffed=function(t){e&&e(t);var o=t.__c;o&&o.__H&&o.__H.__h.length&&(1!==i.push(o)&&r===preact__WEBPACK_IMPORTED_MODULE_0__["options"].requestAnimationFrame||((r=preact__WEBPACK_IMPORTED_MODULE_0__["options"].requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),b&&cancelAnimationFrame(t),setTimeout(n)},r=setTimeout(u,100);b&&(t=requestAnimationFrame(u))})(x)),u=void 0},preact__WEBPACK_IMPORTED_MODULE_0__["options"].__c=function(t,u){u.some(function(t){try{t.__h.forEach(g),t.__h=t.__h.filter(function(n){return!n.__||j(n)})}catch(r){u.some(function(n){n.__h&&(n.__h=[])}),u=[],preact__WEBPACK_IMPORTED_MODULE_0__["options"].__e(r,t.__v)}}),a&&a(t,u)},preact__WEBPACK_IMPORTED_MODULE_0__["options"].unmount=function(t){v&&v(t);var u=t.__c;if(u&&u.__H)try{u.__H.__.forEach(g)}catch(t){preact__WEBPACK_IMPORTED_MODULE_0__["options"].__e(t,u.__v)}};var b="function"==typeof requestAnimationFrame;function g(n){var t=u;"function"==typeof n.__c&&n.__c(),u=t}function j(n){var t=u;n.__c=n.__(),u=t}function k(n,t){return!n||n.length!==t.length||t.some(function(t,u){return t!==n[u]})}function w(n,t){return"function"==typeof t?t(n):t}
//# sourceMappingURL=hooks.module.js.map


/***/ }),

/***/ "./node_modules/react-dom/index.module.js":
/*!************************************************!*\
  !*** ./node_modules/react-dom/index.module.js ***!
  \************************************************/
/*! exports provided: useState, useReducer, useEffect, useLayoutEffect, useRef, useImperativeHandle, useMemo, useCallback, useContext, useDebugValue, useErrorBoundary, createElement, createContext, createRef, Fragment, Component, version, Children, render, hydrate, unmountComponentAtNode, createPortal, createFactory, cloneElement, isValidElement, findDOMNode, PureComponent, memo, forwardRef, unstable_batchedUpdates, StrictMode, Suspense, SuspenseList, lazy, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, unstable_ImmediatePriority, unstable_UserBlockingPriority, unstable_NormalPriority, unstable_LowPriority, unstable_IdlePriority, unstable_runWithPriority, unstable_now, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var preact_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact/compat */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useState", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useReducer", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useReducer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useEffect", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useEffect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useLayoutEffect", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useLayoutEffect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useRef", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useImperativeHandle", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useImperativeHandle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useMemo", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useMemo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useCallback", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useCallback"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useContext", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useDebugValue", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useDebugValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useErrorBoundary", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useErrorBoundary"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["createElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createContext", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["createContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createRef", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["createRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["Fragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["Component"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["version"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Children", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["Children"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hydrate", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["hydrate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unmountComponentAtNode", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unmountComponentAtNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPortal", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["createPortal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createFactory", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["createFactory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cloneElement", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["cloneElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isValidElement", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["isValidElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findDOMNode", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["findDOMNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PureComponent", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["PureComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "memo", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["memo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forwardRef", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["forwardRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_batchedUpdates", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unstable_batchedUpdates"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StrictMode", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["StrictMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Suspense", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["Suspense"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SuspenseList", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["SuspenseList"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lazy", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["lazy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_ImmediatePriority", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unstable_ImmediatePriority"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_UserBlockingPriority", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unstable_UserBlockingPriority"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_NormalPriority", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unstable_NormalPriority"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_LowPriority", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unstable_LowPriority"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_IdlePriority", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unstable_IdlePriority"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_runWithPriority", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unstable_runWithPriority"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_now", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unstable_now"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["default"]; });





/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react/index.module.js":
/*!********************************************!*\
  !*** ./node_modules/react/index.module.js ***!
  \********************************************/
/*! exports provided: useState, useReducer, useEffect, useLayoutEffect, useRef, useImperativeHandle, useMemo, useCallback, useContext, useDebugValue, useErrorBoundary, createElement, createContext, createRef, Fragment, Component, version, Children, render, hydrate, unmountComponentAtNode, createPortal, createFactory, cloneElement, isValidElement, findDOMNode, PureComponent, memo, forwardRef, unstable_batchedUpdates, StrictMode, Suspense, SuspenseList, lazy, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, unstable_ImmediatePriority, unstable_UserBlockingPriority, unstable_NormalPriority, unstable_LowPriority, unstable_IdlePriority, unstable_runWithPriority, unstable_now, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var preact_compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! preact/compat */ "./node_modules/preact/compat/dist/compat.module.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useState", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useReducer", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useReducer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useEffect", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useEffect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useLayoutEffect", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useLayoutEffect"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useRef", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useImperativeHandle", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useImperativeHandle"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useMemo", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useMemo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useCallback", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useCallback"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useContext", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useDebugValue", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useDebugValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useErrorBoundary", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["useErrorBoundary"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["createElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createContext", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["createContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createRef", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["createRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["Fragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["Component"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["version"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Children", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["Children"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "render", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["render"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hydrate", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["hydrate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unmountComponentAtNode", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unmountComponentAtNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPortal", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["createPortal"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createFactory", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["createFactory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cloneElement", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["cloneElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isValidElement", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["isValidElement"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "findDOMNode", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["findDOMNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PureComponent", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["PureComponent"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "memo", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["memo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forwardRef", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["forwardRef"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_batchedUpdates", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unstable_batchedUpdates"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StrictMode", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["StrictMode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Suspense", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["Suspense"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SuspenseList", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["SuspenseList"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lazy", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["lazy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_ImmediatePriority", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unstable_ImmediatePriority"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_UserBlockingPriority", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unstable_UserBlockingPriority"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_NormalPriority", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unstable_NormalPriority"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_LowPriority", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unstable_LowPriority"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_IdlePriority", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unstable_IdlePriority"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_runWithPriority", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unstable_runWithPriority"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_now", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["unstable_now"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return preact_compat__WEBPACK_IMPORTED_MODULE_0__["default"]; });





/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js ***!
  \***********************************************************************/
/*! exports provided: parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
var UNKNOWN_FUNCTION = '<unknown>';
/**
 * This parses the different stack traces and puts them into one format
 * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)
 */

function parse(stackString) {
  var lines = stackString.split('\n');
  return lines.reduce(function (stack, line) {
    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);

    if (parseResult) {
      stack.push(parseResult);
    }

    return stack;
  }, []);
}
var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;

function parseChrome(line) {
  var parts = chromeRe.exec(line);

  if (!parts) {
    return null;
  }

  var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line

  var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

  var submatch = chromeEvalRe.exec(parts[2]);

  if (isEval && submatch != null) {
    // throw out eval line/column and use top-most line/column number
    parts[2] = submatch[1]; // url

    parts[3] = submatch[2]; // line

    parts[4] = submatch[3]; // column
  }

  return {
    file: !isNative ? parts[2] : null,
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: isNative ? [parts[2]] : [],
    lineNumber: parts[3] ? +parts[3] : null,
    column: parts[4] ? +parts[4] : null
  };
}

var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;

function parseWinjs(line) {
  var parts = winjsRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}

var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;

function parseGecko(line) {
  var parts = geckoRe.exec(line);

  if (!parts) {
    return null;
  }

  var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
  var submatch = geckoEvalRe.exec(parts[3]);

  if (isEval && submatch != null) {
    // throw out eval line/column and use top-most line number
    parts[3] = submatch[1];
    parts[4] = submatch[2];
    parts[5] = null; // no column when eval
  }

  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: parts[2] ? parts[2].split(',') : [],
    lineNumber: parts[4] ? +parts[4] : null,
    column: parts[5] ? +parts[5] : null
  };
}

var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;

function parseJSC(line) {
  var parts = javaScriptCoreRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[4],
    column: parts[5] ? +parts[5] : null
  };
}

var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;

function parseNode(line) {
  var parts = nodeRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}




/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/workbox-window/build/workbox-window.prod.es5.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/workbox-window/build/workbox-window.prod.es5.mjs ***!
  \***********************************************************************/
/*! exports provided: Workbox, messageSW */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Workbox", function() { return f; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "messageSW", function() { return n; });
try{self["workbox:window:5.1.4"]&&_()}catch(n){}function n(n,t){return new Promise((function(r){var e=new MessageChannel;e.port1.onmessage=function(n){r(n.data)},n.postMessage(t,[e.port2])}))}function t(n,t){for(var r=0;r<t.length;r++){var e=t[r];e.enumerable=e.enumerable||!1,e.configurable=!0,"value"in e&&(e.writable=!0),Object.defineProperty(n,e.key,e)}}function r(n,t){(null==t||t>n.length)&&(t=n.length);for(var r=0,e=new Array(t);r<t;r++)e[r]=n[r];return e}function e(n,t){var e;if("undefined"==typeof Symbol||null==n[Symbol.iterator]){if(Array.isArray(n)||(e=function(n,t){if(n){if("string"==typeof n)return r(n,t);var e=Object.prototype.toString.call(n).slice(8,-1);return"Object"===e&&n.constructor&&(e=n.constructor.name),"Map"===e||"Set"===e?Array.from(n):"Arguments"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)?r(n,t):void 0}}(n))||t&&n&&"number"==typeof n.length){e&&(n=e);var i=0;return function(){return i>=n.length?{done:!0}:{done:!1,value:n[i++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}return(e=n[Symbol.iterator]()).next.bind(e)}try{self["workbox:core:5.1.4"]&&_()}catch(n){}var i=function(){var n=this;this.promise=new Promise((function(t,r){n.resolve=t,n.reject=r}))};function o(n,t){var r=location.href;return new URL(n,r).href===new URL(t,r).href}var u=function(n,t){this.type=n,Object.assign(this,t)};function a(n,t,r){return r?t?t(n):n:(n&&n.then||(n=Promise.resolve(n)),t?n.then(t):n)}function c(){}var f=function(r){var e,c;function f(n,t){var e,c;return void 0===t&&(t={}),(e=r.call(this)||this).t={},e.i=0,e.o=new i,e.u=new i,e.s=new i,e.v=0,e.h=new Set,e.l=function(){var n=e.m,t=n.installing;e.i>0||!o(t.scriptURL,e.g)||performance.now()>e.v+6e4?(e.p=t,n.removeEventListener("updatefound",e.l)):(e.P=t,e.h.add(t),e.o.resolve(t)),++e.i,t.addEventListener("statechange",e.S)},e.S=function(n){var t=e.m,r=n.target,i=r.state,o=r===e.p,a=o?"external":"",c={sw:r,originalEvent:n};!o&&e.j&&(c.isUpdate=!0),e.dispatchEvent(new u(a+i,c)),"installed"===i?e.A=self.setTimeout((function(){"installed"===i&&t.waiting===r&&e.dispatchEvent(new u(a+"waiting",c))}),200):"activating"===i&&(clearTimeout(e.A),o||e.u.resolve(r))},e.O=function(n){var t=e.P;t===navigator.serviceWorker.controller&&(e.dispatchEvent(new u("controlling",{sw:t,originalEvent:n,isUpdate:e.j})),e.s.resolve(t))},e.U=(c=function(n){var t=n.data,r=n.source;return a(e.getSW(),(function(){e.h.has(r)&&e.dispatchEvent(new u("message",{data:t,sw:r,originalEvent:n}))}))},function(){for(var n=[],t=0;t<arguments.length;t++)n[t]=arguments[t];try{return Promise.resolve(c.apply(this,n))}catch(n){return Promise.reject(n)}}),e.g=n,e.t=t,navigator.serviceWorker.addEventListener("message",e.U),e}c=r,(e=f).prototype=Object.create(c.prototype),e.prototype.constructor=e,e.__proto__=c;var v,h,l,m=f.prototype;return m.register=function(n){var t=(void 0===n?{}:n).immediate,r=void 0!==t&&t;try{var e=this;return function(n,t){var r=n();if(r&&r.then)return r.then(t);return t(r)}((function(){if(!r&&"complete"!==document.readyState)return s(new Promise((function(n){return window.addEventListener("load",n)})))}),(function(){return e.j=Boolean(navigator.serviceWorker.controller),e.I=e.M(),a(e.R(),(function(n){e.m=n,e.I&&(e.P=e.I,e.u.resolve(e.I),e.s.resolve(e.I),e.I.addEventListener("statechange",e.S,{once:!0}));var t=e.m.waiting;return t&&o(t.scriptURL,e.g)&&(e.P=t,Promise.resolve().then((function(){e.dispatchEvent(new u("waiting",{sw:t,wasWaitingBeforeRegister:!0}))})).then((function(){}))),e.P&&(e.o.resolve(e.P),e.h.add(e.P)),e.m.addEventListener("updatefound",e.l),navigator.serviceWorker.addEventListener("controllerchange",e.O,{once:!0}),e.m}))}))}catch(n){return Promise.reject(n)}},m.update=function(){try{return this.m?s(this.m.update()):void 0}catch(n){return Promise.reject(n)}},m.getSW=function(){try{return void 0!==this.P?this.P:this.o.promise}catch(n){return Promise.reject(n)}},m.messageSW=function(t){try{return a(this.getSW(),(function(r){return n(r,t)}))}catch(n){return Promise.reject(n)}},m.M=function(){var n=navigator.serviceWorker.controller;return n&&o(n.scriptURL,this.g)?n:void 0},m.R=function(){try{var n=this;return function(n,t){try{var r=n()}catch(n){return t(n)}if(r&&r.then)return r.then(void 0,t);return r}((function(){return a(navigator.serviceWorker.register(n.g,n.t),(function(t){return n.v=performance.now(),t}))}),(function(n){throw n}))}catch(n){return Promise.reject(n)}},v=f,(h=[{key:"active",get:function(){return this.u.promise}},{key:"controlling",get:function(){return this.s.promise}}])&&t(v.prototype,h),l&&t(v,l),f}(function(){function n(){this.k=new Map}var t=n.prototype;return t.addEventListener=function(n,t){this.B(n).add(t)},t.removeEventListener=function(n,t){this.B(n).delete(t)},t.dispatchEvent=function(n){n.target=this;for(var t,r=e(this.B(n.type));!(t=r()).done;){(0,t.value)(n)}},t.B=function(n){return this.k.has(n)||this.k.set(n,new Set),this.k.get(n)},n}());function s(n,t){if(!t)return n&&n.then?n.then(c):Promise.resolve()}
//# sourceMappingURL=workbox-window.prod.es5.mjs.map


/***/ }),

/***/ 0:
/*!*********************************************************************************************!*\
  !*** multi ./node_modules/next-pwa/register.js ./node_modules/next/dist/client/next-dev.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! C:\Users\Steve\git\Meishicorp\www\node_modules\next-pwa\register.js */"./node_modules/next-pwa/register.js");
module.exports = __webpack_require__(/*! ./node_modules/next/dist/client/next-dev.js */"./node_modules/next/dist/client/next-dev.js");


/***/ })

},[[0,"webpack"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlMaWtlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXJyYXlXaXRoSG9sZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jb25zdHJ1Y3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3RvQ29uc3VtYWJsZUFycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9wb2x5ZmlsbC1tb2R1bGUvZGlzdC9wb2x5ZmlsbC1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvY2xpZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL0Vycm9yQm91bmRhcnkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvUmVhY3REZXZPdmVybGF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2J1cy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL0NvZGVGcmFtZS9Db2RlRnJhbWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9Db2RlRnJhbWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9Db2RlRnJhbWUvc3R5bGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL0RpYWxvZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL0RpYWxvZy9EaWFsb2dCb2R5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL0RpYWxvZ0NvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9EaWFsb2cvRGlhbG9nSGVhZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL3N0eWxlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL0xlZnRSaWdodERpYWxvZ0hlYWRlci9MZWZ0UmlnaHREaWFsb2dIZWFkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9MZWZ0UmlnaHREaWFsb2dIZWFkZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9MZWZ0UmlnaHREaWFsb2dIZWFkZXIvc3R5bGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9PdmVybGF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9ib2R5LWxvY2tlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL092ZXJsYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9PdmVybGF5L21haW50YWluLS10YWItZm9jdXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9PdmVybGF5L3N0eWxlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL1NoYWRvd1BvcnRhbC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL1Rlcm1pbmFsL1Rlcm1pbmFsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvVGVybWluYWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9UZXJtaW5hbC9zdHlsZXMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9Ub2FzdC9Ub2FzdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL1RvYXN0L2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvVG9hc3Qvc3R5bGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbnRhaW5lci9CdWlsZEVycm9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbnRhaW5lci9FcnJvcnMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29udGFpbmVyL1J1bnRpbWVFcnJvci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9oZWxwZXJzL25vZGVTdGFja0ZyYW1lcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9oZWxwZXJzL25vb3AtdGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvaGVscGVycy9wYXJzZVN0YWNrLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2hlbHBlcnMvc3RhY2stZnJhbWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvaG9va3MvdXNlLW9uLWNsaWNrLW91dHNpZGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvc3R5bGVzL0Jhc2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvc3R5bGVzL0NvbXBvbmVudFN0eWxlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9zdHlsZXMvQ3NzUmVzZXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYW5zZXIvbGliL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvY3NzLmVzY2FwZS9jc3MuZXNjYXBlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC1wd2EvcmVnaXN0ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9jbGllbnQvZGV2L2Rldi1idWlsZC13YXRjaGVyLmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vY2xpZW50L2Rldi9lcnJvci1vdmVybGF5L2V2ZW50c291cmNlLmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vY2xpZW50L2Rldi9lcnJvci1vdmVybGF5L2Zvcm1hdC13ZWJwYWNrLW1lc3NhZ2VzLmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vY2xpZW50L2Rldi9lcnJvci1vdmVybGF5L2hvdC1kZXYtY2xpZW50LmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vY2xpZW50L2Rldi9ldmVudC1zb3VyY2UtcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9jbGllbnQvZGV2L2ZvdWMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9jbGllbnQvZGV2L29uLWRlbWFuZC1lbnRyaWVzLWNsaWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL2NsaWVudC9kZXYvb24tZGVtYW5kLWVudHJpZXMtdXRpbHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9jbGllbnQvZGV2L3dlYnBhY2staG90LW1pZGRsZXdhcmUtY2xpZW50LmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L2hlYWQtbWFuYWdlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9pbmRleC50c3giLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvbmV4dC1kZXYuanMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L3BhZ2UtbG9hZGVyLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L3BlcmZvcm1hbmNlLXJlbGF5ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvcmVxdWVzdC1pZGxlLWNhbGxiYWNrLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9yb3V0ZXIudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9jbGllbnQvd2l0aC1yb3V0ZXIudHN4Iiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3N0cmlwLWFuc2kvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvd2ViLXZpdGFscy93ZWItdml0YWxzLmVzNS51bWQubWluLmpzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL2hlYWQtbWFuYWdlci1jb250ZXh0LnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL21pdHQudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyLWNvbnRleHQudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybC50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvZ2V0LWFzc2V0LXBhdGgtZnJvbS1yb3V0ZS50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvaXMtZHluYW1pYy50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wYXRoLW1hdGNoLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wcmVwYXJlLWRlc3RpbmF0aW9uLnRzIiwid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZy50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcmVzb2x2ZS1yZXdyaXRlcy50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci50cyIsIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXgudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcnVudGltZS1jb25maWcudHMiLCJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvcm91dGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcGxhdGZvcm0vcGxhdGZvcm0uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L2Rpc3QvY29tcGF0Lm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3ByZWFjdC9kaXN0L3ByZWFjdC5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcmVhY3QvaG9va3MvZGlzdC9ob29rcy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXgubW9kdWxlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdGFja3RyYWNlLXBhcnNlci9kaXN0L3N0YWNrLXRyYWNlLXBhcnNlci5lc20uanMiLCJ3ZWJwYWNrOi8vX05fRS8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vX05fRS8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy93b3JrYm94LXdpbmRvdy9idWlsZC93b3JrYm94LXdpbmRvdy5wcm9kLmVzNS5tanMiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIm9ubHlGaXJzdCIsInBhdHRlcm4iLCJqb2luIiwiUmVnRXhwIiwidW5kZWZpbmVkIiwiYW5zaVJlZ2V4IiwicmVxdWlyZSIsInN0cmluZyIsInJlcGxhY2UiLCJzaGFkb3dIb3N0IiwiZG9jdW1lbnQiLCJwcmVmaXgiLCJzaGFkb3dSb290IiwibW9kZSIsImNvbnRhaW5lciIsImNyZWF0ZUNvbnRhaW5lciIsImNzcyIsImNyZWF0ZUNzcyIsImlzVmlzaWJsZSIsImlzQnVpbGRpbmciLCJ0aW1lb3V0SWQiLCJldnRTb3VyY2UiLCJwYXRoIiwiZXZlbnQiLCJoYW5kbGVNZXNzYWdlIiwib2JqIiwiYWN0aW9uIiwiSlNPTiIsImNsZWFyVGltZW91dCIsInVwZGF0ZUNvbnRhaW5lciIsInNldFRpbWVvdXQiLCJ0b2dnbGVDYWxsYmFjayIsImV2ZW50Q2FsbGJhY2tzIiwibGFzdEFjdGl2aXR5IiwibGlzdGVuZXJzIiwib3B0aW9ucyIsImluaXQiLCJ0aW1lciIsInNldEludGVydmFsIiwiaGFuZGxlRGlzY29ubmVjdCIsInNvdXJjZSIsIndpbmRvdyIsImNvbnNvbGUiLCJpIiwiY2IiLCJjbGVhckludGVydmFsIiwiY2xvc2UiLCJhZGRNZXNzYWdlTGlzdGVuZXIiLCJFdmVudFNvdXJjZVdyYXBwZXIiLCJmcmllbmRseVN5bnRheEVycm9yTGFiZWwiLCJtZXNzYWdlIiwibGluZXMiLCJsaW5lIiwicGFyc2luZ0Vycm9yIiwiZXJyb3JNZXNzYWdlIiwiZXJyb3JMaW5lIiwiaW5kZXgiLCJhcnIiLCJmb3JtYXR0ZWRFcnJvcnMiLCJqc29uIiwiZm9ybWF0TWVzc2FnZSIsImZvcm1hdHRlZFdhcm5pbmdzIiwicmVzdWx0IiwiZXJyb3JzIiwid2FybmluZ3MiLCJoYWRSdW50aW1lRXJyb3IiLCJEZXZPdmVybGF5IiwicHJvY2Vzc01lc3NhZ2UiLCJzdWJzY3JpYmVUb0htckV2ZW50IiwiY3VzdG9tSG1yRXZlbnRIYW5kbGVyIiwib25VbnJlY292ZXJhYmxlRXJyb3IiLCJpc0ZpcnN0Q29tcGlsYXRpb24iLCJtb3N0UmVjZW50Q29tcGlsYXRpb25IYXNoIiwiaGFzQ29tcGlsZUVycm9ycyIsImNsZWFyT3V0ZGF0ZWRFcnJvcnMiLCJpc0hvdFVwZGF0ZSIsInRyeUFwcGx5VXBkYXRlcyIsIm9uRmFzdFJlZnJlc2giLCJmb3JtYXR0ZWQiLCJwcmludFdhcm5pbmdzIiwicHJvY2VzcyIsInNlbGYiLCJlIiwiaGFuZGxlQXZhaWxhYmxlSGFzaCIsImhhc0Vycm9ycyIsIkJvb2xlYW4iLCJoYW5kbGVFcnJvcnMiLCJoYXNXYXJuaW5ncyIsImhhbmRsZVdhcm5pbmdzIiwiaGFuZGxlU3VjY2VzcyIsImNhbkFwcGx5VXBkYXRlcyIsImZuIiwic3RhdHVzIiwiaXNVcGRhdGVBdmFpbGFibGUiLCJlcnIiLCJoYXNVcGRhdGVzIiwidXBkYXRlZE1vZHVsZXMiLCJvbkhvdFVwZGF0ZVN1Y2Nlc3MiLCJhZnRlckFwcGx5VXBkYXRlcyIsImhhbmRsZUFwcGx5VXBkYXRlcyIsIlJlc3BvbnNlIiwiVGV4dERlY29kZXIiLCJUZXh0RW5jb2RlciIsIkFib3J0Q29udHJvbGxlciIsIlRleHREZWNvZGVyUG9seWZpbGwiLCJvY3RldHNDb3VudCIsImNvZGVQb2ludCIsImJpdHNOZWVkZWQiLCJSRVBMQUNFUiIsIm9jdGV0cyIsIm9jdGV0IiwidmFsaWQiLCJTdHJpbmciLCJzdXBwb3J0c1N0cmVhbU9wdGlvbiIsInN0cmVhbSIsImsiLCJ0aGF0IiwieGhyIiwic3RhdGUiLCJ0aW1lb3V0Iiwib25TdGFydCIsInN0YXR1c1RleHQiLCJjb250ZW50VHlwZSIsIm9uUHJvZ3Jlc3MiLCJyZXNwb25zZVRleHQiLCJvbkZpbmlzaCIsIm9uUmVhZHlTdGF0ZUNoYW5nZSIsIm9uVGltZW91dCIsIlhNTEh0dHBSZXF1ZXN0IiwidXJsIiwiWEhSV3JhcHBlciIsIm5hbWUiLCJjIiwibWFwIiwiT2JqZWN0IiwiYXJyYXkiLCJhbGwiLCJwYXJ0cyIsInZhbHVlIiwidG9Mb3dlckNhc2UiLCJIZWFkZXJzUG9seWZpbGwiLCJYSFJUcmFuc3BvcnQiLCJvZmZzZXQiLCJjaHVuayIsIm9uUHJvZ3Jlc3NDYWxsYmFjayIsImhlYWRlcnMiLCJvblN0YXJ0Q2FsbGJhY2siLCJvbkZpbmlzaENhbGxiYWNrIiwiSGVhZGVyc1dyYXBwZXIiLCJjb250cm9sbGVyIiwic2lnbmFsIiwidGV4dERlY29kZXIiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwid2l0aENyZWRlbnRpYWxzIiwiY2FjaGUiLCJyZWFkZXIiLCJyZXNwb25zZSIsInJlYWROZXh0Q2h1bmsiLCJyZXNvbHZlIiwicmVqZWN0IiwiUHJvbWlzZSIsIkV2ZW50VGFyZ2V0IiwidHlwZUxpc3RlbmVycyIsImxlbmd0aCIsImxpc3RlbmVyIiwidGhyb3dFcnJvciIsInR5cGUiLCJmb3VuZCIsImZpbHRlcmVkIiwiRXZlbnQiLCJNZXNzYWdlRXZlbnQiLCJDb25uZWN0aW9uRXZlbnQiLCJXQUlUSU5HIiwiQ09OTkVDVElORyIsIk9QRU4iLCJDTE9TRUQiLCJBRlRFUl9DUiIsIkZJRUxEX1NUQVJUIiwiRklFTEQiLCJWQUxVRV9TVEFSVCIsIlZBTFVFIiwiY29udGVudFR5cGVSZWdFeHAiLCJNSU5JTVVNX0RVUkFUSU9OIiwiTUFYSU1VTV9EVVJBVElPTiIsInBhcnNlRHVyYXRpb24iLCJuIiwicGFyc2VJbnQiLCJjbGFtcER1cmF0aW9uIiwiTWF0aCIsImZpcmUiLCJmIiwic3RhcnQiLCJpc0ZldGNoU3VwcG9ydGVkIiwiaW5pdGlhbFJldHJ5IiwiaGVhcnRiZWF0VGltZW91dCIsImxhc3RFdmVudElkIiwicmV0cnkiLCJ3YXNBY3Rpdml0eSIsIkN1cnJlbnRUcmFuc3BvcnQiLCJ0cmFuc3BvcnQiLCJjYW5jZWxGdW5jdGlvbiIsImN1cnJlbnRTdGF0ZSIsImRhdGFCdWZmZXIiLCJsYXN0RXZlbnRJZEJ1ZmZlciIsImV2ZW50VHlwZUJ1ZmZlciIsInRleHRCdWZmZXIiLCJmaWVsZFN0YXJ0IiwidmFsdWVTdGFydCIsImVzIiwidGV4dENodW5rIiwicG9zaXRpb24iLCJmaWVsZCIsImRhdGEiLCJyZXF1ZXN0VVJMIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVxdWVzdEhlYWRlcnMiLCJFdmVudFNvdXJjZVBvbHlmaWxsIiwieCIsImNhbGxiYWNrIiwiUm91dGVyIiwic2V0dXBQaW5nIiwiY3VycmVudFBhZ2UiLCJfZXZlbnQiLCJwYXRobmFtZSIsInBhdGhuYW1lRm4iLCJjbG9zZVBpbmciLCJhc3NldFByZWZpeCIsIm9uZGVtYW5kIiwicGF5bG9hZCIsImxvY2F0aW9uIiwicGFnZVJlcyIsImRldkNsaWVudCIsInBhZ2UiLCJET01BdHRyaWJ1dGVOYW1lcyIsImFjY2VwdENoYXJzZXQiLCJjbGFzc05hbWUiLCJodG1sRm9yIiwiaHR0cEVxdWl2Iiwibm9Nb2R1bGUiLCJlbCIsInByb3BzIiwicCIsImF0dHIiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIkFycmF5IiwiY2hpbGRyZW4iLCJoZWFkRWwiLCJoZWFkQ291bnRFbCIsImhlYWRDb3VudCIsIk51bWJlciIsIm9sZFRhZ3MiLCJqIiwibmV3VGFncyIsImNvbXBvbmVudHMiLCJuZXdUYWciLCJsZW4iLCJvbGRUYWciLCJ0IiwidXBkYXRlUHJvbWlzZSIsIm1vdW50ZWRJbnN0YW5jZXMiLCJ1cGRhdGVIZWFkIiwiaGVhZCIsInByb21pc2UiLCJ0YWdzIiwiaCIsInRpdGxlQ29tcG9uZW50IiwidGl0bGUiLCJ1cGRhdGVFbGVtZW50cyIsInZlcnNpb24iLCJfX05FWFRfVkVSU0lPTiIsImxvb3NlVG9BcnJheSIsImRvbWFpbkxvY2FsZXMiLCJkZWZhdWx0TG9jYWxlIiwiX193ZWJwYWNrX3B1YmxpY19wYXRoX18iLCJlbnZDb25maWciLCJzZXJ2ZXJSdW50aW1lQ29uZmlnIiwicHVibGljUnVudGltZUNvbmZpZyIsInJ1bnRpbWVDb25maWciLCJhc1BhdGgiLCJwYWdlTG9hZGVyIiwiUGFnZUxvYWRlciIsInJlZ2lzdGVyIiwiaGVhZE1hbmFnZXIiLCJhcHBFbGVtZW50IiwiY29tcG9uZW50RGlkTW91bnQiLCJyb3V0ZXIiLCJpc0ZhbGxiYWNrIiwiaHlkcmF0ZVByb3BzIiwicXVlcnlzdHJpbmciLCJfaCIsInNoYWxsb3ciLCJjb21wb25lbnREaWRVcGRhdGUiLCJzY3JvbGxUb0hhc2giLCJoYXNoIiwicmVuZGVyIiwiUmVhY3QiLCJDb21wb25lbnQiLCJlbWl0dGVyIiwib3B0cyIsIndlYnBhY2tITVIiLCJhcHBFbnRyeXBvaW50IiwiY29tcG9uZW50IiwiQ2FjaGVkQXBwIiwibW9kIiwib25QZXJmRW50cnkiLCJ1bmlxdWVJRCIsIkRhdGUiLCJlbnRyaWVzIiwicGVyZlN0YXJ0RW50cnkiLCJpZCIsInN0YXJ0VGltZSIsImxhYmVsIiwiZW50cnlUeXBlIiwiaW5pdGlhbEVyciIsImVycm9yIiwicGFnZUVudHJ5cG9pbnQiLCJDYWNoZWRDb21wb25lbnQiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJub2RlIiwiZ2V0Tm9kZUVycm9yIiwiaW5pdGlhbFByb3BzIiwiQXBwIiwid3JhcEFwcCIsInN1YnNjcmlwdGlvbiIsInNjcm9sbCIsImxvY2FsZSIsImxvY2FsZXMiLCJyZW5kZXJDdHgiLCJpbml0aWFsIiwicmVuZGVyaW5nUHJvcHMiLCJyZW5kZXJFcnJvciIsImRvUmVuZGVyIiwicmVuZGVyRXJyIiwic3R5bGVTaGVldHMiLCJBcHBUcmVlIiwiYXBwQ3R4IiwiY3R4IiwicXVlcnkiLCJyZW5kZXJFcnJvclByb3BzIiwiaW5pdFByb3BzIiwicmVhY3RSb290Iiwic2hvdWxkVXNlSHlkcmF0ZSIsIlJlYWN0RE9NIiwiU1QiLCJwZXJmb3JtYW5jZSIsImNsZWFyTWFya3MiLCJuYXZTdGFydEVudHJpZXMiLCJtZWFzdXJlIiwibWFyayIsIndyYXBwZWRBcHBQcm9wcyIsImFwcFByb3BzIiwiaW5wdXQiLCJsYXN0QXBwUHJvcHMiLCJjYW5jZWxlZCIsInJlbmRlclByb21pc2UiLCJsYXN0UmVuZGVyUmVqZWN0IiwicmVzb2x2ZVByb21pc2UiLCJjdXJyZW50U3R5bGVUYWdzIiwiY3VycmVudEhyZWZzIiwidGFnIiwibm9zY3JpcHQiLCJub25jZSIsInN0eWxlVGFnIiwiZWxlbSIsInJlbmRlclJlYWN0RWxlbWVudCIsIl9fUkVQTEFDRV9OT09QX0lNUE9SVF9fIiwiX19ORVhUX0RBVEFfXyIsImJ1aWxkSW5kaWNhdG9ySGFuZGxlciIsInJlcyIsIm1hbmlmZXN0IiwicGFnZXMiLCJjbGVhckluZGljYXRvciIsImRldlBhZ2VzTWFuaWZlc3RMaXN0ZW5lciIsImhhbmRsZXIiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsInJvdXRlIiwiY29uc3RydWN0b3IiLCJidWlsZElkIiwicHJvbWlzZWRTc2dNYW5pZmVzdCIsInByb21pc2VkRGV2UGFnZXNNYW5pZmVzdCIsInJvdXRlTG9hZGVyIiwiZ2V0UGFnZUxpc3QiLCJub3JtYWxpemVSb3V0ZSIsImdldEhyZWZGb3JTbHVnIiwiZGF0YVJvdXRlIiwic3NnIiwiaXNEeW5hbWljIiwiaW50ZXJwb2xhdGVkUm91dGUiLCJzIiwibG9hZFBhZ2UiLCJvIiwiaHJlZiIsInRleHQiLCJwcmVmZXRjaCIsImluaXRpYWxIcmVmIiwiaXNSZWdpc3RlcmVkIiwidXNlclJlcG9ydEhhbmRsZXIiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiZGlkVGltZW91dCIsInRpbWVSZW1haW5pbmciLCJNU19NQVhfSURMRV9ERUxBWSIsImVudHJ5IiwicHJvbSIsInJlc29sdmVyIiwiZnV0dXJlIiwiZ2VuZXJhdG9yIiwibGluayIsImNhblByZWZldGNoIiwiaGFzUHJlZmV0Y2giLCJBU1NFVF9MT0FEX0VSUk9SIiwiU3ltYm9sIiwic2NyaXB0IiwibWFya0Fzc2V0RXJyb3IiLCJvbkJ1aWxkTWFuaWZlc3QiLCJpZGxlVGltZW91dCIsInNjcmlwdHMiLCJlbmNvZGVVUkkiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwiYWxsRmlsZXMiLCJ2IiwiZW50cnlwb2ludHMiLCJsb2FkZWRTY3JpcHRzIiwicm91dGVzIiwiYXBwZW5kU2NyaXB0IiwiY29udGVudCIsIndoZW5FbnRyeXBvaW50Iiwid2l0aEZ1dHVyZSIsIm9uRW50cnlwb2ludCIsIm9sZCIsImxvYWRSb3V0ZSIsImdldEZpbGVzRm9yUm91dGUiLCJlbnRyeXBvaW50Iiwic3R5bGVzIiwiY24iLCJuYXZpZ2F0b3IiLCJvdXRwdXQiLCJwcmVmZXRjaFZpYURvbSIsImNyZWF0ZVJvdXRlTG9hZGVyIiwic2luZ2xldG9uUm91dGVyIiwicmVhZHlDYWxsYmFja3MiLCJyZWFkeSIsInVybFByb3BlcnR5RmllbGRzIiwicm91dGVyRXZlbnRzIiwiY29yZU1ldGhvZEZpZWxkcyIsImdldCIsImdldFJvdXRlciIsImV2ZW50RmllbGQiLCJfc2luZ2xldG9uUm91dGVyIiwiUm91dGVyQ29udGV4dCIsImNyZWF0ZVJvdXRlciIsIl9yb3V0ZXIiLCJpbnN0YW5jZSIsIkNvbXBvc2VkQ29tcG9uZW50IiwiZ2V0SW5pdGlhbFByb3BzIiwiV2l0aFJvdXRlcldyYXBwZXIiLCJyIiwiXyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJhYiIsIl9fZGlybmFtZSIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsInBhdGhuYW1lUGFydHMiLCJkZXRlY3RlZExvY2FsZSIsIm9uIiwib2ZmIiwiZW1pdCIsImJhc2VQYXRoIiwiY2FuY2VsbGVkIiwicGF0aE5vUXVlcnlIYXNoIiwicXVlcnlJbmRleCIsImhhc2hJbmRleCIsImFkZFBhdGhQcmVmaXgiLCJsb2NhdGlvbk9yaWdpbiIsInJlc29sdmVkIiwiaGFzQmFzZVBhdGgiLCJkeW5hbWljUmVnZXgiLCJkeW5hbWljR3JvdXBzIiwiZHluYW1pY01hdGNoZXMiLCJhc1BhdGhuYW1lIiwicGFyYW1zIiwicGFyYW0iLCJyZXBsYWNlZCIsInJlcGVhdCIsIm9wdGlvbmFsIiwic2VnbWVudCIsImZpbHRlcmVkUXVlcnkiLCJrZXkiLCJiYXNlIiwidXJsQXNTdHJpbmciLCJpc0xvY2FsVVJMIiwicmVzb2x2ZUFzIiwiZmluYWxVcmwiLCJpbnRlcnBvbGF0ZWRBcyIsImludGVycG9sYXRlQXMiLCJvbWl0UGFybXNGcm9tUXVlcnkiLCJyZXNvbHZlZEhyZWYiLCJvcmlnaW4iLCJyZXNvbHZlSHJlZiIsImhyZWZIYWRPcmlnaW4iLCJhc0hhZE9yaWdpbiIsInJlc29sdmVkQXMiLCJzdHJpcE9yaWdpbiIsInByZXBhcmVkVXJsIiwiYWRkQmFzZVBhdGgiLCJwcmVwYXJlZEFzIiwiYXMiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIlNTR19EQVRBX05PVF9GT1VORCIsImF0dGVtcHRzIiwiZmV0Y2hSZXRyeSIsIm5vdEZvdW5kIiwiaXNTZXJ2ZXJSZW5kZXIiLCJzZGMiLCJzdWIiLCJjbGMiLCJfYnBzIiwiZXZlbnRzIiwiX3dyYXBBcHAiLCJpc1NzciIsIl9pbkZsaWdodFJvdXRlIiwiX3NoYWxsb3ciLCJpc1JlYWR5IiwiX2lkeCIsIl9fTl9TU0ciLCJfX05fU1NQIiwiYXV0b0V4cG9ydER5bmFtaWMiLCJyZWxvYWQiLCJwcmVwYXJlVXJsQXMiLCJsb2NhbGVDaGFuZ2UiLCJwYXJzZWRBcyIsImRlbEJhc2VQYXRoIiwibG9jYWxlUGF0aFJlc3VsdCIsImRpZE5hdmlnYXRlIiwiZGV0ZWN0ZWREb21haW4iLCJkZXRlY3REb21haW5Mb2NhbGUiLCJyb3V0ZVByb3BzIiwiYWRkTG9jYWxlIiwiY2xlYW5lZEFzIiwiZGVsTG9jYWxlIiwicGFyc2VkIiwiX19yZXdyaXRlcyIsIm1ldGhvZCIsInBvdGVudGlhbEhyZWYiLCJyb3V0ZVJlZ2V4Iiwicm91dGVNYXRjaCIsInNob3VsZEludGVycG9sYXRlIiwibWlzc2luZ1BhcmFtcyIsInJvdXRlSW5mbyIsImRlc3RpbmF0aW9uIiwicGFyc2VkSHJlZiIsIm5vdEZvdW5kUm91dGUiLCJhcHBDb21wIiwiZm9yY2VkU2Nyb2xsIiwieSIsIl9fTiIsImlkeCIsImJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IiLCJleGlzdGluZ1JvdXRlSW5mbyIsImNhY2hlZFJvdXRlSW5mbyIsImRhdGFIcmVmIiwib25seUFIYXNoQ2hhbmdlIiwibmV3SGFzaCIsIm9sZFVybE5vSGFzaCIsIm9sZEhhc2giLCJpZEVsIiwibmFtZUVsIiwidXJsSXNOZXciLCJfcmVzb2x2ZUhyZWYiLCJhcHBseUJhc2VQYXRoIiwiY2xlYW5QYXRobmFtZSIsImlzU3NnIiwiY2FuY2VsIiwiY29tcG9uZW50UmVzdWx0IiwiX2dldFN0YXRpY0RhdGEiLCJmZXRjaE5leHREYXRhIiwiX2dldFNlcnZlckRhdGEiLCJhYm9ydENvbXBvbmVudExvYWQiLCJub3RpZnkiLCJzbGFzaGVkUHJvdG9jb2xzIiwicHJvdG9jb2wiLCJ1cmxPYmoiLCJob3N0IiwiYXV0aCIsImhvc3RuYW1lIiwic2VhcmNoIiwiZXh0IiwiVEVTVF9ST1VURSIsImdsb2JhbEJhc2UiLCJyZXNvbHZlZEJhc2UiLCJtYXRjaGVyT3B0aW9ucyIsInNlbnNpdGl2ZSIsImRlbGltaXRlciIsImN1c3RvbVJvdXRlTWF0Y2hlck9wdGlvbnMiLCJzdHJpY3QiLCJjdXN0b21Sb3V0ZSIsImtleXMiLCJtYXRjaGVyUmVnZXgiLCJwYXRoVG9SZWdleHAiLCJtYXRjaGVyIiwidmFsaWRhdGUiLCJwYXJzZWREZXN0aW5hdGlvbiIsImhhZExvY2FsZSIsInBvcnQiLCJkZXN0UXVlcnkiLCJkZXN0UGF0aCIsImRlc3RQYXRoUGFyYW1LZXlzIiwiZGVzdFBhdGhQYXJhbXMiLCJkZXN0aW5hdGlvbkNvbXBpbGVyIiwic3RyT3JBcnJheSIsImNvbXBpbGVOb25QYXRoIiwicGFyYW1LZXlzIiwiYXBwZW5kUGFyYW1zVG9RdWVyeSIsIm5ld1VybCIsInNlYXJjaFBhcmFtcyIsImlzTmFOIiwiaXRlbSIsInN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0iLCJzZWFyY2hQYXJhbXNMaXN0IiwidGFyZ2V0IiwiY3VzdG9tUm91dGVNYXRjaGVyIiwicmV3cml0ZSIsImRlc3RSZXMiLCJmc1BhdGhuYW1lIiwicmUiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzbHVnTmFtZSIsImciLCJncm91cHMiLCJtIiwic3RyIiwic2VnbWVudHMiLCJub3JtYWxpemVkUm91dGUiLCJncm91cEluZGV4IiwicGFyYW1ldGVyaXplZFJvdXRlIiwicGFyc2VQYXJhbWV0ZXIiLCJwb3MiLCJlc2NhcGVSZWdleCIsInVzZWQiLCJnZXRMb2NhdGlvbk9yaWdpbiIsImdldERpc3BsYXlOYW1lIiwibG9hZEdldEluaXRpYWxQcm9wcyIsInBhZ2VQcm9wcyIsImlzUmVzU2VudCIsInVybE9iamVjdEtleXMiLCJTUCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUEsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1DOzs7Ozs7Ozs7OztBQ1ZBO0FBQ0E7QUFDQTs7QUFFQSxpQzs7Ozs7Ozs7Ozs7QUNKQSx1QkFBdUIsbUJB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsc0JBQXNCLGVBQWU7QUFDbEcseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxzQkFBc0IsZUFBZTtBQUNsRyx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWMsZ0JBQWdCO0FBQ2xGO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjLGdCQUFnQjtBQUNsRjtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQkFBbUI7QUFDM0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVEQUF1RCxnQkFBZ0I7QUFDdkU7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGVBQWU7QUFDcEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlCQUFpQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUU7QUFDZixhQUFhLE9BQU87QUFDcEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEdBQUc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBLDhCQUE4QixlQUFlO0FBQzdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUEwRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksbUNBQU87QUFDWDtBQUNBLEtBQUs7QUFBQSxvR0FBQztBQUNOO0FBQ0E7QUFDQSxPQUFPLEVBU0o7QUFDSCxDQUFDOzs7Ozs7Ozs7Ozs7OztBQzN1Q0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFB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Q0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7QUNwTGE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsMEZBQStCO0FBQzFEOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBOEI7QUFDVTs7Ozs7Ozs7Ozs7O0FDRHhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQTBCLG9CQUFvQixTQUFFO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzN1QkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQ7O0FBRTlELDBEQUEwRDs7QUFFMUQ7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0IsMkJBQTJCOztBQUUzQiwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUI7Ozs7Ozs7Ozs7OztBQ3ZJakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOzs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckJBO0FBQUE7QUFBQTtBQUFBLElBQUksa0NBQWtDLFVBQVUsZ0JBQWdCLGdDQUFnQyx5QkFBeUIsOEJBQThCLFVBQVUsNEJBQTRCLEdBQUcsZ0JBQWdCLFlBQVksV0FBVyxLQUFLLFdBQVcsK0dBQStHLGdCQUFnQixvQ0FBb0MsMkJBQTJCLElBQUksY0FBYyxTQUFTLGdCQUFnQixNQUFNLHlEQUF5RCxzQ0FBc0MsTUFBTSxvQ0FBb0Msb0RBQW9ELGdMQUFnTCx1Q0FBdUMsU0FBUyxRQUFRLGtCQUFrQixvQkFBb0IsUUFBUSxFQUFFLHVCQUF1Qiw2SkFBNkosNENBQTRDLElBQUksZ0NBQWdDLFVBQVUsaUJBQWlCLFdBQVcsd0NBQXdDLHVCQUF1QixJQUFJLGdCQUFnQixvQkFBb0IsNkNBQTZDLG9CQUFvQixtQ0FBbUMsa0JBQWtCLG9FQUFvRSxjQUFjLGtCQUFrQixRQUFRLGdCQUFnQixRQUFRLHdCQUF3Qiw2QkFBNkIsc0VBQXNFLHlCQUF5QixxTEFBcUwsaUJBQWlCLDhEQUE4RCxzQkFBc0IsdUdBQXVHLHNFQUFzRSwrREFBK0QsaUJBQWlCLFVBQVUsOEVBQThFLGtDQUFrQyxtQkFBbUIsb0JBQW9CLHdCQUF3QiwrQkFBK0IsNkNBQTZDLDRCQUE0QixHQUFHLEdBQUcsWUFBWSxpQkFBaUIsbUJBQW1CLHNCQUFzQixJQUFJLHdDQUF3QyxTQUFTLDBCQUEwQix3RUFBd0UsdUZBQXVGLHdCQUF3Qiw4QkFBOEIsb0JBQW9CLDhCQUE4QixJQUFJLFdBQVcscUJBQXFCLFVBQVUsOEJBQThCLFlBQVksYUFBYSwwRUFBMEUseUNBQXlDLElBQUksY0FBYyxzRkFBc0YsOEZBQThGLFFBQVEsR0FBRyxrQkFBa0Isd0VBQXdFLGlDQUFpQyxpQ0FBaUMsR0FBRyxxQkFBcUIsa0pBQWtKLFFBQVEsTUFBTSxHQUFHLEdBQUcsU0FBUywwQkFBMEIscUJBQXFCLElBQUksd0NBQXdDLFNBQVMsMEJBQTBCLG9CQUFvQixJQUFJLDZDQUE2QyxTQUFTLDBCQUEwQix5QkFBeUIsSUFBSSxtQ0FBbUMsY0FBYyxHQUFHLFNBQVMsMEJBQTBCLGdCQUFnQix5Q0FBeUMseUNBQXlDLGdCQUFnQixJQUFJLFdBQVcscUJBQXFCLElBQUksVUFBVSxTQUFTLFlBQVkscUNBQXFDLFNBQVMsYUFBYSxnRUFBZ0UsK0JBQStCLEdBQUcsZUFBZSxRQUFRLEdBQUcsU0FBUywwQkFBMEIsVUFBVSw0QkFBNEIsdUJBQXVCLEVBQUUsaUNBQWlDLHVCQUF1QixpQ0FBaUMsWUFBWSxhQUFhLGVBQWUsa0JBQWtCLHdDQUF3QyxpQkFBaUIscUNBQXFDLG9CQUFvQiw2QkFBNkIsY0FBYyw4QkFBOEIsY0FBYyxFQUFFLGdCQUFnQixpQkFBaUIsMERBQTBELEdBQUcsSUFBSSxnQkFBZ0IsbURBQXVGO0FBQ25oSyIsImZpbGUiOiJzdGF0aWMvY2h1bmtzL21haW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5TGlrZVRvQXJyYXk7IiwiZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheVdpdGhIb2xlczsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXlcIik7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkOyIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG52YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcmVxdWlyZShcIi4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0XCIpO1xuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBzZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0OyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5OyIsImZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZXh0ZW5kczsiLCJmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTtcbiAgfTtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2Y7IiwidmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vc2V0UHJvdG90eXBlT2ZcIik7XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIHNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHM7IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7XG4gIHZhciBjYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCkge1xuICAgIHJldHVybiBjYWNoZTtcbiAgfTtcblxuICByZXR1cm4gY2FjaGU7XG59XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikge1xuICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChvYmogPT09IG51bGwgfHwgX3R5cGVvZihvYmopICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiB7XG4gICAgICBcImRlZmF1bHRcIjogb2JqXG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpO1xuXG4gIGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkge1xuICAgIHJldHVybiBjYWNoZS5nZXQob2JqKTtcbiAgfVxuXG4gIHZhciBuZXdPYmogPSB7fTtcbiAgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7XG5cbiAgICAgIGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajtcblxuICBpZiAoY2FjaGUpIHtcbiAgICBjYWNoZS5zZXQob2JqLCBuZXdPYmopO1xuICB9XG5cbiAgcmV0dXJuIG5ld09iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDsiLCJmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdDsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheTsiLCJmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2l0ZXJhYmxlVG9BcnJheUxpbWl0OyIsImZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX25vbkl0ZXJhYmxlUmVzdDsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVNwcmVhZDsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIGFzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoXCIuL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiKTtcblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjsiLCJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcblxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZjsiLCJ2YXIgYXJyYXlXaXRoSG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheUxpbWl0ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5TGltaXRcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgbm9uSXRlcmFibGVSZXN0ID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVSZXN0XCIpO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9zbGljZWRUb0FycmF5OyIsInZhciBhcnJheVdpdGhvdXRIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aG91dEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vaXRlcmFibGVUb0FycmF5XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlU3ByZWFkID0gcmVxdWlyZShcIi4vbm9uSXRlcmFibGVTcHJlYWRcIik7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90b0NvbnN1bWFibGVBcnJheTsiLCJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIiwiXCJ0cmltU3RhcnRcImluIFN0cmluZy5wcm90b3R5cGV8fChTdHJpbmcucHJvdG90eXBlLnRyaW1TdGFydD1TdHJpbmcucHJvdG90eXBlLnRyaW1MZWZ0KSxcInRyaW1FbmRcImluIFN0cmluZy5wcm90b3R5cGV8fChTdHJpbmcucHJvdG90eXBlLnRyaW1FbmQ9U3RyaW5nLnByb3RvdHlwZS50cmltUmlnaHQpLFwiZGVzY3JpcHRpb25cImluIFN5bWJvbC5wcm90b3R5cGV8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTeW1ib2wucHJvdG90eXBlLFwiZGVzY3JpcHRpb25cIix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3ZhciB0PS9cXCgoLiopXFwpLy5leGVjKHRoaXMudG9TdHJpbmcoKSk7cmV0dXJuIHQ/dFsxXTp2b2lkIDB9fSksQXJyYXkucHJvdG90eXBlLmZsYXR8fChBcnJheS5wcm90b3R5cGUuZmxhdD1mdW5jdGlvbih0LHIpe3JldHVybiByPXRoaXMuY29uY2F0LmFwcGx5KFtdLHRoaXMpLHQ+MSYmci5zb21lKEFycmF5LmlzQXJyYXkpP3IuZmxhdCh0LTEpOnJ9LEFycmF5LnByb3RvdHlwZS5mbGF0TWFwPWZ1bmN0aW9uKHQscil7cmV0dXJuIHRoaXMubWFwKHQscikuZmxhdCgpfSksUHJvbWlzZS5wcm90b3R5cGUuZmluYWxseXx8KFByb21pc2UucHJvdG90eXBlLmZpbmFsbHk9ZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdClyZXR1cm4gdGhpcy50aGVuKHQsdCk7dmFyIHI9dGhpcy5jb25zdHJ1Y3Rvcnx8UHJvbWlzZTtyZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uKG8pe3JldHVybiByLnJlc29sdmUodCgpKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIG99KX0sZnVuY3Rpb24obyl7cmV0dXJuIHIucmVzb2x2ZSh0KCkpLnRoZW4oZnVuY3Rpb24oKXt0aHJvdyBvfSl9KX0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIEJ1cyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9pbnRlcm5hbC9idXNcIikpO1xudmFyIHBhcnNlU3RhY2tfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2hlbHBlcnMvcGFyc2VTdGFja1wiKTtcbnZhciBpc1JlZ2lzdGVyZWQgPSBmYWxzZTtcbnZhciBzdGFja1RyYWNlTGltaXQgPSB1bmRlZmluZWQ7XG5mdW5jdGlvbiBvblVuaGFuZGxlZEVycm9yKGV2KSB7XG4gICAgdmFyIGVycm9yID0gZXYgPT09IG51bGwgfHwgZXYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2LmVycm9yO1xuICAgIGlmICghZXJyb3IgfHwgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB8fCB0eXBlb2YgZXJyb3Iuc3RhY2sgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEEgbm9uLWVycm9yIHdhcyB0aHJvd24sIHdlIGRvbid0IGhhdmUgYW55dGhpbmcgdG8gc2hvdy4gOi0oXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGUgPSBlcnJvcjtcbiAgICBCdXMuZW1pdCh7XG4gICAgICAgIHR5cGU6IEJ1cy5UWVBFX1VOSEFORExFRF9FUlJPUixcbiAgICAgICAgcmVhc29uOiBlcnJvcixcbiAgICAgICAgZnJhbWVzOiBwYXJzZVN0YWNrXzEucGFyc2VTdGFjayhlLnN0YWNrKVxuICAgIH0pO1xufVxuZnVuY3Rpb24gb25VbmhhbmRsZWRSZWplY3Rpb24oZXYpIHtcbiAgICB2YXIgcmVhc29uID0gZXYgPT09IG51bGwgfHwgZXYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2LnJlYXNvbjtcbiAgICBpZiAoIXJlYXNvbiB8fFxuICAgICAgICAhKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yKSB8fFxuICAgICAgICB0eXBlb2YgcmVhc29uLnN0YWNrICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBIG5vbi1lcnJvciB3YXMgdGhyb3duLCB3ZSBkb24ndCBoYXZlIGFueXRoaW5nIHRvIHNob3cuIDotKFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlID0gcmVhc29uO1xuICAgIEJ1cy5lbWl0KHtcbiAgICAgICAgdHlwZTogQnVzLlRZUEVfVU5IQU5ETEVEX1JFSkVDVElPTixcbiAgICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICAgIGZyYW1lczogcGFyc2VTdGFja18xLnBhcnNlU3RhY2soZS5zdGFjaylcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyKCkge1xuICAgIGlmIChpc1JlZ2lzdGVyZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc1JlZ2lzdGVyZWQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBsaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcbiAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gNTA7XG4gICAgICAgIHN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHsgfVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uVW5oYW5kbGVkRXJyb3IpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCBvblVuaGFuZGxlZFJlamVjdGlvbik7XG59XG5leHBvcnRzLnJlZ2lzdGVyID0gcmVnaXN0ZXI7XG5mdW5jdGlvbiB1bnJlZ2lzdGVyKCkge1xuICAgIGlmICghaXNSZWdpc3RlcmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNSZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgaWYgKHN0YWNrVHJhY2VMaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBzdGFja1RyYWNlTGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgc3RhY2tUcmFjZUxpbWl0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvblVuaGFuZGxlZEVycm9yKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgb25VbmhhbmRsZWRSZWplY3Rpb24pO1xufVxuZXhwb3J0cy51bnJlZ2lzdGVyID0gdW5yZWdpc3RlcjtcbmZ1bmN0aW9uIG9uQnVpbGRPaygpIHtcbiAgICBCdXMuZW1pdCh7IHR5cGU6IEJ1cy5UWVBFX0JVSUxEX09LIH0pO1xufVxuZXhwb3J0cy5vbkJ1aWxkT2sgPSBvbkJ1aWxkT2s7XG5mdW5jdGlvbiBvbkJ1aWxkRXJyb3IobWVzc2FnZSkge1xuICAgIEJ1cy5lbWl0KHsgdHlwZTogQnVzLlRZUEVfQlVJTERfRVJST1IsIG1lc3NhZ2U6IG1lc3NhZ2UgfSk7XG59XG5leHBvcnRzLm9uQnVpbGRFcnJvciA9IG9uQnVpbGRFcnJvcjtcbmZ1bmN0aW9uIG9uUmVmcmVzaCgpIHtcbiAgICBCdXMuZW1pdCh7IHR5cGU6IEJ1cy5UWVBFX1JFRkZSRVNIIH0pO1xufVxuZXhwb3J0cy5vblJlZnJlc2ggPSBvblJlZnJlc2g7XG52YXIgbm9kZVN0YWNrRnJhbWVzXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9oZWxwZXJzL25vZGVTdGFja0ZyYW1lc1wiKTtcbmV4cG9ydHMuZ2V0Tm9kZUVycm9yID0gbm9kZVN0YWNrRnJhbWVzXzEuZ2V0Tm9kZUVycm9yO1xudmFyIFJlYWN0RGV2T3ZlcmxheV8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvUmVhY3REZXZPdmVybGF5XCIpO1xuZXhwb3J0cy5SZWFjdERldk92ZXJsYXkgPSBSZWFjdERldk92ZXJsYXlfMVtcImRlZmF1bHRcIl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgcmVhY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIEVycm9yQm91bmRhcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVycm9yQm91bmRhcnksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXJyb3JCb3VuZGFyeSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlID0geyBlcnJvcjogbnVsbCB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEVycm9yQm91bmRhcnkucHJvdG90eXBlLmNvbXBvbmVudERpZENhdGNoID0gZnVuY3Rpb24gKGVycm9yLCBcbiAgICAvLyBMb29zZWx5IHR5cGVkIGJlY2F1c2UgaXQgZGVwZW5kcyBvbiB0aGUgUmVhY3QgdmVyc2lvbiBhbmQgd2FzXG4gICAgLy8gYWNjaWRlbnRhbGx5IGV4Y2x1ZGVkIGluIHNvbWUgdmVyc2lvbnMuXG4gICAgZXJyb3JJbmZvKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25FcnJvcihlcnJvciwgKGVycm9ySW5mbyA9PT0gbnVsbCB8fCBlcnJvckluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9ySW5mby5jb21wb25lbnRTdGFjaykgfHwgbnVsbCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcjogZXJyb3IgfSk7XG4gICAgfTtcbiAgICBFcnJvckJvdW5kYXJ5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yXG4gICAgICAgICAgICA/IC8vIFRoZSBjb21wb25lbnQgaGFzIHRvIGJlIHVubW91bnRlZCBvciBlbHNlIGl0IHdvdWxkIGNvbnRpbnVlIHRvIGVycm9yXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH07XG4gICAgcmV0dXJuIEVycm9yQm91bmRhcnk7XG59KHJlYWN0XzFbXCJkZWZhdWx0XCJdLlB1cmVDb21wb25lbnQpKTtcbmV4cG9ydHMuRXJyb3JCb3VuZGFyeSA9IEVycm9yQm91bmRhcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcnJvckJvdW5kYXJ5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZCA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWQpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgQnVzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2J1c1wiKSk7XG52YXIgU2hhZG93UG9ydGFsXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL1NoYWRvd1BvcnRhbFwiKTtcbnZhciBFcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2NvbnRhaW5lci9FcnJvcnNcIik7XG52YXIgQnVpbGRFcnJvcl8xID0gcmVxdWlyZShcIi4vY29udGFpbmVyL0J1aWxkRXJyb3JcIik7XG52YXIgRXJyb3JCb3VuZGFyeV8xID0gcmVxdWlyZShcIi4vRXJyb3JCb3VuZGFyeVwiKTtcbnZhciBCYXNlXzEgPSByZXF1aXJlKFwiLi9zdHlsZXMvQmFzZVwiKTtcbnZhciBDb21wb25lbnRTdHlsZXNfMSA9IHJlcXVpcmUoXCIuL3N0eWxlcy9Db21wb25lbnRTdHlsZXNcIik7XG52YXIgQ3NzUmVzZXRfMSA9IHJlcXVpcmUoXCIuL3N0eWxlcy9Dc3NSZXNldFwiKTtcbmZ1bmN0aW9uIHJlZHVjZXIoc3RhdGUsIGV2KSB7XG4gICAgc3dpdGNoIChldi50eXBlKSB7XG4gICAgICAgIGNhc2UgQnVzLlRZUEVfQlVJTERfT0s6IHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGUpLCB7IGJ1aWxkRXJyb3I6IG51bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBCdXMuVFlQRV9CVUlMRF9FUlJPUjoge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdGF0ZSksIHsgYnVpbGRFcnJvcjogZXYubWVzc2FnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEJ1cy5UWVBFX1JFRkZSRVNIOiB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlKSwgeyBidWlsZEVycm9yOiBudWxsLCBlcnJvcnM6IFtdIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgQnVzLlRZUEVfVU5IQU5ETEVEX0VSUk9SOlxuICAgICAgICBjYXNlIEJ1cy5UWVBFX1VOSEFORExFRF9SRUpFQ1RJT046IHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGUpLCB7IG5leHRJZDogc3RhdGUubmV4dElkICsgMSwgZXJyb3JzOiBfX3NwcmVhZChzdGF0ZS5lcnJvcnMsIFt7IGlkOiBzdGF0ZS5uZXh0SWQsIGV2ZW50OiBldiB9XSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgdmFyIF8xID0gZXY7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgUmVhY3REZXZPdmVybGF5ID0gZnVuY3Rpb24gUmVhY3REZXZPdmVybGF5KF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XG4gICAgdmFyIF9iID0gX19yZWFkKFJlYWN0LnVzZVJlZHVjZXIocmVkdWNlciwgeyBuZXh0SWQ6IDEsIGJ1aWxkRXJyb3I6IG51bGwsIGVycm9yczogW10gfSksIDIpLCBzdGF0ZSA9IF9iWzBdLCBkaXNwYXRjaCA9IF9iWzFdO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIEJ1cy5vbihkaXNwYXRjaCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBCdXMub2ZmKGRpc3BhdGNoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgb25Db21wb25lbnRFcnJvciA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChfZXJyb3IsIF9jb21wb25lbnRTdGFjaykge1xuICAgICAgICAvLyBUT0RPOiBzcGVjaWFsIGhhbmRsaW5nXG4gICAgfSwgW10pO1xuICAgIHZhciBoYXNCdWlsZEVycm9yID0gc3RhdGUuYnVpbGRFcnJvciAhPSBudWxsO1xuICAgIHZhciBoYXNSdW50aW1lRXJyb3JzID0gQm9vbGVhbihzdGF0ZS5lcnJvcnMubGVuZ3RoKTtcbiAgICB2YXIgaXNNb3VudGVkID0gaGFzQnVpbGRFcnJvciB8fCBoYXNSdW50aW1lRXJyb3JzO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChFcnJvckJvdW5kYXJ5XzEuRXJyb3JCb3VuZGFyeSwgeyBvbkVycm9yOiBvbkNvbXBvbmVudEVycm9yIH0sIGNoaWxkcmVuICE9PSBudWxsICYmIGNoaWxkcmVuICE9PSB2b2lkIDAgPyBjaGlsZHJlbiA6IG51bGwpLFxuICAgICAgICBpc01vdW50ZWQgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChTaGFkb3dQb3J0YWxfMS5TaGFkb3dQb3J0YWwsIG51bGwsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENzc1Jlc2V0XzEuQ3NzUmVzZXQsIG51bGwpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChCYXNlXzEuQmFzZSwgbnVsbCksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudFN0eWxlc18xLkNvbXBvbmVudFN0eWxlcywgbnVsbCksXG4gICAgICAgICAgICBoYXNCdWlsZEVycm9yID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnVpbGRFcnJvcl8xLkJ1aWxkRXJyb3IsIHsgbWVzc2FnZTogc3RhdGUuYnVpbGRFcnJvciB9KSkgOiBoYXNSdW50aW1lRXJyb3JzID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRXJyb3JzXzEuRXJyb3JzLCB7IGVycm9yczogc3RhdGUuZXJyb3JzIH0pKSA6IHVuZGVmaW5lZCkpIDogdW5kZWZpbmVkKSk7XG59O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBSZWFjdERldk92ZXJsYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFjdERldk92ZXJsYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuVFlQRV9CVUlMRF9PSyA9ICdidWlsZC1vayc7XG5leHBvcnRzLlRZUEVfQlVJTERfRVJST1IgPSAnYnVpbGQtZXJyb3InO1xuZXhwb3J0cy5UWVBFX1JFRkZSRVNIID0gJ2Zhc3QtcmVmcmVzaCc7XG5leHBvcnRzLlRZUEVfVU5IQU5ETEVEX0VSUk9SID0gJ3VuaGFuZGxlZC1lcnJvcic7XG5leHBvcnRzLlRZUEVfVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWQtcmVqZWN0aW9uJztcbnZhciBoYW5kbGVycyA9IG5ldyBTZXQoKTtcbnZhciBxdWV1ZSA9IFtdO1xuZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgLy8gRHJhaW5pbmcgc2hvdWxkIG5ldmVyIGhhcHBlbiBzeW5jaHJvbm91c2x5IGluIGNhc2UgbXVsdGlwbGUgaGFuZGxlcnMgYXJlXG4gICAgLy8gcmVnaXN0ZXJlZC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXYgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gaGFuZGxlcihldik7IH0pO1xuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgIC8vIFVudGlsIHdlIGFyZSBvdXQgb2YgZXZlbnRzOlxuICAgICAgICBCb29sZWFuKHF1ZXVlLmxlbmd0aCkgJiZcbiAgICAgICAgICAgIC8vIE9yLCBpZiBhbGwgaGFuZGxlcnMgcmVtb3ZlZCB0aGVtc2VsdmVzIGFzIGEgcmVzdWx0IG9mIGhhbmRsaW5nIHRoZVxuICAgICAgICAgICAgLy8gZXZlbnQocylcbiAgICAgICAgICAgIEJvb2xlYW4oaGFuZGxlcnMuc2l6ZSkpIHtcbiAgICAgICAgICAgIF9sb29wXzEoKTtcbiAgICAgICAgfVxuICAgIH0sIDEpO1xufVxuZnVuY3Rpb24gZW1pdChldikge1xuICAgIHF1ZXVlLnB1c2goT2JqZWN0LmZyZWV6ZShfX2Fzc2lnbih7fSwgZXYpKSk7XG4gICAgZHJhaW4oKTtcbn1cbmV4cG9ydHMuZW1pdCA9IGVtaXQ7XG5mdW5jdGlvbiBvbihmbikge1xuICAgIGlmIChoYW5kbGVycy5oYXMoZm4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFuZGxlcnMuYWRkKGZuKTtcbiAgICBkcmFpbigpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5vbiA9IG9uO1xuZnVuY3Rpb24gb2ZmKGZuKSB7XG4gICAgaWYgKGhhbmRsZXJzLmhhcyhmbikpIHtcbiAgICAgICAgaGFuZGxlcnNbXCJkZWxldGVcIl0oZm4pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5vZmYgPSBvZmY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBhbnNlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhbnNlclwiKSk7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBzdHJpcF9hbnNpXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInN0cmlwLWFuc2lcIikpO1xudmFyIHN0YWNrX2ZyYW1lXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9zdGFjay1mcmFtZVwiKTtcbmV4cG9ydHMuQ29kZUZyYW1lID0gZnVuY3Rpb24gQ29kZUZyYW1lKF9hKSB7XG4gICAgdmFyIHN0YWNrRnJhbWUgPSBfYS5zdGFja0ZyYW1lLCBjb2RlRnJhbWUgPSBfYS5jb2RlRnJhbWU7XG4gICAgLy8gU3RyaXAgbGVhZGluZyBzcGFjZXMgb3V0IG9mIHRoZSBjb2RlIGZyYW1lOlxuICAgIHZhciBmb3JtYXR0ZWRGcmFtZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGluZXMgPSBjb2RlRnJhbWUuc3BsaXQoL1xccj9cXG4vZyk7XG4gICAgICAgIHZhciBwcmVmaXhMZW5ndGggPSBsaW5lc1xuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSkgeyByZXR1cm4gL14+PyArXFxkKyArXFx8ICggKikvLmV4ZWMoc3RyaXBfYW5zaV8xW1wiZGVmYXVsdFwiXShsaW5lKSk7IH0pXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnBvcCgpOyB9KVxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYywgbikgeyByZXR1cm4gKGlzTmFOKGMpID8gbi5sZW5ndGggOiBNYXRoLm1pbihjLCBuLmxlbmd0aCkpOyB9LCBOYU4pO1xuICAgICAgICBpZiAocHJlZml4TGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIHBfMSA9ICcgJy5yZXBlYXQocHJlZml4TGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lc1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGxpbmUsIGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gfihhID0gbGluZS5pbmRleE9mKCd8JykpXG4gICAgICAgICAgICAgICAgICAgID8gbGluZS5zdWJzdHJpbmcoMCwgYSkgKyBsaW5lLnN1YnN0cmluZyhhKS5yZXBsYWNlKHBfMSwgJycpXG4gICAgICAgICAgICAgICAgICAgIDogbGluZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKTtcbiAgICB9LCBbY29kZUZyYW1lXSk7XG4gICAgdmFyIGRlY29kZWQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFuc2VyXzFbXCJkZWZhdWx0XCJdLmFuc2lUb0pzb24oZm9ybWF0dGVkRnJhbWUsIHtcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICB1c2VfY2xhc3NlczogdHJ1ZSxcbiAgICAgICAgICAgIHJlbW92ZV9lbXB0eTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9LCBbZm9ybWF0dGVkRnJhbWVdKTtcbiAgICB2YXIgb3BlbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3RhY2tGcmFtZSkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChrZXksICgoX2EgPSBzdGFja0ZyYW1lW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmXG4gICAgICAgICAgICAuZmV0Y2goKHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgJycpICsgXCIvX19uZXh0anNfbGF1bmNoLWVkaXRvcj9cIiArIHBhcmFtcy50b1N0cmluZygpKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBvcnQgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgfSwgW3N0YWNrRnJhbWVdKTtcbiAgICAvLyBUT0RPOiBtYWtlIHRoZSBjYXJldCBhYnNvbHV0ZVxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtY29kZWZyYW1lXCI6IHRydWUgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgeyByb2xlOiBcImxpbmtcIiwgb25DbGljazogb3BlbiwgdGFiSW5kZXg6IDEsIHRpdGxlOiBcIkNsaWNrIHRvIG9wZW4gaW4geW91ciBlZGl0b3JcIiB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCxcbiAgICAgICAgICAgICAgICBzdGFja19mcmFtZV8xLmdldEZyYW1lU291cmNlKHN0YWNrRnJhbWUpLFxuICAgICAgICAgICAgICAgIFwiIEAgXCIsXG4gICAgICAgICAgICAgICAgc3RhY2tGcmFtZS5tZXRob2ROYW1lKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTggMTN2NmEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMlY4YTIgMiAwIDAgMSAyLTJoNlwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwb2x5bGluZVwiLCB7IHBvaW50czogXCIxNSAzIDIxIDMgMjEgOVwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHsgeDE6IFwiMTBcIiwgeTE6IFwiMTRcIiwgeDI6IFwiMjFcIiwgeTI6IFwiM1wiIH0pKSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoclwiLCBudWxsKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCBudWxsLCBkZWNvZGVkLm1hcChmdW5jdGlvbiAoZW50cnksIGluZGV4KSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBrZXk6IFwiZnJhbWUtXCIgKyBpbmRleCwgc3R5bGU6IF9fYXNzaWduKHsgY29sb3I6IGVudHJ5LmZnID8gXCJ2YXIoLS1jb2xvci1cIiArIGVudHJ5LmZnICsgXCIpXCIgOiB1bmRlZmluZWQgfSwgKGVudHJ5LmRlY29yYXRpb24gPT09ICdib2xkJ1xuICAgICAgICAgICAgICAgID8geyBmb250V2VpZ2h0OiA4MDAgfVxuICAgICAgICAgICAgICAgIDogZW50cnkuZGVjb3JhdGlvbiA9PT0gJ2l0YWxpYydcbiAgICAgICAgICAgICAgICAgICAgPyB7IGZvbnRTdHlsZTogJ2l0YWxpYycgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCkpIH0sIGVudHJ5LmNvbnRlbnQpKTsgfSkpKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29kZUZyYW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBDb2RlRnJhbWVfMSA9IHJlcXVpcmUoXCIuL0NvZGVGcmFtZVwiKTtcbmV4cG9ydHMuQ29kZUZyYW1lID0gQ29kZUZyYW1lXzEuQ29kZUZyYW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xudmFyIHN0eWxlcyA9IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXTo6c2VsZWN0aW9uLFxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gKjo6c2VsZWN0aW9uIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1zZWxlY3Rpb24pO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gKiB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IGhyIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiAwO1xcblxcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci13aWR0aDogMDtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4O1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsYWNrKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gcCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBwOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBwID4gc3ZnIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIGhlaWdodDogMWVtO1xcbiAgICBtYXJnaW4tbGVmdDogOHB4O1xcbiAgfVxcblwiXSwgW1wiXFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJnKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktZmcpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV06OnNlbGVjdGlvbixcXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdICo6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktc2VsZWN0aW9uKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdICoge1xcbiAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+ICoge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpXFxuICAgICAgY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBociB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogMDtcXG5cXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItd2lkdGg6IDA7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDtcXG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJyaWdodC1ibGFjayk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IHAge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gcDpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gcCA+IHN2ZyB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IDFlbTtcXG4gICAgbWFyZ2luLWxlZnQ6IDhweDtcXG4gIH1cXG5cIl0pKSk7XG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIHVzZV9vbl9jbGlja19vdXRzaWRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaG9va3MvdXNlLW9uLWNsaWNrLW91dHNpZGVcIik7XG52YXIgRGlhbG9nID0gZnVuY3Rpb24gRGlhbG9nKF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIHR5cGUgPSBfYS50eXBlLCBvbkNsb3NlID0gX2Eub25DbG9zZSwgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwidHlwZVwiLCBcIm9uQ2xvc2VcIl0pO1xuICAgIHZhciBfYiA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZShudWxsKSwgMiksIGRpYWxvZyA9IF9iWzBdLCBzZXREaWFsb2cgPSBfYlsxXTtcbiAgICB2YXIgb25EaWFsb2cgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBzZXREaWFsb2cobm9kZSk7XG4gICAgfSwgW10pO1xuICAgIHVzZV9vbl9jbGlja19vdXRzaWRlXzEudXNlT25DbGlja091dHNpZGUoZGlhbG9nLCBvbkNsb3NlKTtcbiAgICAvLyBNYWtlIEhUTUxFbGVtZW50cyB3aXRoIGByb2xlPWxpbmtgIGFjY2Vzc2libGUgdG8gYmUgdHJpZ2dlcmVkIGJ5IHRoZVxuICAgIC8vIGtleWJvYXJkLCBpLmUuIFtFbnRlcl0uXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGRpYWxvZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvb3QgPSBkaWFsb2cuZ2V0Um9vdE5vZGUoKTtcbiAgICAgICAgLy8gQWx3YXlzIHRydWUsIGJ1dCB3ZSBkbyB0aGlzIGZvciBUeXBlU2NyaXB0OlxuICAgICAgICBpZiAoIShyb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hhZG93Um9vdCA9IHJvb3Q7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgdmFyIGVsID0gc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKGUua2V5ID09PSAnRW50ZXInICYmXG4gICAgICAgICAgICAgICAgZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgIGVsLmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAnbGluaycpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlbC5jbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNoYWRvd1Jvb3QuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNoYWRvd1Jvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgIH0sIFtkaWFsb2ddKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IG9uRGlhbG9nLCBcImRhdGEtbmV4dGpzLWRpYWxvZ1wiOiB0cnVlLCB0YWJJbmRleDogLTEsIHJvbGU6IFwiZGlhbG9nXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHByb3BzWydhcmlhLWxhYmVsbGVkYnknXSwgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IHByb3BzWydhcmlhLWRlc2NyaWJlZGJ5J10sIFwiYXJpYS1tb2RhbFwiOiBcInRydWVcIiB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXCI6IHRydWUsIGNsYXNzTmFtZTogXCJiYW5uZXItXCIgKyB0eXBlIH0pLFxuICAgICAgICBjaGlsZHJlbikpO1xufTtcbmV4cG9ydHMuRGlhbG9nID0gRGlhbG9nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGlhbG9nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIERpYWxvZ0JvZHkgPSBmdW5jdGlvbiBEaWFsb2dCb2R5KF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWRpYWxvZy1ib2R5XCI6IHRydWUsIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sIGNoaWxkcmVuKSk7XG59O1xuZXhwb3J0cy5EaWFsb2dCb2R5ID0gRGlhbG9nQm9keTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpYWxvZ0JvZHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgRGlhbG9nQ29udGVudCA9IGZ1bmN0aW9uIERpYWxvZ0NvbnRlbnQoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRcIjogdHJ1ZSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSwgY2hpbGRyZW4pKTtcbn07XG5leHBvcnRzLkRpYWxvZ0NvbnRlbnQgPSBEaWFsb2dDb250ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGlhbG9nQ29udGVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBEaWFsb2dIZWFkZXIgPSBmdW5jdGlvbiBEaWFsb2dIZWFkZXIoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtZGlhbG9nLWhlYWRlclwiOiB0cnVlLCBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LCBjaGlsZHJlbikpO1xufTtcbmV4cG9ydHMuRGlhbG9nSGVhZGVyID0gRGlhbG9nSGVhZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGlhbG9nSGVhZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBEaWFsb2dfMSA9IHJlcXVpcmUoXCIuL0RpYWxvZ1wiKTtcbmV4cG9ydHMuRGlhbG9nID0gRGlhbG9nXzEuRGlhbG9nO1xudmFyIERpYWxvZ0JvZHlfMSA9IHJlcXVpcmUoXCIuL0RpYWxvZ0JvZHlcIik7XG5leHBvcnRzLkRpYWxvZ0JvZHkgPSBEaWFsb2dCb2R5XzEuRGlhbG9nQm9keTtcbnZhciBEaWFsb2dDb250ZW50XzEgPSByZXF1aXJlKFwiLi9EaWFsb2dDb250ZW50XCIpO1xuZXhwb3J0cy5EaWFsb2dDb250ZW50ID0gRGlhbG9nQ29udGVudF8xLkRpYWxvZ0NvbnRlbnQ7XG52YXIgRGlhbG9nSGVhZGVyXzEgPSByZXF1aXJlKFwiLi9EaWFsb2dIZWFkZXJcIik7XG5leHBvcnRzLkRpYWxvZ0hlYWRlciA9IERpYWxvZ0hlYWRlcl8xLkRpYWxvZ0hlYWRlcjtcbnZhciBzdHlsZXNfMSA9IHJlcXVpcmUoXCIuL3N0eWxlc1wiKTtcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzXzEuc3R5bGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xudmFyIHN0eWxlcyA9IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIG1hcmdpbi1yaWdodDogYXV0bztcXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICAgIG91dGxpbmU6IG5vbmU7XFxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgIGJveC1zaGFkb3c6IDAgdmFyKC0tc2l6ZS1nYXAtaGFsZikgdmFyKC0tc2l6ZS1nYXAtZG91YmxlKVxcbiAgICAgIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwJSAtIDU2cHgpO1xcbiAgICBvdmVyZmxvdy15OiBoaWRkZW47XFxuICB9XFxuXFxuICBAbWVkaWEgKG1heC1oZWlnaHQ6IDgxMnB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheV0ge1xcbiAgICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwJSAtIDE1cHgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogNTc2cHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogNTQwcHg7XFxuICAgICAgYm94LXNoYWRvdzogMCB2YXIoLS1zaXplLWdhcCkgdmFyKC0tc2l6ZS1nYXAtcXVhZCkgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgICBtYXgtd2lkdGg6IDcyMHB4O1xcbiAgICB9XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogOTYwcHg7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXS5iYW5uZXItd2FybmluZyB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS15ZWxsb3cpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdLmJhbm5lci1lcnJvciB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdOjphZnRlciB7XFxuICAgIHotaW5kZXg6IDI7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICAvKiBiYW5uZXIgd2lkdGg6ICovXFxuICAgIGJvcmRlci10b3Atd2lkdGg6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAwO1xcbiAgICBib3JkZXItdG9wLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLWJvdHRvbS1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci10b3AtY29sb3I6IGluaGVyaXQ7XFxuICAgIGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XSB7XFxuICAgIG92ZXJmbG93LXk6IGF1dG87XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICAvKiBjYWxjKHBhZGRpbmcgKyBiYW5uZXIgd2lkdGggb2Zmc2V0KSAqL1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1oZWFkZXJdIHtcXG4gICAgZmxleC1zaHJpbms6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1ib2R5XSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgZmxleDogMSAxIGF1dG87XFxuICB9XFxuXCJdLCBbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIG1hcmdpbi1yaWdodDogYXV0bztcXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICAgIG91dGxpbmU6IG5vbmU7XFxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgIGJveC1zaGFkb3c6IDAgdmFyKC0tc2l6ZS1nYXAtaGFsZikgdmFyKC0tc2l6ZS1nYXAtZG91YmxlKVxcbiAgICAgIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwJSAtIDU2cHgpO1xcbiAgICBvdmVyZmxvdy15OiBoaWRkZW47XFxuICB9XFxuXFxuICBAbWVkaWEgKG1heC1oZWlnaHQ6IDgxMnB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheV0ge1xcbiAgICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwJSAtIDE1cHgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogNTc2cHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogNTQwcHg7XFxuICAgICAgYm94LXNoYWRvdzogMCB2YXIoLS1zaXplLWdhcCkgdmFyKC0tc2l6ZS1nYXAtcXVhZCkgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgICBtYXgtd2lkdGg6IDcyMHB4O1xcbiAgICB9XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogOTYwcHg7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXS5iYW5uZXItd2FybmluZyB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS15ZWxsb3cpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdLmJhbm5lci1lcnJvciB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdOjphZnRlciB7XFxuICAgIHotaW5kZXg6IDI7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICAvKiBiYW5uZXIgd2lkdGg6ICovXFxuICAgIGJvcmRlci10b3Atd2lkdGg6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAwO1xcbiAgICBib3JkZXItdG9wLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLWJvdHRvbS1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci10b3AtY29sb3I6IGluaGVyaXQ7XFxuICAgIGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XSB7XFxuICAgIG92ZXJmbG93LXk6IGF1dG87XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICAvKiBjYWxjKHBhZGRpbmcgKyBiYW5uZXIgd2lkdGggb2Zmc2V0KSAqL1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1oZWFkZXJdIHtcXG4gICAgZmxleC1zaHJpbms6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1ib2R5XSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgZmxleDogMSAxIGF1dG87XFxuICB9XFxuXCJdKSkpO1xuZXhwb3J0cy5zdHlsZXMgPSBzdHlsZXM7XG52YXIgdGVtcGxhdGVPYmplY3RfMTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBMZWZ0UmlnaHREaWFsb2dIZWFkZXIgPSBmdW5jdGlvbiBMZWZ0UmlnaHREaWFsb2dIZWFkZXIoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lLCBwcmV2aW91cyA9IF9hLnByZXZpb3VzLCBuZXh0ID0gX2EubmV4dCwgY2xvc2UgPSBfYS5jbG9zZTtcbiAgICB2YXIgYnV0dG9uTGVmdCA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICB2YXIgYnV0dG9uUmlnaHQgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgdmFyIGJ1dHRvbkNsb3NlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciBfYiA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZShudWxsKSwgMiksIG5hdiA9IF9iWzBdLCBzZXROYXYgPSBfYlsxXTtcbiAgICB2YXIgb25OYXYgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgc2V0TmF2KGVsKTtcbiAgICB9LCBbXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG5hdiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvb3QgPSBuYXYuZ2V0Um9vdE5vZGUoKTtcbiAgICAgICAgdmFyIGQgPSBzZWxmLmRvY3VtZW50O1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmtleSA9PT0gJ0Fycm93TGVmdCcpIHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChidXR0b25MZWZ0LmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uTGVmdC5jdXJyZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzICYmIHByZXZpb3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLmtleSA9PT0gJ0Fycm93UmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uUmlnaHQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBidXR0b25SaWdodC5jdXJyZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQgJiYgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhICYmIGEgIT09IGJ1dHRvbkNsb3NlLmN1cnJlbnQgJiYgYSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcik7XG4gICAgICAgIGlmIChyb290ICE9PSBkKSB7XG4gICAgICAgICAgICBkLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcik7XG4gICAgICAgICAgICBpZiAocm9vdCAhPT0gZCkge1xuICAgICAgICAgICAgICAgIGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtjbG9zZSwgbmF2LCBuZXh0LCBwcmV2aW91c10pO1xuICAgIC8vIFVubG9jayBmb2N1cyBmb3IgYnJvd3NlcnMgbGlrZSBGaXJlZm94LCB0aGF0IGJyZWFrIGFsbCB1c2VyIGZvY3VzIGlmIHRoZVxuICAgIC8vIGN1cnJlbnRseSBmb2N1c2VkIGl0ZW0gYmVjb21lcyBkaXNhYmxlZC5cbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobmF2ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm9vdCA9IG5hdi5nZXRSb290Tm9kZSgpO1xuICAgICAgICAvLyBBbHdheXMgdHJ1ZSwgYnV0IHdlIGRvIHRoaXMgZm9yIFR5cGVTY3JpcHQ6XG4gICAgICAgIGlmIChyb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgICAgICAgdmFyIGEgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAocHJldmlvdXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChidXR0b25MZWZ0LmN1cnJlbnQgJiYgYSA9PT0gYnV0dG9uTGVmdC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkxlZnQuY3VycmVudC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1dHRvblJpZ2h0LmN1cnJlbnQgJiYgYSA9PT0gYnV0dG9uUmlnaHQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBidXR0b25SaWdodC5jdXJyZW50LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbbmF2LCBuZXh0LCBwcmV2aW91c10pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRcIjogdHJ1ZSwgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcIm5hdlwiLCB7IHJlZjogb25OYXYgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyByZWY6IGJ1dHRvbkxlZnQsIHR5cGU6IFwiYnV0dG9uXCIsIGRpc2FibGVkOiBwcmV2aW91cyA9PSBudWxsID8gdHJ1ZSA6IHVuZGVmaW5lZCwgXCJhcmlhLWRpc2FibGVkXCI6IHByZXZpb3VzID09IG51bGwgPyB0cnVlIDogdW5kZWZpbmVkLCBvbkNsaWNrOiBwcmV2aW91cyAhPT0gbnVsbCAmJiBwcmV2aW91cyAhPT0gdm9pZCAwID8gcHJldmlvdXMgOiB1bmRlZmluZWQgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgdmlld0JveDogXCIwIDAgMTQgMTRcIiwgZmlsbDogXCJub25lXCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk02Ljk5OTk2IDEuMTY2NjZMMS4xNjY2MyA2Ljk5OTk5TDYuOTk5OTYgMTIuODMzM00xMi44MzMzIDYuOTk5OTlIMS45OTk5NkgxMi44MzMzWlwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0pKSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgcmVmOiBidXR0b25SaWdodCwgdHlwZTogXCJidXR0b25cIiwgZGlzYWJsZWQ6IG5leHQgPT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWQsIFwiYXJpYS1kaXNhYmxlZFwiOiBuZXh0ID09IG51bGwgPyB0cnVlIDogdW5kZWZpbmVkLCBvbkNsaWNrOiBuZXh0ICE9PSBudWxsICYmIG5leHQgIT09IHZvaWQgMCA/IG5leHQgOiB1bmRlZmluZWQgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgdmlld0JveDogXCIwIDAgMTQgMTRcIiwgZmlsbDogXCJub25lXCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk02Ljk5OTk2IDEuMTY2NjZMMTIuODMzMyA2Ljk5OTk5TDYuOTk5OTYgMTIuODMzM00xLjE2NjYzIDYuOTk5OTlIMTJIMS4xNjY2M1pcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiB9KSkpLFxuICAgICAgICAgICAgXCJcXHUwMEEwXCIsXG4gICAgICAgICAgICBjaGlsZHJlbiksXG4gICAgICAgIGNsb3NlID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyByZWY6IGJ1dHRvbkNsb3NlLCB0eXBlOiBcImJ1dHRvblwiLCBvbkNsaWNrOiBjbG9zZSwgXCJhcmlhLWxhYmVsXCI6IFwiQ2xvc2VcIiB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHdpZHRoOiBcIjI0XCIsIGhlaWdodDogXCIyNFwiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcIm5vbmVcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTE4IDZMNiAxOFwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0pLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTYgNkwxOCAxOFwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0pKSkpKSA6IG51bGwpKTtcbn07XG5leHBvcnRzLkxlZnRSaWdodERpYWxvZ0hlYWRlciA9IExlZnRSaWdodERpYWxvZ0hlYWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxlZnRSaWdodERpYWxvZ0hlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgTGVmdFJpZ2h0RGlhbG9nSGVhZGVyXzEgPSByZXF1aXJlKFwiLi9MZWZ0UmlnaHREaWFsb2dIZWFkZXJcIik7XG5leHBvcnRzLkxlZnRSaWdodERpYWxvZ0hlYWRlciA9IExlZnRSaWdodERpYWxvZ0hlYWRlcl8xLkxlZnRSaWdodERpYWxvZ0hlYWRlcjtcbnZhciBzdHlsZXNfMSA9IHJlcXVpcmUoXCIuL3N0eWxlc1wiKTtcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzXzEuc3R5bGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xudmFyIHN0eWxlcyA9IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b24ge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuXFxuICAgIHdpZHRoOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcCkpO1xcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICAgIGZvbnQtc2l6ZTogMDtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjEpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4yNXMgZWFzZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b24gPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjIpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpkaXNhYmxlZCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMSk7XFxuICAgIGNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjQpO1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpmaXJzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZikgMCAwIHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDFweDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246bGFzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyLXJhZGl1czogMCB2YXIoLS1zaXplLWdhcC1oYWxmKSB2YXIoLS1zaXplLWdhcC1oYWxmKSAwO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IGJ1dHRvbjpsYXN0LW9mLXR5cGUge1xcbiAgICBib3JkZXI6IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBhcHBlYXJhbmNlOiBub25lO1xcblxcbiAgICBvcGFjaXR5OiAwLjQ7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4yNXMgZWFzZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBidXR0b246bGFzdC1vZi10eXBlOmhvdmVyIHtcXG4gICAgb3BhY2l0eTogMC43O1xcbiAgfVxcblwiXSwgW1wiXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcblxcbiAgICB3aWR0aDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXApKTtcXG4gICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcCkpO1xcbiAgICBmb250LXNpemU6IDA7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDg1LCA4NSwgMC4xKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktcmVkKTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDAuMjVzIGVhc2U7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uID4gc3ZnIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDg1LCA4NSwgMC4yKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246ZGlzYWJsZWQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjEpO1xcbiAgICBjb2xvcjogcmdiYSgyNTUsIDg1LCA4NSwgMC40KTtcXG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246Zmlyc3Qtb2YtdHlwZSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpIDAgMCB2YXIoLS1zaXplLWdhcC1oYWxmKTtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxcHg7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uOmxhc3Qtb2YtdHlwZSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IDAgdmFyKC0tc2l6ZS1nYXAtaGFsZikgdmFyKC0tc2l6ZS1nYXAtaGFsZikgMDtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBidXR0b246bGFzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyOiAwO1xcbiAgICBwYWRkaW5nOiAwO1xcblxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgYXBwZWFyYW5jZTogbm9uZTtcXG5cXG4gICAgb3BhY2l0eTogMC40O1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMjVzIGVhc2U7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gYnV0dG9uOmxhc3Qtb2YtdHlwZTpob3ZlciB7XFxuICAgIG9wYWNpdHk6IDAuNztcXG4gIH1cXG5cIl0pKSk7XG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbi8vIEB0cy1pZ25vcmVcbnZhciBtYWludGFpbl9fdGFiX2ZvY3VzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbWFpbnRhaW4tLXRhYi1mb2N1c1wiKSk7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBib2R5X2xvY2tlcl8xID0gcmVxdWlyZShcIi4vYm9keS1sb2NrZXJcIik7XG52YXIgT3ZlcmxheSA9IGZ1bmN0aW9uIE92ZXJsYXkoX2EpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBmaXhlZCA9IF9hLmZpeGVkO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGJvZHlfbG9ja2VyXzEubG9jaygpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgYm9keV9sb2NrZXJfMS51bmxvY2soKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIF9iID0gX19yZWFkKFJlYWN0LnVzZVN0YXRlKG51bGwpLCAyKSwgb3ZlcmxheSA9IF9iWzBdLCBzZXRPdmVybGF5ID0gX2JbMV07XG4gICAgdmFyIG9uT3ZlcmxheSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICBzZXRPdmVybGF5KGVsKTtcbiAgICB9LCBbXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG92ZXJsYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYW5kbGUyID0gbWFpbnRhaW5fX3RhYl9mb2N1c18xW1wiZGVmYXVsdFwiXSh7IGNvbnRleHQ6IG92ZXJsYXkgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBoYW5kbGUyLmRpc2VuZ2FnZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtvdmVybGF5XSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheVwiOiB0cnVlLCBjbGFzc05hbWU6IGNsYXNzTmFtZSwgcmVmOiBvbk92ZXJsYXkgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtZGlhbG9nLWJhY2tkcm9wXCI6IHRydWUsIFwiZGF0YS1uZXh0anMtZGlhbG9nLWJhY2tkcm9wLWZpeGVkXCI6IGZpeGVkID8gdHJ1ZSA6IHVuZGVmaW5lZCB9KSxcbiAgICAgICAgY2hpbGRyZW4pKTtcbn07XG5leHBvcnRzLk92ZXJsYXkgPSBPdmVybGF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3ZlcmxheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgcHJldmlvdXNCb2R5UGFkZGluZ1JpZ2h0O1xudmFyIHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZztcbnZhciBhY3RpdmVMb2NrcyA9IDA7XG5mdW5jdGlvbiBsb2NrKCkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoYWN0aXZlTG9ja3MrKyA+IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Nyb2xsQmFyR2FwID0gd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgIGlmIChzY3JvbGxCYXJHYXAgPiAwKSB7XG4gICAgICAgICAgICBwcmV2aW91c0JvZHlQYWRkaW5nUmlnaHQgPSBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodDtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gc2Nyb2xsQmFyR2FwICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZyA9IGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB9KTtcbn1cbmV4cG9ydHMubG9jayA9IGxvY2s7XG5mdW5jdGlvbiB1bmxvY2soKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhY3RpdmVMb2NrcyA9PT0gMCB8fCAtLWFjdGl2ZUxvY2tzICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZpb3VzQm9keVBhZGRpbmdSaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHByZXZpb3VzQm9keVBhZGRpbmdSaWdodDtcbiAgICAgICAgICAgIHByZXZpb3VzQm9keVBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBwcmV2aW91c0JvZHlPdmVyZmxvd1NldHRpbmc7XG4gICAgICAgICAgICBwcmV2aW91c0JvZHlPdmVyZmxvd1NldHRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMudW5sb2NrID0gdW5sb2NrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9keS1sb2NrZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIE92ZXJsYXlfMSA9IHJlcXVpcmUoXCIuL092ZXJsYXlcIik7XG5leHBvcnRzLk92ZXJsYXkgPSBPdmVybGF5XzEuT3ZlcmxheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEB0cy1ub2NoZWNrXG4vLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanNcbi8vIExpY2Vuc2U6IE1JVFxuLy8gQ29weXJpZ2h0IChjKSAyMDE1IFJvZG5leSBSZWhtXG4vL1xuLy8gRW50cnlwb2ludDogYWxseS5qcy9tYWludGFpbi90YWItZm9jdXNcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgcGxhdGZvcm1fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicGxhdGZvcm1cIikpO1xudmFyIGNzc19lc2NhcGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY3NzLmVzY2FwZVwiKSk7XG4vLyBpbnB1dCBtYXkgYmUgdW5kZWZpbmVkLCBzZWxlY3Rvci10cmluZywgTm9kZSwgTm9kZUxpc3QsIEhUTUxDb2xsZWN0aW9uLCBhcnJheSBvZiBOb2Rlc1xuLy8geWVzLCB0byBzb21lIGV4dGVudCB0aGlzIGlzIGEgYmFkIHJlcGxpY2Egb2YgalF1ZXJ5J3MgY29uc3RydWN0b3IgZnVuY3Rpb25cbmZ1bmN0aW9uIG5vZGVBcnJheShpbnB1dCkge1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICAvLyBpbnN0YW5jZW9mIE5vZGUgLSBkb2VzIG5vdCB3b3JrIHdpdGggaWZyYW1lc1xuICAgIGlmIChpbnB1dC5ub2RlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbaW5wdXRdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAoaW5wdXQubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoaW5wdXQsIDApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmV4cGVjdGVkIGlucHV0ICcgKyBTdHJpbmcoaW5wdXQpKTtcbn1cbmZ1bmN0aW9uIGNvbnRleHRUb0VsZW1lbnQoX3JlZikge1xuICAgIHZhciBjb250ZXh0ID0gX3JlZi5jb250ZXh0LCBfcmVmJGxhYmVsID0gX3JlZi5sYWJlbCwgbGFiZWwgPSBfcmVmJGxhYmVsID09PSB1bmRlZmluZWQgPyAnY29udGV4dC10by1lbGVtZW50JyA6IF9yZWYkbGFiZWwsIHJlc29sdmVEb2N1bWVudCA9IF9yZWYucmVzb2x2ZURvY3VtZW50LCBkZWZhdWx0VG9Eb2N1bWVudCA9IF9yZWYuZGVmYXVsdFRvRG9jdW1lbnQ7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlQXJyYXkoY29udGV4dClbMF07XG4gICAgaWYgKHJlc29sdmVEb2N1bWVudCAmJiBlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSkge1xuICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuICAgIGlmICghZWxlbWVudCAmJiBkZWZhdWx0VG9Eb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihsYWJlbCArICcgcmVxdWlyZXMgdmFsaWQgb3B0aW9ucy5jb250ZXh0Jyk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSAmJlxuICAgICAgICBlbGVtZW50Lm5vZGVUeXBlICE9PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihsYWJlbCArICcgcmVxdWlyZXMgb3B0aW9ucy5jb250ZXh0IHRvIGJlIGFuIEVsZW1lbnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRTaGFkb3dIb3N0KCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSwgY29udGV4dCA9IF9yZWYuY29udGV4dDtcbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHRUb0VsZW1lbnQoe1xuICAgICAgICBsYWJlbDogJ2dldC9zaGFkb3ctaG9zdCcsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9KTtcbiAgICAvLyB3YWxrIHVwIHRvIHRoZSByb290XG4gICAgdmFyIGNvbnRhaW5lciA9IG51bGw7XG4gICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgICAgY29udGFpbmVyID0gZWxlbWVudDtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUubm9kZVR5cGVcbiAgICAvLyBOT1RFOiBGaXJlZm94IDM0IGRvZXMgbm90IGV4cG9zZSBTaGFkb3dSb290Lmhvc3QgKGJ1dCAzNyBkb2VzKVxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IGNvbnRhaW5lci5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmXG4gICAgICAgIGNvbnRhaW5lci5ob3N0KSB7XG4gICAgICAgIC8vIHRoZSByb290IGlzIGF0dGFjaGVkIHRvIGEgZnJhZ21lbnQgbm9kZSB0aGF0IGhhcyBhIGhvc3RcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5ob3N0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50KG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xufVxuZnVuY3Rpb24gaXNBY3RpdmVFbGVtZW50KGNvbnRleHQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHRUb0VsZW1lbnQoe1xuICAgICAgICBsYWJlbDogJ2lzL2FjdGl2ZS1lbGVtZW50JyxcbiAgICAgICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfSk7XG4gICAgdmFyIF9kb2N1bWVudCA9IGdldERvY3VtZW50KGVsZW1lbnQpO1xuICAgIGlmIChfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHNoYWRvd0hvc3QgPSBnZXRTaGFkb3dIb3N0KHsgY29udGV4dDogZWxlbWVudCB9KTtcbiAgICBpZiAoc2hhZG93SG9zdCAmJiBzaGFkb3dIb3N0LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudCA9PT0gZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gW2VsZW0sIGVsZW0ucGFyZW50LCBlbGVtLnBhcmVudC5wYXJlbnQsIOKApiwgaHRtbF1cbi8vIHdpbGwgbm90IGNvbnRhaW4gdGhlIHNoYWRvd1Jvb3QgKERPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIGFuZCBzaGFkb3dIb3N0XG5mdW5jdGlvbiBnZXRQYXJlbnRzKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSwgY29udGV4dCA9IF9yZWYuY29udGV4dDtcbiAgICB2YXIgbGlzdCA9IFtdO1xuICAgIHZhciBlbGVtZW50ID0gY29udGV4dFRvRWxlbWVudCh7XG4gICAgICAgIGxhYmVsOiAnZ2V0L3BhcmVudHMnLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfSk7XG4gICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgICAgbGlzdC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAvLyBJRSBkb2VzIGtub3cgc3VwcG9ydCBwYXJlbnRFbGVtZW50IG9uIFNWR0VsZW1lbnRcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufVxuLy8gRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyBtYXkgYmUgYXZhaWxhYmxlIGF0IGEgZGlmZmVyZW50IG5hbWVcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FbGVtZW50L21hdGNoZXNcbnZhciBuYW1lcyA9IFtcbiAgICAnbWF0Y2hlcycsXG4gICAgJ3dlYmtpdE1hdGNoZXNTZWxlY3RvcicsXG4gICAgJ21vek1hdGNoZXNTZWxlY3RvcicsXG4gICAgJ21zTWF0Y2hlc1NlbGVjdG9yJyxcbl07XG52YXIgbmFtZSA9IG51bGw7XG5mdW5jdGlvbiBmaW5kTWV0aG9kTmFtZShlbGVtZW50KSB7XG4gICAgbmFtZXMuc29tZShmdW5jdGlvbiAoX25hbWUpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50W19uYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBfbmFtZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlcyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIGlmICghbmFtZSkge1xuICAgICAgICBmaW5kTWV0aG9kTmFtZShlbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRbbmFtZV0oc2VsZWN0b3IpO1xufVxuLy8gZGVlcCBjbG9uZSBvZiBvcmlnaW5hbCBwbGF0Zm9ybVxudmFyIHBsYXRmb3JtID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwbGF0Zm9ybV8xW1wiZGVmYXVsdFwiXSkpO1xuLy8gb3BlcmF0aW5nIHN5c3RlbVxudmFyIG9zID0gcGxhdGZvcm0ub3MuZmFtaWx5IHx8ICcnO1xudmFyIEFORFJPSUQgPSBvcyA9PT0gJ0FuZHJvaWQnO1xudmFyIFdJTkRPV1MgPSBvcy5zbGljZSgwLCA3KSA9PT0gJ1dpbmRvd3MnO1xudmFyIE9TWCA9IG9zID09PSAnT1MgWCc7XG52YXIgSU9TID0gb3MgPT09ICdpT1MnO1xuLy8gbGF5b3V0XG52YXIgQkxJTksgPSBwbGF0Zm9ybS5sYXlvdXQgPT09ICdCbGluayc7XG52YXIgR0VDS08gPSBwbGF0Zm9ybS5sYXlvdXQgPT09ICdHZWNrbyc7XG52YXIgVFJJREVOVCA9IHBsYXRmb3JtLmxheW91dCA9PT0gJ1RyaWRlbnQnO1xudmFyIEVER0UgPSBwbGF0Zm9ybS5sYXlvdXQgPT09ICdFZGdlSFRNTCc7XG52YXIgV0VCS0lUID0gcGxhdGZvcm0ubGF5b3V0ID09PSAnV2ViS2l0Jztcbi8vIGJyb3dzZXIgdmVyc2lvbiAobm90IGxheW91dCBlbmdpbmUgdmVyc2lvbiEpXG52YXIgdmVyc2lvbiA9IHBhcnNlRmxvYXQocGxhdGZvcm0udmVyc2lvbik7XG52YXIgbWFqb3JWZXJzaW9uID0gTWF0aC5mbG9vcih2ZXJzaW9uKTtcbnBsYXRmb3JtLm1ham9yVmVyc2lvbiA9IG1ham9yVmVyc2lvbjtcbnBsYXRmb3JtLmlzID0ge1xuICAgIC8vIG9wZXJhdGluZyBzeXN0ZW1cbiAgICBBTkRST0lEOiBBTkRST0lELFxuICAgIFdJTkRPV1M6IFdJTkRPV1MsXG4gICAgT1NYOiBPU1gsXG4gICAgSU9TOiBJT1MsXG4gICAgLy8gbGF5b3V0XG4gICAgQkxJTks6IEJMSU5LLFxuICAgIEdFQ0tPOiBHRUNLTyxcbiAgICBUUklERU5UOiBUUklERU5ULFxuICAgIEVER0U6IEVER0UsXG4gICAgV0VCS0lUOiBXRUJLSVQsXG4gICAgLy8gSU5URVJORVQgRVhQTE9SRVJTXG4gICAgSUU5OiBUUklERU5UICYmIG1ham9yVmVyc2lvbiA9PT0gOSxcbiAgICBJRTEwOiBUUklERU5UICYmIG1ham9yVmVyc2lvbiA9PT0gMTAsXG4gICAgSUUxMTogVFJJREVOVCAmJiBtYWpvclZlcnNpb24gPT09IDExXG59O1xuZnVuY3Rpb24gYmVmb3JlKCkge1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgICAvLyByZW1lbWJlciB3aGF0IGhhZCBmb2N1cyB0byByZXN0b3JlIGFmdGVyIHRlc3RcbiAgICAgICAgYWN0aXZlRWxlbWVudDogZG9jdW1lbnQuYWN0aXZlRWxlbWVudCxcbiAgICAgICAgLy8gcmVtZW1iZXIgc2Nyb2xsIHBvc2l0aW9ucyB0byByZXN0b3JlIGFmdGVyIHRlc3RcbiAgICAgICAgd2luZG93U2Nyb2xsVG9wOiB3aW5kb3cuc2Nyb2xsVG9wLFxuICAgICAgICB3aW5kb3dTY3JvbGxMZWZ0OiB3aW5kb3cuc2Nyb2xsTGVmdCxcbiAgICAgICAgYm9keVNjcm9sbFRvcDogZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgIGJvZHlTY3JvbGxMZWZ0OiBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnRcbiAgICB9O1xuICAgIC8vIHdyYXAgdGVzdHMgaW4gYW4gZWxlbWVudCBoaWRkZW4gZnJvbSBzY3JlZW4gcmVhZGVycyB0byBwcmV2ZW50IHRoZW1cbiAgICAvLyBmcm9tIGFubm91bmNpbmcgZm9jdXMsIHdoaWNoIGNhbiBiZSBxdWl0ZSBpcnJpdGF0aW5nIHRvIHRoZSB1c2VyXG4gICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3Bvc2l0aW9uOmFic29sdXRlOyBwb3NpdGlvbjpmaXhlZDsgdG9wOjA7IGxlZnQ6LTJweDsgd2lkdGg6MXB4OyBoZWlnaHQ6MXB4OyBvdmVyZmxvdzpoaWRkZW47Jyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ29mZicpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtYnVzeScsICd0cnVlJyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICB2YXIgX3dpbmRvdyA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuICAgIHZhciBfZG9jdW1lbnQgPSBfd2luZG93LmRvY3VtZW50O1xuICAgIF9kb2N1bWVudC5vcGVuKCk7XG4gICAgX2RvY3VtZW50LmNsb3NlKCk7XG4gICAgdmFyIHdyYXBwZXIgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgZGF0YS5pZnJhbWUgPSBpZnJhbWU7XG4gICAgZGF0YS53cmFwcGVyID0gd3JhcHBlcjtcbiAgICBkYXRhLndpbmRvdyA9IF93aW5kb3c7XG4gICAgZGF0YS5kb2N1bWVudCA9IF9kb2N1bWVudDtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8vIG9wdGlvbnMuZWxlbWVudDpcbi8vICB7c3RyaW5nfSBlbGVtZW50IG5hbWVcbi8vICB7ZnVuY3Rpb259IGNhbGxiYWNrKHdyYXBwZXIsIGRvY3VtZW50KSB0byBnZW5lcmF0ZSBhbiBlbGVtZW50XG4vLyBvcHRpb25zLm11dGF0ZTogKG9wdGlvbmFsKVxuLy8gIHtmdW5jdGlvbn0gY2FsbGJhY2soZWxlbWVudCwgd3JhcHBlciwgZG9jdW1lbnQpIHRvIG1hbmlwdWxhdGUgZWxlbWVudCBwcmlvciB0byBmb2N1cy10ZXN0LlxuLy8gICAgICAgICAgICAgQ2FuIHJldHVybiBET01FbGVtZW50IHRvIGRlZmluZSBmb2N1cyB0YXJnZXQgKGRlZmF1bHQ6IGVsZW1lbnQpXG4vLyBvcHRpb25zLnZhbGlkYXRlOiAob3B0aW9uYWwpXG4vLyAge2Z1bmN0aW9ufSBjYWxsYmFjayhlbGVtZW50LCBmb2N1c1RhcmdldCwgZG9jdW1lbnQpIHRvIG1hbmlwdWxhdGUgdGVzdC1yZXN1bHRcbmZ1bmN0aW9uIHRlc3QoZGF0YSwgb3B0aW9ucykge1xuICAgIC8vIG1ha2Ugc3VyZSB3ZSBvcGVyYXRlIG9uIGEgY2xlYW4gc2xhdGVcbiAgICBkYXRhLndyYXBwZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgLy8gY3JlYXRlIGR1bW15IGVsZW1lbnQgdG8gdGVzdCBmb2N1c2FiaWxpdHkgb2ZcbiAgICB2YXIgZWxlbWVudCA9IHR5cGVvZiBvcHRpb25zLmVsZW1lbnQgPT09ICdzdHJpbmcnXG4gICAgICAgID8gZGF0YS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KG9wdGlvbnMuZWxlbWVudClcbiAgICAgICAgOiBvcHRpb25zLmVsZW1lbnQoZGF0YS53cmFwcGVyLCBkYXRhLmRvY3VtZW50KTtcbiAgICAvLyBhbGxvdyBjYWxsYmFjayB0byBmdXJ0aGVyIHNwZWNpZnkgZHVtbXkgZWxlbWVudFxuICAgIC8vIGFuZCBvcHRpb25hbGx5IGRlZmluZSBlbGVtZW50IHRvIGZvY3VzXG4gICAgdmFyIGZvY3VzID0gb3B0aW9ucy5tdXRhdGUgJiYgb3B0aW9ucy5tdXRhdGUoZWxlbWVudCwgZGF0YS53cmFwcGVyLCBkYXRhLmRvY3VtZW50KTtcbiAgICBpZiAoIWZvY3VzICYmIGZvY3VzICE9PSBmYWxzZSkge1xuICAgICAgICBmb2N1cyA9IGVsZW1lbnQ7XG4gICAgfVxuICAgIC8vIGVsZW1lbnQgbmVlZHMgdG8gYmUgcGFydCBvZiB0aGUgRE9NIHRvIGJlIGZvY3VzYWJsZVxuICAgICFlbGVtZW50LnBhcmVudE5vZGUgJiYgZGF0YS53cmFwcGVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIC8vIHRlc3QgaWYgdGhlIGVsZW1lbnQgd2l0aCBpbnZhbGlkIHRhYmluZGV4IGNhbiBiZSBmb2N1c2VkXG4gICAgZm9jdXMgJiYgZm9jdXMuZm9jdXMgJiYgZm9jdXMuZm9jdXMoKTtcbiAgICAvLyB2YWxpZGF0ZSB0ZXN0J3MgcmVzdWx0XG4gICAgcmV0dXJuIG9wdGlvbnMudmFsaWRhdGVcbiAgICAgICAgPyBvcHRpb25zLnZhbGlkYXRlKGVsZW1lbnQsIGZvY3VzLCBkYXRhLmRvY3VtZW50KVxuICAgICAgICA6IGRhdGEuZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZm9jdXM7XG59XG5mdW5jdGlvbiBhZnRlcihkYXRhKSB7XG4gICAgLy8gcmVzdG9yZSBmb2N1cyB0byB3aGF0IGl0IHdhcyBiZWZvcmUgdGVzdCBhbmQgY2xlYW51cFxuICAgIGlmIChkYXRhLmFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuICAgICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyICYmXG4gICAgICAgICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgaWYgKHBsYXRmb3JtLmlzLklFMTApIHtcbiAgICAgICAgICAgIC8vIElFMTAgZG9lcyBub3QgcmVkaXJlY3QgZm9jdXMgdG8gPGJvZHk+IHdoZW4gdGhlIGFjdGl2ZUVsZW1lbnQgaXMgcmVtb3ZlZFxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkYXRhLmFjdGl2ZUVsZW1lbnQgJiYgZGF0YS5hY3RpdmVFbGVtZW50LmZvY3VzICYmIGRhdGEuYWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRhdGEuaWZyYW1lKTtcbiAgICAvLyByZXN0b3JlIHNjcm9sbCBwb3NpdGlvblxuICAgIHdpbmRvdy5zY3JvbGxUb3AgPSBkYXRhLndpbmRvd1Njcm9sbFRvcDtcbiAgICB3aW5kb3cuc2Nyb2xsTGVmdCA9IGRhdGEud2luZG93U2Nyb2xsTGVmdDtcbiAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA9IGRhdGEuYm9keVNjcm9sbFRvcDtcbiAgICBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgPSBkYXRhLmJvZHlTY3JvbGxMZWZ0O1xufVxuZnVuY3Rpb24gZGV0ZWN0Rm9jdXModGVzdHMpIHtcbiAgICB2YXIgZGF0YSA9IGJlZm9yZSgpO1xuICAgIHZhciByZXN1bHRzID0ge307XG4gICAgT2JqZWN0LmtleXModGVzdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJlc3VsdHNba2V5XSA9IHRlc3QoZGF0YSwgdGVzdHNba2V5XSk7XG4gICAgfSk7XG4gICAgYWZ0ZXIoZGF0YSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG4vLyB0aGlzIGZpbGUgaXMgb3ZlcndyaXR0ZW4gYnkgYG5wbSBydW4gYnVpbGQ6cHJlYFxudmFyIHZlcnNpb24kMSA9ICcxLjQuMSc7XG4vKlxuICAgIEZhY2lsaXR5IHRvIGNhY2hlIHRlc3QgcmVzdWx0cyBpbiBsb2NhbFN0b3JhZ2UuXG5cbiAgICBVU0FHRTpcbiAgICAgIGNhY2hlLmdldCgna2V5Jyk7XG4gICAgICBjYWNoZS5zZXQoJ2tleScsICd2YWx1ZScpO1xuICovXG5mdW5jdGlvbiByZWFkTG9jYWxTdG9yYWdlKGtleSkge1xuICAgIC8vIGFsbG93IHJlYWRpbmcgZnJvbSBzdG9yYWdlIHRvIHJldHJpZXZlIHByZXZpb3VzIHN1cHBvcnQgcmVzdWx0c1xuICAgIC8vIGV2ZW4gd2hpbGUgdGhlIGRvY3VtZW50IGRvZXMgbm90IGhhdmUgZm9jdXNcbiAgICB2YXIgZGF0YSA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgICBkYXRhID0gd2luZG93LmxvY2FsU3RvcmFnZSAmJiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgZGF0YSA9IGRhdGEgPyBKU09OLnBhcnNlKGRhdGEpIDoge307XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGRhdGEgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiB3cml0ZUxvY2FsU3RvcmFnZShrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFkb2N1bWVudC5oYXNGb2N1cygpKSB7XG4gICAgICAgIC8vIGlmIHRoZSBkb2N1bWVudCBkb2VzIG5vdCBoYXZlIGZvY3VzIHdoZW4gdGVzdHMgYXJlIGV4ZWN1dGVkLCBmb2N1cygpIG1heVxuICAgICAgICAvLyBub3QgYmUgaGFuZGxlZCBwcm9wZXJseSBhbmQgZXZlbnRzIG1heSBub3QgYmUgZGlzcGF0Y2hlZCBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBkb2N1bWVudCBpcyByZWxvYWRlZCB3aGlsZSBEZXZlbG9wZXIgVG9vbHMgaGF2ZSBmb2N1cy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UgJiYgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZSAmJlxuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgfVxufVxudmFyIHVzZXJBZ2VudCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgJyc7XG52YXIgY2FjaGVLZXkgPSAnYWxseS1zdXBwb3J0cy1jYWNoZSc7XG52YXIgY2FjaGUgPSByZWFkTG9jYWxTdG9yYWdlKGNhY2hlS2V5KTtcbi8vIHVwZGF0ZSB0aGUgY2FjaGUgaWYgYWxseSBvciB0aGUgdXNlciBhZ2VudCBjaGFuZ2VkIChuZXdlciB2ZXJzaW9uLCBldGMpXG5pZiAoY2FjaGUudXNlckFnZW50ICE9PSB1c2VyQWdlbnQgfHwgY2FjaGUudmVyc2lvbiAhPT0gdmVyc2lvbiQxKSB7XG4gICAgY2FjaGUgPSB7fTtcbn1cbmNhY2hlLnVzZXJBZ2VudCA9IHVzZXJBZ2VudDtcbmNhY2hlLnZlcnNpb24gPSB2ZXJzaW9uJDE7XG52YXIgY2FjaGUkMSA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWVzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjYWNoZVtrZXldID0gdmFsdWVzW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICBjYWNoZS50aW1lID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICB3cml0ZUxvY2FsU3RvcmFnZShjYWNoZUtleSwgY2FjaGUpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBjc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yKCkge1xuICAgIHZhciBjb21iaW5hdG9yID0gdm9pZCAwO1xuICAgIC8vIHNlZSBodHRwczovL2Rldi53My5vcmcvY3Nzd2cvY3NzLXNjb3BpbmctMS8jZGVlcC1jb21iaW5hdG9yXG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTExNzU3MlxuICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDYwNTFcbiAgICB0cnkge1xuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sID4+PiA6Zmlyc3QtY2hpbGQnKTtcbiAgICAgICAgY29tYmluYXRvciA9ICc+Pj4nO1xuICAgIH1cbiAgICBjYXRjaCAobm9BcnJvd0Fycm93QXJyb3cpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIG9sZCBzeW50YXggc3VwcG9ydGVkIGF0IGxlYXN0IHVwIHRvIENocm9tZSA0MVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NjA1MVxuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaHRtbCAvZGVlcC8gOmZpcnN0LWNoaWxkJyk7XG4gICAgICAgICAgICBjb21iaW5hdG9yID0gJy9kZWVwLyc7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKG5vRGVlcCkge1xuICAgICAgICAgICAgY29tYmluYXRvciA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb21iaW5hdG9yO1xufVxudmFyIGdpZiA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL3lINUJBRUFBQUFBTEFBQUFBQUJBQUVBQUFJQlJBQTcnO1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLXVzZW1hcFxudmFyIGZvY3VzQXJlYUltZ1RhYmluZGV4ID0ge1xuICAgIGVsZW1lbnQ6ICdkaXYnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPVxuICAgICAgICAgICAgJzxtYXAgbmFtZT1cImltYWdlLW1hcC10YWJpbmRleC10ZXN0XCI+JyArXG4gICAgICAgICAgICAgICAgJzxhcmVhIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgK1xuICAgICAgICAgICAgICAgICc8aW1nIHVzZW1hcD1cIiNpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiIHRhYmluZGV4PVwiLTFcIiBhbHQ9XCJcIiBzcmM9XCInICtcbiAgICAgICAgICAgICAgICBnaWYgK1xuICAgICAgICAgICAgICAgICdcIj4nO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhcmVhJyk7XG4gICAgfVxufTtcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWcjYXR0ci11c2VtYXBcbnZhciBmb2N1c0FyZWFUYWJpbmRleCA9IHtcbiAgICBlbGVtZW50OiAnZGl2JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiPicgK1xuICAgICAgICAgICAgICAgICc8YXJlYSBocmVmPVwiI3ZvaWRcIiB0YWJpbmRleD1cIi0xXCIgc2hhcGU9XCJyZWN0XCIgY29vcmRzPVwiNjMsMTksMTQ0LDQ1XCI+PC9tYXA+JyArXG4gICAgICAgICAgICAgICAgJzxpbWcgdXNlbWFwPVwiI2ltYWdlLW1hcC10YWJpbmRleC10ZXN0XCIgYWx0PVwiXCIgc3JjPVwiJyArXG4gICAgICAgICAgICAgICAgZ2lmICtcbiAgICAgICAgICAgICAgICAnXCI+JztcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGVsZW1lbnQsIGZvY3VzVGFyZ2V0LCBfZG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKHBsYXRmb3JtLmlzLkdFQ0tPKSB7XG4gICAgICAgICAgICAvLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XG4gICAgICAgICAgICAvLyBGaXJlZm94IGxvYWRzIHRoZSBEYXRhVVJJIGFzeW5jaHJvbm91c2x5LCBjYXVzaW5nIGEgZmFsc2UtbmVnYXRpdmVcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb2N1cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignYXJlYScpO1xuICAgICAgICBmb2N1cy5mb2N1cygpO1xuICAgICAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZvY3VzO1xuICAgIH1cbn07XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXG52YXIgZm9jdXNBcmVhV2l0aG91dEhyZWYgPSB7XG4gICAgZWxlbWVudDogJ2RpdicsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9XG4gICAgICAgICAgICAnPG1hcCBuYW1lPVwiaW1hZ2UtbWFwLWFyZWEtaHJlZi10ZXN0XCI+JyArXG4gICAgICAgICAgICAgICAgJzxhcmVhIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgK1xuICAgICAgICAgICAgICAgICc8aW1nIHVzZW1hcD1cIiNpbWFnZS1tYXAtYXJlYS1ocmVmLXRlc3RcIiBhbHQ9XCJcIiBzcmM9XCInICtcbiAgICAgICAgICAgICAgICBnaWYgK1xuICAgICAgICAgICAgICAgICdcIj4nO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhcmVhJyk7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xuICAgICAgICBpZiAocGxhdGZvcm0uaXMuR0VDS08pIHtcbiAgICAgICAgICAgIC8vIGZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMzVcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggbG9hZHMgdGhlIERhdGFVUkkgYXN5bmNocm9ub3VzbHksIGNhdXNpbmcgYSBmYWxzZS1uZWdhdGl2ZVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmb2N1c1RhcmdldDtcbiAgICB9XG59O1xudmFyIGZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMgPSB7XG4gICAgbmFtZTogJ2Nhbi1mb2N1cy1hdWRpby13aXRob3V0LWNvbnRyb2xzJyxcbiAgICBlbGVtZW50OiAnYXVkaW8nLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGludmFsaWQgbWVkaWEgZmlsZSBjYW4gdHJpZ2dlciB3YXJuaW5nIGluIGNvbnNvbGUsIGRhdGEtdXJpIHRvIHByZXZlbnQgSFRUUCByZXF1ZXN0XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3JjJywgZ2lmKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSUU5IG1heSB0aHJvdyBcIkVycm9yOiBOb3QgaW1wbGVtZW50ZWRcIlxuICAgICAgICB9XG4gICAgfVxufTtcbnZhciBpbnZhbGlkR2lmID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8vWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWic7XG4vLyBOT1RFOiBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXG52YXIgZm9jdXNCcm9rZW5JbWFnZU1hcCA9IHtcbiAgICBlbGVtZW50OiAnZGl2JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICc8bWFwIG5hbWU9XCJicm9rZW4taW1hZ2UtbWFwLXRlc3RcIj48YXJlYSBocmVmPVwiI3ZvaWRcIiBzaGFwZT1cInJlY3RcIiBjb29yZHM9XCI2MywxOSwxNDQsNDVcIj48L21hcD4nICtcbiAgICAgICAgICAgICAgICAnPGltZyB1c2VtYXA9XCIjYnJva2VuLWltYWdlLW1hcC10ZXN0XCIgYWx0PVwiXCIgc3JjPVwiJyArXG4gICAgICAgICAgICAgICAgaW52YWxpZEdpZiArXG4gICAgICAgICAgICAgICAgJ1wiPic7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2FyZWEnKTtcbiAgICB9XG59O1xuLy8gQ2hpbGRyZW4gb2YgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGggZGlzcGxheTpmbGV4IGFyZSBmb2N1c2FibGUgaW4gSUUxMC0xMVxudmFyIGZvY3VzQ2hpbGRyZW5PZkZvY3VzYWJsZUZsZXhib3ggPSB7XG4gICAgZWxlbWVudDogJ2RpdicsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IC13ZWJraXQtZmxleDsgZGlzcGxheTogLW1zLWZsZXhib3g7IGRpc3BsYXk6IGZsZXg7Jyk7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxzcGFuIHN0eWxlPVwiZGlzcGxheTogYmxvY2s7XCI+aGVsbG88L3NwYW4+JztcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICAgIH1cbn07XG4vLyBmaWVsZHNldFt0YWJpbmRleD0wXVtkaXNhYmxlZF0gc2hvdWxkIG5vdCBiZSBmb2N1c2FibGUsIGJ1dCBCbGluayBhbmQgV2ViS2l0IGRpc2FncmVlXG4vLyBAc3BlY2lmaWNhdGlvbiBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZGlzYWJsZWQtZWxlbWVudHMuaHRtbCNjb25jZXB0LWVsZW1lbnQtZGlzYWJsZWRcbi8vIEBicm93c2VyLWlzc3VlIENocm9taXVtIGh0dHBzOi8vY3JidWcuY29tLzQ1Mzg0N1xuLy8gQGJyb3dzZXItaXNzdWUgV2ViS2l0IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDEwODZcbnZhciBmb2N1c0ZpZWxkc2V0RGlzYWJsZWQgPSB7XG4gICAgZWxlbWVudDogJ2ZpZWxkc2V0JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICB9XG59O1xudmFyIGZvY3VzRmllbGRzZXQgPSB7XG4gICAgZWxlbWVudDogJ2ZpZWxkc2V0JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxsZWdlbmQ+bGVnZW5kPC9sZWdlbmQ+PHA+Y29udGVudDwvcD4nO1xuICAgIH1cbn07XG4vLyBlbGVtZW50cyB3aXRoIGRpc3BsYXk6ZmxleCBhcmUgZm9jdXNhYmxlIGluIElFMTAtMTFcbnZhciBmb2N1c0ZsZXhib3hDb250YWluZXIgPSB7XG4gICAgZWxlbWVudDogJ3NwYW4nLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IC13ZWJraXQtZmxleDsgZGlzcGxheTogLW1zLWZsZXhib3g7IGRpc3BsYXk6IGZsZXg7Jyk7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxzcGFuIHN0eWxlPVwiZGlzcGxheTogYmxvY2s7XCI+aGVsbG88L3NwYW4+JztcbiAgICB9XG59O1xuLy8gZm9ybVt0YWJpbmRleD0wXVtkaXNhYmxlZF0gc2hvdWxkIGJlIGZvY3VzYWJsZSBhcyB0aGVcbi8vIHNwZWNpZmljYXRpb24gZG9lc24ndCBrbm93IHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUgb24gdGhlIGZvcm0gZWxlbWVudFxuLy8gQHNwZWNpZmljYXRpb24gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjdGhlLWZvcm0tZWxlbWVudFxudmFyIGZvY3VzRm9ybURpc2FibGVkID0ge1xuICAgIGVsZW1lbnQ6ICdmb3JtJyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgICB9XG59O1xuLy8gTk9URTogaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8zNVxuLy8gZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8yMFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLWlzbWFwXG52YXIgZm9jdXNJbWdJc21hcCA9IHtcbiAgICBlbGVtZW50OiAnYScsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmhyZWYgPSAnI3ZvaWQnO1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8aW1nIGlzbWFwIHNyYz1cIicgKyBnaWYgKyAnXCIgYWx0PVwiXCI+JztcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcignaW1nJyk7XG4gICAgfVxufTtcbi8vIE5PVEU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMzVcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWcjYXR0ci11c2VtYXBcbnZhciBmb2N1c0ltZ1VzZW1hcFRhYmluZGV4ID0ge1xuICAgIGVsZW1lbnQ6ICdkaXYnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPVxuICAgICAgICAgICAgJzxtYXAgbmFtZT1cImltYWdlLW1hcC10YWJpbmRleC10ZXN0XCI+PGFyZWEgaHJlZj1cIiN2b2lkXCIgc2hhcGU9XCJyZWN0XCIgY29vcmRzPVwiNjMsMTksMTQ0LDQ1XCI+PC9tYXA+JyArXG4gICAgICAgICAgICAgICAgJzxpbWcgdXNlbWFwPVwiI2ltYWdlLW1hcC10YWJpbmRleC10ZXN0XCIgdGFiaW5kZXg9XCItMVwiIGFsdD1cIlwiICcgK1xuICAgICAgICAgICAgICAgICdzcmM9XCInICtcbiAgICAgICAgICAgICAgICBnaWYgK1xuICAgICAgICAgICAgICAgICdcIj4nO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcbiAgICB9XG59O1xudmFyIGZvY3VzSW5IaWRkZW5JZnJhbWUgPSB7XG4gICAgZWxlbWVudDogZnVuY3Rpb24gZWxlbWVudCh3cmFwcGVyLCBfZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIGlmcmFtZSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgLy8gaWZyYW1lIG11c3QgYmUgcGFydCBvZiB0aGUgRE9NIGJlZm9yZSBhY2Nlc3NpbmcgdGhlIGNvbnRlbnRXaW5kb3cgaXMgcG9zc2libGVcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgICAvLyBjcmVhdGUgdGhlIGlmcmFtZSdzIGRlZmF1bHQgZG9jdW1lbnQgKDxodG1sPjxoZWFkPjwvaGVhZD48Ym9keT48L2JvZHk+PC9odG1sPilcbiAgICAgICAgdmFyIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgICAgICAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIGlmcmFtZTtcbiAgICB9LFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGlmcmFtZSkge1xuICAgICAgICBpZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICB2YXIgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgdmFyIGlucHV0ID0gaWZyYW1lRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgaWZyYW1lRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShpZnJhbWUpIHtcbiAgICAgICAgdmFyIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgIHZhciBmb2N1cyA9IGlmcmFtZURvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgICAgIHJldHVybiBpZnJhbWVEb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmb2N1cztcbiAgICB9XG59O1xudmFyIHJlc3VsdCA9ICFwbGF0Zm9ybS5pcy5XRUJLSVQ7XG5mdW5jdGlvbiBmb2N1c0luWmVyb0RpbWVuc2lvbk9iamVjdCgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gRmlyZWZveCBhbGxvd3MgKmFueSogdmFsdWUgYW5kIHRyZWF0cyBpbnZhbGlkIHZhbHVlcyBsaWtlIHRhYmluZGV4PVwiLTFcIlxuLy8gQGJyb3dzZXItaXNzdWUgR2Vja28gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyODA1NFxudmFyIGZvY3VzSW52YWxpZFRhYmluZGV4ID0ge1xuICAgIGVsZW1lbnQ6ICdkaXYnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJ2ludmFsaWQtdmFsdWUnKTtcbiAgICB9XG59O1xudmFyIGZvY3VzTGFiZWxUYWJpbmRleCA9IHtcbiAgICBlbGVtZW50OiAnbGFiZWwnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xuICAgICAgICAvLyBmb3JjZSBsYXlvdXQgaW4gQ2hyb21lIDQ5LCBvdGhlcndpc2UgdGhlIGVsZW1lbnQgd29uJ3QgYmUgZm9jdXNhYmxlXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgICAgIHZhciB2YXJpYWJsZVRvUHJldmVudERlYWRDb2RlRWxpbWluYXRpb24gPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIHJldHVybiBfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWxlbWVudDtcbiAgICB9XG59O1xudmFyIHN2ZyA9ICdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGh0YicgK1xuICAgICdHNXpPbmhzYVc1clBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1TDNoc2FXNXJJaUJwWkQwaWMzWm5JajQ4ZEdWNGRDQjRQU0l4TUNJZ2VUMGlNakFpSUdsa1BTSicgK1xuICAgICd6ZG1jdGJHbHVheTEwWlhoMElqNTBaWGgwUEM5MFpYaDBQand2YzNablBnPT0nO1xuLy8gTm90ZTogSUUxMCBvbiBCcm93c2VyU3RhY2sgZG9lcyBub3QgbGlrZSB0aGlzIHRlc3RcbnZhciBmb2N1c09iamVjdFN2Z0hpZGRlbiA9IHtcbiAgICBlbGVtZW50OiAnb2JqZWN0JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2ltYWdlL3N2Zyt4bWwnKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEnLCBzdmcpO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMjAwJyk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnNTAnKTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgfVxufTtcbi8vIE5vdGU6IElFMTAgb24gQnJvd3NlclN0YWNrIGRvZXMgbm90IGxpa2UgdGhpcyB0ZXN0XG52YXIgZm9jdXNPYmplY3RTdmcgPSB7XG4gICAgbmFtZTogJ2Nhbi1mb2N1cy1vYmplY3Qtc3ZnJyxcbiAgICBlbGVtZW50OiAnb2JqZWN0JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0eXBlJywgJ2ltYWdlL3N2Zyt4bWwnKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEnLCBzdmcpO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMjAwJyk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnNTAnKTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShlbGVtZW50LCBmb2N1c1RhcmdldCwgX2RvY3VtZW50KSB7XG4gICAgICAgIGlmIChwbGF0Zm9ybS5pcy5HRUNLTykge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBzZWVtcyB0byBiZSBoYW5kbGluZyB0aGUgb2JqZWN0IGNyZWF0aW9uIGFzeW5jaHJvbm91c2x5IGFuZCB0aGVyZWJ5IHByb2R1Y2VzIGEgZmFsc2UgbmVnYXRpdmUgdGVzdCByZXN1bHQuXG4gICAgICAgICAgICAvLyBCZWNhdXNlIHdlIGtub3cgRmlyZWZveCBpcyBhYmxlIHRvIGZvY3VzIG9iamVjdCBlbGVtZW50cyByZWZlcmVuY2luZyBTVkdzLCB3ZSBzaW1wbHkgY2hlYXQgYnkgc25pZmZpbmcgdGhlIHVzZXIgYWdlbnQgc3RyaW5nXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gICAgfVxufTtcbi8vIEV2ZXJ5IEVudmlyb25tZW50IGV4Y2VwdCBJRTkgY29uc2lkZXJzIFNXRiBvYmplY3RzIGZvY3VzYWJsZVxudmFyIHJlc3VsdCQxID0gIXBsYXRmb3JtLmlzLklFOTtcbmZ1bmN0aW9uIGZvY3VzT2JqZWN0U3dmKCkge1xuICAgIHJldHVybiByZXN1bHQkMTtcbn1cbnZhciBmb2N1c1JlZGlyZWN0SW1nVXNlbWFwID0ge1xuICAgIGVsZW1lbnQ6ICdkaXYnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPVxuICAgICAgICAgICAgJzxtYXAgbmFtZT1cImZvY3VzLXJlZGlyZWN0LWltZy11c2VtYXBcIj48YXJlYSBocmVmPVwiI3ZvaWRcIiBzaGFwZT1cInJlY3RcIiBjb29yZHM9XCI2MywxOSwxNDQsNDVcIj48L21hcD4nICtcbiAgICAgICAgICAgICAgICAnPGltZyB1c2VtYXA9XCIjZm9jdXMtcmVkaXJlY3QtaW1nLXVzZW1hcFwiIGFsdD1cIlwiICcgK1xuICAgICAgICAgICAgICAgICdzcmM9XCInICtcbiAgICAgICAgICAgICAgICBnaWYgK1xuICAgICAgICAgICAgICAgICdcIj4nO1xuICAgICAgICAvLyBmb2N1cyB0aGUgPGltZz4sIG5vdCB0aGUgPGRpdj5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcignaW1nJyk7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhcmVhJyk7XG4gICAgICAgIHJldHVybiBfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGFyZ2V0O1xuICAgIH1cbn07XG4vLyBzZWUgaHR0cHM6Ly9qc2Jpbi5jb20vbmVuaXJpc2FnZS9lZGl0P2h0bWwsanMsY29uc29sZSxvdXRwdXRcbnZhciBmb2N1c1JlZGlyZWN0TGVnZW5kID0ge1xuICAgIGVsZW1lbnQ6ICdmaWVsZHNldCcsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9XG4gICAgICAgICAgICAnPGxlZ2VuZD5sZWdlbmQ8L2xlZ2VuZD48aW5wdXQgdGFiaW5kZXg9XCItMVwiPjxpbnB1dCB0YWJpbmRleD1cIjBcIj4nO1xuICAgICAgICAvLyB0YWtlIGNhcmUgb2YgZm9jdXMgaW4gdmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGVsZW1lbnQsIGZvY3VzVGFyZ2V0LCBfZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIGZvY3VzYWJsZSA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbdGFiaW5kZXg9XCItMVwiXScpO1xuICAgICAgICB2YXIgdGFiYmFibGUgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3RhYmluZGV4PVwiMFwiXScpO1xuICAgICAgICAvLyBGaXJlZm94IHJlcXVpcmVzIHRoaXMgdGVzdCB0byBmb2N1cyB0aGUgPGZpZWxkc2V0PiBmaXJzdCwgd2hpbGUgdGhpcyBpcyBub3QgbmVjZXNzYXJ5IGluXG4gICAgICAgIC8vIGh0dHBzOi8vanNiaW4uY29tL25lbmlyaXNhZ2UvZWRpdD9odG1sLGpzLGNvbnNvbGUsb3V0cHV0XG4gICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdsZWdlbmQnKS5mb2N1cygpO1xuICAgICAgICByZXR1cm4gKChfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZm9jdXNhYmxlICYmICdmb2N1c2FibGUnKSB8fFxuICAgICAgICAgICAgKF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0YWJiYWJsZSAmJiAndGFiYmFibGUnKSB8fFxuICAgICAgICAgICAgJycpO1xuICAgIH1cbn07XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIxXG52YXIgZm9jdXNTY3JvbGxCb2R5ID0ge1xuICAgIGVsZW1lbnQ6ICdkaXYnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3dpZHRoOiAxMDBweDsgaGVpZ2h0OiA1MHB4OyBvdmVyZmxvdzogYXV0bzsnKTtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPVxuICAgICAgICAgICAgJzxkaXYgc3R5bGU9XCJ3aWR0aDogNTAwcHg7IGhlaWdodDogNDBweDtcIj5zY3JvbGxhYmxlIGNvbnRlbnQ8L2Rpdj4nO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdkaXYnKTtcbiAgICB9XG59O1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8yMVxudmFyIGZvY3VzU2Nyb2xsQ29udGFpbmVyV2l0aG91dE92ZXJmbG93ID0ge1xuICAgIGVsZW1lbnQ6ICdkaXYnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3dpZHRoOiAxMDBweDsgaGVpZ2h0OiA1MHB4OycpO1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9XG4gICAgICAgICAgICAnPGRpdiBzdHlsZT1cIndpZHRoOiA1MDBweDsgaGVpZ2h0OiA0MHB4O1wiPnNjcm9sbGFibGUgY29udGVudDwvZGl2Pic7XG4gICAgfVxufTtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMjFcbnZhciBmb2N1c1Njcm9sbENvbnRhaW5lciA9IHtcbiAgICBlbGVtZW50OiAnZGl2JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHlsZScsICd3aWR0aDogMTAwcHg7IGhlaWdodDogNTBweDsgb3ZlcmZsb3c6IGF1dG87Jyk7XG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICc8ZGl2IHN0eWxlPVwid2lkdGg6IDUwMHB4OyBoZWlnaHQ6IDQwcHg7XCI+c2Nyb2xsYWJsZSBjb250ZW50PC9kaXY+JztcbiAgICB9XG59O1xudmFyIGZvY3VzU3VtbWFyeSA9IHtcbiAgICBlbGVtZW50OiAnZGV0YWlscycsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8c3VtbWFyeT5mb288L3N1bW1hcnk+PHA+Y29udGVudDwvcD4nO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICB9XG59O1xuZnVuY3Rpb24gbWFrZUZvY3VzYWJsZUZvcmVpZ25PYmplY3QoKSB7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZnJhZ21lbnQuaW5uZXJIVE1MID1cbiAgICAgICAgJzxzdmc+PGZvcmVpZ25PYmplY3Qgd2lkdGg9XCIzMFwiIGhlaWdodD1cIjMwXCI+XFxuICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIvPlxcbiAgPC9mb3JlaWduT2JqZWN0Pjwvc3ZnPic7XG4gICAgcmV0dXJuIGZyYWdtZW50LmZpcnN0Q2hpbGQuZmlyc3RDaGlsZDtcbn1cbmZ1bmN0aW9uIGZvY3VzU3ZnRm9yZWlnbk9iamVjdEhhY2soZWxlbWVudCkge1xuICAgIC8vIEVkZ2UxMywgRWRnZTE0OiBmb3JlaWduT2JqZWN0IGZvY3VzIGhhY2tcbiAgICAvLyBodHRwczovL2pzYmluLmNvbS9rdW5laGludWdpL2VkaXQ/aHRtbCxqcyxvdXRwdXRcbiAgICAvLyBodHRwczovL2pzYmluLmNvbS9mYWphZ2kvMy9lZGl0P2h0bWwsanMsb3V0cHV0XG4gICAgdmFyIGlzU3ZnRWxlbWVudCA9IGVsZW1lbnQub3duZXJTVkdFbGVtZW50IHx8IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2Zyc7XG4gICAgaWYgKCFpc1N2Z0VsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBpbmplY3QgYW5kIGZvY3VzIGFuIDxpbnB1dD4gZWxlbWVudCBpbnRvIHRoZSBTVkcgZWxlbWVudCB0byByZWNlaXZlIGZvY3VzXG4gICAgdmFyIGZvcmVpZ25PYmplY3QgPSBtYWtlRm9jdXNhYmxlRm9yZWlnbk9iamVjdCgpO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZm9yZWlnbk9iamVjdCk7XG4gICAgdmFyIGlucHV0ID0gZm9yZWlnbk9iamVjdC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpO1xuICAgIGlucHV0LmZvY3VzKCk7XG4gICAgLy8gdXBvbiBkaXNhYmxpbmcgdGhlIGFjdGl2ZUVsZW1lbnQsIElFIGFuZCBFZGdlXG4gICAgLy8gd2lsbCBub3Qgc2hpZnQgZm9jdXMgdG8gPGJvZHk+IGxpa2UgYWxsIHRoZSBvdGhlclxuICAgIC8vIGJyb3dzZXJzLCBidXQgaW5zdGVhZCBmaW5kIHRoZSBmaXJzdCBmb2N1c2FibGVcbiAgICAvLyBhbmNlc3RvciBhbmQgc2hpZnQgZm9jdXMgdG8gdGhhdFxuICAgIGlucHV0LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAvLyBjbGVhbiB1cFxuICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZm9yZWlnbk9iamVjdCk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZShlbGVtZW50KSB7XG4gICAgcmV0dXJuICgnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI+JyArXG4gICAgICAgIGVsZW1lbnQgK1xuICAgICAgICAnPC9zdmc+Jyk7XG59XG5mdW5jdGlvbiBmb2N1cyhlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQuZm9jdXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuZm9jdXMuY2FsbChlbGVtZW50KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZm9jdXNTdmdGb3JlaWduT2JqZWN0SGFjayhlbGVtZW50KTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZShlbGVtZW50LCBmb2N1c1RhcmdldCwgX2RvY3VtZW50KSB7XG4gICAgZm9jdXMoZm9jdXNUYXJnZXQpO1xuICAgIHJldHVybiBfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZm9jdXNUYXJnZXQ7XG59XG52YXIgZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUgPSB7XG4gICAgZWxlbWVudDogJ2RpdicsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IGdlbmVyYXRlKCc8dGV4dCBmb2N1c2FibGU9XCJ0cnVlXCI+YTwvdGV4dD4nKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGV4dCcpO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlXG59O1xudmFyIGZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUgPSB7XG4gICAgZWxlbWVudDogJ2RpdicsXG4gICAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IGdlbmVyYXRlKCc8dGV4dCB0YWJpbmRleD1cIjBcIj5hPC90ZXh0PicpO1xuICAgICAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0ZXh0Jyk7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGVcbn07XG52YXIgZm9jdXNTdmdOZWdhdGl2ZVRhYmluZGV4QXR0cmlidXRlID0ge1xuICAgIGVsZW1lbnQ6ICdkaXYnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBnZW5lcmF0ZSgnPHRleHQgdGFiaW5kZXg9XCItMVwiPmE8L3RleHQ+Jyk7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RleHQnKTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZVxufTtcbnZhciBmb2N1c1N2Z1VzZVRhYmluZGV4ID0ge1xuICAgIGVsZW1lbnQ6ICdkaXYnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBnZW5lcmF0ZShbXG4gICAgICAgICAgICAnPGcgaWQ9XCJhbGx5LXRlc3QtdGFyZ2V0XCI+PGEgeGxpbms6aHJlZj1cIiN2b2lkXCI+PHRleHQ+bGluazwvdGV4dD48L2E+PC9nPicsXG4gICAgICAgICAgICAnPHVzZSB4bGluazpocmVmPVwiI2FsbHktdGVzdC10YXJnZXRcIiB4PVwiMFwiIHk9XCIwXCIgdGFiaW5kZXg9XCItMVwiIC8+JyxcbiAgICAgICAgXS5qb2luKCcnKSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3VzZScpO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlXG59O1xudmFyIGZvY3VzU3ZnRm9yZWlnbm9iamVjdFRhYmluZGV4ID0ge1xuICAgIGVsZW1lbnQ6ICdkaXYnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBnZW5lcmF0ZSgnPGZvcmVpZ25PYmplY3QgdGFiaW5kZXg9XCItMVwiPjxpbnB1dCB0eXBlPVwidGV4dFwiIC8+PC9mb3JlaWduT2JqZWN0PicpO1xuICAgICAgICAvLyBTYWZhcmkgOCdzIHF1ZXJzU2VsZWN0b3IoKSBjYW4ndCBpZGVudGlmeSBmb3JlaWduT2JqZWN0LCBidXQgZ2V0RWxlbWVudHlCeVRhZ05hbWUoKSBjYW5cbiAgICAgICAgcmV0dXJuIChlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ZvcmVpZ25PYmplY3QnKSB8fFxuICAgICAgICAgICAgZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZm9yZWlnbk9iamVjdCcpWzBdKTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZVxufTtcbi8vIEZpcmVmb3ggc2VlbXMgdG8gYmUgaGFuZGxpbmcgdGhlIFNWRy1kb2N1bWVudC1pbi1pZnJhbWUgY3JlYXRpb24gYXN5bmNocm9ub3VzbHlcbi8vIGFuZCB0aGVyZWJ5IHByb2R1Y2VzIGEgZmFsc2UgbmVnYXRpdmUgdGVzdCByZXN1bHQuIFRodXMgdGhlIHRlc3QgaXMgcG9pbnRsZXNzXG4vLyBhbmQgd2UgcmVzb3J0IHRvIFVBIHNuaWZmaW5nIG9uY2UgYWdhaW4uXG4vLyBzZWUgaHR0cDovL2pzYmluLmNvbS92dW5hZG9ob2tvLzEvZWRpdD9qcyxjb25zb2xlLG91dHB1dFxudmFyIHJlc3VsdCQyID0gQm9vbGVhbihwbGF0Zm9ybS5pcy5HRUNLTyAmJlxuICAgIHR5cGVvZiBTVkdFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIFNWR0VsZW1lbnQucHJvdG90eXBlLmZvY3VzKTtcbmZ1bmN0aW9uIGZvY3VzU3ZnSW5JZnJhbWUoKSB7XG4gICAgcmV0dXJuIHJlc3VsdCQyO1xufVxudmFyIGZvY3VzU3ZnID0ge1xuICAgIGVsZW1lbnQ6ICdkaXYnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBnZW5lcmF0ZSgnJyk7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGVcbn07XG4vLyBGaXJlZm94IGFsbG93cyAqYW55KiB2YWx1ZSBhbmQgdHJlYXRzIGludmFsaWQgdmFsdWVzIGxpa2UgdGFiaW5kZXg9XCItMVwiXG4vLyBAYnJvd3Nlci1pc3N1ZSBHZWNrbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTI4MDU0XG52YXIgZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVycyA9IHtcbiAgICBlbGVtZW50OiAnZGl2JyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICczeCcpO1xuICAgIH1cbn07XG52YXIgZm9jdXNUYWJsZSA9IHtcbiAgICBlbGVtZW50OiAndGFibGUnLFxuICAgIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQsIHdyYXBwZXIsIF9kb2N1bWVudCkge1xuICAgICAgICAvLyBJRTkgaGFzIGEgcHJvYmxlbSByZXBsYWNpbmcgVEJPRFkgY29udGVudHMgd2l0aCBpbm5lckhUTUwuXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84MDk3MDU1LzUxNTEyNFxuICAgICAgICAvLyBlbGVtZW50LmlubmVySFRNTCA9ICc8dHI+PHRkPmNlbGw8L3RkPjwvdHI+JztcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgZnJhZ21lbnQuaW5uZXJIVE1MID0gJzx0cj48dGQ+Y2VsbDwvdGQ+PC90cj4nO1xuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICB9XG59O1xudmFyIGZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHMgPSB7XG4gICAgZWxlbWVudDogJ3ZpZGVvJyxcbiAgICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBpbnZhbGlkIG1lZGlhIGZpbGUgY2FuIHRyaWdnZXIgd2FybmluZyBpbiBjb25zb2xlLCBkYXRhLXVyaSB0byBwcmV2ZW50IEhUVFAgcmVxdWVzdFxuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NyYycsIGdpZik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElFOSBtYXkgdGhyb3cgXCJFcnJvcjogTm90IGltcGxlbWVudGVkXCJcbiAgICAgICAgfVxuICAgIH1cbn07XG4vLyBodHRwczovL2pzYmluLmNvbS92YWZhYmEvMy9lZGl0P2h0bWwsanMsY29uc29sZSxvdXRwdXRcbnZhciByZXN1bHQkMyA9IHBsYXRmb3JtLmlzLkdFQ0tPIHx8IHBsYXRmb3JtLmlzLlRSSURFTlQgfHwgcGxhdGZvcm0uaXMuRURHRTtcbmZ1bmN0aW9uIHRhYnNlcXVlbmNlQXJlYUF0SW1nUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHJlc3VsdCQzO1xufVxudmFyIHRlc3RDYWxsYmFja3MgPSB7XG4gICAgY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcjogY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcixcbiAgICBmb2N1c0luWmVyb0RpbWVuc2lvbk9iamVjdDogZm9jdXNJblplcm9EaW1lbnNpb25PYmplY3QsXG4gICAgZm9jdXNPYmplY3RTd2Y6IGZvY3VzT2JqZWN0U3dmLFxuICAgIGZvY3VzU3ZnSW5JZnJhbWU6IGZvY3VzU3ZnSW5JZnJhbWUsXG4gICAgdGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvbjogdGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvblxufTtcbnZhciB0ZXN0RGVzY3JpcHRpb25zID0ge1xuICAgIGZvY3VzQXJlYUltZ1RhYmluZGV4OiBmb2N1c0FyZWFJbWdUYWJpbmRleCxcbiAgICBmb2N1c0FyZWFUYWJpbmRleDogZm9jdXNBcmVhVGFiaW5kZXgsXG4gICAgZm9jdXNBcmVhV2l0aG91dEhyZWY6IGZvY3VzQXJlYVdpdGhvdXRIcmVmLFxuICAgIGZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHM6IGZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMsXG4gICAgZm9jdXNCcm9rZW5JbWFnZU1hcDogZm9jdXNCcm9rZW5JbWFnZU1hcCxcbiAgICBmb2N1c0NoaWxkcmVuT2ZGb2N1c2FibGVGbGV4Ym94OiBmb2N1c0NoaWxkcmVuT2ZGb2N1c2FibGVGbGV4Ym94LFxuICAgIGZvY3VzRmllbGRzZXREaXNhYmxlZDogZm9jdXNGaWVsZHNldERpc2FibGVkLFxuICAgIGZvY3VzRmllbGRzZXQ6IGZvY3VzRmllbGRzZXQsXG4gICAgZm9jdXNGbGV4Ym94Q29udGFpbmVyOiBmb2N1c0ZsZXhib3hDb250YWluZXIsXG4gICAgZm9jdXNGb3JtRGlzYWJsZWQ6IGZvY3VzRm9ybURpc2FibGVkLFxuICAgIGZvY3VzSW1nSXNtYXA6IGZvY3VzSW1nSXNtYXAsXG4gICAgZm9jdXNJbWdVc2VtYXBUYWJpbmRleDogZm9jdXNJbWdVc2VtYXBUYWJpbmRleCxcbiAgICBmb2N1c0luSGlkZGVuSWZyYW1lOiBmb2N1c0luSGlkZGVuSWZyYW1lLFxuICAgIGZvY3VzSW52YWxpZFRhYmluZGV4OiBmb2N1c0ludmFsaWRUYWJpbmRleCxcbiAgICBmb2N1c0xhYmVsVGFiaW5kZXg6IGZvY3VzTGFiZWxUYWJpbmRleCxcbiAgICBmb2N1c09iamVjdFN2ZzogZm9jdXNPYmplY3RTdmcsXG4gICAgZm9jdXNPYmplY3RTdmdIaWRkZW46IGZvY3VzT2JqZWN0U3ZnSGlkZGVuLFxuICAgIGZvY3VzUmVkaXJlY3RJbWdVc2VtYXA6IGZvY3VzUmVkaXJlY3RJbWdVc2VtYXAsXG4gICAgZm9jdXNSZWRpcmVjdExlZ2VuZDogZm9jdXNSZWRpcmVjdExlZ2VuZCxcbiAgICBmb2N1c1Njcm9sbEJvZHk6IGZvY3VzU2Nyb2xsQm9keSxcbiAgICBmb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdzogZm9jdXNTY3JvbGxDb250YWluZXJXaXRob3V0T3ZlcmZsb3csXG4gICAgZm9jdXNTY3JvbGxDb250YWluZXI6IGZvY3VzU2Nyb2xsQ29udGFpbmVyLFxuICAgIGZvY3VzU3VtbWFyeTogZm9jdXNTdW1tYXJ5LFxuICAgIGZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlOiBmb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZSxcbiAgICBmb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlOiBmb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlLFxuICAgIGZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZTogZm9jdXNTdmdOZWdhdGl2ZVRhYmluZGV4QXR0cmlidXRlLFxuICAgIGZvY3VzU3ZnVXNlVGFiaW5kZXg6IGZvY3VzU3ZnVXNlVGFiaW5kZXgsXG4gICAgZm9jdXNTdmdGb3JlaWdub2JqZWN0VGFiaW5kZXg6IGZvY3VzU3ZnRm9yZWlnbm9iamVjdFRhYmluZGV4LFxuICAgIGZvY3VzU3ZnOiBmb2N1c1N2ZyxcbiAgICBmb2N1c1RhYmluZGV4VHJhaWxpbmdDaGFyYWN0ZXJzOiBmb2N1c1RhYmluZGV4VHJhaWxpbmdDaGFyYWN0ZXJzLFxuICAgIGZvY3VzVGFibGU6IGZvY3VzVGFibGUsXG4gICAgZm9jdXNWaWRlb1dpdGhvdXRDb250cm9sczogZm9jdXNWaWRlb1dpdGhvdXRDb250cm9sc1xufTtcbmZ1bmN0aW9uIGV4ZWN1dGVUZXN0cygpIHtcbiAgICB2YXIgcmVzdWx0cyA9IGRldGVjdEZvY3VzKHRlc3REZXNjcmlwdGlvbnMpO1xuICAgIE9iamVjdC5rZXlzKHRlc3RDYWxsYmFja3MpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXN1bHRzW2tleV0gPSB0ZXN0Q2FsbGJhY2tzW2tleV0oKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn1cbnZhciBzdXBwb3J0c0NhY2hlID0gbnVsbDtcbmZ1bmN0aW9uIF9zdXBwb3J0cygpIHtcbiAgICBpZiAoc3VwcG9ydHNDYWNoZSkge1xuICAgICAgICByZXR1cm4gc3VwcG9ydHNDYWNoZTtcbiAgICB9XG4gICAgc3VwcG9ydHNDYWNoZSA9IGNhY2hlJDEuZ2V0KCk7XG4gICAgaWYgKCFzdXBwb3J0c0NhY2hlLnRpbWUpIHtcbiAgICAgICAgY2FjaGUkMS5zZXQoZXhlY3V0ZVRlc3RzKCkpO1xuICAgICAgICBzdXBwb3J0c0NhY2hlID0gY2FjaGUkMS5nZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRzQ2FjaGU7XG59XG52YXIgc3VwcG9ydHMgPSB2b2lkIDA7XG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5mcmFzdHJ1Y3R1cmUuaHRtbCNydWxlcy1mb3ItcGFyc2luZy1pbnRlZ2Vyc1xuLy8gTk9URTogYWxsIGJyb3dzZXJzIGFncmVlIHRvIGFsbG93IHRyYWlsaW5nIHNwYWNlcyBhcyB3ZWxsXG52YXIgdmFsaWRJbnRlZ2VyUGF0dGVybk5vVHJhaWxpbmcgPSAvXlxccyooLXxcXCspP1swLTldK1xccyokLztcbnZhciB2YWxpZEludGVnZXJQYXR0ZXJuV2l0aFRyYWlsaW5nID0gL15cXHMqKC18XFwrKT9bMC05XSsuKiQvO1xuZnVuY3Rpb24gaXNWYWxpZFRhYmluZGV4KGNvbnRleHQpIHtcbiAgICBpZiAoIXN1cHBvcnRzKSB7XG4gICAgICAgIHN1cHBvcnRzID0gX3N1cHBvcnRzKCk7XG4gICAgfVxuICAgIHZhciB2YWxpZEludGVnZXJQYXR0ZXJuID0gc3VwcG9ydHMuZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVyc1xuICAgICAgICA/IHZhbGlkSW50ZWdlclBhdHRlcm5XaXRoVHJhaWxpbmdcbiAgICAgICAgOiB2YWxpZEludGVnZXJQYXR0ZXJuTm9UcmFpbGluZztcbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHRUb0VsZW1lbnQoe1xuICAgICAgICBsYWJlbDogJ2lzL3ZhbGlkLXRhYmluZGV4JyxcbiAgICAgICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfSk7XG4gICAgLy8gRWRnZSAxNCBoYXMgYSBjYXBpdGFsaXphdGlvbiBwcm9ibGVtIG9uIFNWRyBlbGVtZW50cyxcbiAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvOTI4MjA1OC9cbiAgICB2YXIgaGFzVGFiaW5kZXggPSBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB2YXIgaGFzVGFiSW5kZXggPSBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICBpZiAoIWhhc1RhYmluZGV4ICYmICFoYXNUYWJJbmRleCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG9sZGVyIEZpcmVmb3ggYW5kIEludGVybmV0IEV4cGxvcmVyIGRvbid0IHN1cHBvcnQgdGFiaW5kZXggb24gU1ZHIGVsZW1lbnRzXG4gICAgdmFyIGlzU3ZnRWxlbWVudCA9IGVsZW1lbnQub3duZXJTVkdFbGVtZW50IHx8IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2Zyc7XG4gICAgaWYgKGlzU3ZnRWxlbWVudCAmJiAhc3VwcG9ydHMuZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEBicm93c2VyLWlzc3VlIEdlY2tvIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExMjgwNTRcbiAgICBpZiAoc3VwcG9ydHMuZm9jdXNJbnZhbGlkVGFiaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIGFuIGVsZW1lbnQgbWF0Y2hlcyB0aGUgdGFiaW5kZXggc2VsZWN0b3IgZXZlbiBpZiBpdHMgdmFsdWUgaXMgaW52YWxpZFxuICAgIHZhciB0YWJpbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGhhc1RhYmluZGV4ID8gJ3RhYmluZGV4JyA6ICd0YWJJbmRleCcpO1xuICAgIC8vIElFMTEgcGFyc2VzIHRhYmluZGV4PVwiXCIgYXMgdGhlIHZhbHVlIFwiLTMyNzY4XCJcbiAgICAvLyBAYnJvd3Nlci1pc3N1ZSBUcmlkZW50IGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTA3Mjk2NVxuICAgIGlmICh0YWJpbmRleCA9PT0gJy0zMjc2OCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gQm9vbGVhbih0YWJpbmRleCAmJiB2YWxpZEludGVnZXJQYXR0ZXJuLnRlc3QodGFiaW5kZXgpKTtcbn1cbmZ1bmN0aW9uIHRhYmluZGV4VmFsdWUoZWxlbWVudCkge1xuICAgIGlmICghaXNWYWxpZFRhYmluZGV4KGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBFZGdlIDE0IGhhcyBhIGNhcGl0YWxpemF0aW9uIHByb2JsZW0gb24gU1ZHIGVsZW1lbnRzLFxuICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy85MjgyMDU4L1xuICAgIHZhciBoYXNUYWJpbmRleCA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gaGFzVGFiaW5kZXggPyAndGFiaW5kZXgnIDogJ3RhYkluZGV4JztcbiAgICAvLyBAYnJvd3Nlci1pc3N1ZSBHZWNrbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTI4MDU0XG4gICAgdmFyIHRhYmluZGV4ID0gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSksIDEwKTtcbiAgICByZXR1cm4gaXNOYU4odGFiaW5kZXgpID8gLTEgOiB0YWJpbmRleDtcbn1cbi8vIHRoaXMgaXMgYSBzaGFyZWQgdXRpbGl0eSBmaWxlIGZvciBmb2N1cy1yZWxldmFudC5qcyBhbmQgdGFiYmFibGUuanNcbi8vIHNlcGFyYXRlIHRlc3Rpbmcgb2YgdGhpcyBmaWxlJ3MgZnVuY3Rpb25zIGlzIG5vdCBuZWNlc3NhcnksXG4vLyBhcyB0aGV5J3JlIGltcGxpY2l0bHkgdGVzdGVkIGJ5IHdheSBvZiB0aGUgY29uc3VtZXJzXG5mdW5jdGlvbiBpc1VzZXJNb2RpZnlXcml0YWJsZShzdHlsZSkge1xuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8xOTk5L1dELWNzczMtdXNlcmludC0xOTk5MDkxNiN1c2VyLW1vZGlmeVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMTdcbiAgICB2YXIgdXNlck1vZGlmeSA9IHN0eWxlLndlYmtpdFVzZXJNb2RpZnkgfHwgJyc7XG4gICAgcmV0dXJuIEJvb2xlYW4odXNlck1vZGlmeSAmJiB1c2VyTW9kaWZ5LmluZGV4T2YoJ3dyaXRlJykgIT09IC0xKTtcbn1cbmZ1bmN0aW9uIGhhc0Nzc092ZXJmbG93U2Nyb2xsKHN0eWxlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cnKSxcbiAgICAgICAgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cteCcpLFxuICAgICAgICBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdy15JyksXG4gICAgXS5zb21lKGZ1bmN0aW9uIChvdmVyZmxvdykge1xuICAgICAgICByZXR1cm4gb3ZlcmZsb3cgPT09ICdhdXRvJyB8fCBvdmVyZmxvdyA9PT0gJ3Njcm9sbCc7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYXNDc3NEaXNwbGF5RmxleChzdHlsZSkge1xuICAgIHJldHVybiBzdHlsZS5kaXNwbGF5LmluZGV4T2YoJ2ZsZXgnKSA+IC0xO1xufVxuZnVuY3Rpb24gaXNTY3JvbGxhYmxlQ29udGFpbmVyKGVsZW1lbnQsIG5vZGVOYW1lLCBwYXJlbnROb2RlTmFtZSwgcGFyZW50U3R5bGUpIHtcbiAgICBpZiAobm9kZU5hbWUgIT09ICdkaXYnICYmIG5vZGVOYW1lICE9PSAnc3BhbicpIHtcbiAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgYWR2YW5jZXMgc2Nyb2xsYWJsZSBjb250YWluZXJzIGFuZCBib2RpZXMgdG8gZm9jdXNhYmxlXG4gICAgICAgIC8vIG9ubHkgaWYgdGhlIHNjcm9sbGFibGUgY29udGFpbmVyIGlzIDxkaXY+IG9yIDxzcGFuPiAtIHRoaXMgZG9lcyAqbm90KlxuICAgICAgICAvLyBoYXBwZW4gZm9yIDxzZWN0aW9uPiwgPGFydGljbGU+LCDigKZcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGFyZW50Tm9kZU5hbWUgJiZcbiAgICAgICAgcGFyZW50Tm9kZU5hbWUgIT09ICdkaXYnICYmXG4gICAgICAgIHBhcmVudE5vZGVOYW1lICE9PSAnc3BhbicgJiZcbiAgICAgICAgIWhhc0Nzc092ZXJmbG93U2Nyb2xsKHBhcmVudFN0eWxlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoZWxlbWVudC5vZmZzZXRIZWlnaHQgPCBlbGVtZW50LnNjcm9sbEhlaWdodCB8fFxuICAgICAgICBlbGVtZW50Lm9mZnNldFdpZHRoIDwgZWxlbWVudC5zY3JvbGxXaWR0aCk7XG59XG52YXIgc3VwcG9ydHMkMSA9IHZvaWQgMDtcbmZ1bmN0aW9uIGlzRm9jdXNSZWxldmFudFJ1bGVzKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSwgY29udGV4dCA9IF9yZWYuY29udGV4dCwgX3JlZiRleGNlcHQgPSBfcmVmLmV4Y2VwdCwgZXhjZXB0ID0gX3JlZiRleGNlcHQgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGZsZXhib3g6IGZhbHNlLFxuICAgICAgICAgICAgc2Nyb2xsYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBzaGFkb3c6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgOiBfcmVmJGV4Y2VwdDtcbiAgICBpZiAoIXN1cHBvcnRzJDEpIHtcbiAgICAgICAgc3VwcG9ydHMkMSA9IF9zdXBwb3J0cygpO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHRUb0VsZW1lbnQoe1xuICAgICAgICBsYWJlbDogJ2lzL2ZvY3VzLXJlbGV2YW50JyxcbiAgICAgICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfSk7XG4gICAgaWYgKCFleGNlcHQuc2hhZG93ICYmIGVsZW1lbnQuc2hhZG93Um9vdCkge1xuICAgICAgICAvLyBhIFNoYWRvd0RPTSBob3N0IHJlY2VpdmVzIGZvY3VzIHdoZW4gdGhlIGZvY3VzIG1vdmVzIHRvIGl0cyBjb250ZW50XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW1lbnQudHlwZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgLy8gaW5wdXRbdHlwZT1cImhpZGRlblwiXSBzdXBwb3J0cy5jYW5ub3QgYmUgZm9jdXNlZFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0JyB8fFxuICAgICAgICBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHxcbiAgICAgICAgbm9kZU5hbWUgPT09ICdidXR0b24nIHx8XG4gICAgICAgIG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZU5hbWUgPT09ICdsZWdlbmQnICYmIHN1cHBvcnRzJDEuZm9jdXNSZWRpcmVjdExlZ2VuZCkge1xuICAgICAgICAvLyBzcGVjaWZpY3MgZmlsdGVyZWQgaW4gaXMvZm9jdXNhYmxlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZU5hbWUgPT09ICdsYWJlbCcpIHtcbiAgICAgICAgLy8gc3BlY2lmaWNzIGZpbHRlcmVkIGluIGlzL2ZvY3VzYWJsZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAnYXJlYScpIHtcbiAgICAgICAgLy8gc3BlY2lmaWNzIGZpbHRlcmVkIGluIGlzL2ZvY3VzYWJsZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAnYScgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAnb2JqZWN0JyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndXNlbWFwJykpIHtcbiAgICAgICAgLy8gb2JqZWN0W3VzZW1hcF0gaXMgbm90IGZvY3VzYWJsZSBpbiBhbnkgYnJvd3NlclxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIHN2Z1R5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgICBpZiAoIXN1cHBvcnRzJDEuZm9jdXNPYmplY3RTdmcgJiYgc3ZnVHlwZSA9PT0gJ2ltYWdlL3N2Zyt4bWwnKSB7XG4gICAgICAgICAgICAvLyBvYmplY3RbdHlwZT1cImltYWdlL3N2Zyt4bWxcIl0gaXMgbm90IGZvY3VzYWJsZSBpbiBJbnRlcm5ldCBFeHBsb3JlclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFzdXBwb3J0cyQxLmZvY3VzT2JqZWN0U3dmICYmXG4gICAgICAgICAgICBzdmdUeXBlID09PSAnYXBwbGljYXRpb24veC1zaG9ja3dhdmUtZmxhc2gnKSB7XG4gICAgICAgICAgICAvLyBvYmplY3RbdHlwZT1cImFwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoXCJdIGlzIG5vdCBmb2N1c2FibGUgaW4gSW50ZXJuZXQgRXhwbG9yZXIgOVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gJ2lmcmFtZScgfHwgbm9kZU5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIGJyb3dzaW5nIGNvbnRleHQgY29udGFpbmVyc1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAnZW1iZWQnIHx8IG5vZGVOYW1lID09PSAna2V5Z2VuJykge1xuICAgICAgICAvLyBlbWJlZCBpcyBjb25zaWRlcmVkIGZvY3VzLXJlbGV2YW50IGJ1dCBub3QgZm9jdXNhYmxlXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzgyXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XG4gICAgICAgIC8vIGFsc28gc2VlIENTUyBwcm9wZXJ0eSB1c2VyLW1vZGlmeSBiZWxvd1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAnYXVkaW8nICYmXG4gICAgICAgIChzdXBwb3J0cyQxLmZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRyb2xzJykpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZU5hbWUgPT09ICd2aWRlbycgJiZcbiAgICAgICAgKHN1cHBvcnRzJDEuZm9jdXNWaWRlb1dpdGhvdXRDb250cm9scyB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udHJvbHMnKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0cyQxLmZvY3VzU3VtbWFyeSAmJiBub2RlTmFtZSA9PT0gJ3N1bW1hcnknKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgdmFsaWRUYWJpbmRleCA9IGlzVmFsaWRUYWJpbmRleChlbGVtZW50KTtcbiAgICBpZiAobm9kZU5hbWUgPT09ICdpbWcnICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCd1c2VtYXAnKSkge1xuICAgICAgICAvLyBHZWNrbywgVHJpZGVudCBhbmQgRWRnZSBkbyBub3QgYWxsb3cgYW4gaW1hZ2Ugd2l0aCBhbiBpbWFnZSBtYXAgYW5kIHRhYmluZGV4IHRvIGJlIGZvY3VzZWQsXG4gICAgICAgIC8vIGl0IGFwcGVhcnMgdGhlIHRhYmluZGV4IGlzIG92ZXJydWxlZCBzbyBmb2N1cyBpcyBzdGlsbCBmb3J3YXJkZWQgdG8gdGhlIDxtYXA+XG4gICAgICAgIHJldHVybiAoKHZhbGlkVGFiaW5kZXggJiYgc3VwcG9ydHMkMS5mb2N1c0ltZ1VzZW1hcFRhYmluZGV4KSB8fFxuICAgICAgICAgICAgc3VwcG9ydHMkMS5mb2N1c1JlZGlyZWN0SW1nVXNlbWFwKTtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnRzJDEuZm9jdXNUYWJsZSAmJiAobm9kZU5hbWUgPT09ICd0YWJsZScgfHwgbm9kZU5hbWUgPT09ICd0ZCcpKSB7XG4gICAgICAgIC8vIElFMTAtMTEgc3VwcG9ydHMuY2FuIGZvY3VzIDx0YWJsZT4gYW5kIDx0ZD5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0cyQxLmZvY3VzRmllbGRzZXQgJiYgbm9kZU5hbWUgPT09ICdmaWVsZHNldCcpIHtcbiAgICAgICAgLy8gSUUxMC0xMSBzdXBwb3J0cy5jYW4gZm9jdXMgPGZpZWxkc2V0PlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGlzU3ZnRWxlbWVudCA9IG5vZGVOYW1lID09PSAnc3ZnJztcbiAgICB2YXIgaXNTdmdDb250ZW50ID0gZWxlbWVudC5vd25lclNWR0VsZW1lbnQ7XG4gICAgdmFyIGZvY3VzYWJsZUF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdmb2N1c2FibGUnKTtcbiAgICB2YXIgdGFiaW5kZXggPSB0YWJpbmRleFZhbHVlKGVsZW1lbnQpO1xuICAgIGlmIChub2RlTmFtZSA9PT0gJ3VzZScgJiZcbiAgICAgICAgdGFiaW5kZXggIT09IG51bGwgJiZcbiAgICAgICAgIXN1cHBvcnRzJDEuZm9jdXNTdmdVc2VUYWJpbmRleCkge1xuICAgICAgICAvLyA8dXNlPiBjYW5ub3QgYmUgbWFkZSBmb2N1c2FibGUgYnkgYWRkaW5nIGEgdGFiaW5kZXggYXR0cmlidXRlIGFueXdoZXJlIGJ1dCBCbGluayBhbmQgV2ViS2l0XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAnZm9yZWlnbm9iamVjdCcpIHtcbiAgICAgICAgLy8gPHVzZT4gY2FuIG9ubHkgYmUgbWFkZSBmb2N1c2FibGUgaW4gQmxpbmsgYW5kIFdlYktpdFxuICAgICAgICByZXR1cm4gdGFiaW5kZXggIT09IG51bGwgJiYgc3VwcG9ydHMkMS5mb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnRNYXRjaGVzKGVsZW1lbnQsICdzdmcgYScpICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCd4bGluazpocmVmJykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgoaXNTdmdFbGVtZW50IHx8IGlzU3ZnQ29udGVudCkgJiZcbiAgICAgICAgZWxlbWVudC5mb2N1cyAmJlxuICAgICAgICAhc3VwcG9ydHMkMS5mb2N1c1N2Z05lZ2F0aXZlVGFiaW5kZXhBdHRyaWJ1dGUgJiZcbiAgICAgICAgdGFiaW5kZXggPCAwKSB7XG4gICAgICAgIC8vIEZpcmVmb3ggNTEgYW5kIDUyIHRyZWF0IGFueSBuYXRpdmVseSB0YWJiYWJsZSBTVkcgZWxlbWVudCB3aXRoXG4gICAgICAgIC8vIHRhYmluZGV4PVwiLTFcIiBhcyB0YWJiYWJsZSBhbmQgZXZlcnl0aGluZyBlbHNlIGFzIGluZXJ0XG4gICAgICAgIC8vIHNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzAyMzQwXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzU3ZnRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gKHZhbGlkVGFiaW5kZXggfHxcbiAgICAgICAgICAgIHN1cHBvcnRzJDEuZm9jdXNTdmcgfHxcbiAgICAgICAgICAgIHN1cHBvcnRzJDEuZm9jdXNTdmdJbklmcmFtZSB8fFxuICAgICAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgdW5kZXJzdGFuZHMgdGhlIGZvY3VzYWJsZSBhdHRyaWJ1dGUgaW50cm9kdWNlZCBpbiBTVkcgVGlueSAxLjJcbiAgICAgICAgICAgIEJvb2xlYW4oc3VwcG9ydHMkMS5mb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZSAmJlxuICAgICAgICAgICAgICAgIGZvY3VzYWJsZUF0dHJpYnV0ZSAmJlxuICAgICAgICAgICAgICAgIGZvY3VzYWJsZUF0dHJpYnV0ZSA9PT0gJ3RydWUnKSk7XG4gICAgfVxuICAgIGlmIChpc1N2Z0NvbnRlbnQpIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzJDEuZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZSAmJiB2YWxpZFRhYmluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VwcG9ydHMkMS5mb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgdW5kZXJzdGFuZHMgdGhlIGZvY3VzYWJsZSBhdHRyaWJ1dGUgaW50cm9kdWNlZCBpbiBTVkcgVGlueSAxLjJcbiAgICAgICAgICAgIHJldHVybiBmb2N1c2FibGVBdHRyaWJ1dGUgPT09ICd0cnVlJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZWRpdGluZy5odG1sI3NlcXVlbnRpYWwtZm9jdXMtbmF2aWdhdGlvbi1hbmQtdGhlLXRhYmluZGV4LWF0dHJpYnV0ZVxuICAgIGlmICh2YWxpZFRhYmluZGV4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgICBpZiAoaXNVc2VyTW9kaWZ5V3JpdGFibGUoc3R5bGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHMkMS5mb2N1c0ltZ0lzbWFwICYmXG4gICAgICAgIG5vZGVOYW1lID09PSAnaW1nJyAmJlxuICAgICAgICBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaXNtYXAnKSkge1xuICAgICAgICAvLyBJRTEwLTExIGNvbnNpZGVycyB0aGUgPGltZz4gaW4gPGEgaHJlZj48aW1nIGlzbWFwPiBmb2N1c2FibGVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8yMFxuICAgICAgICB2YXIgaGFzTGlua1BhcmVudCA9IGdldFBhcmVudHMoeyBjb250ZXh0OiBlbGVtZW50IH0pLnNvbWUoZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIChwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnICYmIHBhcmVudC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzTGlua1BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8yMVxuICAgIGlmICghZXhjZXB0LnNjcm9sbGFibGUgJiYgc3VwcG9ydHMkMS5mb2N1c1Njcm9sbENvbnRhaW5lcikge1xuICAgICAgICBpZiAoc3VwcG9ydHMkMS5mb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdykge1xuICAgICAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgZG9lcyB3aWxsIGNvbnNpZGVyIHRoZSBzY3JvbGxhYmxlIGFyZWEgZm9jdXNhYmxlXG4gICAgICAgICAgICAvLyBpZiB0aGUgZWxlbWVudCBpcyBhIDxkaXY+IG9yIGEgPHNwYW4+IGFuZCBpdCBpcyBpbiBmYWN0IHNjcm9sbGFibGUsXG4gICAgICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHRoZSBDU1Mgb3ZlcmZsb3cgcHJvcGVydHlcbiAgICAgICAgICAgIGlmIChpc1Njcm9sbGFibGVDb250YWluZXIoZWxlbWVudCwgbm9kZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzQ3NzT3ZlcmZsb3dTY3JvbGwoc3R5bGUpKSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IHJlcXVpcmVzIHByb3BlciBvdmVyZmxvdyBzZXR0aW5nLCBJRSBkb2VzIG5vdCBuZWNlc3NhcmlseVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL292ZXJmbG93XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWV4Y2VwdC5mbGV4Ym94ICYmXG4gICAgICAgIHN1cHBvcnRzJDEuZm9jdXNGbGV4Ym94Q29udGFpbmVyICYmXG4gICAgICAgIGhhc0Nzc0Rpc3BsYXlGbGV4KHN0eWxlKSkge1xuICAgICAgICAvLyBlbGVtZW50cyB3aXRoIGRpc3BsYXk6ZmxleCBhcmUgZm9jdXNhYmxlIGluIElFMTAtMTFcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKCFleGNlcHQuc2Nyb2xsYWJsZSAmJiBwYXJlbnQpIHtcbiAgICAgICAgdmFyIHBhcmVudE5vZGVOYW1lID0gcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBwYXJlbnRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudCwgbnVsbCk7XG4gICAgICAgIGlmIChzdXBwb3J0cyQxLmZvY3VzU2Nyb2xsQm9keSAmJlxuICAgICAgICAgICAgaXNTY3JvbGxhYmxlQ29udGFpbmVyKHBhcmVudCwgbm9kZU5hbWUsIHBhcmVudE5vZGVOYW1lLCBwYXJlbnRTdHlsZSkpIHtcbiAgICAgICAgICAgIC8vIHNjcm9sbGFibGUgYm9kaWVzIGFyZSBmb2N1c2FibGUgSW50ZXJuZXQgRXhwbG9yZXJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMjFcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoaWxkcmVuIG9mIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoIGRpc3BsYXk6ZmxleCBhcmUgZm9jdXNhYmxlIGluIElFMTAtMTFcbiAgICAgICAgaWYgKHN1cHBvcnRzJDEuZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveCkge1xuICAgICAgICAgICAgaWYgKGhhc0Nzc0Rpc3BsYXlGbGV4KHBhcmVudFN0eWxlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5PVEU6IGVsZW1lbnRzIG1hcmtlZCBhcyBpbmVydCBhcmUgbm90IGZvY3VzYWJsZSxcbiAgICAvLyBidXQgdGhhdCBwcm9wZXJ0eSBpcyBub3QgZXhwb3NlZCB0byB0aGUgRE9NXG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNpbmVydFxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIGJpbmQgZXhjZXB0aW9ucyB0byBhbiBpdGVyYXRvciBjYWxsYmFja1xuaXNGb2N1c1JlbGV2YW50UnVsZXMuZXhjZXB0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBleGNlcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBpc0ZvY3VzUmVsZXZhbnQgPSBmdW5jdGlvbiBpc0ZvY3VzUmVsZXZhbnQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gaXNGb2N1c1JlbGV2YW50UnVsZXMoe1xuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIGV4Y2VwdDogZXhjZXB0XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaXNGb2N1c1JlbGV2YW50LnJ1bGVzID0gaXNGb2N1c1JlbGV2YW50UnVsZXM7XG4gICAgcmV0dXJuIGlzRm9jdXNSZWxldmFudDtcbn07XG4vLyBwcm92aWRlIGlzRm9jdXNSZWxldmFudChjb250ZXh0KSBhcyBkZWZhdWx0IGl0ZXJhdG9yIGNhbGxiYWNrXG52YXIgaXNGb2N1c1JlbGV2YW50ID0gaXNGb2N1c1JlbGV2YW50UnVsZXMuZXhjZXB0KHt9KTtcbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgY2FsbGJhY2spIHtcbiAgICAvLyBhdHRlbXB0IHRvIHVzZSBuYXRpdmUgb3IgcG9seWZpbGxlZCBBcnJheSNmaW5kSW5kZXggZmlyc3RcbiAgICBpZiAoYXJyYXkuZmluZEluZGV4KSB7XG4gICAgICAgIHJldHVybiBhcnJheS5maW5kSW5kZXgoY2FsbGJhY2spO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIC8vIHNob3J0Y3V0IGlmIHRoZSBhcnJheSBpcyBlbXB0eVxuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2UgbG9vcCBvdmVyIGFycmF5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY2FsbGJhY2soYXJyYXlbaV0sIGksIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZ2V0Q29udGVudERvY3VtZW50KG5vZGUpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyB3b3JrcyBvbiA8b2JqZWN0PiBhbmQgPGlmcmFtZT5cbiAgICAgICAgcmV0dXJuIChub2RlLmNvbnRlbnREb2N1bWVudCB8fFxuICAgICAgICAgICAgLy8gd29ya3Mgb24gPG9iamVjdD4gYW5kIDxpZnJhbWU+XG4gICAgICAgICAgICAobm9kZS5jb250ZW50V2luZG93ICYmIG5vZGUuY29udGVudFdpbmRvdy5kb2N1bWVudCkgfHxcbiAgICAgICAgICAgIC8vIHdvcmtzIG9uIDxvYmplY3Q+IGFuZCA8aWZyYW1lPiB0aGF0IGNvbnRhaW4gU1ZHXG4gICAgICAgICAgICAobm9kZS5nZXRTVkdEb2N1bWVudCAmJiBub2RlLmdldFNWR0RvY3VtZW50KCkpIHx8XG4gICAgICAgICAgICBudWxsKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gU2VjdXJpdHlFcnJvcjogRmFpbGVkIHRvIHJlYWQgdGhlICdjb250ZW50RG9jdW1lbnQnIHByb3BlcnR5IGZyb20gJ0hUTUxPYmplY3RFbGVtZW50J1xuICAgICAgICAvLyBhbHNvIElFIG1heSB0aHJvdyBtZW1iZXIgbm90IGZvdW5kIGV4Y2VwdGlvbiBlLmcuIG9uIDxvYmplY3QgdHlwZT1cImltYWdlL3BuZ1wiPlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICAgIHZhciBfZG9jdW1lbnQgPSBnZXREb2N1bWVudChub2RlKTtcbiAgICByZXR1cm4gX2RvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbn1cbnZhciBzaGFkb3dQcmVmaXggPSB2b2lkIDA7XG5mdW5jdGlvbiBzZWxlY3RJblNoYWRvd3Moc2VsZWN0b3IpIHtcbiAgICBpZiAodHlwZW9mIHNoYWRvd1ByZWZpeCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIG9wZXJhdG9yID0gY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcigpO1xuICAgICAgICBpZiAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgIHNoYWRvd1ByZWZpeCA9ICcsIGh0bWwgJyArIG9wZXJhdG9yICsgJyAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghc2hhZG93UHJlZml4KSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIChzZWxlY3RvciArXG4gICAgICAgIHNoYWRvd1ByZWZpeCArXG4gICAgICAgIHNlbGVjdG9yXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzKixcXHMqL2csICcsJylcbiAgICAgICAgICAgIC5zcGxpdCgnLCcpXG4gICAgICAgICAgICAuam9pbihzaGFkb3dQcmVmaXgpKTtcbn1cbnZhciBzZWxlY3RvciA9IHZvaWQgMDtcbmZ1bmN0aW9uIGZpbmREb2N1bWVudEhvc3RFbGVtZW50KF93aW5kb3cpIHtcbiAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0SW5TaGFkb3dzKCdvYmplY3QsIGlmcmFtZScpO1xuICAgIH1cbiAgICBpZiAoX3dpbmRvdy5fZnJhbWVFbGVtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIF93aW5kb3cuX2ZyYW1lRWxlbWVudDtcbiAgICB9XG4gICAgX3dpbmRvdy5fZnJhbWVFbGVtZW50ID0gbnVsbDtcbiAgICB2YXIgcG90ZW50aWFsSG9zdHMgPSBfd2luZG93LnBhcmVudC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICBbXS5zb21lLmNhbGwocG90ZW50aWFsSG9zdHMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBfZG9jdW1lbnQgPSBnZXRDb250ZW50RG9jdW1lbnQoZWxlbWVudCk7XG4gICAgICAgIGlmIChfZG9jdW1lbnQgIT09IF93aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBfd2luZG93Ll9mcmFtZUVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3dpbmRvdy5fZnJhbWVFbGVtZW50O1xufVxuZnVuY3Rpb24gZ2V0RnJhbWVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgX3dpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgICBpZiAoIV93aW5kb3cucGFyZW50IHx8IF93aW5kb3cucGFyZW50ID09PSBfd2luZG93KSB7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIHBhcmVudCBicm93c2luZyBjb250ZXh0LFxuICAgICAgICAvLyB3ZSdyZSBub3QgZ29pbmcgdG8gZ2V0IGEgZnJhbWVFbGVtZW50IGVpdGhlciB3YXlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L2ZyYW1lRWxlbWVudFxuICAgICAgICAvLyBkb2VzIG5vdCB3b3JrIHdpdGhpbiA8ZW1iZWQ+IGFueXdoZXJlLCBhbmQgbm90IHdpdGhpbiBpbiA8b2JqZWN0PiBpbiBJRVxuICAgICAgICByZXR1cm4gX3dpbmRvdy5mcmFtZUVsZW1lbnQgfHwgZmluZERvY3VtZW50SG9zdEVsZW1lbnQoX3dpbmRvdyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9yZW5kZXJpbmcuaHRtbCNiZWluZy1yZW5kZXJlZFxuLy8gPGFyZWE+IGlzIG5vdCByZW5kZXJlZCwgYnV0IHdlICpjb25zaWRlciogaXQgdmlzaWJsZSB0byBzaW1wbGZpeSB0aGlzIGZ1bmN0aW9uJ3MgdXNhZ2VcbnZhciBub3RSZW5kZXJlZEVsZW1lbnRzUGF0dGVybiA9IC9eKGFyZWEpJC87XG5mdW5jdGlvbiBjb21wdXRlZFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xufVxuZnVuY3Rpb24gbm90RGlzcGxheWVkKF9wYXRoKSB7XG4gICAgcmV0dXJuIF9wYXRoLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gZGlzcGxheTpub25lIGlzIG5vdCB2aXNpYmxlIChvcHRpbWl6ZWQgYXdheSBhdCBsYXlvdXQpXG4gICAgICAgIHJldHVybiBjb21wdXRlZFN0eWxlKGVsZW1lbnQsICdkaXNwbGF5JykgPT09ICdub25lJztcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vdFZpc2libGUoX3BhdGgpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS11aS9ibG9iL21hc3Rlci91aS9jb3JlLmpzI0wxMDktTDExNFxuICAgIC8vIE5PVEU6IGEgbmVzdGVkIGVsZW1lbnQgY2FuIHJldmVyc2UgdmlzaWJpbGl0eTpoaWRkZW58Y29sbGFwc2UgYnkgZXhwbGljaXRseSBzZXR0aW5nIHZpc2liaWxpdHk6dmlzaWJsZVxuICAgIC8vIE5PVEU6IHZpc2liaWxpdHkgY2FuIGJlIFtcIlwiLCBcInZpc2libGVcIiwgXCJoaWRkZW5cIiwgXCJjb2xsYXBzZVwiXVxuICAgIHZhciBoaWRkZW4gPSBmaW5kSW5kZXgoX3BhdGgsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciB2aXNpYmlsaXR5ID0gY29tcHV0ZWRTdHlsZShlbGVtZW50LCAndmlzaWJpbGl0eScpO1xuICAgICAgICByZXR1cm4gdmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicgfHwgdmlzaWJpbGl0eSA9PT0gJ2NvbGxhcHNlJztcbiAgICB9KTtcbiAgICBpZiAoaGlkZGVuID09PSAtMSkge1xuICAgICAgICAvLyB0aGVyZSBpcyBubyBoaWRkZW4gZWxlbWVudFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB2aXNpYmxlID0gZmluZEluZGV4KF9wYXRoLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gY29tcHV0ZWRTdHlsZShlbGVtZW50LCAndmlzaWJpbGl0eScpID09PSAndmlzaWJsZSc7XG4gICAgfSk7XG4gICAgaWYgKHZpc2libGUgPT09IC0xKSB7XG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIHZpc2libGUgZWxlbWVudCAoYnV0IGEgaGlkZGVuIGVsZW1lbnQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaGlkZGVuIDwgdmlzaWJsZSkge1xuICAgICAgICAvLyB0aGVyZSBpcyBhIGhpZGRlbiBlbGVtZW50IGFuZCBpdCdzIGNsb3NlciB0aGFuIHRoZSBmaXJzdCB2aXNpYmxlIGVsZW1lbnRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIHRoZXJlIG1heSBiZSBhIGhpZGRlbiBlbGVtZW50LCBidXQgdGhlIGNsb3Nlc3QgZWxlbWVudCBpcyB2aXNpYmxlXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sbGFwc2VkUGFyZW50KF9wYXRoKSB7XG4gICAgdmFyIG9mZnNldCA9IDE7XG4gICAgaWYgKF9wYXRoWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdW1tYXJ5Jykge1xuICAgICAgICBvZmZzZXQgPSAyO1xuICAgIH1cbiAgICByZXR1cm4gX3BhdGguc2xpY2Uob2Zmc2V0KS5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIC8vIFwiY29udGVudCBjaGlsZHJlblwiIG9mIGEgY2xvc2VkIGRldGFpbHMgZWxlbWVudCBhcmUgbm90IHZpc2libGVcbiAgICAgICAgcmV0dXJuIChlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdkZXRhaWxzJyAmJiBlbGVtZW50Lm9wZW4gPT09IGZhbHNlKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzVmlzaWJsZVJ1bGVzKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSwgY29udGV4dCA9IF9yZWYuY29udGV4dCwgX3JlZiRleGNlcHQgPSBfcmVmLmV4Y2VwdCwgZXhjZXB0ID0gX3JlZiRleGNlcHQgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIG5vdFJlbmRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNzc0Rpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgY3NzVmlzaWJpbGl0eTogZmFsc2UsXG4gICAgICAgICAgICBkZXRhaWxzRWxlbWVudDogZmFsc2UsXG4gICAgICAgICAgICBicm93c2luZ0NvbnRleHQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgOiBfcmVmJGV4Y2VwdDtcbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHRUb0VsZW1lbnQoe1xuICAgICAgICBsYWJlbDogJ2lzL3Zpc2libGUnLFxuICAgICAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9KTtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCFleGNlcHQubm90UmVuZGVyZWQgJiYgbm90UmVuZGVyZWRFbGVtZW50c1BhdHRlcm4udGVzdChub2RlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBfcGF0aCA9IGdldFBhcmVudHMoeyBjb250ZXh0OiBlbGVtZW50IH0pO1xuICAgIC8vIGluIEludGVybmV0IEV4cGxvcmVyIDxhdWRpbz4gaGFzIGEgZGVmYXVsdCBkaXNwbGF5OiBub25lLCB3aGVyZSBvdGhlcnMgaGF2ZSBkaXNwbGF5OiBpbmxpbmVcbiAgICAvLyBidXQgSUUgYWxsb3dzIGZvY3VzaW5nIDxhdWRpbyBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPiwgYnV0IG5vdCA8ZGl2IGRpc3BsYXk6bm9uZT48YXVkaW8+XG4gICAgLy8gdGhpcyBpcyBpcnJlbGV2YW50IHRvIG90aGVyIGJyb3dzZXJzLCBhcyB0aGUgY29udHJvbHMgYXR0cmlidXRlIGlzIHJlcXVpcmVkIHRvIG1ha2UgPGF1ZGlvPiBmb2N1c2FibGVcbiAgICB2YXIgaXNBdWRpb1dpdGhvdXRDb250cm9scyA9IG5vZGVOYW1lID09PSAnYXVkaW8nICYmICFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udHJvbHMnKTtcbiAgICBpZiAoIWV4Y2VwdC5jc3NEaXNwbGF5ICYmXG4gICAgICAgIG5vdERpc3BsYXllZChpc0F1ZGlvV2l0aG91dENvbnRyb2xzID8gX3BhdGguc2xpY2UoMSkgOiBfcGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWV4Y2VwdC5jc3NWaXNpYmlsaXR5ICYmIG5vdFZpc2libGUoX3BhdGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFleGNlcHQuZGV0YWlsc0VsZW1lbnQgJiYgY29sbGFwc2VkUGFyZW50KF9wYXRoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZXhjZXB0LmJyb3dzaW5nQ29udGV4dCkge1xuICAgICAgICAvLyBlbGVtZW50cyB3aXRoaW4gYSBicm93c2luZyBjb250ZXh0IGFyZSBhZmZlY3RlZCBieSB0aGVcbiAgICAgICAgLy8gYnJvd3NpbmcgY29udGV4dCBob3N0IGVsZW1lbnQncyB2aXNpYmlsaXR5IGFuZCB0YWJpbmRleFxuICAgICAgICB2YXIgZnJhbWVFbGVtZW50ID0gZ2V0RnJhbWVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB2YXIgX2lzVmlzaWJsZSA9IGlzVmlzaWJsZVJ1bGVzLmV4Y2VwdChleGNlcHQpO1xuICAgICAgICBpZiAoZnJhbWVFbGVtZW50ICYmICFfaXNWaXNpYmxlKGZyYW1lRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIGJpbmQgZXhjZXB0aW9ucyB0byBhbiBpdGVyYXRvciBjYWxsYmFja1xuaXNWaXNpYmxlUnVsZXMuZXhjZXB0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBleGNlcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBpc1Zpc2libGUgPSBmdW5jdGlvbiBpc1Zpc2libGUoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gaXNWaXNpYmxlUnVsZXMoe1xuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIGV4Y2VwdDogZXhjZXB0XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaXNWaXNpYmxlLnJ1bGVzID0gaXNWaXNpYmxlUnVsZXM7XG4gICAgcmV0dXJuIGlzVmlzaWJsZTtcbn07XG4vLyBwcm92aWRlIGlzVmlzaWJsZShjb250ZXh0KSBhcyBkZWZhdWx0IGl0ZXJhdG9yIGNhbGxiYWNrXG52YXIgaXNWaXNpYmxlID0gaXNWaXNpYmxlUnVsZXMuZXhjZXB0KHt9KTtcbmZ1bmN0aW9uIGdldE1hcEJ5TmFtZShuYW1lLCBfZG9jdW1lbnQpIHtcbiAgICAvLyBhcHBhcmVudGx5IGdldEVsZW1lbnRzQnlOYW1lKCkgYWxzbyBjb25zaWRlcnMgaWQgYXR0cmlidXRlIGluIElFICYgb3BlcmFcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvZ2V0RWxlbWVudHNCeU5hbWVcbiAgICB2YXIgbWFwID0gX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21hcFtuYW1lPVwiJyArIGNzc19lc2NhcGVfMVtcImRlZmF1bHRcIl0obmFtZSkgKyAnXCJdJyk7XG4gICAgcmV0dXJuIG1hcCB8fCBudWxsO1xufVxuZnVuY3Rpb24gZ2V0SW1hZ2VPZkFyZWEoZWxlbWVudCkge1xuICAgIHZhciBtYXAgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKCFtYXAubmFtZSB8fCBtYXAubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ21hcCcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIE5PVEU6IGltYWdlIG1hcHMgY2FuIGFsc28gYmUgYXBwbGllZCB0byA8b2JqZWN0PiB3aXRoIGltYWdlIGNvbnRlbnQsXG4gICAgLy8gYnV0IG5vIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyBhdCB0aGUgbW9tZW50XG4gICAgLy8gSFRNTDUgc3BlY2lmaWVzIEhUTUxNYXBFbGVtZW50LmltYWdlcyB0byBiZSBhbiBIVE1MQ29sbGVjdGlvbiBvZiBhbGxcbiAgICAvLyA8aW1nPiBhbmQgPG9iamVjdD4gcmVmZXJlbmNpbmcgdGhlIDxtYXA+IGVsZW1lbnQsIGJ1dCBubyBicm93c2VyIGltcGxlbWVudHMgdGhpc1xuICAgIC8vICAgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VtYmVkZGVkLWNvbnRlbnQtMC5odG1sI3RoZS1tYXAtZWxlbWVudFxuICAgIC8vICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNYXBFbGVtZW50XG4gICAgLy8gdGhlIGltYWdlIG11c3QgYmUgdmFsaWQgYW5kIGxvYWRlZCBmb3IgdGhlIG1hcCB0byB0YWtlIGVmZmVjdFxuICAgIHZhciBfZG9jdW1lbnQgPSBnZXREb2N1bWVudChlbGVtZW50KTtcbiAgICByZXR1cm4gKF9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdpbWdbdXNlbWFwPVwiIycgKyBjc3NfZXNjYXBlXzFbXCJkZWZhdWx0XCJdKG1hcC5uYW1lKSArICdcIl0nKSB8fFxuICAgICAgICBudWxsKTtcbn1cbnZhciBzdXBwb3J0cyQyID0gdm9pZCAwO1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L21hcFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLXVzZW1hcFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnktdWkvYmxvYi9tYXN0ZXIvdWkvY29yZS5qcyNMODgtTDEwN1xuZnVuY3Rpb24gaXNWYWxpZEFyZWEoY29udGV4dCkge1xuICAgIGlmICghc3VwcG9ydHMkMikge1xuICAgICAgICBzdXBwb3J0cyQyID0gX3N1cHBvcnRzKCk7XG4gICAgfVxuICAgIHZhciBlbGVtZW50ID0gY29udGV4dFRvRWxlbWVudCh7XG4gICAgICAgIGxhYmVsOiAnaXMvdmFsaWQtYXJlYScsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9KTtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG5vZGVOYW1lICE9PSAnYXJlYScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaGFzVGFiaW5kZXggPSBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICBpZiAoIXN1cHBvcnRzJDIuZm9jdXNBcmVhVGFiaW5kZXggJiYgaGFzVGFiaW5kZXgpIHtcbiAgICAgICAgLy8gQmxpbmsgYW5kIFdlYktpdCBkbyBub3QgY29uc2lkZXIgPGFyZWEgdGFiaW5kZXg9XCItMVwiIGhyZWY9XCIjdm9pZFwiPiBmb2N1c2FibGVcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaW1nID0gZ2V0SW1hZ2VPZkFyZWEoZWxlbWVudCk7XG4gICAgaWYgKCFpbWcgfHwgIWlzVmlzaWJsZShpbWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gRmlyZWZveCBvbmx5IGFsbG93cyBmdWxseSBsb2FkZWQgaW1hZ2VzIHRvIHJlZmVyZW5jZSBpbWFnZSBtYXBzXG4gICAgLy8gaHR0cHM6Ly9zdGVyZW9jaHJvLm1lL2lkZWFzL2RldGVjdGluZy1icm9rZW4taW1hZ2VzLWpzXG4gICAgaWYgKCFzdXBwb3J0cyQyLmZvY3VzQnJva2VuSW1hZ2VNYXAgJiZcbiAgICAgICAgKCFpbWcuY29tcGxldGUgfHxcbiAgICAgICAgICAgICFpbWcubmF0dXJhbEhlaWdodCB8fFxuICAgICAgICAgICAgaW1nLm9mZnNldFdpZHRoIDw9IDAgfHxcbiAgICAgICAgICAgIGltZy5vZmZzZXRIZWlnaHQgPD0gMCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBGaXJlZm94IHN1cHBvcnRzLmNhbiBmb2N1cyBhcmVhIGVsZW1lbnRzIGV2ZW4gaWYgdGhleSBkb24ndCBoYXZlIGFuIGhyZWYgYXR0cmlidXRlXG4gICAgaWYgKCFzdXBwb3J0cyQyLmZvY3VzQXJlYVdpdGhvdXRIcmVmICYmICFlbGVtZW50LmhyZWYpIHtcbiAgICAgICAgLy8gSW50ZXJuZXQgZXhwbG9yZXIgc3VwcG9ydHMuY2FuIGZvY3VzIGFyZWEgZWxlbWVudHMgd2l0aG91dCBocmVmIGlmIGVpdGhlclxuICAgICAgICAvLyB0aGUgYXJlYSBlbGVtZW50IG9yIHRoZSBpbWFnZSBlbGVtZW50IGhhcyBhIHRhYmluZGV4IGF0dHJpYnV0ZVxuICAgICAgICByZXR1cm4gKChzdXBwb3J0cyQyLmZvY3VzQXJlYVRhYmluZGV4ICYmIGhhc1RhYmluZGV4KSB8fFxuICAgICAgICAgICAgKHN1cHBvcnRzJDIuZm9jdXNBcmVhSW1nVGFiaW5kZXggJiYgaW1nLmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkpO1xuICAgIH1cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXG4gICAgdmFyIGNoaWxkT2ZJbnRlcmFjdGl2ZSA9IGdldFBhcmVudHMoeyBjb250ZXh0OiBpbWcgfSlcbiAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgIC5zb21lKGZ1bmN0aW9uIChfZWxlbWVudCkge1xuICAgICAgICB2YXIgbmFtZSA9IF9lbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBuYW1lID09PSAnYnV0dG9uJyB8fCBuYW1lID09PSAnYSc7XG4gICAgfSk7XG4gICAgaWYgKGNoaWxkT2ZJbnRlcmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxudmFyIHN1cHBvcnRzJDMgPSB2b2lkIDA7XG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZGlzYWJsZWQtZWxlbWVudHMuaHRtbCNjb25jZXB0LWVsZW1lbnQtZGlzYWJsZWRcbnZhciBkaXNhYmxlZEVsZW1lbnRzUGF0dGVybiA9IHZvaWQgMDtcbnZhciBkaXNhYmxlZEVsZW1lbnRzID0ge1xuICAgIGlucHV0OiB0cnVlLFxuICAgIHNlbGVjdDogdHJ1ZSxcbiAgICB0ZXh0YXJlYTogdHJ1ZSxcbiAgICBidXR0b246IHRydWUsXG4gICAgZmllbGRzZXQ6IHRydWUsXG4gICAgZm9ybTogdHJ1ZVxufTtcbmZ1bmN0aW9uIGlzTmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQoY29udGV4dCkge1xuICAgIGlmICghc3VwcG9ydHMkMykge1xuICAgICAgICBzdXBwb3J0cyQzID0gX3N1cHBvcnRzKCk7XG4gICAgICAgIGlmIChzdXBwb3J0cyQzLmZvY3VzRmllbGRzZXREaXNhYmxlZCkge1xuICAgICAgICAgICAgZGVsZXRlIGRpc2FibGVkRWxlbWVudHMuZmllbGRzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1cHBvcnRzJDMuZm9jdXNGb3JtRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkaXNhYmxlZEVsZW1lbnRzLmZvcm07XG4gICAgICAgIH1cbiAgICAgICAgZGlzYWJsZWRFbGVtZW50c1BhdHRlcm4gPSBuZXcgUmVnRXhwKCdeKCcgKyBPYmplY3Qua2V5cyhkaXNhYmxlZEVsZW1lbnRzKS5qb2luKCd8JykgKyAnKSQnKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0VG9FbGVtZW50KHtcbiAgICAgICAgbGFiZWw6ICdpcy9uYXRpdmUtZGlzYWJsZWQtc3VwcG9ydGVkJyxcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0pO1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gQm9vbGVhbihkaXNhYmxlZEVsZW1lbnRzUGF0dGVybi50ZXN0KG5vZGVOYW1lKSk7XG59XG52YXIgc3VwcG9ydHMkNCA9IHZvaWQgMDtcbmZ1bmN0aW9uIGlzRGlzYWJsZWRGaWVsZHNldChlbGVtZW50KSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBub2RlTmFtZSA9PT0gJ2ZpZWxkc2V0JyAmJiBlbGVtZW50LmRpc2FibGVkO1xufVxuZnVuY3Rpb24gaXNEaXNhYmxlZEZvcm0oZWxlbWVudCkge1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbm9kZU5hbWUgPT09ICdmb3JtJyAmJiBlbGVtZW50LmRpc2FibGVkO1xufVxuZnVuY3Rpb24gaXNEaXNhYmxlZChjb250ZXh0KSB7XG4gICAgaWYgKCFzdXBwb3J0cyQ0KSB7XG4gICAgICAgIHN1cHBvcnRzJDQgPSBfc3VwcG9ydHMoKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0VG9FbGVtZW50KHtcbiAgICAgICAgbGFiZWw6ICdpcy9kaXNhYmxlZCcsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9KTtcbiAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtYWxseS1kaXNhYmxlZCcpKSB7XG4gICAgICAgIC8vIHRyZWF0IGFsbHkncyBlbGVtZW50L2Rpc2FibGVkIGxpa2UgdGhlIERPTSBuYXRpdmUgZWxlbWVudC5kaXNhYmxlZFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFpc05hdGl2ZURpc2FibGVkU3VwcG9ydGVkKGVsZW1lbnQpKSB7XG4gICAgICAgIC8vIG5vbi1mb3JtIGVsZW1lbnRzIGRvIG5vdCBzdXBwb3J0IHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGVcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5kaXNhYmxlZCkge1xuICAgICAgICAvLyB0aGUgZWxlbWVudCBpdHNlbGYgaXMgZGlzYWJsZWRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBwYXJlbnRzID0gZ2V0UGFyZW50cyh7IGNvbnRleHQ6IGVsZW1lbnQgfSk7XG4gICAgaWYgKHBhcmVudHMuc29tZShpc0Rpc2FibGVkRmllbGRzZXQpKSB7XG4gICAgICAgIC8vIGEgcGFyZW50YWwgPGZpZWxkc2V0PiBpcyBkaXNhYmxkIGFuZCBpbmhlcml0cyB0aGUgc3RhdGUgb250byB0aGlzIGVsZW1lbnRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghc3VwcG9ydHMkNC5mb2N1c0Zvcm1EaXNhYmxlZCAmJiBwYXJlbnRzLnNvbWUoaXNEaXNhYmxlZEZvcm0pKSB7XG4gICAgICAgIC8vIGEgcGFyZW50YWwgPGZvcm0+IGlzIGRpc2FibGQgYW5kIGluaGVyaXRzIHRoZSBzdGF0ZSBvbnRvIHRoaXMgZWxlbWVudFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNPbmx5VGFiYmFibGVSdWxlcygpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsIF9yZWYkZXhjZXB0ID0gX3JlZi5leGNlcHQsIGV4Y2VwdCA9IF9yZWYkZXhjZXB0ID09PSB1bmRlZmluZWRcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBvbmx5Rm9jdXNhYmxlQnJvd3NpbmdDb250ZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgOiBfcmVmJGV4Y2VwdDtcbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHRUb0VsZW1lbnQoe1xuICAgICAgICBsYWJlbDogJ2lzL29ubHktdGFiYmFibGUnLFxuICAgICAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9KTtcbiAgICBpZiAoIWV4Y2VwdC52aXNpYmxlICYmICFpc1Zpc2libGUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWV4Y2VwdC5vbmx5Rm9jdXNhYmxlQnJvd3NpbmdDb250ZXh0ICYmXG4gICAgICAgIChwbGF0Zm9ybS5pcy5HRUNLTyB8fCBwbGF0Zm9ybS5pcy5UUklERU5UIHx8IHBsYXRmb3JtLmlzLkVER0UpKSB7XG4gICAgICAgIHZhciBmcmFtZUVsZW1lbnQgPSBnZXRGcmFtZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIGlmIChmcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0YWJpbmRleFZhbHVlKGZyYW1lRWxlbWVudCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWZyYW1lW3RhYmluZGV4PVwiLTFcIl0gYW5kIG9iamVjdFt0YWJpbmRleD1cIi0xXCJdIGluaGVyaXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gdGFiYmFibGUgZGVtb3Rpb24gb250byBlbGVtZW50cyBvZiB0aGVpciBicm93c2luZyBjb250ZXh0c1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHRhYmluZGV4ID0gdGFiaW5kZXhWYWx1ZShlbGVtZW50KTtcbiAgICBpZiAobm9kZU5hbWUgPT09ICdsYWJlbCcgJiYgcGxhdGZvcm0uaXMuR0VDS08pIHtcbiAgICAgICAgLy8gRmlyZWZveCBjYW5ub3QgZm9jdXMsIGJ1dCB0YWIgdG86IGxhYmVsW3RhYmluZGV4PTBdXG4gICAgICAgIHJldHVybiB0YWJpbmRleCAhPT0gbnVsbCAmJiB0YWJpbmRleCA+PSAwO1xuICAgIH1cbiAgICAvLyBTVkcgRWxlbWVudHMgd2VyZSBrZXlib2FyZCBmb2N1c2FibGUgYnV0IG5vdCBzY3JpcHQgZm9jdXNhYmxlIGJlZm9yZSBGaXJlZm94IDUxLlxuICAgIC8vIEZpcmVmb3ggNTEgYWRkZWQgdGhlIGZvY3VzIG1hbmFnZW1lbnQgRE9NIEFQSSAoLmZvY3VzIGFuZCAuYmx1cikgdG8gU1ZHRWxlbWVudCxcbiAgICAvLyBzZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Nzc4NjU0XG4gICAgaWYgKHBsYXRmb3JtLmlzLkdFQ0tPICYmIGVsZW1lbnQub3duZXJTVkdFbGVtZW50ICYmICFlbGVtZW50LmZvY3VzKSB7XG4gICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ2EnICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCd4bGluazpocmVmJykpIHtcbiAgICAgICAgICAgIC8vIGFueSBmb2N1c2FibGUgY2hpbGQgb2YgPHN2Zz4gY2Fubm90IGJlIGZvY3VzZWQsIGJ1dCB0YWJiZWQgdG9cbiAgICAgICAgICAgIGlmIChwbGF0Zm9ybS5pcy5HRUNLTykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIGJpbmQgZXhjZXB0aW9ucyB0byBhbiBpdGVyYXRvciBjYWxsYmFja1xuaXNPbmx5VGFiYmFibGVSdWxlcy5leGNlcHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4Y2VwdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIGlzT25seVRhYmJhYmxlID0gZnVuY3Rpb24gaXNPbmx5VGFiYmFibGUoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gaXNPbmx5VGFiYmFibGVSdWxlcyh7XG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgZXhjZXB0OiBleGNlcHRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpc09ubHlUYWJiYWJsZS5ydWxlcyA9IGlzT25seVRhYmJhYmxlUnVsZXM7XG4gICAgcmV0dXJuIGlzT25seVRhYmJhYmxlO1xufTtcbi8vIHByb3ZpZGUgaXNPbmx5VGFiYmFibGUoY29udGV4dCkgYXMgZGVmYXVsdCBpdGVyYXRvciBjYWxsYmFja1xudmFyIGlzT25seVRhYmJhYmxlID0gaXNPbmx5VGFiYmFibGVSdWxlcy5leGNlcHQoe30pO1xudmFyIHN1cHBvcnRzJDUgPSB2b2lkIDA7XG5mdW5jdGlvbiBpc09ubHlGb2N1c1JlbGV2YW50KGVsZW1lbnQpIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnZW1iZWQnIHx8IG5vZGVOYW1lID09PSAna2V5Z2VuJykge1xuICAgICAgICAvLyBlbWJlZCBpcyBjb25zaWRlcmVkIGZvY3VzLXJlbGV2YW50IGJ1dCBub3QgZm9jdXNhYmxlXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzgyXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgX3RhYmluZGV4ID0gdGFiaW5kZXhWYWx1ZShlbGVtZW50KTtcbiAgICBpZiAoZWxlbWVudC5zaGFkb3dSb290ICYmIF90YWJpbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBTaGFkb3dET00gaG9zdCBlbGVtZW50cyAqbWF5KiByZWNlaXZlIGZvY3VzXG4gICAgICAgIC8vIGV2ZW4gdGhvdWdoIHRoZXkgYXJlIG5vdCBjb25zaWRlcmVkIGZvY3VhYmxlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZU5hbWUgPT09ICdsYWJlbCcpIHtcbiAgICAgICAgLy8gPGxhYmVsIHRhYmluZGV4PVwiMFwiPiBpcyBvbmx5IHRhYmJhYmxlIGluIEZpcmVmb3gsIG5vdCBzY3JpcHQtZm9jdXNhYmxlXG4gICAgICAgIC8vIHRoZXJlJ3Mgbm8gd2F5IHRvIG1ha2UgYW4gZWxlbWVudCBmb2N1c2FibGUgb3RoZXIgdGhhbiBieSBhZGRpbmcgYSB0YWJpbmRleCxcbiAgICAgICAgLy8gYW5kIGZvY3VzIGJlaGF2aW9yIG9mIHRoZSBsYWJlbCBlbGVtZW50IHNlZW1zIGhhcmQtd2lyZWQgdG8gaWdub3JlIHRhYmluZGV4XG4gICAgICAgIC8vIGluIHNvbWUgYnJvd3NlcnMgKGxpa2UgR2Vja28sIEJsaW5rIGFuZCBXZWJLaXQpXG4gICAgICAgIHJldHVybiAhc3VwcG9ydHMkNS5mb2N1c0xhYmVsVGFiaW5kZXggfHwgX3RhYmluZGV4ID09PSBudWxsO1xuICAgIH1cbiAgICBpZiAobm9kZU5hbWUgPT09ICdsZWdlbmQnKSB7XG4gICAgICAgIHJldHVybiBfdGFiaW5kZXggPT09IG51bGw7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0cyQ1LmZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlICYmXG4gICAgICAgIChlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCB8fCBub2RlTmFtZSA9PT0gJ3N2ZycpKSB7XG4gICAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIHVuZGVyc3RhbmRzIHRoZSBmb2N1c2FibGUgYXR0cmlidXRlIGludHJvZHVjZWQgaW4gU1ZHIFRpbnkgMS4yXG4gICAgICAgIHZhciBmb2N1c2FibGVBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZm9jdXNhYmxlJyk7XG4gICAgICAgIHJldHVybiBmb2N1c2FibGVBdHRyaWJ1dGUgJiYgZm9jdXNhYmxlQXR0cmlidXRlID09PSAnZmFsc2UnO1xuICAgIH1cbiAgICBpZiAobm9kZU5hbWUgPT09ICdpbWcnICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCd1c2VtYXAnKSkge1xuICAgICAgICAvLyBHZWNrbywgVHJpZGVudCBhbmQgRWRnZSBkbyBub3QgYWxsb3cgYW4gaW1hZ2Ugd2l0aCBhbiBpbWFnZSBtYXAgYW5kIHRhYmluZGV4IHRvIGJlIGZvY3VzZWQsXG4gICAgICAgIC8vIGl0IGFwcGVhcnMgdGhlIHRhYmluZGV4IGlzIG92ZXJydWxlZCBzbyBmb2N1cyBpcyBzdGlsbCBmb3J3YXJkZWQgdG8gdGhlIDxtYXA+XG4gICAgICAgIHJldHVybiBfdGFiaW5kZXggPT09IG51bGwgfHwgIXN1cHBvcnRzJDUuZm9jdXNJbWdVc2VtYXBUYWJpbmRleDtcbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAnYXJlYScpIHtcbiAgICAgICAgLy8gYWxsIDxhcmVhPnMgYXJlIGNvbnNpZGVyZWQgcmVsZXZhbnQsXG4gICAgICAgIC8vIGJ1dCBvbmx5IHRoZSB2YWxpZCA8YXJlYT5zIGFyZSBmb2N1c2FibGVcbiAgICAgICAgcmV0dXJuICFpc1ZhbGlkQXJlYShlbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNGb2N1c2FibGVSdWxlcygpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsIF9yZWYkZXhjZXB0ID0gX3JlZi5leGNlcHQsIGV4Y2VwdCA9IF9yZWYkZXhjZXB0ID09PSB1bmRlZmluZWRcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIG9ubHlUYWJiYWJsZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgICA6IF9yZWYkZXhjZXB0O1xuICAgIGlmICghc3VwcG9ydHMkNSkge1xuICAgICAgICBzdXBwb3J0cyQ1ID0gX3N1cHBvcnRzKCk7XG4gICAgfVxuICAgIHZhciBfaXNPbmx5VGFiYmFibGUgPSBpc09ubHlUYWJiYWJsZS5ydWxlcy5leGNlcHQoe1xuICAgICAgICBvbmx5Rm9jdXNhYmxlQnJvd3NpbmdDb250ZXh0OiB0cnVlLFxuICAgICAgICB2aXNpYmxlOiBleGNlcHQudmlzaWJsZVxuICAgIH0pO1xuICAgIHZhciBlbGVtZW50ID0gY29udGV4dFRvRWxlbWVudCh7XG4gICAgICAgIGxhYmVsOiAnaXMvZm9jdXNhYmxlJyxcbiAgICAgICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfSk7XG4gICAgdmFyIGZvY3VzUmVsZXZhbnQgPSBpc0ZvY3VzUmVsZXZhbnQucnVsZXMoe1xuICAgICAgICBjb250ZXh0OiBlbGVtZW50LFxuICAgICAgICBleGNlcHQ6IGV4Y2VwdFxuICAgIH0pO1xuICAgIGlmICghZm9jdXNSZWxldmFudCB8fCBpc09ubHlGb2N1c1JlbGV2YW50KGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFleGNlcHQuZGlzYWJsZWQgJiYgaXNEaXNhYmxlZChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZXhjZXB0Lm9ubHlUYWJiYWJsZSAmJiBfaXNPbmx5VGFiYmFibGUoZWxlbWVudCkpIHtcbiAgICAgICAgLy8gc29tZSBlbGVtZW50cyBtYXkgYmUga2V5Ym9hcmQgZm9jdXNhYmxlLCBidXQgbm90IHNjcmlwdCBmb2N1c2FibGVcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBlbGVtZW50cyB0aGF0IGFyZSBub3QgcmVuZGVyZWQsIGNhbm5vdCBiZSBmb2N1c2VkXG4gICAgaWYgKCFleGNlcHQudmlzaWJsZSkge1xuICAgICAgICB2YXIgdmlzaWJpbGl0eU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBjb250ZXh0OiBlbGVtZW50LFxuICAgICAgICAgICAgZXhjZXB0OiB7fVxuICAgICAgICB9O1xuICAgICAgICBpZiAoc3VwcG9ydHMkNS5mb2N1c0luSGlkZGVuSWZyYW1lKSB7XG4gICAgICAgICAgICAvLyBXZWJLaXQgYW5kIEJsaW5rIGNhbiBmb2N1cyBjb250ZW50IGluIGhpZGRlbiA8aWZyYW1lPiBhbmQgPG9iamVjdD5cbiAgICAgICAgICAgIHZpc2liaWxpdHlPcHRpb25zLmV4Y2VwdC5icm93c2luZ0NvbnRleHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdXBwb3J0cyQ1LmZvY3VzT2JqZWN0U3ZnSGlkZGVuKSB7XG4gICAgICAgICAgICAvLyBCbGluayBhbGxvd3MgZm9jdXNpbmcgdGhlIG9iamVjdCBlbGVtZW50LCBldmVuIGlmIGl0IGhhcyB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgICAgICAgICAvLyBAYnJvd3Nlci1pc3N1ZSBCbGluayBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg2MTkxXG4gICAgICAgICAgICB2YXIgX25vZGVOYW1lMiA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChfbm9kZU5hbWUyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlPcHRpb25zLmV4Y2VwdC5jc3NWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVmlzaWJsZS5ydWxlcyh2aXNpYmlsaXR5T3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZnJhbWVFbGVtZW50ID0gZ2V0RnJhbWVFbGVtZW50KGVsZW1lbnQpO1xuICAgIGlmIChmcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF9ub2RlTmFtZSA9IGZyYW1lRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoX25vZGVOYW1lID09PSAnb2JqZWN0JyAmJiAhc3VwcG9ydHMkNS5mb2N1c0luWmVyb0RpbWVuc2lvbk9iamVjdCkge1xuICAgICAgICAgICAgaWYgKCFmcmFtZUVsZW1lbnQub2Zmc2V0V2lkdGggfHwgIWZyYW1lRWxlbWVudC5vZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZWJLaXQgY2FuIG5vdCBmb2N1cyBjb250ZW50IGluIDxvYmplY3Q+IGlmIGl0IGRvZXNuJ3QgaGF2ZSBkaW1lbnNpb25zXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobm9kZU5hbWUgPT09ICdzdmcnICYmXG4gICAgICAgIHN1cHBvcnRzJDUuZm9jdXNTdmdJbklmcmFtZSAmJlxuICAgICAgICAhZnJhbWVFbGVtZW50ICYmXG4gICAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBiaW5kIGV4Y2VwdGlvbnMgdG8gYW4gaXRlcmF0b3IgY2FsbGJhY2tcbmlzRm9jdXNhYmxlUnVsZXMuZXhjZXB0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBleGNlcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBpc0ZvY3VzYWJsZSA9IGZ1bmN0aW9uIGlzRm9jdXNhYmxlKGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIGlzRm9jdXNhYmxlUnVsZXMoe1xuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIGV4Y2VwdDogZXhjZXB0XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaXNGb2N1c2FibGUucnVsZXMgPSBpc0ZvY3VzYWJsZVJ1bGVzO1xuICAgIHJldHVybiBpc0ZvY3VzYWJsZTtcbn07XG4vLyBwcm92aWRlIGlzRm9jdXNSZWxldmFudChjb250ZXh0KSBhcyBkZWZhdWx0IGl0ZXJhdG9yIGNhbGxiYWNrXG52YXIgaXNGb2N1c2FibGUgPSBpc0ZvY3VzYWJsZVJ1bGVzLmV4Y2VwdCh7fSk7XG5mdW5jdGlvbiBjcmVhdGVGaWx0ZXIoY29uZGl0aW9uKSB7XG4gICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlRmlsdGVyXG4gICAgdmFyIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBTaGFkb3dSb290IGVsZW1lbnRzIHJlZ2FyZGxlc3Mgb2YgdGhlbSBiZWluZyBmb2N1c2FibGUsXG4gICAgICAgICAgICAvLyBzbyB0aGV5IGNhbiBiZSB3YWxrZWQgcmVjdXJzaXZlbHkgbGF0ZXJcbiAgICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmRpdGlvbihub2RlKSkge1xuICAgICAgICAgICAgLy8gZmluZHMgZWxlbWVudHMgdGhhdCBjb3VsZCBoYXZlIGJlZW4gZm91bmQgYnkgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgpXG4gICAgICAgICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgIH07XG4gICAgLy8gSUUgcmVxdWlyZXMgYSBmdW5jdGlvbiwgQnJvd3NlcnMgcmVxdWlyZSB7YWNjZXB0Tm9kZTogZnVuY3Rpb259XG4gICAgLy8gc2VlIGh0dHA6Ly93d3cuYmVubmFkZWwuY29tL2Jsb2cvMjYwNy1maW5kaW5nLWh0bWwtY29tbWVudC1ub2Rlcy1pbi10aGUtZG9tLXVzaW5nLXRyZWV3YWxrZXIuaHRtXG4gICAgZmlsdGVyLmFjY2VwdE5vZGUgPSBmaWx0ZXI7XG4gICAgcmV0dXJuIGZpbHRlcjtcbn1cbnZhciBQb3NzaWJseUZvY3VzYWJsZUZpbHRlciA9IGNyZWF0ZUZpbHRlcihpc0ZvY3VzUmVsZXZhbnQpO1xuZnVuY3Rpb24gcXVlcnlGb2N1c2FibGVTdHJpY3QoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LCBjb250ZXh0ID0gX3JlZi5jb250ZXh0LCBpbmNsdWRlQ29udGV4dCA9IF9yZWYuaW5jbHVkZUNvbnRleHQsIGluY2x1ZGVPbmx5VGFiYmFibGUgPSBfcmVmLmluY2x1ZGVPbmx5VGFiYmFibGUsIHN0cmF0ZWd5ID0gX3JlZi5zdHJhdGVneTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9XG4gICAgdmFyIF9pc0ZvY3VzYWJsZSA9IGlzRm9jdXNhYmxlLnJ1bGVzLmV4Y2VwdCh7XG4gICAgICAgIG9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZVxuICAgIH0pO1xuICAgIHZhciBfZG9jdW1lbnQgPSBnZXREb2N1bWVudChjb250ZXh0KTtcbiAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2NyZWF0ZVRyZWVXYWxrZXJcbiAgICB2YXIgd2Fsa2VyID0gX2RvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoXG4gICAgLy8gcm9vdCBlbGVtZW50IHRvIHN0YXJ0IHNlYXJjaCBpblxuICAgIGNvbnRleHQsIFxuICAgIC8vIGVsZW1lbnQgdHlwZSBmaWx0ZXJcbiAgICBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwgXG4gICAgLy8gY3VzdG9tIE5vZGVGaWx0ZXIgZmlsdGVyXG4gICAgc3RyYXRlZ3kgPT09ICdhbGwnID8gUG9zc2libHlGb2N1c2FibGVGaWx0ZXIgOiBjcmVhdGVGaWx0ZXIoX2lzRm9jdXNhYmxlKSwgXG4gICAgLy8gZGVwcmVjYXRlZCwgYnV0IElFIHJlcXVpcmVzIGl0XG4gICAgZmFsc2UpO1xuICAgIHZhciBsaXN0ID0gW107XG4gICAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgIGlmICh3YWxrZXIuY3VycmVudE5vZGUuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgaWYgKF9pc0ZvY3VzYWJsZSh3YWxrZXIuY3VycmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5wdXNoKHdhbGtlci5jdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0ID0gbGlzdC5jb25jYXQocXVlcnlGb2N1c2FibGVTdHJpY3Qoe1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHdhbGtlci5jdXJyZW50Tm9kZS5zaGFkb3dSb290LFxuICAgICAgICAgICAgICAgIGluY2x1ZGVPbmx5VGFiYmFibGU6IGluY2x1ZGVPbmx5VGFiYmFibGUsXG4gICAgICAgICAgICAgICAgc3RyYXRlZ3k6IHN0cmF0ZWd5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsaXN0LnB1c2god2Fsa2VyLmN1cnJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgY29udGV4dCBpZiByZXF1ZXN0ZWQgYW5kIGZvY3VzYWJsZVxuICAgIGlmIChpbmNsdWRlQ29udGV4dCkge1xuICAgICAgICBpZiAoc3RyYXRlZ3kgPT09ICdhbGwnKSB7XG4gICAgICAgICAgICBpZiAoaXNGb2N1c1JlbGV2YW50KGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgbGlzdC51bnNoaWZ0KGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9pc0ZvY3VzYWJsZShjb250ZXh0KSkge1xuICAgICAgICAgICAgbGlzdC51bnNoaWZ0KGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufVxuLy8gTk9URTogdGhpcyBzZWxlY3RvciBNVVNUICpuZXZlciogYmUgdXNlZCBkaXJlY3RseSxcbnZhciBzdXBwb3J0cyQ2ID0gdm9pZCAwO1xudmFyIHNlbGVjdG9yJDEgPSB2b2lkIDA7XG5mdW5jdGlvbiBzZWxlY3RvciQyKCkge1xuICAgIGlmICghc3VwcG9ydHMkNikge1xuICAgICAgICBzdXBwb3J0cyQ2ID0gX3N1cHBvcnRzKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IkMSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yJDE7XG4gICAgfVxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjc2VxdWVudGlhbC1mb2N1cy1uYXZpZ2F0aW9uLWFuZC10aGUtdGFiaW5kZXgtYXR0cmlidXRlXG4gICAgc2VsZWN0b3IkMSA9XG4gICAgICAgICcnICtcbiAgICAgICAgICAgIC8vIElFMTEgc3VwcG9ydHMuY2FuIGZvY3VzIDx0YWJsZT4gYW5kIDx0ZD5cbiAgICAgICAgICAgIChzdXBwb3J0cyQ2LmZvY3VzVGFibGUgPyAndGFibGUsIHRkLCcgOiAnJykgK1xuICAgICAgICAgICAgLy8gSUUxMSBzdXBwb3J0cy5jYW4gZm9jdXMgPGZpZWxkc2V0PlxuICAgICAgICAgICAgKHN1cHBvcnRzJDYuZm9jdXNGaWVsZHNldCA/ICdmaWVsZHNldCwnIDogJycpICtcbiAgICAgICAgICAgIC8vIE5hbWVzcGFjZSBwcm9ibGVtcyBvZiBbeGxpbms6aHJlZl0gZXhwbGFpbmVkIGluIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMzA0Nzg4OC81MTUxMjRcbiAgICAgICAgICAgIC8vIHN2ZyBhWyp8aHJlZl0gZG9lcyBub3QgbWF0Y2ggaW4gSUU5LCBidXQgc2luY2Ugd2UncmUgZmlsdGVyaW5nXG4gICAgICAgICAgICAvLyB0aHJvdWdoIGlzL2ZvY3VzYWJsZSB3ZSBjYW4gaW5jbHVkZSBhbGwgPGE+IGZyb20gU1ZHXG4gICAgICAgICAgICAnc3ZnIGEsJyArXG4gICAgICAgICAgICAvLyBtYXkgYmVoYXZlIGFzICdzdmcsIHN2ZyAqLCcgaW4gY2hyb21lIGFzICpldmVyeSogc3ZnIGVsZW1lbnQgd2l0aCBhIGZvY3VzIGV2ZW50IGxpc3RlbmVyIGlzIGZvY3VzYWJsZVxuICAgICAgICAgICAgLy8gbmF2aWdhdGlvbmFsIGVsZW1lbnRzXG4gICAgICAgICAgICAnYVtocmVmXSwnICtcbiAgICAgICAgICAgIC8vIHZhbGlkaXR5IGRldGVybWluZWQgYnkgaXMvdmFsaWQtYXJlYS5qc1xuICAgICAgICAgICAgJ2FyZWFbaHJlZl0sJyArXG4gICAgICAgICAgICAvLyB2YWxpZGl0eSBkZXRlcm1pbmVkIGJ5IGlzL2Rpc2FibGVkLmpzXG4gICAgICAgICAgICAnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGJ1dHRvbiwnICtcbiAgICAgICAgICAgIC8vIGJyb3dzaW5nIGNvbnRleHQgY29udGFpbmVyc1xuICAgICAgICAgICAgJ2lmcmFtZSwgb2JqZWN0LCBlbWJlZCwnICtcbiAgICAgICAgICAgIC8vIGludGVyYWN0aXZlIGNvbnRlbnRcbiAgICAgICAgICAgICdrZXlnZW4sJyArXG4gICAgICAgICAgICAoc3VwcG9ydHMkNi5mb2N1c0F1ZGlvV2l0aG91dENvbnRyb2xzID8gJ2F1ZGlvLCcgOiAnYXVkaW9bY29udHJvbHNdLCcpICtcbiAgICAgICAgICAgIChzdXBwb3J0cyQ2LmZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHMgPyAndmlkZW8sJyA6ICd2aWRlb1tjb250cm9sc10sJykgK1xuICAgICAgICAgICAgKHN1cHBvcnRzJDYuZm9jdXNTdW1tYXJ5ID8gJ3N1bW1hcnksJyA6ICcnKSArXG4gICAgICAgICAgICAvLyB2YWxpZGl0eSBkZXRlcm1pbmVkIGJ5IGlzL3ZhbGlkLXRhYmluZGV4LmpzXG4gICAgICAgICAgICAnW3RhYmluZGV4XSwnICtcbiAgICAgICAgICAgIC8vIGVkaXRpbmcgaG9zdHNcbiAgICAgICAgICAgICdbY29udGVudGVkaXRhYmxlXSc7XG4gICAgLy8gd2hlcmUgU2hhZG93RE9NIGlzIHN1cHBvcnRlZCwgd2UgYWxzbyB3YW50IHRoZSBzaGFkb3dlZCBmb2N1c2FibGUgZWxlbWVudHMgKHZpYSBcIj4+PlwiIG9yIFwiL2RlZXAvXCIpXG4gICAgc2VsZWN0b3IkMSA9IHNlbGVjdEluU2hhZG93cyhzZWxlY3RvciQxKTtcbiAgICByZXR1cm4gc2VsZWN0b3IkMTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5Rm9jdXNhYmxlUXVpY2soKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LCBjb250ZXh0ID0gX3JlZi5jb250ZXh0LCBpbmNsdWRlQ29udGV4dCA9IF9yZWYuaW5jbHVkZUNvbnRleHQsIGluY2x1ZGVPbmx5VGFiYmFibGUgPSBfcmVmLmluY2x1ZGVPbmx5VGFiYmFibGU7XG4gICAgdmFyIF9zZWxlY3RvciA9IHNlbGVjdG9yJDIoKTtcbiAgICB2YXIgZWxlbWVudHMgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoX3NlbGVjdG9yKTtcbiAgICAvLyB0aGUgc2VsZWN0b3IgcG90ZW50aWFsbHkgbWF0Y2hlcyBtb3JlIHRoYW4gcmVhbGx5IGlzIGZvY3VzYWJsZVxuICAgIHZhciBfaXNGb2N1c2FibGUgPSBpc0ZvY3VzYWJsZS5ydWxlcy5leGNlcHQoe1xuICAgICAgICBvbmx5VGFiYmFibGU6IGluY2x1ZGVPbmx5VGFiYmFibGVcbiAgICB9KTtcbiAgICB2YXIgcmVzdWx0ID0gW10uZmlsdGVyLmNhbGwoZWxlbWVudHMsIF9pc0ZvY3VzYWJsZSk7XG4gICAgLy8gYWRkIGNvbnRleHQgaWYgcmVxdWVzdGVkIGFuZCBmb2N1c2FibGVcbiAgICBpZiAoaW5jbHVkZUNvbnRleHQgJiYgX2lzRm9jdXNhYmxlKGNvbnRleHQpKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcXVlcnlGb2N1c2FibGUoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LCBjb250ZXh0ID0gX3JlZi5jb250ZXh0LCBpbmNsdWRlQ29udGV4dCA9IF9yZWYuaW5jbHVkZUNvbnRleHQsIGluY2x1ZGVPbmx5VGFiYmFibGUgPSBfcmVmLmluY2x1ZGVPbmx5VGFiYmFibGUsIF9yZWYkc3RyYXRlZ3kgPSBfcmVmLnN0cmF0ZWd5LCBzdHJhdGVneSA9IF9yZWYkc3RyYXRlZ3kgPT09IHVuZGVmaW5lZCA/ICdxdWljaycgOiBfcmVmJHN0cmF0ZWd5O1xuICAgIHZhciBlbGVtZW50ID0gY29udGV4dFRvRWxlbWVudCh7XG4gICAgICAgIGxhYmVsOiAncXVlcnkvZm9jdXNhYmxlJyxcbiAgICAgICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxuICAgICAgICBkZWZhdWx0VG9Eb2N1bWVudDogdHJ1ZSxcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH0pO1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICBjb250ZXh0OiBlbGVtZW50LFxuICAgICAgICBpbmNsdWRlQ29udGV4dDogaW5jbHVkZUNvbnRleHQsXG4gICAgICAgIGluY2x1ZGVPbmx5VGFiYmFibGU6IGluY2x1ZGVPbmx5VGFiYmFibGUsXG4gICAgICAgIHN0cmF0ZWd5OiBzdHJhdGVneVxuICAgIH07XG4gICAgaWYgKHN0cmF0ZWd5ID09PSAncXVpY2snKSB7XG4gICAgICAgIHJldHVybiBxdWVyeUZvY3VzYWJsZVF1aWNrKG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdHJhdGVneSA9PT0gJ3N0cmljdCcgfHwgc3RyYXRlZ3kgPT09ICdhbGwnKSB7XG4gICAgICAgIHJldHVybiBxdWVyeUZvY3VzYWJsZVN0cmljdChvcHRpb25zKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncXVlcnkvZm9jdXNhYmxlIHJlcXVpcmVzIG9wdGlvbi5zdHJhdGVneSB0byBiZSBvbmUgb2YgW1wicXVpY2tcIiwgXCJzdHJpY3RcIiwgXCJhbGxcIl0nKTtcbn1cbnZhciBzdXBwb3J0cyQ3ID0gdm9pZCAwO1xuLy8gSW50ZXJuZXQgRXhwbG9yZXIgMTEgY29uc2lkZXJzIGZpZWxkc2V0LCB0YWJsZSwgdGQgZm9jdXNhYmxlLCBidXQgbm90IHRhYmJhYmxlXG4vLyBJbnRlcm5ldCBFeHBsb3JlciAxMSBjb25zaWRlcnMgYm9keSB0byBoYXZlIFt0YWJpbmRleD0wXSwgYnV0IGRvZXMgbm90IGFsbG93IHRhYmJpbmcgdG8gaXRcbnZhciBmb2N1c2FibGVFbGVtZW50c1BhdHRlcm4gPSAvXihmaWVsZHNldHx0YWJsZXx0ZHxib2R5KSQvO1xuZnVuY3Rpb24gaXNUYWJiYWJsZVJ1bGVzKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSwgY29udGV4dCA9IF9yZWYuY29udGV4dCwgX3JlZiRleGNlcHQgPSBfcmVmLmV4Y2VwdCwgZXhjZXB0ID0gX3JlZiRleGNlcHQgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGZsZXhib3g6IGZhbHNlLFxuICAgICAgICAgICAgc2Nyb2xsYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBzaGFkb3c6IGZhbHNlLFxuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBvbmx5VGFiYmFibGU6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgOiBfcmVmJGV4Y2VwdDtcbiAgICBpZiAoIXN1cHBvcnRzJDcpIHtcbiAgICAgICAgc3VwcG9ydHMkNyA9IF9zdXBwb3J0cygpO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudCA9IGNvbnRleHRUb0VsZW1lbnQoe1xuICAgICAgICBsYWJlbDogJ2lzL3RhYmJhYmxlJyxcbiAgICAgICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfSk7XG4gICAgaWYgKHBsYXRmb3JtLmlzLkJMSU5LICYmIHBsYXRmb3JtLmlzLkFORFJPSUQgJiYgcGxhdGZvcm0ubWFqb3JWZXJzaW9uID4gNDIpIHtcbiAgICAgICAgLy8gRXh0ZXJuYWwga2V5Ym9hcmQgc3VwcG9ydCB3b3JrZWQgZmluZSBpbiBDSHJvbWUgNDIsIGJ1dCBzdG9wcGVkIHdvcmtpbmcgaW4gQ2hyb21lIDQ1LlxuICAgICAgICAvLyBUaGUgb24tc2NyZWVuIGtleWJvYXJkIGRvZXMgbm90IHByb3ZpZGUgYSB3YXkgdG8gZm9jdXMgdGhlIG5leHQgaW5wdXQgZWxlbWVudCAobGlrZSBpT1MgZG9lcykuXG4gICAgICAgIC8vIFRoYXQgbGVhdmVzIHVzIHdpdGggbm8gb3B0aW9uIHRvIGFkdmFuY2UgZm9jdXMgYnkga2V5Ym9hcmQsIGVyZ28gbm90aGluZyBpcyB0YWJiYWJsZSAoa2V5Ym9hcmQgZm9jdXNhYmxlKS5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZnJhbWVFbGVtZW50ID0gZ2V0RnJhbWVFbGVtZW50KGVsZW1lbnQpO1xuICAgIGlmIChmcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHBsYXRmb3JtLmlzLldFQktJVCAmJiBwbGF0Zm9ybS5pcy5JT1MpIHtcbiAgICAgICAgICAgIC8vIGlPUyBvbmx5IGRvZXMgbm90IGNvbnNpZGVyIGFueXRoaW5nIGZyb20gYW5vdGhlciBicm93c2luZyBjb250ZXh0IGtleWJvYXJkIGZvY3VzYWJsZVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmcmFtZVt0YWJpbmRleD1cIi0xXCJdIGFuZCBvYmplY3RbdGFiaW5kZXg9XCItMVwiXSBpbmhlcml0IHRoZVxuICAgICAgICAvLyB0YWJiYWJsZSBkZW1vdGlvbiBvbnRvIGVsZW1lbnRzIG9mIHRoZWlyIGJyb3dzaW5nIGNvbnRleHRzXG4gICAgICAgIGlmICh0YWJpbmRleFZhbHVlKGZyYW1lRWxlbWVudCkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleGNlcHQudmlzaWJsZSAmJlxuICAgICAgICAgICAgKHBsYXRmb3JtLmlzLkJMSU5LIHx8IHBsYXRmb3JtLmlzLldFQktJVCkgJiZcbiAgICAgICAgICAgICFpc1Zpc2libGUoZnJhbWVFbGVtZW50KSkge1xuICAgICAgICAgICAgLy8gQmxpbmsgYW5kIFdlYktpdCBjb25zaWRlciBlbGVtZW50cyBpbiBoaWRkZW4gYnJvd3NpbmcgY29udGV4dHMgZm9jdXNhYmxlLCBidXQgbm90IHRhYmJhYmxlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Via2l0IGFuZCBCbGluayBkb24ndCBjb25zaWRlciBhbnl0aGluZyBpbiA8b2JqZWN0PiB0YWJiYWJsZVxuICAgICAgICAvLyBCbGluayBmaXhlZCB0aGF0IGZpeGVkIGluIENocm9tZSA1NCwgT3BlcmEgNDFcbiAgICAgICAgdmFyIGZyYW1lTm9kZU5hbWUgPSBmcmFtZUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGZyYW1lTm9kZU5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB2YXIgaXNGaXhlZEJsaW5rID0gKHBsYXRmb3JtLm5hbWUgPT09ICdDaHJvbWUnICYmIHBsYXRmb3JtLm1ham9yVmVyc2lvbiA+PSA1NCkgfHxcbiAgICAgICAgICAgICAgICAocGxhdGZvcm0ubmFtZSA9PT0gJ09wZXJhJyAmJiBwbGF0Zm9ybS5tYWpvclZlcnNpb24gPj0gNDEpO1xuICAgICAgICAgICAgaWYgKHBsYXRmb3JtLmlzLldFQktJVCB8fCAocGxhdGZvcm0uaXMuQkxJTksgJiYgIWlzRml4ZWRCbGluaykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBfdGFiaW5kZXggPSB0YWJpbmRleFZhbHVlKGVsZW1lbnQpO1xuICAgIHZhciB0YWJpbmRleCA9IF90YWJpbmRleCA9PT0gbnVsbCA/IG51bGwgOiBfdGFiaW5kZXggPj0gMDtcbiAgICBpZiAocGxhdGZvcm0uaXMuRURHRSAmJlxuICAgICAgICBwbGF0Zm9ybS5tYWpvclZlcnNpb24gPj0gMTQgJiZcbiAgICAgICAgZnJhbWVFbGVtZW50ICYmXG4gICAgICAgIGVsZW1lbnQub3duZXJTVkdFbGVtZW50ICYmXG4gICAgICAgIF90YWJpbmRleCA8IDApIHtcbiAgICAgICAgLy8gRWRnZSAxNCsgY29uc2lkZXJzIDxhIHhsaW5rOmhyZWY9XCLigKZcIiB0YWJpbmRleD1cIi0xXCI+IGtleWJvYXJkIGZvY3VzYWJsZVxuICAgICAgICAvLyBpZiB0aGUgZWxlbWVudCBpcyBpbiBhIG5lc3RlZCBicm93c2luZyBjb250ZXh0XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgaGFzVGFiYmFibGVUYWJpbmRleE9yTm9uZSA9IHRhYmluZGV4ICE9PSBmYWxzZTtcbiAgICB2YXIgaGFzVGFiYmFibGVUYWJpbmRleCA9IF90YWJpbmRleCAhPT0gbnVsbCAmJiBfdGFiaW5kZXggPj0gMDtcbiAgICAvLyBOT1RFOiBGaXJlZm94IDMxIGNvbnNpZGVycyBbY29udGVudGVkaXRhYmxlXSB0byBoYXZlIFt0YWJpbmRleD0tMV0sIGJ1dCBhbGxvd3MgdGFiYmluZyB0byBpdFxuICAgIC8vIGZpeGVkIGluIEZpcmVmb3ggNDAgdGhlIGxhdGVzdCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTExODU2NTdcbiAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XG4gICAgICAgIC8vIHRhYmJpbmcgY2FuIHN0aWxsIGJlIGRpc2FibGVkIGJ5IGV4cGxpY2l0bHkgcHJvdmlkaW5nIFt0YWJpbmRleD1cIi0xXCJdXG4gICAgICAgIHJldHVybiBoYXNUYWJiYWJsZVRhYmluZGV4T3JOb25lO1xuICAgIH1cbiAgICBpZiAoZm9jdXNhYmxlRWxlbWVudHNQYXR0ZXJuLnRlc3Qobm9kZU5hbWUpICYmIHRhYmluZGV4ICE9PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtLmlzLldFQktJVCAmJiBwbGF0Zm9ybS5pcy5JT1MpIHtcbiAgICAgICAgLy8gaU9TIG9ubHkgY29uc2lkZXJzIGEgaGFuZCBmdWxsIG9mIGVsZW1lbnRzIHRhYmJhYmxlIChrZXlib2FyZCBmb2N1c2FibGUpXG4gICAgICAgIC8vIHRoaXMgaG9sZHMgdHJ1ZSBldmVuIHdpdGggZXh0ZXJuYWwga2V5Ym9hcmRzXG4gICAgICAgIHZhciBwb3RlbnRpYWxseVRhYmJhYmxlID0gKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW1lbnQudHlwZSA9PT0gJ3RleHQnKSB8fFxuICAgICAgICAgICAgZWxlbWVudC50eXBlID09PSAncGFzc3dvcmQnIHx8XG4gICAgICAgICAgICBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHxcbiAgICAgICAgICAgIG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8XG4gICAgICAgICAgICBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG4gICAgICAgIGlmICghcG90ZW50aWFsbHlUYWJiYWJsZSkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gICAgICAgICAgICBwb3RlbnRpYWxseVRhYmJhYmxlID0gaXNVc2VyTW9kaWZ5V3JpdGFibGUoc3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcG90ZW50aWFsbHlUYWJiYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gJ3VzZScgJiYgX3RhYmluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChwbGF0Zm9ybS5pcy5CTElOSyB8fFxuICAgICAgICAgICAgKHBsYXRmb3JtLmlzLldFQktJVCAmJiBwbGF0Zm9ybS5tYWpvclZlcnNpb24gPT09IDkpKSB7XG4gICAgICAgICAgICAvLyBJbiBDaHJvbWUgYW5kIFNhZmFyaSA5IHRoZSA8dXNlPiBlbGVtZW50IGlzIGtleWJvYXJkIGZvY3VzYWJsZSBldmVuIGZvciB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbGVtZW50TWF0Y2hlcyhlbGVtZW50LCAnc3ZnIGEnKSAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgneGxpbms6aHJlZicpKSB7XG4gICAgICAgIGlmIChoYXNUYWJiYWJsZVRhYmluZGV4T3JOb25lKSB7XG4gICAgICAgICAgICAvLyBpbiBUcmlkZW50IGFuZCBHZWNrbyBTVkdFbGVtZW50IGRvZXMgbm90IGhhbmRsZSB0aGUgdGFiSW5kZXggcHJvcGVydHkgcHJvcGVybHlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50LmZvY3VzICYmICFzdXBwb3J0cyQ3LmZvY3VzU3ZnTmVnYXRpdmVUYWJpbmRleEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgLy8gRmlyZWZveCA1MSBhbmQgNTIgdHJlYXQgYW55IG5hdGl2ZWx5IHRhYmJhYmxlIFNWRyBlbGVtZW50IHdpdGhcbiAgICAgICAgICAgIC8vIHRhYmluZGV4PVwiLTFcIiBhcyB0YWJiYWJsZSBhbmQgZXZlcnl0aGluZyBlbHNlIGFzIGluZXJ0XG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTMwMjM0MFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAnc3ZnJyAmJlxuICAgICAgICBzdXBwb3J0cyQ3LmZvY3VzU3ZnSW5JZnJhbWUgJiZcbiAgICAgICAgaGFzVGFiYmFibGVUYWJpbmRleE9yTm9uZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtLmlzLlRSSURFTlQgfHwgcGxhdGZvcm0uaXMuRURHRSkge1xuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdzdmcnKSB7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHMkNy5mb2N1c1N2Zykge1xuICAgICAgICAgICAgICAgIC8vIG9sZGVyIEludGVybmV0IEV4cGxvcmVycyBjb25zaWRlciA8c3ZnPiBrZXlib2FyZCBmb2N1c2FibGVcbiAgICAgICAgICAgICAgICAvLyB1bmxlc3MgdGhleSBoYXZlIGZvY3NhYmxlPVwiZmFsc2VcIiwgYnV0IHRoZW4gdGhleSB3b3VsZG4ndFxuICAgICAgICAgICAgICAgIC8vIGJlIGZvY3VzYWJsZSBhbmQgdGh1cyBub3QgZXZlbiByZWFjaCB0aGlzIGZpbHRlclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxlbWVudHMgdGhhdCBoYXZlIFtmb2N1c2FibGVdIGFyZSBhdXRvbWF0aWNhbGx5IGtleWJvYXJkIGZvY3VzYWJsZSByZWdhcmRsZXNzIG9mIHRoZSBhdHRyaWJ1dGUncyB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdmb2N1c2FibGUnKSB8fCBoYXNUYWJiYWJsZVRhYmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzJDcuZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZSAmJiBoYXNUYWJiYWJsZVRhYmluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbGVtZW50cyB0aGF0IGhhdmUgW2ZvY3VzYWJsZV0gYXJlIGF1dG9tYXRpY2FsbHkga2V5Ym9hcmQgZm9jdXNhYmxlIHJlZ2FyZGxlc3Mgb2YgdGhlIGF0dHJpYnV0ZSdzIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnRhYkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oZXhjZXB0Lm9ubHlUYWJiYWJsZSk7XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250cm9scycpKSB7XG4gICAgICAgICAgICAvLyBJbiBJbnRlcm5ldCBFeHBsb3JlciB0aGUgPGF1ZGlvPiBlbGVtZW50IGlzIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZSwgYW5kIHRhYkluZGV4IHByb3BlcnR5IGlzIHdyb25nXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGxhdGZvcm0uaXMuQkxJTkspIHtcbiAgICAgICAgICAgIC8vIEluIENocm9tZSA8YXVkaW8gY29udHJvbHMgdGFiaW5kZXg9XCItMVwiPiByZW1haW5zIGtleWJvYXJkIGZvY3VzYWJsZVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGVOYW1lID09PSAndmlkZW8nKSB7XG4gICAgICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRyb2xzJykpIHtcbiAgICAgICAgICAgIGlmIChwbGF0Zm9ybS5pcy5UUklERU5UIHx8IHBsYXRmb3JtLmlzLkVER0UpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSB0aGUgPHZpZGVvPiBlbGVtZW50IGlzIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZSwgYW5kIHRhYkluZGV4IHByb3BlcnR5IGlzIHdyb25nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBsYXRmb3JtLmlzLkJMSU5LIHx8IHBsYXRmb3JtLmlzLkdFQ0tPKSB7XG4gICAgICAgICAgICAvLyBJbiBDaHJvbWUgYW5kIEZpcmVmb3ggPHZpZGVvIGNvbnRyb2xzIHRhYmluZGV4PVwiLTFcIj4gcmVtYWlucyBrZXlib2FyZCBmb2N1c2FibGVcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHBsYXRmb3JtLmlzLkJMSU5LIHx8IHBsYXRmb3JtLmlzLldFQktJVCkge1xuICAgICAgICAgICAgLy8gSW4gYWxsIEJsaW5rIGFuZCBXZWJLaXQgYmFzZWQgYnJvd3NlcnMgPGVtYmVkPiBhbmQgPG9iamVjdD4gYXJlIG5ldmVyIGtleWJvYXJkIGZvY3VzYWJsZSwgZXZlbiB3aXRoIHRhYmluZGV4PVwiMFwiIHNldFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlTmFtZSA9PT0gJ2lmcmFtZScpIHtcbiAgICAgICAgLy8gSW4gSW50ZXJuZXQgRXhwbG9yZXIgYWxsIGlmcmFtZXMgYXJlIG9ubHkgZm9jdXNhYmxlXG4gICAgICAgIC8vIEluIFdlYktpdCwgQmxpbmsgYW5kIEdlY2tvIGlmcmFtZXMgbWF5IGJlIHRhYmJhYmxlIGRlcGVuZGluZyBvbiBjb250ZW50LlxuICAgICAgICAvLyBTaW5jZSB3ZSBjYW4ndCByZWxpYWJseSBpbnZlc3RpZ2F0ZSBpZnJhbWUgZG9jdW1lbnRzIGJlY2F1c2Ugb2YgdGhlXG4gICAgICAgIC8vIFNhbWVPcmlnaW5Qb2xpY3ksIHdlJ3JlIGRlY2xhcmluZyBldmVyeXRoaW5nIG9ubHkgZm9jdXNhYmxlLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghZXhjZXB0LnNjcm9sbGFibGUgJiYgcGxhdGZvcm0uaXMuR0VDS08pIHtcbiAgICAgICAgLy8gRmlyZWZveCBjb25zaWRlcnMgc2Nyb2xsYWJsZSBjb250YWluZXJzIGtleWJvYXJkIGZvY3VzYWJsZSxcbiAgICAgICAgLy8gZXZlbiB0aG91Z2ggdGhlaXIgdGFiSW5kZXggcHJvcGVydHkgaXMgLTFcbiAgICAgICAgdmFyIF9zdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ3NzT3ZlcmZsb3dTY3JvbGwoX3N0eWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhc1RhYmJhYmxlVGFiaW5kZXhPck5vbmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtLmlzLlRSSURFTlQgfHwgcGxhdGZvcm0uaXMuRURHRSkge1xuICAgICAgICAvLyBJRSBhbmQgRWRnZSBkZWdyYWRlIDxhcmVhPiB0byBzY3JpcHQgZm9jdXNhYmxlLCBpZiB0aGUgaW1hZ2VcbiAgICAgICAgLy8gdXNpbmcgdGhlIDxtYXA+IGhhcyBiZWVuIGdpdmVuIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdhcmVhJykge1xuICAgICAgICAgICAgdmFyIGltZyA9IGdldEltYWdlT2ZBcmVhKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGltZyAmJiB0YWJpbmRleFZhbHVlKGltZykgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBfc3R5bGUyID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gICAgICAgIGlmIChpc1VzZXJNb2RpZnlXcml0YWJsZShfc3R5bGUyKSkge1xuICAgICAgICAgICAgLy8gcHJldmVudCBiZWluZyBzd2FsbG93ZWQgYnkgdGhlIG92ZXJ6ZWFsb3VzIGlzU2Nyb2xsYWJsZUNvbnRhaW5lcigpIGJlbG93XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC50YWJJbmRleCA+PSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXhjZXB0LmZsZXhib3ggJiYgaGFzQ3NzRGlzcGxheUZsZXgoX3N0eWxlMikpIHtcbiAgICAgICAgICAgIGlmIChfdGFiaW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzVGFiYmFibGVUYWJpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoaXNGb2N1c1JlbGV2YW50V2l0aG91dEZsZXhib3goZWxlbWVudCkgJiZcbiAgICAgICAgICAgICAgICBpc1RhYmJhYmxlV2l0aG91dEZsZXhib3goZWxlbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElFIGNvbnNpZGVycyBzY3JvbGxhYmxlIGNvbnRhaW5lcnMgc2NyaXB0IGZvY3VzYWJsZSBvbmx5LFxuICAgICAgICAvLyBldmVuIHRob3VnaCB0aGVpciB0YWJJbmRleCBwcm9wZXJ0eSBpcyAwXG4gICAgICAgIGlmIChpc1Njcm9sbGFibGVDb250YWluZXIoZWxlbWVudCwgbm9kZU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudE5vZGVOYW1lID0gcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgcGFyZW50U3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQsIG51bGwpO1xuICAgICAgICAgICAgLy8gSUUgY29uc2lkZXJzIHNjcm9sbGFibGUgYm9kaWVzIHNjcmlwdCBmb2N1c2FibGUgb25seSxcbiAgICAgICAgICAgIGlmIChpc1Njcm9sbGFibGVDb250YWluZXIocGFyZW50LCBub2RlTmFtZSwgcGFyZW50Tm9kZU5hbWUsIHBhcmVudFN0eWxlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoaWxkcmVuIG9mIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoIGRpc3BsYXk6ZmxleCBhcmUgZm9jdXNhYmxlIGluIElFMTAtMTEsXG4gICAgICAgICAgICAvLyBldmVuIHRob3VnaCB0aGVpciB0YWJJbmRleCBwcm9wZXJ0eSBzdWdnZXN0cyBvdGhlcndpc2VcbiAgICAgICAgICAgIGlmIChoYXNDc3NEaXNwbGF5RmxleChwYXJlbnRTdHlsZSkpIHtcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZSBvZiB0YWJpbmRleCB0YWtlcyBwcmVjZWRlbmNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc1RhYmJhYmxlVGFiaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1dBSS9QRi9hcmlhLXByYWN0aWNlcy8jZm9jdXNfdGFiaW5kZXhcbiAgICByZXR1cm4gZWxlbWVudC50YWJJbmRleCA+PSAwO1xufVxuLy8gYmluZCBleGNlcHRpb25zIHRvIGFuIGl0ZXJhdG9yIGNhbGxiYWNrXG5pc1RhYmJhYmxlUnVsZXMuZXhjZXB0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBleGNlcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBpc1RhYmJhYmxlID0gZnVuY3Rpb24gaXNUYWJiYWJsZShjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBpc1RhYmJhYmxlUnVsZXMoe1xuICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgIGV4Y2VwdDogZXhjZXB0XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaXNUYWJiYWJsZS5ydWxlcyA9IGlzVGFiYmFibGVSdWxlcztcbiAgICByZXR1cm4gaXNUYWJiYWJsZTtcbn07XG52YXIgaXNGb2N1c1JlbGV2YW50V2l0aG91dEZsZXhib3ggPSBpc0ZvY3VzUmVsZXZhbnQucnVsZXMuZXhjZXB0KHtcbiAgICBmbGV4Ym94OiB0cnVlXG59KTtcbnZhciBpc1RhYmJhYmxlV2l0aG91dEZsZXhib3ggPSBpc1RhYmJhYmxlUnVsZXMuZXhjZXB0KHsgZmxleGJveDogdHJ1ZSB9KTtcbi8vIHByb3ZpZGUgaXNUYWJiYWJsZShjb250ZXh0KSBhcyBkZWZhdWx0IGl0ZXJhdG9yIGNhbGxiYWNrXG52YXIgaXNUYWJiYWJsZSA9IGlzVGFiYmFibGVSdWxlcy5leGNlcHQoe30pO1xuZnVuY3Rpb24gcXVlcnlUYWJiYWJsZSgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsIGluY2x1ZGVDb250ZXh0ID0gX3JlZi5pbmNsdWRlQ29udGV4dCwgaW5jbHVkZU9ubHlUYWJiYWJsZSA9IF9yZWYuaW5jbHVkZU9ubHlUYWJiYWJsZSwgc3RyYXRlZ3kgPSBfcmVmLnN0cmF0ZWd5O1xuICAgIHZhciBfaXNUYWJiYWJsZSA9IGlzVGFiYmFibGUucnVsZXMuZXhjZXB0KHtcbiAgICAgICAgb25seVRhYmJhYmxlOiBpbmNsdWRlT25seVRhYmJhYmxlXG4gICAgfSk7XG4gICAgcmV0dXJuIHF1ZXJ5Rm9jdXNhYmxlKHtcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgaW5jbHVkZUNvbnRleHQ6IGluY2x1ZGVDb250ZXh0LFxuICAgICAgICBpbmNsdWRlT25seVRhYmJhYmxlOiBpbmNsdWRlT25seVRhYmJhYmxlLFxuICAgICAgICBzdHJhdGVneTogc3RyYXRlZ3lcbiAgICB9KS5maWx0ZXIoX2lzVGFiYmFibGUpO1xufVxuLy8gc29ydHMgYSBsaXN0IG9mIGVsZW1lbnRzIGFjY29yZGluZyB0byB0aGVpciBvcmRlciBpbiB0aGUgRE9NXG5mdW5jdGlvbiBjb21wYXJlRG9tUG9zaXRpb24oYSwgYikge1xuICAgIHJldHVybiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkdcbiAgICAgICAgPyAtMVxuICAgICAgICA6IDE7XG59XG5mdW5jdGlvbiBzb3J0RG9tT3JkZXIoZWxlbWVudHMpIHtcbiAgICByZXR1cm4gZWxlbWVudHMuc29ydChjb21wYXJlRG9tUG9zaXRpb24pO1xufVxuZnVuY3Rpb24gZ2V0Rmlyc3RTdWNjZXNzb3JPZmZzZXQobGlzdCwgdGFyZ2V0KSB7XG4gICAgLy8gZmluZCB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGNvbWVzIEFGVEVSIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgIHJldHVybiBmaW5kSW5kZXgobGlzdCwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuICh0YXJnZXQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudCkgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmaW5kSW5zZXJ0aW9uT2Zmc2V0cyhsaXN0LCBlbGVtZW50cywgcmVzb2x2ZUVsZW1lbnQpIHtcbiAgICAvLyBpbnN0ZWFkIG9mIG11dGF0aW5nIHRoZSBlbGVtZW50cyBsaXN0IGRpcmVjdGx5LCByZW1lbWJlciBwb3NpdGlvbiBhbmQgbWFwXG4gICAgLy8gdG8gaW5qZWN0IGxhdGVyLCB3aGVuIHdlIGNhbiBkbyB0aGlzIG1vcmUgZWZmaWNpZW50bHlcbiAgICB2YXIgaW5zZXJ0aW9ucyA9IFtdO1xuICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHJlcGxhY2UgPSB0cnVlO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gbGlzdC5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgICBpZiAob2Zmc2V0ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBub3QgaW4gdGFyZ2V0IGxpc3RcbiAgICAgICAgICAgIG9mZnNldCA9IGdldEZpcnN0U3VjY2Vzc29yT2Zmc2V0KGxpc3QsIGVsZW1lbnQpO1xuICAgICAgICAgICAgcmVwbGFjZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBzdWNjZXNzb3IgaW4gdGhlIHRhYnNlcXVlbmNlLFxuICAgICAgICAgICAgLy8gbWVhbmluZyB0aGUgaW1hZ2UgbXVzdCBiZSB0aGUgbGFzdCBlbGVtZW50XG4gICAgICAgICAgICBvZmZzZXQgPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbGxvdyB0aGUgY29uc3VtZXIgdG8gcmVwbGFjZSB0aGUgaW5qZWN0ZWQgZWxlbWVudFxuICAgICAgICB2YXIgaW5qZWN0aW9ucyA9IG5vZGVBcnJheShyZXNvbHZlRWxlbWVudCA/IHJlc29sdmVFbGVtZW50KGVsZW1lbnQpIDogZWxlbWVudCk7XG4gICAgICAgIGlmICghaW5qZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHdlIGNhbid0IGluamVjdCB6ZXJvIGVsZW1lbnRzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICAgICAgICAgIGVsZW1lbnRzOiBpbmplY3Rpb25zXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBpbnNlcnRpb25zO1xufVxuZnVuY3Rpb24gaW5zZXJ0RWxlbWVudHNBdE9mZnNldHMobGlzdCwgaW5zZXJ0aW9ucykge1xuICAgIC8vIHJlbWVtYmVyIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgd2UgaGF2ZSBhbHJlYWR5IGluamVjdGVkXG4gICAgLy8gc28gd2UgYWNjb3VudCBmb3IgdGhlIGNhdXNlZCBpbmRleCBvZmZzZXRcbiAgICB2YXIgaW5zZXJ0ZWQgPSAwO1xuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHdlIGluc2VydCB0aGUgZWxlbWVudHMgaW4gc2VxdWVuY2UsXG4gICAgLy8gb3RoZXJ3aXNlIHRoZSBvZmZzZXQgY29tcGVuc2F0aW9uIHdvbid0IHdvcmtcbiAgICBpbnNlcnRpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEub2Zmc2V0IC0gYi5vZmZzZXQ7XG4gICAgfSk7XG4gICAgaW5zZXJ0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnNlcnRpb24pIHtcbiAgICAgICAgLy8gYXJyYXkuc3BsaWNlIGhhcyBhbiBhbm5veWluZyBmdW5jdGlvbiBzaWduYXR1cmUgOihcbiAgICAgICAgdmFyIHJlbW92ZSA9IGluc2VydGlvbi5yZXBsYWNlID8gMSA6IDA7XG4gICAgICAgIHZhciBhcmdzID0gW2luc2VydGlvbi5vZmZzZXQgKyBpbnNlcnRlZCwgcmVtb3ZlXS5jb25jYXQoaW5zZXJ0aW9uLmVsZW1lbnRzKTtcbiAgICAgICAgbGlzdC5zcGxpY2UuYXBwbHkobGlzdCwgYXJncyk7XG4gICAgICAgIGluc2VydGVkICs9IGluc2VydGlvbi5lbGVtZW50cy5sZW5ndGggLSByZW1vdmU7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBtZXJnZUluRG9tT3JkZXIoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LCBsaXN0ID0gX3JlZi5saXN0LCBlbGVtZW50cyA9IF9yZWYuZWxlbWVudHMsIHJlc29sdmVFbGVtZW50ID0gX3JlZi5yZXNvbHZlRWxlbWVudDtcbiAgICAvLyBvcGVyYXRlIG9uIGEgY29weSBzbyB3ZSBkb24ndCBtdXRhdGUgdGhlIG9yaWdpbmFsIGFycmF5XG4gICAgdmFyIF9saXN0ID0gbGlzdC5zbGljZSgwKTtcbiAgICAvLyBtYWtlIHN1cmUgdGhlIGVsZW1lbnRzIHdlJ3JlIGluamVjdGluZyBhcmUgcHJvdmlkZWQgaW4gRE9NIG9yZGVyXG4gICAgdmFyIF9lbGVtZW50cyA9IG5vZGVBcnJheShlbGVtZW50cykuc2xpY2UoMCk7XG4gICAgc29ydERvbU9yZGVyKF9lbGVtZW50cyk7XG4gICAgLy8gZmluZCB0aGUgb2Zmc2V0cyB3aXRoaW4gdGhlIHRhcmdldCBhcnJheSAobGlzdCkgYXQgd2hpY2ggdG8gaW5qZWN0XG4gICAgLy8gZWFjaCBpbmRpdmlkdWFsIGVsZW1lbnQgKGZyb20gZWxlbWVudHMpXG4gICAgdmFyIGluc2VydGlvbnMgPSBmaW5kSW5zZXJ0aW9uT2Zmc2V0cyhfbGlzdCwgX2VsZW1lbnRzLCByZXNvbHZlRWxlbWVudCk7XG4gICAgLy8gYWN0dWFsbHkgaW5qZWN0IHRoZSBlbGVtZW50cyBpbnRvIHRoZSB0YXJnZXQgYXJyYXkgYXQgdGhlIGlkZW50aWZpZWQgcG9zaXRpb25zXG4gICAgaW5zZXJ0RWxlbWVudHNBdE9mZnNldHMoX2xpc3QsIGluc2VydGlvbnMpO1xuICAgIHJldHVybiBfbGlzdDtcbn1cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcilcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgICAgICBpZiAocHJvdG9Qcm9wcylcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICAgICAgaWYgKHN0YXRpY1Byb3BzKVxuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgfTtcbn0pKCk7XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7XG4gICAgfVxufVxudmFyIE1hcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcHMoY29udGV4dCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFwcyk7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gZ2V0RG9jdW1lbnQoY29udGV4dCk7XG4gICAgICAgIHRoaXMubWFwcyA9IHt9O1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoTWFwcywgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdnZXRBcmVhc0ZvcicsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXJlYXNGb3IobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXBzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtYXAgaXMgbm90IGRlZmluZWQgd2l0aGluIHRoZSBjb250ZXh0LCBzbyB3ZVxuICAgICAgICAgICAgICAgICAgICAvLyBoYXZlIHRvIGdvIGZpbmQgaXQgZWxzZXdoZXJlIGluIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1hcEJ5TmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnYWRkTWFwQnlOYW1lJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRNYXBCeU5hbWUobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBnZXRNYXBCeU5hbWUobmFtZSwgdGhpcy5fZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIG1hcCwgdGhlIGltZ1t1c2VtYXBdIHdhc24ndCBkb2luZyBhbnl0aGluZyBhbnl3YXlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1hcHNbbWFwLm5hbWVdID0gcXVlcnlUYWJiYWJsZSh7IGNvbnRleHQ6IG1hcCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnZXh0cmFjdEFyZWFzRnJvbUxpc3QnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RBcmVhc0Zyb21MaXN0KGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCA8YXJlYT4gZWxlbWVudHMgZnJvbSB0aGUgZWxlbWVudHMgbGlzdCxcbiAgICAgICAgICAgICAgICAvLyBidXQgcHV0IHRoZW0gdGhlIG1hcCBmb3IgbGF0ZXIgcmV0cmlldmFsXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSAhPT0gJ2FyZWEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWFwc1ttYXAubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwc1ttYXAubmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHNbbWFwLm5hbWVdLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICBdKTtcbiAgICByZXR1cm4gTWFwcztcbn0pKCk7XG5mdW5jdGlvbiBzb3J0QXJlYShlbGVtZW50cywgY29udGV4dCkge1xuICAgIC8vIGltYWdlcyAtIHVubGVzcyB0aGV5IGFyZSBmb2N1c2FibGUgdGhlbXNlbHZlcywgbGlrZWx5IG5vdFxuICAgIC8vIHBhcnQgb2YgdGhlIGVsZW1lbnRzIGxpc3QsIHNvIHdlJ2xsIGhhdmUgdG8gZmluZCB0aGVtIGFuZFxuICAgIC8vIHNvcnQgdGhlbSBpbnRvIHRoZSBlbGVtZW50cyBsaXN0IG1hbnVhbGx5XG4gICAgdmFyIHVzZW1hcHMgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltZ1t1c2VtYXBdJyk7XG4gICAgdmFyIG1hcHMgPSBuZXcgTWFwcyhjb250ZXh0KTtcbiAgICAvLyByZW1vdmUgYWxsIDxhcmVhPiBlbGVtZW50cyBmcm9tIHRoZSBlbGVtZW50cyBsaXN0LFxuICAgIC8vIGJ1dCBwdXQgdGhlbSB0aGUgbWFwIGZvciBsYXRlciByZXRyaWV2YWxcbiAgICB2YXIgX2VsZW1lbnRzID0gbWFwcy5leHRyYWN0QXJlYXNGcm9tTGlzdChlbGVtZW50cyk7XG4gICAgaWYgKCF1c2VtYXBzLmxlbmd0aCkge1xuICAgICAgICAvLyB0aGUgY29udGV4dCBkb2VzIG5vdCBjb250YWluIGFueSA8YXJlYT5zIHNvIG5vIG5lZWRcbiAgICAgICAgLy8gdG8gcmVwbGFjZSBhbnl0aGluZywganVzdCByZW1vdmUgYW55IG1hcHNcbiAgICAgICAgcmV0dXJuIF9lbGVtZW50cztcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlSW5Eb21PcmRlcih7XG4gICAgICAgIGxpc3Q6IF9lbGVtZW50cyxcbiAgICAgICAgZWxlbWVudHM6IHVzZW1hcHMsXG4gICAgICAgIHJlc29sdmVFbGVtZW50OiBmdW5jdGlvbiByZXNvbHZlRWxlbWVudChpbWFnZSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ3VzZW1hcCcpLnNsaWNlKDEpO1xuICAgICAgICAgICAgcmV0dXJuIG1hcHMuZ2V0QXJlYXNGb3IobmFtZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbnZhciBfY3JlYXRlQ2xhc3MkMSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgICAgIGlmIChwcm90b1Byb3BzKVxuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgICAgICBpZiAoc3RhdGljUHJvcHMpXG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICB9O1xufSkoKTtcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayQxKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpO1xuICAgIH1cbn1cbnZhciBTaGFkb3dzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaGFkb3dzKGNvbnRleHQsIHNvcnRFbGVtZW50cykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2skMSh0aGlzLCBTaGFkb3dzKTtcbiAgICAgICAgLy8gZG9jdW1lbnQgY29udGV4dCB3ZSdyZSB3b3JraW5nIHdpdGhcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgLy8gY2FsbGJhY2sgdGhhdCBzb3J0cyBhbiBhcnJheSBvZiBlbGVtZW50c1xuICAgICAgICB0aGlzLnNvcnRFbGVtZW50cyA9IHNvcnRFbGVtZW50cztcbiAgICAgICAgLy8gcmVmZXJlbmNlIHRvIGNyZWF0ZSB1bmlxdWUgSURzIGZvciBlYWNoIFNoYWRvd0hvc3RcbiAgICAgICAgdGhpcy5ob3N0Q291bnRlciA9IDE7XG4gICAgICAgIC8vIHJlZmVyZW5jZSBtYXAgZm9yIGNoaWxkLVNoYWRvd0hvc3RzIG9mIGEgU2hhZG93SG9zdFxuICAgICAgICB0aGlzLmluSG9zdCA9IHt9O1xuICAgICAgICAvLyByZWZlcmVuY2UgbWFwIGZvciBjaGlsZC1TaGFkb3dIb3N0IG9mIHRoZSBkb2N1bWVudFxuICAgICAgICB0aGlzLmluRG9jdW1lbnQgPSBbXTtcbiAgICAgICAgLy8gcmVmZXJlbmNlIG1hcCBmb3IgU2hhZG93SG9zdHNcbiAgICAgICAgdGhpcy5ob3N0cyA9IHt9O1xuICAgICAgICAvLyByZWZlcmVuY2UgbWFwIGZvciB0YWJiYWJsZSBlbGVtZW50cyBvZiBhIFNoYWRvd0hvc3RcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IHt9O1xuICAgIH1cbiAgICAvLyByZW1lbWJlciB3aGljaCBob3N0cyB3ZSBoYXZlIHRvIHNvcnQgd2l0aGluIGxhdGVyXG4gICAgX2NyZWF0ZUNsYXNzJDEoU2hhZG93cywgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdfcmVnaXN0ZXJIb3N0JyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVnaXN0ZXJIb3N0KGhvc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdC5fc29ydGluZ0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgU2hhZG93SG9zdCBpZGVudGlmaWFibGUgKHNlZSBjbGVhbnVwKCkgZm9yIHVuZG8pXG4gICAgICAgICAgICAgICAgaG9zdC5fc29ydGluZ0lkID0gJ3NoYWRvdy0nICsgdGhpcy5ob3N0Q291bnRlcisrO1xuICAgICAgICAgICAgICAgIHRoaXMuaG9zdHNbaG9zdC5fc29ydGluZ0lkXSA9IGhvc3Q7XG4gICAgICAgICAgICAgICAgLy8gaG9zdHMgbWF5IGNvbnRhaW4gb3RoZXIgaG9zdHNcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SG9zdCA9IGdldFNoYWRvd0hvc3QoeyBjb250ZXh0OiBob3N0IH0pO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRIb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVySG9zdChwYXJlbnRIb3N0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJIb3N0UGFyZW50KGhvc3QsIHBhcmVudEhvc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbkRvY3VtZW50LnB1c2goaG9zdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdfcmVnaXN0ZXJIb3N0UGFyZW50JyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVnaXN0ZXJIb3N0UGFyZW50KGhvc3QsIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pbkhvc3RbcGFyZW50Ll9zb3J0aW5nSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5Ib3N0W3BhcmVudC5fc29ydGluZ0lkXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmluSG9zdFtwYXJlbnQuX3NvcnRpbmdJZF0ucHVzaChob3N0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnX3JlZ2lzdGVyRWxlbWVudCcsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZ2lzdGVyRWxlbWVudChlbGVtZW50LCBob3N0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnRzW2hvc3QuX3NvcnRpbmdJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tob3N0Ll9zb3J0aW5nSWRdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbaG9zdC5fc29ydGluZ0lkXS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdleHRyYWN0RWxlbWVudHMnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4dHJhY3RFbGVtZW50cyhlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3QgPSBnZXRTaGFkb3dIb3N0KHsgY29udGV4dDogZWxlbWVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWdpc3Rlckhvc3QoaG9zdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyRWxlbWVudChlbGVtZW50LCBob3N0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdzb3J0JyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzb3J0KGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9lbGVtZW50cyA9IHRoaXMuX2luamVjdEhvc3RzKGVsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICBfZWxlbWVudHMgPSB0aGlzLl9yZXBsYWNlSG9zdHMoX2VsZW1lbnRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9lbGVtZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnX2luamVjdEhvc3RzJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5qZWN0SG9zdHMoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmhvc3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChfc29ydGluZ0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfbGlzdCA9IHRoaXMuZWxlbWVudHNbX3NvcnRpbmdJZF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBfZWxlbWVudHMgPSB0aGlzLmluSG9zdFtfc29ydGluZ0lkXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jb250ZXh0ID0gdGhpcy5ob3N0c1tfc29ydGluZ0lkXS5zaGFkb3dSb290O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzW19zb3J0aW5nSWRdID0gdGhpcy5fbWVyZ2UoX2xpc3QsIF9lbGVtZW50cywgX2NvbnRleHQpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tZXJnZShlbGVtZW50cywgdGhpcy5pbkRvY3VtZW50LCB0aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6ICdfbWVyZ2UnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tZXJnZShsaXN0LCBlbGVtZW50cywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBtZXJnZWQgPSBtZXJnZUluRG9tT3JkZXIoe1xuICAgICAgICAgICAgICAgICAgICBsaXN0OiBsaXN0LFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zb3J0RWxlbWVudHMobWVyZ2VkLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiAnX3JlcGxhY2VIb3N0cycsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcGxhY2VIb3N0cyhlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZUluRG9tT3JkZXIoe1xuICAgICAgICAgICAgICAgICAgICBsaXN0OiBlbGVtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHM6IHRoaXMuaW5Eb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUVsZW1lbnQ6IHRoaXMuX3Jlc29sdmVIb3N0RWxlbWVudC5iaW5kKHRoaXMpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ19yZXNvbHZlSG9zdEVsZW1lbnQnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNvbHZlSG9zdEVsZW1lbnQoaG9zdCkge1xuICAgICAgICAgICAgICAgIHZhciBtZXJnZWQgPSBtZXJnZUluRG9tT3JkZXIoe1xuICAgICAgICAgICAgICAgICAgICBsaXN0OiB0aGlzLmVsZW1lbnRzW2hvc3QuX3NvcnRpbmdJZF0sXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiB0aGlzLmluSG9zdFtob3N0Ll9zb3J0aW5nSWRdLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlRWxlbWVudDogdGhpcy5fcmVzb2x2ZUhvc3RFbGVtZW50LmJpbmQodGhpcylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgX3RhYmluZGV4ID0gdGFiaW5kZXhWYWx1ZShob3N0KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RhYmluZGV4ICE9PSBudWxsICYmIF90YWJpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbaG9zdF0uY29uY2F0KG1lcmdlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogJ19jbGVhbnVwJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xlYW51cCgpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhvc2UgaWRlbnRpZmVycyB3ZSBwdXQgb24gdGhlIFNoYWRvd0hvc3QgdG8gYXZvaWQgdXNpbmcgTWFwKClcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmhvc3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaG9zdHNba2V5XS5fc29ydGluZ0lkO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIF0pO1xuICAgIHJldHVybiBTaGFkb3dzO1xufSkoKTtcbmZ1bmN0aW9uIHNvcnRTaGFkb3dlZChlbGVtZW50cywgY29udGV4dCwgc29ydEVsZW1lbnRzKSB7XG4gICAgdmFyIHNoYWRvd3MgPSBuZXcgU2hhZG93cyhjb250ZXh0LCBzb3J0RWxlbWVudHMpO1xuICAgIHZhciBfZWxlbWVudHMgPSBzaGFkb3dzLmV4dHJhY3RFbGVtZW50cyhlbGVtZW50cyk7XG4gICAgaWYgKF9lbGVtZW50cy5sZW5ndGggPT09IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAvLyBubyBzaGFkb3dlZCBjb250ZW50IGZvdW5kLCBubyBuZWVkIHRvIGNvbnRpbnVlXG4gICAgICAgIHJldHVybiBzb3J0RWxlbWVudHMoZWxlbWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZG93cy5zb3J0KF9lbGVtZW50cyk7XG59XG5mdW5jdGlvbiBzb3J0VGFiaW5kZXgoZWxlbWVudHMpIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQudGFiSW5kZXhcbiAgICAvLyBlbGVtZW50cyB3aXRoIHRhYkluZGV4IFwiMFwiIChpbmNsdWRpbmcgdGFiYmFibGVFbGVtZW50cyB3aXRob3V0IHRhYkluZGV4KSBzaG91bGQgYmUgbmF2aWdhdGVkIGluIHRoZSBvcmRlciB0aGV5IGFwcGVhci5cbiAgICAvLyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpdmUgdGFiSW5kZXg6XG4gICAgLy8gICBFbGVtZW50cyB0aGF0IGhhdmUgaWRlbnRpY2FsIHRhYkluZGV4ZXMgc2hvdWxkIGJlIG5hdmlnYXRlZCBpbiB0aGUgb3JkZXIgdGhleSBhcHBlYXIuXG4gICAgLy8gICBOYXZpZ2F0aW9uIHByb2NlZWRzIGZyb20gdGhlIGxvd2VzdCB0YWJJbmRleCB0byB0aGUgaGlnaGVzdCB0YWJJbmRleC5cbiAgICAvLyBOT1RFOiBzb3J0IGltcGxlbWVudGF0aW9uIG1heSBiZSB1bnN0YWJsZSBhbmQgdGh1cyBtZXNzIHVwIERPTSBvcmRlcixcbiAgICAvLyB0aGF0J3Mgd2h5IHdlIGJ1aWxkIGEgbWFwIHRoYXQncyBiZWluZyBzb3J0ZWQgaW5zdGVhZC4gSWYgd2Ugd2VyZSBhYmxlIHRvIHJlbHlcbiAgICAvLyBvbiBhIHN0YWJsZSBzb3J0aW5nIGFsZ29yaXRobSwgc29ydFRhYmluZGV4KCkgY291bGQgYmUgYXMgc2ltcGxlIGFzXG4gICAgLy8gZWxlbWVudHMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDsgfSk7XG4gICAgLy8gYXQgdGhpcyB0aW1lIENocm9tZSBkb2VzIG5vdCB1c2UgYSBzdGFibGUgc29ydGluZyBhbGdvcml0aG1cbiAgICAvLyBzZWUgaHR0cDovL2Jsb2cucm9kbmV5cmVobS5kZS9hcmNoaXZlcy8xNC1Tb3J0aW5nLVdlcmUtRG9pbmctSXQtV3JvbmcuaHRtbCNzdGFiaWxpdHlcbiAgICAvLyBOT1RFOiBjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiBzZWVtZWQgbGlrZSBtb3JlIG92ZXJoZWFkIHRoYW4ganVzdCBzb3J0aW5nIHRoaXMgd2l0aCBidWNrZXRzXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb25cbiAgICB2YXIgbWFwID0ge307XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgICB2YXIgbm9ybWFsID0gZWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIC8vIGluIFRyaWRlbnQgYW5kIEdlY2tvIFNWR0VsZW1lbnQgZG9lcyBub3Qga25vdyBhYm91dCB0aGUgdGFiSW5kZXggcHJvcGVydHlcbiAgICAgICAgdmFyIHRhYkluZGV4ID0gZWxlbWVudC50YWJJbmRleDtcbiAgICAgICAgaWYgKHRhYkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRhYkluZGV4ID0gdGFiaW5kZXhWYWx1ZShlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleHRyYWN0IGVsZW1lbnRzIHRoYXQgZG9uJ3QgbmVlZCBzb3J0aW5nXG4gICAgICAgIGlmICh0YWJJbmRleCA8PSAwIHx8IHRhYkluZGV4ID09PSBudWxsIHx8IHRhYkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWFwW3RhYkluZGV4XSkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIHNvcnRhYmxlIGJ1Y2tldCBmb3IgZG9tLW9yZGVyLXByZXNlcnZhdGlvbiBvZiBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIHRhYkluZGV4XG4gICAgICAgICAgICBtYXBbdGFiSW5kZXhdID0gW107XG4gICAgICAgICAgICAvLyBtYWludGFpbiBhIGxpc3Qgb2YgdW5pcXVlIHRhYkluZGV4ZXNcbiAgICAgICAgICAgIGluZGV4ZXMucHVzaCh0YWJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc29ydCBlbGVtZW50IGludG8gdGhlIHByb3BlciBidWNrZXRcbiAgICAgICAgbWFwW3RhYkluZGV4XS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAvLyBlbGVtZW50IG1vdmVkIHRvIHNvcnRpbmcgbWFwLCBzbyBub3QgXCJub3JtYWxcIiBhbnltb3JlXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICAvLyBzb3J0IHRoZSB0YWJpbmRleCBhc2NlbmRpbmcsXG4gICAgLy8gdGhlbiByZXNvbHZlIHRoZW0gdG8gdGhlaXIgYXBwcm9wcmlhdGUgYnVja2V0cyxcbiAgICAvLyB0aGVuIGZsYXR0ZW4gdGhlIGFycmF5IG9mIGFycmF5cyB0byBhbiBhcnJheVxuICAgIHZhciBfZWxlbWVudHMgPSBpbmRleGVzXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodGFiSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG1hcFt0YWJJbmRleF07XG4gICAgfSlcbiAgICAgICAgLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkge1xuICAgICAgICByZXR1cm4gY3VycmVudC5jb25jYXQocHJldmlvdXMpO1xuICAgIH0sIG5vcm1hbCk7XG4gICAgcmV0dXJuIF9lbGVtZW50cztcbn1cbnZhciBzdXBwb3J0cyQ4ID0gdm9pZCAwO1xuZnVuY3Rpb24gbW92ZUNvbnRleHRUb0JlZ2lubmluZyhlbGVtZW50cywgY29udGV4dCkge1xuICAgIHZhciBwb3MgPSBlbGVtZW50cy5pbmRleE9mKGNvbnRleHQpO1xuICAgIGlmIChwb3MgPiAwKSB7XG4gICAgICAgIHZhciB0bXAgPSBlbGVtZW50cy5zcGxpY2UocG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHRtcC5jb25jYXQoZWxlbWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudHM7XG59XG5mdW5jdGlvbiBzb3J0RWxlbWVudHMoZWxlbWVudHMsIF9jb250ZXh0KSB7XG4gICAgaWYgKHN1cHBvcnRzJDgudGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvbikge1xuICAgICAgICAvLyBTb21lIGJyb3dzZXJzIHNvcnQgPGFyZWE+IGluIERPTSBvcmRlciwgc29tZSBwbGFjZSB0aGUgPGFyZWE+c1xuICAgICAgICAvLyB3aGVyZSB0aGUgPGltZz4gcmVmZXJlY2luZyB0aGVtIHdvdWxkJ3ZlIGJlZW4gaW4gRE9NIG9yZGVyLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzVcbiAgICAgICAgZWxlbWVudHMgPSBzb3J0QXJlYShlbGVtZW50cywgX2NvbnRleHQpO1xuICAgIH1cbiAgICBlbGVtZW50cyA9IHNvcnRUYWJpbmRleChlbGVtZW50cyk7XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xufVxuZnVuY3Rpb24gcXVlcnlUYWJzZXF1ZW5jZSgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsIGluY2x1ZGVDb250ZXh0ID0gX3JlZi5pbmNsdWRlQ29udGV4dCwgaW5jbHVkZU9ubHlUYWJiYWJsZSA9IF9yZWYuaW5jbHVkZU9ubHlUYWJiYWJsZSwgc3RyYXRlZ3kgPSBfcmVmLnN0cmF0ZWd5O1xuICAgIGlmICghc3VwcG9ydHMkOCkge1xuICAgICAgICBzdXBwb3J0cyQ4ID0gX3N1cHBvcnRzKCk7XG4gICAgfVxuICAgIHZhciBfY29udGV4dCA9IG5vZGVBcnJheShjb250ZXh0KVswXSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIGVsZW1lbnRzID0gcXVlcnlUYWJiYWJsZSh7XG4gICAgICAgIGNvbnRleHQ6IF9jb250ZXh0LFxuICAgICAgICBpbmNsdWRlQ29udGV4dDogaW5jbHVkZUNvbnRleHQsXG4gICAgICAgIGluY2x1ZGVPbmx5VGFiYmFibGU6IGluY2x1ZGVPbmx5VGFiYmFibGUsXG4gICAgICAgIHN0cmF0ZWd5OiBzdHJhdGVneVxuICAgIH0pO1xuICAgIGlmIChkb2N1bWVudC5ib2R5LmNyZWF0ZVNoYWRvd1Jvb3QgJiYgcGxhdGZvcm0uaXMuQkxJTkspIHtcbiAgICAgICAgLy8gc29ydCB0YWJpbmRleCBsb2NhbGl6ZWQgdG8gc2hhZG93IGRvbVxuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy82XG4gICAgICAgIGVsZW1lbnRzID0gc29ydFNoYWRvd2VkKGVsZW1lbnRzLCBfY29udGV4dCwgc29ydEVsZW1lbnRzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVsZW1lbnRzID0gc29ydEVsZW1lbnRzKGVsZW1lbnRzLCBfY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlQ29udGV4dCkge1xuICAgICAgICAvLyBpZiB3ZSBpbmNsdWRlIHRoZSBjb250ZXh0IGl0c2VsZiwgaXQgaGFzIHRvIGJlIHRoZSBmaXJzdFxuICAgICAgICAvLyBlbGVtZW50IG9mIHRoZSBzZXF1ZW5jZVxuICAgICAgICBlbGVtZW50cyA9IG1vdmVDb250ZXh0VG9CZWdpbm5pbmcoZWxlbWVudHMsIF9jb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xufVxuLy8gY29kZXMgbW9zdGx5IGNsb25lZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rZWl0aGFtdXMvandlcnR5L2Jsb2IvbWFzdGVyL2p3ZXJ0eS5qc1xuLy8gZGVsaWJlcmF0ZWx5IG5vdCBleHBvc2luZyBjaGFyYWN0ZXJzIGxpa2UgPCwuLSMqIGJlY2F1c2UgdGhleSB2YXJ5ICp3aWxkbHkqXG4vLyBhY3Jvc3Mga2V5Ym9hcmQgbGF5b3V0cyBhbmQgbWF5IGNhdXNlIHZhcmlvdXMgcHJvYmxlbXNcbi8vIChlLmcuIFwiKlwiIGlzIFwiU2hpZnQgK1wiIG9uIGEgR2VybWFuIE1hYyBrZXlib2FyZClcbi8vIChlLmcuIFwiQFwiIGlzIFwiQWx0IExcIiBvbiBhIEdlcm1hbiBNYWMga2V5Ym9hcmQpXG52YXIga2V5Y29kZSA9IHtcbiAgICAvLyBFbGVtZW50IEZvY3VzXG4gICAgdGFiOiA5LFxuICAgIC8vIE5hdmlnYXRpb25cbiAgICBsZWZ0OiAzNyxcbiAgICB1cDogMzgsXG4gICAgcmlnaHQ6IDM5LFxuICAgIGRvd246IDQwLFxuICAgIHBhZ2VVcDogMzMsXG4gICAgJ3BhZ2UtdXAnOiAzMyxcbiAgICBwYWdlRG93bjogMzQsXG4gICAgJ3BhZ2UtZG93bic6IDM0LFxuICAgIGVuZDogMzUsXG4gICAgaG9tZTogMzYsXG4gICAgLy8gQWN0aW9uXG4gICAgZW50ZXI6IDEzLFxuICAgIGVzY2FwZTogMjcsXG4gICAgc3BhY2U6IDMyLFxuICAgIC8vIE1vZGlmaWVyXG4gICAgc2hpZnQ6IDE2LFxuICAgIGNhcHNMb2NrOiAyMCxcbiAgICAnY2Fwcy1sb2NrJzogMjAsXG4gICAgY3RybDogMTcsXG4gICAgYWx0OiAxOCxcbiAgICBtZXRhOiA5MSxcbiAgICAvLyBpbiBmaXJlZm94OiAyMjRcbiAgICAvLyBvbiBtYWMgKGNocm9tZSk6IG1ldGEtbGVmdD05MSwgbWV0YS1yaWdodD05M1xuICAgIC8vIG9uIHdpbiAoSUUxMSk6IG1ldGEtbGVmdD05MSwgbWV0YS1yaWdodD05MlxuICAgIHBhdXNlOiAxOSxcbiAgICAvLyBDb250ZW50IE1hbmlwdWxhdGlvblxuICAgIGluc2VydDogNDUsXG4gICAgXCJkZWxldGVcIjogNDYsXG4gICAgYmFja3NwYWNlOiA4LFxuICAgIC8vIHRoZSBzYW1lIGxvZ2ljYWwga2V5IG1heSBiZSBpZGVudGlmaWVkIHRocm91Z2ggZGlmZmVyZW50IGtleUNvZGVzXG4gICAgX2FsaWFzOiB7XG4gICAgICAgIDkxOiBbOTIsIDkzLCAyMjRdXG4gICAgfVxufTtcbi8vIEZ1bmN0aW9uIGtleXMgKDExMiAtIDEzNylcbi8vIE5PVEU6IG5vdCBldmVyeSBrZXlib2FyZCBrbm93cyBGMTMrXG5mb3IgKHZhciBuID0gMTsgbiA8IDI2OyBuKyspIHtcbiAgICBrZXljb2RlWydmJyArIG5dID0gbiArIDExMTtcbn1cbi8vIE51bWJlciBrZXlzICg0OC01NywgbnVtcGFkIDk2LTEwNSlcbi8vIE5PVEU6IG5vdCBldmVyeSBrZXlib2FyZCBrbm93cyBudW0tMCtcbmZvciAodmFyIF9uID0gMDsgX24gPCAxMDsgX24rKykge1xuICAgIHZhciBjb2RlID0gX24gKyA0ODtcbiAgICB2YXIgbnVtQ29kZSA9IF9uICsgOTY7XG4gICAga2V5Y29kZVtfbl0gPSBjb2RlO1xuICAgIGtleWNvZGVbJ251bS0nICsgX25dID0gbnVtQ29kZTtcbiAgICBrZXljb2RlLl9hbGlhc1tjb2RlXSA9IFtudW1Db2RlXTtcbn1cbi8vIExhdGluIGNoYXJhY3RlcnMgKDY1IC0gOTApXG5mb3IgKHZhciBfbjIgPSAwOyBfbjIgPCAyNjsgX24yKyspIHtcbiAgICB2YXIgX2NvZGUgPSBfbjIgKyA2NTtcbiAgICB2YXIgbmFtZSQxID0gU3RyaW5nLmZyb21DaGFyQ29kZShfY29kZSkudG9Mb3dlckNhc2UoKTtcbiAgICBrZXljb2RlW25hbWUkMV0gPSBfY29kZTtcbn1cbnZhciBtb2RpZmllciA9IHtcbiAgICBhbHQ6ICdhbHRLZXknLFxuICAgIGN0cmw6ICdjdHJsS2V5JyxcbiAgICBtZXRhOiAnbWV0YUtleScsXG4gICAgc2hpZnQ6ICdzaGlmdEtleSdcbn07XG52YXIgbW9kaWZpZXJTZXF1ZW5jZSA9IE9iamVjdC5rZXlzKG1vZGlmaWVyKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gbW9kaWZpZXJbbmFtZV07XG59KTtcbmZ1bmN0aW9uIGNyZWF0ZUV4cGVjdGVkTW9kaWZpZXJzKGlnbm9yZU1vZGlmaWVycykge1xuICAgIHZhciB2YWx1ZSA9IGlnbm9yZU1vZGlmaWVycyA/IG51bGwgOiBmYWxzZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhbHRLZXk6IHZhbHVlLFxuICAgICAgICBjdHJsS2V5OiB2YWx1ZSxcbiAgICAgICAgbWV0YUtleTogdmFsdWUsXG4gICAgICAgIHNoaWZ0S2V5OiB2YWx1ZVxuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICAgIHZhciBpZ25vcmVNb2RpZmllcnMgPSBtb2RpZmllcnMuaW5kZXhPZignKicpICE9PSAtMTtcbiAgICB2YXIgZXhwZWN0ZWQgPSBjcmVhdGVFeHBlY3RlZE1vZGlmaWVycyhpZ25vcmVNb2RpZmllcnMpO1xuICAgIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4gPT09ICcqJykge1xuICAgICAgICAgICAgLy8gd2UndmUgYWxyZWFkeSBjb3ZlcmVkIHRoZSBhbGwtaW4gb3BlcmF0b3JcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSB3YW50IHRoZSBtb2RpZmllciBwcmVzc2VkXG4gICAgICAgIHZhciB2YWx1ZSA9IHRydWU7XG4gICAgICAgIHZhciBvcGVyYXRvciA9IHRva2VuLnNsaWNlKDAsIDEpO1xuICAgICAgICBpZiAob3BlcmF0b3IgPT09ICc/Jykge1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgY2FyZSBpZiB0aGUgbW9kaWZpZXIgaXMgcHJlc3NlZFxuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdG9yID09PSAnIScpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvIG5vdCB3YW50IHRoZSBtb2RpZmllciBwcmVzc2VkXG4gICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gY29tcGVuc2F0ZSBmb3IgdGhlIG1vZGlmaWVyJ3Mgb3BlcmF0b3JcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW4uc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IG1vZGlmaWVyW3Rva2VuXTtcbiAgICAgICAgaWYgKCFwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gbW9kaWZpZXIgXCInICsgdG9rZW4gKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3RlZFtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGV4cGVjdGVkO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUtleShrZXkpIHtcbiAgICB2YXIgY29kZSA9IGtleWNvZGVba2V5XSB8fCBwYXJzZUludChrZXksIDEwKTtcbiAgICBpZiAoIWNvZGUgfHwgdHlwZW9mIGNvZGUgIT09ICdudW1iZXInIHx8IGlzTmFOKGNvZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24ga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgIH1cbiAgICByZXR1cm4gW2NvZGVdLmNvbmNhdChrZXljb2RlLl9hbGlhc1tjb2RlXSB8fCBbXSk7XG59XG5mdW5jdGlvbiBtYXRjaE1vZGlmaWVycyhleHBlY3RlZCwgZXZlbnQpIHtcbiAgICAvLyByZXR1cm5zIHRydWUgb24gbWF0Y2hcbiAgICByZXR1cm4gIW1vZGlmaWVyU2VxdWVuY2Uuc29tZShmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAvLyByZXR1cm5zIHRydWUgb24gbWlzbWF0Y2hcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgZXhwZWN0ZWRbcHJvcF0gPT09ICdib29sZWFuJyAmJlxuICAgICAgICAgICAgQm9vbGVhbihldmVudFtwcm9wXSkgIT09IGV4cGVjdGVkW3Byb3BdKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGtleUJpbmRpbmcodGV4dCkge1xuICAgIHJldHVybiB0ZXh0LnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uIChfdGV4dCkge1xuICAgICAgICB2YXIgdG9rZW5zID0gX3RleHQuc3BsaXQoJysnKTtcbiAgICAgICAgdmFyIF9tb2RpZmllcnMgPSByZXNvbHZlTW9kaWZpZXJzKHRva2Vucy5zbGljZSgwLCAtMSkpO1xuICAgICAgICB2YXIgX2tleUNvZGVzID0gcmVzb2x2ZUtleSh0b2tlbnMuc2xpY2UoLTEpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleUNvZGVzOiBfa2V5Q29kZXMsXG4gICAgICAgICAgICBtb2RpZmllcnM6IF9tb2RpZmllcnMsXG4gICAgICAgICAgICBtYXRjaE1vZGlmaWVyczogbWF0Y2hNb2RpZmllcnMuYmluZChudWxsLCBfbW9kaWZpZXJzKVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuLy8gTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiBpcyBhdmFpbGFibGUgc2luY2UgSUU5XG4vLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb25cbi8vIGNhbGxiYWNrIHJldHVybnMgdHJ1ZSB3aGVuIGVsZW1lbnQgaXMgY29udGFpbmVkIGJ5IHBhcmVudCBvciBpcyB0aGUgcGFyZW50IHN1aXRlZCBmb3IgdXNlIHdpdGggQXJyYXkuc29tZSgpXG4vKlxuICBVU0FHRTpcbiAgICB2YXIgaXNDaGlsZE9mID0gZ2V0UGFyZW50Q29tcGFyYXRvcih7cGFyZW50OiBzb21lTm9kZX0pO1xuICAgIGxpc3RPZkVsZW1lbnRzLnNvbWUoaXNDaGlsZE9mKVxuKi9cbmZ1bmN0aW9uIGdldFBhcmVudENvbXBhcmF0b3IoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LCBwYXJlbnQgPSBfcmVmLnBhcmVudCwgZWxlbWVudCA9IF9yZWYuZWxlbWVudCwgaW5jbHVkZVNlbGYgPSBfcmVmLmluY2x1ZGVTZWxmO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzQ2hpbGRPZihub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbigoaW5jbHVkZVNlbGYgJiYgbm9kZSA9PT0gcGFyZW50KSB8fFxuICAgICAgICAgICAgICAgIHBhcmVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihub2RlKSAmXG4gICAgICAgICAgICAgICAgICAgIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaXNQYXJlbnRPZihub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbigoaW5jbHVkZVNlbGYgJiYgZWxlbWVudCA9PT0gbm9kZSkgfHxcbiAgICAgICAgICAgICAgICBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQpICZcbiAgICAgICAgICAgICAgICAgICAgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1dGlsL2NvbXBhcmUtcG9zaXRpb24jZ2V0UGFyZW50Q29tcGFyYXRvciByZXF1aXJlZCBlaXRoZXIgb3B0aW9ucy5wYXJlbnQgb3Igb3B0aW9ucy5lbGVtZW50Jyk7XG59XG4vLyBCdWcgMjg2OTMzIC0gS2V5IGV2ZW50cyBpbiB0aGUgYXV0b2NvbXBsZXRlIHBvcHVwIHNob3VsZCBiZSBoaWRkZW4gZnJvbSBwYWdlIHNjcmlwdHNcbi8vIEBicm93c2VyLWlzc3VlIEdlY2tvIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTI4NjkzM1xuZnVuY3Rpb24gd2hlbktleSgpIHtcbiAgICB2YXIgbWFwID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIgYmluZGluZ3MgPSB7fTtcbiAgICB2YXIgY29udGV4dCA9IG5vZGVBcnJheShtYXAuY29udGV4dClbMF0gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIGRlbGV0ZSBtYXAuY29udGV4dDtcbiAgICB2YXIgZmlsdGVyID0gbm9kZUFycmF5KG1hcC5maWx0ZXIpO1xuICAgIGRlbGV0ZSBtYXAuZmlsdGVyO1xuICAgIHZhciBtYXBLZXlzID0gT2JqZWN0LmtleXMobWFwKTtcbiAgICBpZiAoIW1hcEtleXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3doZW4va2V5IHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBvcHRpb24ga2V5Jyk7XG4gICAgfVxuICAgIHZhciByZWdpc3RlckJpbmRpbmcgPSBmdW5jdGlvbiByZWdpc3RlckJpbmRpbmcoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQua2V5Q29kZXMuZm9yRWFjaChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAgICAgaWYgKCFiaW5kaW5nc1tjb2RlXSkge1xuICAgICAgICAgICAgICAgIGJpbmRpbmdzW2NvZGVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiaW5kaW5nc1tjb2RlXS5wdXNoKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBtYXBLZXlzLmZvckVhY2goZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBbdGV4dF0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3doZW4va2V5IHJlcXVpcmVzIG9wdGlvbltcIicgKyB0ZXh0ICsgJ1wiXSB0byBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFkZENhbGxiYWNrID0gZnVuY3Rpb24gYWRkQ2FsbGJhY2soZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LmNhbGxiYWNrID0gbWFwW3RleHRdO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICB9O1xuICAgICAgICBrZXlCaW5kaW5nKHRleHQpLm1hcChhZGRDYWxsYmFjaykuZm9yRWFjaChyZWdpc3RlckJpbmRpbmcpO1xuICAgIH0pO1xuICAgIHZhciBoYW5kbGVLZXlEb3duID0gZnVuY3Rpb24gaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZWxlbWVudHMgd2l0aGluIHRoZSBleGVtcHRlZCBzdWItdHJlZXNcbiAgICAgICAgICAgIHZhciBpc1BhcmVudE9mRWxlbWVudCA9IGdldFBhcmVudENvbXBhcmF0b3Ioe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICBpbmNsdWRlU2VsZjogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZmlsdGVyLnNvbWUoaXNQYXJlbnRPZkVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSBldmVudC5rZXlDb2RlIHx8IGV2ZW50LndoaWNoO1xuICAgICAgICBpZiAoIWJpbmRpbmdzW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBiaW5kaW5nc1trZXldLmZvckVhY2goZnVuY3Rpb24gKF9ldmVudCkge1xuICAgICAgICAgICAgaWYgKCFfZXZlbnQubWF0Y2hNb2RpZmllcnMoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2V2ZW50LmNhbGxiYWNrLmNhbGwoY29udGV4dCwgZXZlbnQsIGRpc2VuZ2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29udGV4dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93biwgZmFsc2UpO1xuICAgIHZhciBkaXNlbmdhZ2UgPSBmdW5jdGlvbiBkaXNlbmdhZ2UoKSB7XG4gICAgICAgIGNvbnRleHQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24sIGZhbHNlKTtcbiAgICB9O1xuICAgIHJldHVybiB7IGRpc2VuZ2FnZTogZGlzZW5nYWdlIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0XzEoX2EpIHtcbiAgICB2YXIgY29udGV4dCA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkuY29udGV4dDtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBzdXBwb3J0cyB0ZXN0cyBhcmUgcnVuIGJlZm9yZSBpbnRlcmNlcHRpbmcgdGhlIFRhYiBrZXksXG4gICAgLy8gb3IgSUUxMCBhbmQgSUUxMSB3aWxsIGZhaWwgdG8gcHJvY2VzcyB0aGUgZmlyc3QgVGFiIGtleSBldmVudC4gTm90XG4gICAgLy8gbGltaXRpbmcgdGhpcyB3YXJtLXVwIHRvIElFIGJlY2F1c2UgaXQgbWF5IGJlIGEgcHJvYmxlbSBlbHNld2hlcmUsIHRvby5cbiAgICBxdWVyeVRhYnNlcXVlbmNlKCk7XG4gICAgcmV0dXJuIHdoZW5LZXkoe1xuICAgICAgICAvLyBTYWZhcmkgb24gT1NYIG1heSByZXF1aXJlIEFMVCtUQUIgdG8gcmVhY2ggbGlua3MsXG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzE0NlxuICAgICAgICAnP2FsdCs/c2hpZnQrdGFiJzogZnVuY3Rpb24gYWx0U2hpZnRUYWIoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIHdlJ3JlIGNvbXBsZXRlbHkgdGFraW5nIG92ZXIgdGhlIFRhYiBrZXkgaGFuZGxpbmdcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB2YXIgc2VxdWVuY2UgPSBxdWVyeVRhYnNlcXVlbmNlKHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBiYWNrd2FyZCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICAgICAgdmFyIGZpcnN0ID0gc2VxdWVuY2VbMF07XG4gICAgICAgICAgICB2YXIgbGFzdCA9IHNlcXVlbmNlW3NlcXVlbmNlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgLy8gd3JhcCBhcm91bmQgZmlyc3QgdG8gbGFzdCwgbGFzdCB0byBmaXJzdFxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGJhY2t3YXJkID8gZmlyc3QgOiBsYXN0O1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGJhY2t3YXJkID8gbGFzdCA6IGZpcnN0O1xuICAgICAgICAgICAgaWYgKGlzQWN0aXZlRWxlbWVudChzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmluZCBjdXJyZW50IHBvc2l0aW9uIGluIHRhYnNlcXVlbmNlXG4gICAgICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gc2VxdWVuY2Uuc29tZShmdW5jdGlvbiAoZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWN0aXZlRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVkaXJlY3QgdG8gZmlyc3QgYXMgd2UncmUgbm90IGluIG91ciB0YWJzZXF1ZW5jZVxuICAgICAgICAgICAgICAgIGZpcnN0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2hpZnQgZm9jdXMgdG8gcHJldmlvdXMvbmV4dCBlbGVtZW50IGluIHRoZSBzZXF1ZW5jZVxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGJhY2t3YXJkID8gLTEgOiAxO1xuICAgICAgICAgICAgc2VxdWVuY2VbY3VycmVudEluZGV4ICsgb2Zmc2V0XS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGRlZmF1bHRfMTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1haW50YWluLS10YWItZm9jdXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xudmFyIHN0eWxlcyA9IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheV0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIHotaW5kZXg6IDkwMDA7XFxuXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgcGFkZGluZzogMTB2aCAxNXB4IDA7XFxuICB9XFxuXFxuICBAbWVkaWEgKG1heC1oZWlnaHQ6IDgxMnB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheV0ge1xcbiAgICAgIHBhZGRpbmc6IDE1cHggMTVweCAwO1xcbiAgICB9XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhY2tkcm9wXSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE3LCAxNywgMTcsIDAuMik7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxuICAgIHotaW5kZXg6IC0xO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYWNrZHJvcC1maXhlZF0ge1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgICAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjogYmx1cig4cHgpO1xcbiAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoOHB4KTtcXG4gIH1cXG5cIl0sIFtcIlxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1vdmVybGF5XSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgei1pbmRleDogOTAwMDtcXG5cXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBwYWRkaW5nOiAxMHZoIDE1cHggMDtcXG4gIH1cXG5cXG4gIEBtZWRpYSAobWF4LWhlaWdodDogODEycHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZy1vdmVybGF5XSB7XFxuICAgICAgcGFkZGluZzogMTVweCAxNXB4IDA7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3BdIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB0b3A6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBib3R0b206IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTcsIDE3LCAxNywgMC4yKTtcXG4gICAgcG9pbnRlci1ldmVudHM6IGFsbDtcXG4gICAgei1pbmRleDogLTE7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhY2tkcm9wLWZpeGVkXSB7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxuICAgIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOiBibHVyKDhweCk7XFxuICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cig4cHgpO1xcbiAgfVxcblwiXSkpKTtcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgcmVhY3RfZG9tXzEgPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpO1xuZXhwb3J0cy5TaGFkb3dQb3J0YWwgPSBmdW5jdGlvbiBQb3J0YWwoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcbiAgICB2YXIgbW91bnROb2RlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciBwb3J0YWxOb2RlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciBzaGFkb3dOb2RlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciBfYiA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZSgpLCAyKSwgZm9yY2VVcGRhdGUgPSBfYlsxXTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3duZXJEb2N1bWVudCA9IG1vdW50Tm9kZS5jdXJyZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIHBvcnRhbE5vZGUuY3VycmVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbmV4dGpzLXBvcnRhbCcpO1xuICAgICAgICBzaGFkb3dOb2RlLmN1cnJlbnQgPSBwb3J0YWxOb2RlLmN1cnJlbnQuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICBvd25lckRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocG9ydGFsTm9kZS5jdXJyZW50KTtcbiAgICAgICAgZm9yY2VVcGRhdGUoe30pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBvcnRhbE5vZGUuY3VycmVudCAmJiBwb3J0YWxOb2RlLmN1cnJlbnQub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHBvcnRhbE5vZGUuY3VycmVudC5vd25lckRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocG9ydGFsTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHNoYWRvd05vZGUuY3VycmVudCA/IChyZWFjdF9kb21fMS5jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHNoYWRvd05vZGUuY3VycmVudCkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgcmVmOiBtb3VudE5vZGUgfSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNoYWRvd1BvcnRhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGFuc2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFuc2VyXCIpKTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xuZXhwb3J0cy5UZXJtaW5hbCA9IGZ1bmN0aW9uIFRlcm1pbmFsKF9hKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBfYS5jb250ZW50O1xuICAgIHZhciBkZWNvZGVkID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhbnNlcl8xW1wiZGVmYXVsdFwiXS5hbnNpVG9Kc29uKGNvbnRlbnQsIHtcbiAgICAgICAgICAgIGpzb246IHRydWUsXG4gICAgICAgICAgICB1c2VfY2xhc3NlczogdHJ1ZSxcbiAgICAgICAgICAgIHJlbW92ZV9lbXB0eTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9LCBbY29udGVudF0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtdGVybWluYWxcIjogdHJ1ZSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicHJlXCIsIG51bGwsIGRlY29kZWQubWFwKGZ1bmN0aW9uIChlbnRyeSwgaW5kZXgpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGtleTogXCJ0ZXJtaW5hbC1lbnRyeS1cIiArIGluZGV4LCBzdHlsZTogX19hc3NpZ24oeyBjb2xvcjogZW50cnkuZmcgPyBcInZhcigtLWNvbG9yLVwiICsgZW50cnkuZmcgKyBcIilcIiA6IHVuZGVmaW5lZCB9LCAoZW50cnkuZGVjb3JhdGlvbiA9PT0gJ2JvbGQnXG4gICAgICAgICAgICAgICAgPyB7IGZvbnRXZWlnaHQ6IDgwMCB9XG4gICAgICAgICAgICAgICAgOiBlbnRyeS5kZWNvcmF0aW9uID09PSAnaXRhbGljJ1xuICAgICAgICAgICAgICAgICAgICA/IHsgZm9udFN0eWxlOiAnaXRhbGljJyB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKSkgfSwgZW50cnkuY29udGVudCkpOyB9KSkpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXJtaW5hbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgVGVybWluYWxfMSA9IHJlcXVpcmUoXCIuL1Rlcm1pbmFsXCIpO1xuZXhwb3J0cy5UZXJtaW5hbCA9IFRlcm1pbmFsXzEuVGVybWluYWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gICAgcmV0dXJuIGNvb2tlZDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XG52YXIgc3R5bGVzID0gbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgW2RhdGEtbmV4dGpzLXRlcm1pbmFsXSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJnKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktZmcpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLXRlcm1pbmFsXTo6c2VsZWN0aW9uLFxcbiAgW2RhdGEtbmV4dGpzLXRlcm1pbmFsXSAqOjpzZWxlY3Rpb24ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXNlbGVjdGlvbik7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICoge1xcbiAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdID4gKiB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHByZSB7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gICAgd29yZC1icmVhazogYnJlYWstd29yZDtcXG4gIH1cXG5cIl0sIFtcIlxcbiAgW2RhdGEtbmV4dGpzLXRlcm1pbmFsXSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJnKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktZmcpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLXRlcm1pbmFsXTo6c2VsZWN0aW9uLFxcbiAgW2RhdGEtbmV4dGpzLXRlcm1pbmFsXSAqOjpzZWxlY3Rpb24ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXNlbGVjdGlvbik7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICoge1xcbiAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdID4gKiB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHByZSB7XFxuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG4gICAgd29yZC1icmVhazogYnJlYWstd29yZDtcXG4gIH1cXG5cIl0pKSk7XG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xuZXhwb3J0cy5Ub2FzdCA9IGZ1bmN0aW9uIFRvYXN0KF9hKSB7XG4gICAgdmFyIG9uQ2xpY2sgPSBfYS5vbkNsaWNrLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWU7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy10b2FzdFwiOiB0cnVlLCBvbkNsaWNrOiBvbkNsaWNrLCBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy10b2FzdC13cmFwcGVyXCI6IHRydWUgfSwgY2hpbGRyZW4pKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG9hc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIHN0eWxlc18xID0gcmVxdWlyZShcIi4vc3R5bGVzXCIpO1xuZXhwb3J0cy5zdHlsZXMgPSBzdHlsZXNfMS5zdHlsZXM7XG52YXIgVG9hc3RfMSA9IHJlcXVpcmUoXCIuL1RvYXN0XCIpO1xuZXhwb3J0cy5Ub2FzdCA9IFRvYXN0XzEuVG9hc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gICAgcmV0dXJuIGNvb2tlZDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XG52YXIgc3R5bGVzID0gbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgW2RhdGEtbmV4dGpzLXRvYXN0XSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBsZWZ0OiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBtYXgtd2lkdGg6IDQyMHB4O1xcbiAgICB6LWluZGV4OiA5MDAwO1xcbiAgfVxcblxcbiAgQG1lZGlhIChtYXgtd2lkdGg6IDQ0MHB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy10b2FzdF0ge1xcbiAgICAgIG1heC13aWR0aDogOTB2dztcXG4gICAgICBsZWZ0OiA1dnc7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10b2FzdC13cmFwcGVyXSB7XFxuICAgIHBhZGRpbmc6IDE2cHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1icmlnaHQtd2hpdGUpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICAgIGJveC1zaGFkb3c6IDBweCB2YXIoLS1zaXplLWdhcC1kb3VibGUpIHZhcigtLXNpemUtZ2FwLXF1YWQpXFxuICAgICAgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gIH1cXG5cIl0sIFtcIlxcbiAgW2RhdGEtbmV4dGpzLXRvYXN0XSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBsZWZ0OiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBtYXgtd2lkdGg6IDQyMHB4O1xcbiAgICB6LWluZGV4OiA5MDAwO1xcbiAgfVxcblxcbiAgQG1lZGlhIChtYXgtd2lkdGg6IDQ0MHB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy10b2FzdF0ge1xcbiAgICAgIG1heC13aWR0aDogOTB2dztcXG4gICAgICBsZWZ0OiA1dnc7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10b2FzdC13cmFwcGVyXSB7XFxuICAgIHBhZGRpbmc6IDE2cHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1icmlnaHQtd2hpdGUpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICAgIGJveC1zaGFkb3c6IDBweCB2YXIoLS1zaXplLWdhcC1kb3VibGUpIHZhcigtLXNpemUtZ2FwLXF1YWQpXFxuICAgICAgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gIH1cXG5cIl0pKSk7XG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgICByZXR1cm4gY29va2VkO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBEaWFsb2dfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL0RpYWxvZ1wiKTtcbnZhciBPdmVybGF5XzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9PdmVybGF5XCIpO1xudmFyIFRlcm1pbmFsXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9UZXJtaW5hbFwiKTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuZXhwb3J0cy5CdWlsZEVycm9yID0gZnVuY3Rpb24gQnVpbGRFcnJvcihfYSkge1xuICAgIHZhciBtZXNzYWdlID0gX2EubWVzc2FnZTtcbiAgICB2YXIgbm9vcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHsgfSwgW10pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChPdmVybGF5XzEuT3ZlcmxheSwgeyBmaXhlZDogdHJ1ZSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZywgeyB0eXBlOiBcImVycm9yXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IFwibmV4dGpzX19jb250YWluZXJfYnVpbGRfZXJyb3JfbGFiZWxcIiwgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IFwibmV4dGpzX19jb250YWluZXJfYnVpbGRfZXJyb3JfZGVzY1wiLCBvbkNsb3NlOiBub29wIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0NvbnRlbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaWFsb2dfMS5EaWFsb2dIZWFkZXIsIHsgY2xhc3NOYW1lOiBcIm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItaGVhZGVyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHsgaWQ6IFwibmV4dGpzX19jb250YWluZXJfYnVpbGRfZXJyb3JfbGFiZWxcIiB9LCBcIkZhaWxlZCB0byBjb21waWxlXCIpKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0JvZHksIHsgY2xhc3NOYW1lOiBcIm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItYm9keVwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGVybWluYWxfMS5UZXJtaW5hbCwgeyBjb250ZW50OiBtZXNzYWdlIH0pLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZm9vdGVyXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCB7IGlkOiBcIm5leHRqc19fY29udGFpbmVyX2J1aWxkX2Vycm9yX2Rlc2NcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzbWFsbFwiLCBudWxsLCBcIlRoaXMgZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBidWlsZCBwcm9jZXNzIGFuZCBjYW4gb25seSBiZSBkaXNtaXNzZWQgYnkgZml4aW5nIHRoZSBlcnJvci5cIikpKSkpKSkpO1xufTtcbmV4cG9ydHMuc3R5bGVzID0gbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItaGVhZGVyID4gaDQge1xcbiAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IGZvb3RlciB7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgZm9vdGVyIHAge1xcbiAgICBtYXJnaW46IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IHNtYWxsIHtcXG4gICAgY29sb3I6ICM3NTc1NzU7XFxuICB9XFxuXCJdLCBbXCJcXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWhlYWRlciA+IGg0IHtcXG4gICAgbGluZS1oZWlnaHQ6IDEuNTtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgfVxcblxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItYm9keSBmb290ZXIge1xcbiAgICBtYXJnaW4tdG9wOiB2YXIoLS1zaXplLWdhcCk7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IGZvb3RlciBwIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgfVxcblxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItYm9keSBzbWFsbCB7XFxuICAgIGNvbG9yOiAjNzU3NTc1O1xcbiAgfVxcblwiXSkpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnVpbGRFcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gICAgcmV0dXJuIGNvb2tlZDtcbn07XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBidXNfMSA9IHJlcXVpcmUoXCIuLi9idXNcIik7XG52YXIgRGlhbG9nXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9EaWFsb2dcIik7XG52YXIgTGVmdFJpZ2h0RGlhbG9nSGVhZGVyXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9MZWZ0UmlnaHREaWFsb2dIZWFkZXJcIik7XG52YXIgT3ZlcmxheV8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvT3ZlcmxheVwiKTtcbnZhciBUb2FzdF8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvVG9hc3RcIik7XG52YXIgbm9kZVN0YWNrRnJhbWVzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub2RlU3RhY2tGcmFtZXNcIik7XG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcbnZhciBzdGFja19mcmFtZV8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvc3RhY2stZnJhbWVcIik7XG52YXIgUnVudGltZUVycm9yXzEgPSByZXF1aXJlKFwiLi9SdW50aW1lRXJyb3JcIik7XG5mdW5jdGlvbiBnZXRFcnJvclNpZ25hdHVyZShldikge1xuICAgIHZhciBldmVudCA9IGV2LmV2ZW50O1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIGJ1c18xLlRZUEVfVU5IQU5ETEVEX0VSUk9SOlxuICAgICAgICBjYXNlIGJ1c18xLlRZUEVfVU5IQU5ETEVEX1JFSkVDVElPTjoge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnJlYXNvbi5uYW1lICsgXCI6OlwiICsgZXZlbnQucmVhc29uLm1lc3NhZ2UgKyBcIjo6XCIgKyBldmVudC5yZWFzb24uc3RhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgXyA9IGV2ZW50O1xuICAgIHJldHVybiAnJztcbn1cbnZhciBIb3RsaW5rZWRUZXh0ID0gZnVuY3Rpb24gSG90bGlua2VkVGV4dChwcm9wcykge1xuICAgIHZhciB0ZXh0ID0gcHJvcHMudGV4dDtcbiAgICB2YXIgbGlua1JlZ2V4ID0gL2h0dHBzPzpcXC9cXC9bXlxccy8kLj8jXS5bXlxcc1wiXSovaTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGxpbmtSZWdleC50ZXN0KHRleHQpXG4gICAgICAgID8gdGV4dC5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAod29yZCwgaW5kZXgsIGFycmF5KSB7XG4gICAgICAgICAgICBpZiAobGlua1JlZ2V4LnRlc3Qod29yZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIHsga2V5OiBcImxpbmstXCIgKyBpbmRleCB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB7IGhyZWY6IHdvcmQgfSwgd29yZCksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID09PSBhcnJheS5sZW5ndGggLSAxID8gJycgOiAnICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gYXJyYXkubGVuZ3RoIC0gMSA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCB7IGtleTogXCJ0ZXh0LVwiICsgaW5kZXggfSwgd29yZCkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIHsga2V5OiBcInRleHQtXCIgKyBpbmRleCB9LFxuICAgICAgICAgICAgICAgIHdvcmQsXG4gICAgICAgICAgICAgICAgXCIgXCIpKTtcbiAgICAgICAgfSlcbiAgICAgICAgOiB0ZXh0KSk7XG59O1xuZnVuY3Rpb24gZ2V0RXJyb3JCeVR5cGUoZXYpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZCwgZXZlbnQsIF9hLCBfYiwgXztcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBldi5pZCwgZXZlbnQgPSBldi5ldmVudDtcbiAgICAgICAgICAgICAgICAgICAgX2EgPSBldmVudC50eXBlO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGJ1c18xLlRZUEVfVU5IQU5ETEVEX0VSUk9SOiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgYnVzXzEuVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OOiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIF9iID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVudGltZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBldmVudC5yZWFzb25cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3RhY2tfZnJhbWVfMS5nZXRPcmlnaW5hbFN0YWNrRnJhbWVzKG5vZGVTdGFja0ZyYW1lc18xLmlzTm9kZUVycm9yKGV2ZW50LnJlYXNvbiksIGV2ZW50LmZyYW1lcyldO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYi5mcmFtZXMgPSBfYy5zZW50KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBfYildO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgXyA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R5cGUgc3lzdGVtIGludmFyaWFudCB2aW9sYXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLkVycm9ycyA9IGZ1bmN0aW9uIEVycm9ycyhfYSkge1xuICAgIHZhciBlcnJvcnMgPSBfYS5lcnJvcnM7XG4gICAgdmFyIF9iID0gX19yZWFkKFJlYWN0LnVzZVN0YXRlKHt9KSwgMiksIGxvb2t1cHMgPSBfYlswXSwgc2V0TG9va3VwcyA9IF9iWzFdO1xuICAgIHZhciBfYyA9IF9fcmVhZChSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlYWR5ID0gW107XG4gICAgICAgIHZhciBuZXh0ID0gbnVsbDtcbiAgICAgICAgLy8gRW5zdXJlIGVycm9ycyBhcmUgZGlzcGxheWVkIGluIHRoZSBvcmRlciB0aGV5IG9jY3VycmVkIGluOlxuICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBlcnJvcnMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgdmFyIGUgPSBlcnJvcnNbaWR4XTtcbiAgICAgICAgICAgIHZhciBpZCA9IGUuaWQ7XG4gICAgICAgICAgICBpZiAoaWQgaW4gbG9va3Vwcykge1xuICAgICAgICAgICAgICAgIHJlYWR5LnB1c2gobG9va3Vwc1tpZF0pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZSBlcnJvcnNcbiAgICAgICAgICAgIGlmIChpZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXYgPSBlcnJvcnNbaWR4IC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGdldEVycm9yU2lnbmF0dXJlKHByZXYpID09PSBnZXRFcnJvclNpZ25hdHVyZShlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcmVhZHksIG5leHRdO1xuICAgIH0sIFtlcnJvcnMsIGxvb2t1cHNdKSwgMiksIHJlYWR5RXJyb3JzID0gX2NbMF0sIG5leHRFcnJvciA9IF9jWzFdO1xuICAgIHZhciBpc0xvYWRpbmcgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlYWR5RXJyb3JzLmxlbmd0aCA8IDEgJiYgQm9vbGVhbihlcnJvcnMubGVuZ3RoKTtcbiAgICB9LCBbZXJyb3JzLmxlbmd0aCwgcmVhZHlFcnJvcnMubGVuZ3RoXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG5leHRFcnJvciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vdW50ZWQgPSB0cnVlO1xuICAgICAgICBnZXRFcnJvckJ5VHlwZShuZXh0RXJyb3IpLnRoZW4oZnVuY3Rpb24gKHJlc29sdmVkKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBjYXJlIGlmIHRoZSBkZXNpcmVkIGVycm9yIGNoYW5nZWQgd2hpbGUgd2Ugd2VyZSByZXNvbHZpbmcsXG4gICAgICAgICAgICAvLyB0aHVzIHdlJ3JlIG5vdCB0cmFja2luZyBpdCB1c2luZyBhIHJlZi4gT25jZSB0aGUgd29yayBoYXMgYmVlbiBkb25lLFxuICAgICAgICAgICAgLy8gd2UnbGwgc3RvcmUgaXQuXG4gICAgICAgICAgICBpZiAobW91bnRlZCkge1xuICAgICAgICAgICAgICAgIHNldExvb2t1cHMoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBtKSwgKF9hID0ge30sIF9hW3Jlc29sdmVkLmlkXSA9IHJlc29sdmVkLCBfYSkpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogaGFuZGxlIHRoaXMsIHRob3VnaCBhbiBlZGdlIGNhc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtb3VudGVkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSwgW25leHRFcnJvcl0pO1xuICAgIHZhciBfZCA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZShmYWxzZSksIDIpLCBpc01pbmltaXplZCA9IF9kWzBdLCBzZXRNaW5pbWl6ZWQgPSBfZFsxXTtcbiAgICB2YXIgX2UgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUoMCksIDIpLCBhY3RpdmVJZHggPSBfZVswXSwgc2V0QWN0aXZlSW5kZXggPSBfZVsxXTtcbiAgICB2YXIgcHJldmlvdXMgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgICAgICBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc2V0QWN0aXZlSW5kZXgoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIE1hdGgubWF4KDAsIHYgLSAxKTsgfSk7XG4gICAgfSwgW10pO1xuICAgIHZhciBuZXh0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNldEFjdGl2ZUluZGV4KGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4ocmVhZHlFcnJvcnMubGVuZ3RoIC0gMSwgdiArIDEpKTtcbiAgICAgICAgfSk7XG4gICAgfSwgW3JlYWR5RXJyb3JzLmxlbmd0aF0pO1xuICAgIHZhciBhY3RpdmVFcnJvciA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkgeyB2YXIgX2E7IHJldHVybiAoX2EgPSByZWFkeUVycm9yc1thY3RpdmVJZHhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsOyB9LCBbYWN0aXZlSWR4LCByZWFkeUVycm9yc10pO1xuICAgIC8vIFJlc2V0IGNvbXBvbmVudCBzdGF0ZSB3aGVuIHRoZXJlIGFyZSBubyBlcnJvcnMgdG8gYmUgZGlzcGxheWVkLlxuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGxldHMgaGFuZGxlIGl0LlxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgc2V0TG9va3Vwcyh7fSk7XG4gICAgICAgICAgICBzZXRNaW5pbWl6ZWQoZmFsc2UpO1xuICAgICAgICAgICAgc2V0QWN0aXZlSW5kZXgoMCk7XG4gICAgICAgIH1cbiAgICB9LCBbZXJyb3JzLmxlbmd0aF0pO1xuICAgIHZhciBtaW5pbWl6ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZXRNaW5pbWl6ZWQodHJ1ZSk7XG4gICAgfSwgW10pO1xuICAgIHZhciByZW9wZW4gPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgICAgICBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc2V0TWluaW1pemVkKGZhbHNlKTtcbiAgICB9LCBbXSk7XG4gICAgLy8gVGhpcyBjb21wb25lbnQgc2hvdWxkbid0IGJlIHJlbmRlcmVkIHdpdGggbm8gZXJyb3JzLCBidXQgaWYgaXQgaXMsIGxldCdzXG4gICAgLy8gaGFuZGxlIGl0IGdyYWNlZnVsbHkgYnkgcmVuZGVyaW5nIG5vdGhpbmcuXG4gICAgaWYgKGVycm9ycy5sZW5ndGggPCAxIHx8IGFjdGl2ZUVycm9yID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc0xvYWRpbmcpIHtcbiAgICAgICAgLy8gVE9ETzogYmV0dGVyIGxvYWRpbmcgc3RhdGVcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoT3ZlcmxheV8xLk92ZXJsYXksIG51bGwpO1xuICAgIH1cbiAgICBpZiAoaXNNaW5pbWl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFRvYXN0XzEuVG9hc3QsIHsgY2xhc3NOYW1lOiBcIm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50XCIsIG9uQ2xpY2s6IHJlb3BlbiB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJuZXh0anMtdG9hc3QtZXJyb3JzXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IFwiMjRcIiwgaGVpZ2h0OiBcIjI0XCIsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwgeyBjeDogXCIxMlwiLCBjeTogXCIxMlwiLCByOiBcIjEwXCIgfSksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHsgeDE6IFwiMTJcIiwgeTE6IFwiOFwiLCB4MjogXCIxMlwiLCB5MjogXCIxMlwiIH0pLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7IHgxOiBcIjEyXCIsIHkxOiBcIjE2XCIsIHgyOiBcIjEyLjAxXCIsIHkyOiBcIjE2XCIgfSkpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlYWR5RXJyb3JzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgXCIgZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhZHlFcnJvcnMubGVuZ3RoID4gMSA/ICdzJyA6ICcnKSkpKTtcbiAgICB9XG4gICAgdmFyIGlzU2VydmVyRXJyb3IgPSBub2RlU3RhY2tGcmFtZXNfMS5pc05vZGVFcnJvcihhY3RpdmVFcnJvci5lcnJvcik7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KE92ZXJsYXlfMS5PdmVybGF5LCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZywgeyB0eXBlOiBcImVycm9yXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IFwibmV4dGpzX19jb250YWluZXJfZXJyb3JzX2xhYmVsXCIsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBcIm5leHRqc19fY29udGFpbmVyX2Vycm9yc19kZXNjXCIsIG9uQ2xvc2U6IGlzU2VydmVyRXJyb3IgPyB1bmRlZmluZWQgOiBtaW5pbWl6ZSB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaWFsb2dfMS5EaWFsb2dDb250ZW50LCBudWxsLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGlhbG9nXzEuRGlhbG9nSGVhZGVyLCB7IGNsYXNzTmFtZTogXCJuZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXJcIiB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KExlZnRSaWdodERpYWxvZ0hlYWRlcl8xLkxlZnRSaWdodERpYWxvZ0hlYWRlciwgeyBwcmV2aW91czogYWN0aXZlSWR4ID4gMCA/IHByZXZpb3VzIDogbnVsbCwgbmV4dDogYWN0aXZlSWR4IDwgcmVhZHlFcnJvcnMubGVuZ3RoIC0gMSA/IG5leHQgOiBudWxsLCBjbG9zZTogaXNTZXJ2ZXJFcnJvciA/IHVuZGVmaW5lZCA6IG1pbmltaXplIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic21hbGxcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBhY3RpdmVJZHggKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBvZlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCByZWFkeUVycm9ycy5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIHVuaGFuZGxlZCBlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWR5RXJyb3JzLmxlbmd0aCA8IDIgPyAnJyA6ICdzJykpLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDFcIiwgeyBpZDogXCJuZXh0anNfX2NvbnRhaW5lcl9lcnJvcnNfbGFiZWxcIiB9LCBpc1NlcnZlckVycm9yID8gJ1NlcnZlciBFcnJvcicgOiAnVW5oYW5kbGVkIFJ1bnRpbWUgRXJyb3InKSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgeyBpZDogXCJuZXh0anNfX2NvbnRhaW5lcl9lcnJvcnNfZGVzY1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVFcnJvci5lcnJvci5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCI6XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAnICcsXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEhvdGxpbmtlZFRleHQsIHsgdGV4dDogYWN0aXZlRXJyb3IuZXJyb3IubWVzc2FnZSB9KSksXG4gICAgICAgICAgICAgICAgICAgIGlzU2VydmVyRXJyb3IgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNtYWxsXCIsIG51bGwsIFwiVGhpcyBlcnJvciBoYXBwZW5lZCB3aGlsZSBnZW5lcmF0aW5nIHRoZSBwYWdlLiBBbnkgY29uc29sZSBsb2dzIHdpbGwgYmUgZGlzcGxheWVkIGluIHRoZSB0ZXJtaW5hbCB3aW5kb3cuXCIpKSkgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGlhbG9nXzEuRGlhbG9nQm9keSwgeyBjbGFzc05hbWU6IFwibmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtYm9keVwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUnVudGltZUVycm9yXzEuUnVudGltZUVycm9yLCB7IGtleTogYWN0aXZlRXJyb3IuaWQudG9TdHJpbmcoKSwgZXJyb3I6IGFjdGl2ZUVycm9yIH0pKSkpKSk7XG59O1xuZXhwb3J0cy5zdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gaDEge1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1iaWcpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgc21hbGwge1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTEpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgc21hbGwgPiBzcGFuIHtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBwIHtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZyk7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gZGl2ID4gc21hbGwge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciA+IHAgPiBhIHtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktcmVkKTtcXG4gIH1cXG5cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1ib2R5ID4gaDU6bm90KDpmaXJzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tdG9wOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcCkpO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWJvZHkgPiBoNSB7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwKTtcXG4gIH1cXG5cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzLXBhcmVudCB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMnMgZWFzZTtcXG4gIH1cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzLXBhcmVudDpob3ZlciB7XFxuICAgIHRyYW5zZm9ybTogc2NhbGUoMS4xKTtcXG4gIH1cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMgPiBzdmcge1xcbiAgICBtYXJnaW4tcmlnaHQ6IHZhcigtLXNpemUtZ2FwKTtcXG4gIH1cXG5cIl0sIFtcIlxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciA+IGgxIHtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtYmlnKTtcXG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLXNpemUtZm9udC1iaWdnZXIpO1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBtYXJnaW4tdG9wOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyIHNtYWxsIHtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYWNjZW50cy0xKTtcXG4gICAgbWFyZ2luLWxlZnQ6IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyIHNtYWxsID4gc3BhbiB7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gcCB7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLXNpemUtZm9udC1iaWcpO1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBtYXJnaW4tdG9wOiB2YXIoLS1zaXplLWdhcC1oYWxmKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktcmVkKTtcXG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlciA+IGRpdiA+IHNtYWxsIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBtYXJnaW4tdG9wOiB2YXIoLS1zaXplLWdhcC1oYWxmKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBwID4gYSB7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtYm9keSA+IGg1Om5vdCg6Zmlyc3QtY2hpbGQpIHtcXG4gICAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXApKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1ib2R5ID4gaDUge1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICB9XFxuXFxuICAubmV4dGpzLXRvYXN0LWVycm9ycy1wYXJlbnQge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjJzIGVhc2U7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycy1wYXJlbnQ6aG92ZXIge1xcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMSk7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gIH1cXG4gIC5uZXh0anMtdG9hc3QtZXJyb3JzID4gc3ZnIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiB2YXIoLS1zaXplLWdhcCk7XFxuICB9XFxuXCJdKSkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcnJvcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIENvZGVGcmFtZV8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvQ29kZUZyYW1lXCIpO1xudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XG52YXIgc3RhY2tfZnJhbWVfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3N0YWNrLWZyYW1lXCIpO1xudmFyIENhbGxTdGFja0ZyYW1lID0gZnVuY3Rpb24gQ2FsbFN0YWNrRnJhbWUoX2EpIHtcbiAgICAvLyBUT0RPOiBhYmlsaXR5IHRvIGV4cGFuZCByZXNvbHZlZCBmcmFtZXNcbiAgICAvLyBUT0RPOiByZW5kZXIgZXJyb3Igb3IgZXh0ZXJuYWwgaW5kaWNhdG9yXG4gICAgdmFyIGZyYW1lID0gX2EuZnJhbWU7XG4gICAgdmFyIF9iO1xuICAgIHZhciBmID0gKF9iID0gZnJhbWUub3JpZ2luYWxTdGFja0ZyYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmcmFtZS5zb3VyY2VTdGFja0ZyYW1lO1xuICAgIHZhciBoYXNTb3VyY2UgPSBCb29sZWFuKGZyYW1lLm9yaWdpbmFsQ29kZUZyYW1lKTtcbiAgICB2YXIgb3BlbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWhhc1NvdXJjZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGYpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoa2V5LCAoKF9hID0gZltrZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJykudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZlxuICAgICAgICAgICAgLmZldGNoKChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnKSArIFwiL19fbmV4dGpzX2xhdW5jaC1lZGl0b3I/XCIgKyBwYXJhbXMudG9TdHJpbmcoKSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwb3J0IGVycm9yXG4gICAgICAgIH0pO1xuICAgIH0sIFtoYXNTb3VyY2UsIGZdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVcIjogdHJ1ZSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDZcIiwgeyBcImRhdGEtbmV4dGpzLWZyYW1lLWV4cGFuZGVkXCI6IEJvb2xlYW4oZnJhbWUuZXhwYW5kZWQpIH0sIGYubWV0aG9kTmFtZSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtaGFzLXNvdXJjZVwiOiBoYXNTb3VyY2UgPyAndHJ1ZScgOiB1bmRlZmluZWQsIHRhYkluZGV4OiBoYXNTb3VyY2UgPyAxMCA6IHVuZGVmaW5lZCwgcm9sZTogaGFzU291cmNlID8gJ2xpbmsnIDogdW5kZWZpbmVkLCBvbkNsaWNrOiBvcGVuLCB0aXRsZTogaGFzU291cmNlID8gJ0NsaWNrIHRvIG9wZW4gaW4geW91ciBlZGl0b3InIDogdW5kZWZpbmVkIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLCBzdGFja19mcmFtZV8xLmdldEZyYW1lU291cmNlKGYpKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogXCIyXCIsIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTggMTN2NmEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMlY4YTIgMiAwIDAgMSAyLTJoNlwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwb2x5bGluZVwiLCB7IHBvaW50czogXCIxNSAzIDIxIDMgMjEgOVwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHsgeDE6IFwiMTBcIiwgeTE6IFwiMTRcIiwgeDI6IFwiMjFcIiwgeTI6IFwiM1wiIH0pKSkpKTtcbn07XG52YXIgUnVudGltZUVycm9yID0gZnVuY3Rpb24gUnVudGltZUVycm9yKF9hKSB7XG4gICAgdmFyIGVycm9yID0gX2EuZXJyb3I7XG4gICAgdmFyIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXggPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLmZyYW1lcy5maW5kSW5kZXgoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkuZXhwYW5kZWQgJiZcbiAgICAgICAgICAgICAgICBCb29sZWFuKGVudHJ5Lm9yaWdpbmFsQ29kZUZyYW1lKSAmJlxuICAgICAgICAgICAgICAgIEJvb2xlYW4oZW50cnkub3JpZ2luYWxTdGFja0ZyYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfSwgW2Vycm9yLmZyYW1lc10pO1xuICAgIHZhciBmaXJzdEZyYW1lID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IGVycm9yLmZyYW1lc1tmaXJzdEZpcnN0UGFydHlGcmFtZUluZGV4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICB9LCBbZXJyb3IuZnJhbWVzLCBmaXJzdEZpcnN0UGFydHlGcmFtZUluZGV4XSk7XG4gICAgdmFyIGFsbExlYWRpbmdGcmFtZXMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXggPCAwXG4gICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICA6IGVycm9yLmZyYW1lcy5zbGljZSgwLCBmaXJzdEZpcnN0UGFydHlGcmFtZUluZGV4KTtcbiAgICB9LCBbZXJyb3IuZnJhbWVzLCBmaXJzdEZpcnN0UGFydHlGcmFtZUluZGV4XSk7XG4gICAgdmFyIF9iID0gX19yZWFkKFJlYWN0LnVzZVN0YXRlKGZpcnN0RnJhbWUgPT0gbnVsbCksIDIpLCBhbGwgPSBfYlswXSwgc2V0QWxsID0gX2JbMV07XG4gICAgdmFyIHRvZ2dsZUFsbCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0QWxsKGZ1bmN0aW9uICh2KSB7IHJldHVybiAhdjsgfSk7XG4gICAgfSwgW10pO1xuICAgIHZhciBsZWFkaW5nRnJhbWVzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBhbGxMZWFkaW5nRnJhbWVzLmZpbHRlcihmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5leHBhbmRlZCB8fCBhbGw7IH0pOyB9LCBbYWxsLCBhbGxMZWFkaW5nRnJhbWVzXSk7XG4gICAgdmFyIGFsbENhbGxTdGFja0ZyYW1lcyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3IuZnJhbWVzLnNsaWNlKGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXggKyAxKTsgfSwgW2Vycm9yLmZyYW1lcywgZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleF0pO1xuICAgIHZhciB2aXNpYmxlQ2FsbFN0YWNrRnJhbWVzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBhbGxDYWxsU3RhY2tGcmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLmV4cGFuZGVkIHx8IGFsbDsgfSk7IH0sIFthbGwsIGFsbENhbGxTdGFja0ZyYW1lc10pO1xuICAgIHZhciBjYW5TaG93TW9yZSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKGFsbENhbGxTdGFja0ZyYW1lcy5sZW5ndGggIT09IHZpc2libGVDYWxsU3RhY2tGcmFtZXMubGVuZ3RoIHx8XG4gICAgICAgICAgICAoYWxsICYmIGZpcnN0RnJhbWUgIT0gbnVsbCkpO1xuICAgIH0sIFtcbiAgICAgICAgYWxsLFxuICAgICAgICBhbGxDYWxsU3RhY2tGcmFtZXMubGVuZ3RoLFxuICAgICAgICBmaXJzdEZyYW1lLFxuICAgICAgICB2aXNpYmxlQ2FsbFN0YWNrRnJhbWVzLmxlbmd0aCxcbiAgICBdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIGZpcnN0RnJhbWUgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNVwiLCBudWxsLCBcIlNvdXJjZVwiKSxcbiAgICAgICAgICAgIGxlYWRpbmdGcmFtZXMubWFwKGZ1bmN0aW9uIChmcmFtZSwgaW5kZXgpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KENhbGxTdGFja0ZyYW1lLCB7IGtleTogXCJsZWFkaW5nLWZyYW1lLVwiICsgaW5kZXggKyBcIi1cIiArIGFsbCwgZnJhbWU6IGZyYW1lIH0pKTsgfSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENvZGVGcmFtZV8xLkNvZGVGcmFtZSwgeyBzdGFja0ZyYW1lOiBmaXJzdEZyYW1lLm9yaWdpbmFsU3RhY2tGcmFtZSwgY29kZUZyYW1lOiBmaXJzdEZyYW1lLm9yaWdpbmFsQ29kZUZyYW1lIH0pKSkgOiB1bmRlZmluZWQsXG4gICAgICAgIHZpc2libGVDYWxsU3RhY2tGcmFtZXMubGVuZ3RoID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDVcIiwgbnVsbCwgXCJDYWxsIFN0YWNrXCIpLFxuICAgICAgICAgICAgdmlzaWJsZUNhbGxTdGFja0ZyYW1lcy5tYXAoZnVuY3Rpb24gKGZyYW1lLCBpbmRleCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbFN0YWNrRnJhbWUsIHsga2V5OiBcImNhbGwtc3RhY2stXCIgKyBpbmRleCArIFwiLVwiICsgYWxsLCBmcmFtZTogZnJhbWUgfSkpOyB9KSkpIDogdW5kZWZpbmVkLFxuICAgICAgICBjYW5TaG93TW9yZSA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHRhYkluZGV4OiAxMCwgXCJkYXRhLW5leHRqcy1kYXRhLXJ1bnRpbWUtZXJyb3ItY29sbGFwc2VkLWFjdGlvblwiOiB0cnVlLCB0eXBlOiBcImJ1dHRvblwiLCBvbkNsaWNrOiB0b2dnbGVBbGwgfSxcbiAgICAgICAgICAgICAgICBhbGwgPyAnSGlkZScgOiAnU2hvdycsXG4gICAgICAgICAgICAgICAgXCIgY29sbGFwc2VkIGZyYW1lc1wiKSkpIDogdW5kZWZpbmVkKSk7XG59O1xuZXhwb3J0cy5SdW50aW1lRXJyb3IgPSBSdW50aW1lRXJyb3I7XG5leHBvcnRzLnN0eWxlcyA9IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIGJ1dHRvbltkYXRhLW5leHRqcy1kYXRhLXJ1bnRpbWUtZXJyb3ItY29sbGFwc2VkLWFjdGlvbl0ge1xcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLXNpemUtZm9udC1iaWdnZXIpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYWNjZW50cy0zKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXTpub3QoOmxhc3QtY2hpbGQpIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGg2IHtcXG4gICAgbWFyZ2luLXRvcDogMDtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXApO1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICBjb2xvcjogIzIyMjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGg2W2RhdGEtbmV4dGpzLWZyYW1lLWV4cGFuZGVkPSdmYWxzZSddIHtcXG4gICAgY29sb3I6ICM2NjY7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXYge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBwYWRkaW5nLWxlZnQ6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGNvbG9yOiAjOTk5O1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2ID4gc3ZnIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIGhlaWdodDogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgbWFyZ2luLWxlZnQ6IHZhcigtLXNpemUtZ2FwKTtcXG5cXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV06aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXSA+IHN2ZyB7XFxuICAgIGRpc3BsYXk6IHVuc2V0O1xcbiAgfVxcblwiXSwgW1wiXFxuICBidXR0b25bZGF0YS1uZXh0anMtZGF0YS1ydW50aW1lLWVycm9yLWNvbGxhcHNlZC1hY3Rpb25dIHtcXG4gICAgYmFja2dyb3VuZDogbm9uZTtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtYmlnZ2VyKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFjY2VudHMtMyk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV06bm90KDpsYXN0LWNoaWxkKSB7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBoNiB7XFxuICAgIG1hcmdpbi10b3A6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwKTtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gICAgY29sb3I6ICMyMjI7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBoNltkYXRhLW5leHRqcy1mcmFtZS1leHBhbmRlZD0nZmFsc2UnXSB7XFxuICAgIGNvbG9yOiAjNjY2O1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgcGFkZGluZy1sZWZ0OiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBjb2xvcjogIzk5OTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdiA+IHN2ZyB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIG1hcmdpbi1sZWZ0OiB2YXIoLS1zaXplLWdhcCk7XFxuXFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXSB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0gPiBzdmcge1xcbiAgICBkaXNwbGF5OiB1bnNldDtcXG4gIH1cXG5cIl0pKSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJ1bnRpbWVFcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIHN0YWNrdHJhY2VfcGFyc2VyXzEgPSByZXF1aXJlKFwic3RhY2t0cmFjZS1wYXJzZXJcIik7XG5mdW5jdGlvbiBnZXRGaWxlc3lzdGVtRnJhbWUoZnJhbWUpIHtcbiAgICB2YXIgZiA9IF9fYXNzaWduKHt9LCBmcmFtZSk7XG4gICAgaWYgKHR5cGVvZiBmLmZpbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gUG9zaXg6XG4gICAgICAgIGYuZmlsZS5zdGFydHNXaXRoKCcvJykgfHxcbiAgICAgICAgICAgIC8vIFdpbjMyOlxuICAgICAgICAgICAgL15bYS16XTpcXFxcL2kudGVzdChmLmZpbGUpIHx8XG4gICAgICAgICAgICAvLyBXaW4zMiBVTkM6XG4gICAgICAgICAgICBmLmZpbGUuc3RhcnRzV2l0aCgnXFxcXFxcXFwnKSkge1xuICAgICAgICAgICAgZi5maWxlID0gXCJmaWxlOi8vXCIgKyBmLmZpbGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGY7XG59XG5leHBvcnRzLmdldEZpbGVzeXN0ZW1GcmFtZSA9IGdldEZpbGVzeXN0ZW1GcmFtZTtcbnZhciBzeW1ib2xOb2RlRXJyb3IgPSBTeW1ib2woJ05leHRqc05vZGVFcnJvcicpO1xuZnVuY3Rpb24gaXNOb2RlRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gc3ltYm9sTm9kZUVycm9yIGluIGVycm9yO1xufVxuZXhwb3J0cy5pc05vZGVFcnJvciA9IGlzTm9kZUVycm9yO1xuZnVuY3Rpb24gZ2V0Tm9kZUVycm9yKGVycm9yKSB7XG4gICAgdmFyIG47XG4gICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBuID0gZTtcbiAgICB9XG4gICAgbi5uYW1lID0gZXJyb3IubmFtZTtcbiAgICB0cnkge1xuICAgICAgICBuLnN0YWNrID0gc3RhY2t0cmFjZV9wYXJzZXJfMS5wYXJzZShlcnJvci5zdGFjaylcbiAgICAgICAgICAgIC5tYXAoZ2V0RmlsZXN5c3RlbUZyYW1lKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgdmFyIHN0ciA9IFwiICAgIGF0IFwiICsgZi5tZXRob2ROYW1lO1xuICAgICAgICAgICAgaWYgKGYuZmlsZSkge1xuICAgICAgICAgICAgICAgIHZhciBsb2MgPSBmLmZpbGU7XG4gICAgICAgICAgICAgICAgaWYgKGYubGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBsb2MgKz0gXCI6XCIgKyBmLmxpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmLmNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jICs9IFwiOlwiICsgZi5jb2x1bW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyICs9IFwiIChcIiArIGxvYyArIFwiKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIG4uc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHN5bWJvbE5vZGVFcnJvciwge1xuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIG47XG59XG5leHBvcnRzLmdldE5vZGVFcnJvciA9IGdldE5vZGVFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vZGVTdGFja0ZyYW1lcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5mdW5jdGlvbiBub29wKHN0cmluZ3MpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGtleXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBsYXN0SW5kZXggPSBzdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIChzdHJpbmdzLnNsaWNlKDAsIGxhc3RJbmRleCkucmVkdWNlKGZ1bmN0aW9uIChwLCBzLCBpKSB7IHJldHVybiBwICsgcyArIGtleXNbaV07IH0sICcnKSArXG4gICAgICAgIHN0cmluZ3NbbGFzdEluZGV4XSk7XG59XG5leHBvcnRzLm5vb3AgPSBub29wO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9vcC10ZW1wbGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgc3RhY2t0cmFjZV9wYXJzZXJfMSA9IHJlcXVpcmUoXCJzdGFja3RyYWNlLXBhcnNlclwiKTtcbnZhciByZWdleE5leHRTdGF0aWMgPSAvXFwvX25leHQoXFwvc3RhdGljXFwvLispL2c7XG5mdW5jdGlvbiBwYXJzZVN0YWNrKHN0YWNrKSB7XG4gICAgdmFyIGZyYW1lcyA9IHN0YWNrdHJhY2VfcGFyc2VyXzEucGFyc2Uoc3RhY2spO1xuICAgIHJldHVybiBmcmFtZXMubWFwKGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHVybCA9IG5ldyBVUkwoZnJhbWUuZmlsZSk7XG4gICAgICAgICAgICB2YXIgcmVzID0gcmVnZXhOZXh0U3RhdGljLmV4ZWModXJsLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdERpciA9IChfYiA9IChfYSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ESVNUX0RJUikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2UoL1xcXFwvZywgJy8nKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3REaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUuZmlsZSA9ICdmaWxlOi8vJyArIGRpc3REaXIuY29uY2F0KHJlcy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYykgeyB9XG4gICAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucGFyc2VTdGFjayA9IHBhcnNlU3RhY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZVN0YWNrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5mdW5jdGlvbiBnZXRPcmlnaW5hbFN0YWNrRnJhbWVzKGlzU2VydmVyU2lkZSwgZnJhbWVzKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGZyYW1lcy5tYXAoZnVuY3Rpb24gKGZyYW1lKSB7IHJldHVybiBnZXRPcmlnaW5hbFN0YWNrRnJhbWUoaXNTZXJ2ZXJTaWRlLCBmcmFtZSk7IH0pKTtcbn1cbmV4cG9ydHMuZ2V0T3JpZ2luYWxTdGFja0ZyYW1lcyA9IGdldE9yaWdpbmFsU3RhY2tGcmFtZXM7XG5mdW5jdGlvbiBnZXRPcmlnaW5hbFN0YWNrRnJhbWUoaXNTZXJ2ZXJTaWRlLCBzb3VyY2UpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGZ1bmN0aW9uIF9nZXRPcmlnaW5hbFN0YWNrRnJhbWUoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcywga2V5LCBjb250cm9sbGVyLCB0bSwgcmVzLCBfZSwgX2YsIF9nLCBib2R5O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfaCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2gubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZCgnaXNTZXJ2ZXJTaWRlJywgU3RyaW5nKGlzU2VydmVyU2lkZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChrZXksICgoX2EgPSBzb3VyY2Vba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sbGVyLmFib3J0KCk7IH0sIDMwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2VsZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmV0Y2goKHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgJycpICsgXCIvX19uZXh0anNfb3JpZ2luYWwtc3RhY2stZnJhbWU/XCIgKyBwYXJhbXMudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlbXCJmaW5hbGx5XCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IF9oLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCFyZXMub2sgfHwgcmVzLnN0YXR1cyA9PT0gMjA0KSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBfZiA9IChfZSA9IFByb21pc2UpLnJlamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9nID0gRXJyb3IuYmluZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlcy50ZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfZi5hcHBseShfZSwgW25ldyAoX2cuYXBwbHkoRXJyb3IsIFt2b2lkIDAsIF9oLnNlbnQoKV0pKSgpXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIHJlcy5qc29uKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gX2guc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVybmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQ6ICFCb29sZWFuKChfZCA9IChfYyA9IChfYiA9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb2xsYXBzZWQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5vcmlnaW5hbFN0YWNrRnJhbWUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5maWxlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaW5jbHVkZXMoJ25vZGVfbW9kdWxlcycpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0cnVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlU3RhY2tGcmFtZTogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YWNrRnJhbWU6IGJvZHkub3JpZ2luYWxTdGFja0ZyYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbENvZGVGcmFtZTogYm9keS5vcmlnaW5hbENvZGVGcmFtZSB8fCBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoISgoKF9hID0gc291cmNlLmZpbGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGFydHNXaXRoKCd3ZWJwYWNrLWludGVybmFsOicpKSB8fCAoKF9iID0gc291cmNlLmZpbGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGFydHNXaXRoKCdmaWxlOicpKSkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICBlcnJvcjogZmFsc2UsXG4gICAgICAgICAgICByZWFzb246IG51bGwsXG4gICAgICAgICAgICBleHRlcm5hbDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGFuZGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHNvdXJjZVN0YWNrRnJhbWU6IHNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhY2tGcmFtZTogbnVsbCxcbiAgICAgICAgICAgIG9yaWdpbmFsQ29kZUZyYW1lOiBudWxsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gX2dldE9yaWdpbmFsU3RhY2tGcmFtZSgpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgIGVycm9yOiB0cnVlLFxuICAgICAgICAgICAgcmVhc29uOiAoX2IgPSAoX2EgPSBlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIubWVzc2FnZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdVbmtub3duIEVycm9yJyxcbiAgICAgICAgICAgIGV4dGVybmFsOiBmYWxzZSxcbiAgICAgICAgICAgIGV4cGFuZGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHNvdXJjZVN0YWNrRnJhbWU6IHNvdXJjZSxcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhY2tGcmFtZTogbnVsbCxcbiAgICAgICAgICAgIG9yaWdpbmFsQ29kZUZyYW1lOiBudWxsXG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5nZXRPcmlnaW5hbFN0YWNrRnJhbWUgPSBnZXRPcmlnaW5hbFN0YWNrRnJhbWU7XG5mdW5jdGlvbiBnZXRGcmFtZVNvdXJjZShmcmFtZSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHUgPSBuZXcgVVJMKGZyYW1lLmZpbGUpO1xuICAgICAgICAvLyBTdHJpcCB0aGUgb3JpZ2luIGZvciBzYW1lLW9yaWdpbiBzY3JpcHRzLlxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAoKF9hID0gZ2xvYmFsVGhpcy5sb2NhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9yaWdpbikgIT09IHUub3JpZ2luKSB7XG4gICAgICAgICAgICAvLyBVUkxzIGNhbiBiZSB2YWxpZCB3aXRob3V0IGFuIGBvcmlnaW5gLCBzbyBsb25nIGFzIHRoZXkgaGF2ZSBhXG4gICAgICAgICAgICAvLyBgcHJvdG9jb2xgLiBIb3dldmVyLCBgb3JpZ2luYCBpcyBwcmVmZXJyZWQuXG4gICAgICAgICAgICBpZiAodS5vcmlnaW4gPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgIHN0ciArPSB1LnByb3RvY29sO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyICs9IHUub3JpZ2luO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0cmlwIHF1ZXJ5IHN0cmluZyBpbmZvcm1hdGlvbiBhcyBpdCdzIHR5cGljYWxseSB0b28gdmVyYm9zZSB0byBiZVxuICAgICAgICAvLyBtZWFuaW5nZnVsLlxuICAgICAgICBzdHIgKz0gdS5wYXRobmFtZTtcbiAgICAgICAgc3RyICs9ICcgJztcbiAgICB9XG4gICAgY2F0Y2ggKF9iKSB7XG4gICAgICAgIHN0ciArPSAoZnJhbWUuZmlsZSB8fCAnKHVua25vd24pJykgKyAnICc7XG4gICAgfVxuICAgIGlmIChmcmFtZS5saW5lTnVtYmVyICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGZyYW1lLmNvbHVtbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgKz0gXCIoXCIgKyBmcmFtZS5saW5lTnVtYmVyICsgXCI6XCIgKyBmcmFtZS5jb2x1bW4gKyBcIikgXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHIgKz0gXCIoXCIgKyBmcmFtZS5saW5lTnVtYmVyICsgXCIpIFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgLTEpO1xufVxuZXhwb3J0cy5nZXRGcmFtZVNvdXJjZSA9IGdldEZyYW1lU291cmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhY2stZnJhbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5mdW5jdGlvbiB1c2VPbkNsaWNrT3V0c2lkZShlbCwgaGFuZGxlcikge1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChlbCA9PSBudWxsIHx8IGhhbmRsZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGNsaWNraW5nIHJlZidzIGVsZW1lbnQgb3IgZGVzY2VuZGVudCBlbGVtZW50c1xuICAgICAgICAgICAgaWYgKCFlbCB8fCBlbC5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVyKGUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcm9vdCA9IGVsLmdldFJvb3ROb2RlKCk7XG4gICAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbGlzdGVuZXIpO1xuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICB9LCBbaGFuZGxlciwgZWxdKTtcbn1cbmV4cG9ydHMudXNlT25DbGlja091dHNpZGUgPSB1c2VPbkNsaWNrT3V0c2lkZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZS1vbi1jbGljay1vdXRzaWRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgICByZXR1cm4gY29va2VkO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuZnVuY3Rpb24gQmFzZSgpIHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICBfX2h0bWw6IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICAgIC0tc2l6ZS1nYXAtaGFsZjogNHB4O1xcbiAgICAgICAgICAgIC0tc2l6ZS1nYXA6IDhweDtcXG4gICAgICAgICAgICAtLXNpemUtZ2FwLWRvdWJsZTogMTZweDtcXG4gICAgICAgICAgICAtLXNpemUtZ2FwLXF1YWQ6IDMycHg7XFxuXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQtc21hbGw6IDE0cHg7XFxuICAgICAgICAgICAgLS1zaXplLWZvbnQ6IDE2cHg7XFxuICAgICAgICAgICAgLS1zaXplLWZvbnQtYmlnOiAyMHB4O1xcbiAgICAgICAgICAgIC0tc2l6ZS1mb250LWJpZ2dlcjogMjRweDtcXG5cXG4gICAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMTogIzgwODA4MDtcXG4gICAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMjogIzIyMjIyMjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMzogIzQwNDA0MDtcXG5cXG4gICAgICAgICAgICAtLWZvbnQtc3RhY2stbW9ub3NwYWNlOiAnU0ZNb25vLVJlZ3VsYXInLCBDb25zb2xhcyxcXG4gICAgICAgICAgICAgICdMaWJlcmF0aW9uIE1vbm8nLCBNZW5sbywgQ291cmllciwgbW9ub3NwYWNlO1xcblxcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1zZWxlY3Rpb246IHJnYmEoOTUsIDEyNiwgMTUxLCAwLjQ4KTtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYmc6ICMxMTExMTE7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWZnOiAjY2NjY2NjO1xcblxcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS13aGl0ZTogIzc3Nzc3NztcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYmxhY2s6ICMxNDE0MTQ7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJsdWU6ICMwMGFhZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWN5YW46ICM4OGRkZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWdyZWVuOiAjOThlYzY1O1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1tYWdlbnRhOiAjYWE4OGZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1yZWQ6ICNmZjU1NTU7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXllbGxvdzogI2ZmY2MzMztcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlOiAjZmZmZmZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtYmxhY2s6ICM3Nzc3Nzc7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ibHVlOiAjMzNiYmZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtY3lhbjogI2JiZWNmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWdyZWVuOiAjYjZmMjkyO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtbWFnZW50YTogI2NlYmJmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXJlZDogI2ZmODg4ODtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXllbGxvdzogI2ZmZDk2NjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICAubW9ubyB7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBoMSxcXG4gICAgICAgICAgaDIsXFxuICAgICAgICAgIGgzLFxcbiAgICAgICAgICBoNCxcXG4gICAgICAgICAgaDUsXFxuICAgICAgICAgIGg2IHtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDQwcHg7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDIge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMzJweDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBoMyB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAyOHB4O1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGg0IHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDI0cHg7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDUge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMjBweDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBoNiB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgICAgICB9XFxuICAgICAgICBcIl0sIFtcIlxcbiAgICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgICAgLS1zaXplLWdhcC1oYWxmOiA0cHg7XFxuICAgICAgICAgICAgLS1zaXplLWdhcDogOHB4O1xcbiAgICAgICAgICAgIC0tc2l6ZS1nYXAtZG91YmxlOiAxNnB4O1xcbiAgICAgICAgICAgIC0tc2l6ZS1nYXAtcXVhZDogMzJweDtcXG5cXG4gICAgICAgICAgICAtLXNpemUtZm9udC1zbWFsbDogMTRweDtcXG4gICAgICAgICAgICAtLXNpemUtZm9udDogMTZweDtcXG4gICAgICAgICAgICAtLXNpemUtZm9udC1iaWc6IDIwcHg7XFxuICAgICAgICAgICAgLS1zaXplLWZvbnQtYmlnZ2VyOiAyNHB4O1xcblxcbiAgICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0xOiAjODA4MDgwO1xcbiAgICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0yOiAjMjIyMjIyO1xcbiAgICAgICAgICAgIC0tY29sb3ItYWNjZW50cy0zOiAjNDA0MDQwO1xcblxcbiAgICAgICAgICAgIC0tZm9udC1zdGFjay1tb25vc3BhY2U6ICdTRk1vbm8tUmVndWxhcicsIENvbnNvbGFzLFxcbiAgICAgICAgICAgICAgJ0xpYmVyYXRpb24gTW9ubycsIE1lbmxvLCBDb3VyaWVyLCBtb25vc3BhY2U7XFxuXFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXNlbGVjdGlvbjogcmdiYSg5NSwgMTI2LCAxNTEsIDAuNDgpO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1iZzogIzExMTExMTtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktZmc6ICNjY2NjY2M7XFxuXFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXdoaXRlOiAjNzc3Nzc3O1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1ibGFjazogIzE0MTQxNDtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYmx1ZTogIzAwYWFmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktY3lhbjogIzg4ZGRmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktZ3JlZW46ICM5OGVjNjU7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLW1hZ2VudGE6ICNhYTg4ZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXJlZDogI2ZmNTU1NTtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2kteWVsbG93OiAjZmZjYzMzO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtd2hpdGU6ICNmZmZmZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ibGFjazogIzc3Nzc3NztcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsdWU6ICMzM2JiZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1jeWFuOiAjYmJlY2ZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtZ3JlZW46ICNiNmYyOTI7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1tYWdlbnRhOiAjY2ViYmZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtcmVkOiAjZmY4ODg4O1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQteWVsbG93OiAjZmZkOTY2O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIC5tb25vIHtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxLFxcbiAgICAgICAgICBoMixcXG4gICAgICAgICAgaDMsXFxuICAgICAgICAgIGg0LFxcbiAgICAgICAgICBoNSxcXG4gICAgICAgICAgaDYge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwKTtcXG4gICAgICAgICAgICBmb250LXdlaWdodDogNTAwO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaDEge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogNDBweDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBoMiB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAzMnB4O1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGgzIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDI4cHg7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDQge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMjRweDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBoNSB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAyMHB4O1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGg2IHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgICAgIH1cXG4gICAgICAgIFwiXSkpKVxuICAgICAgICB9IH0pKTtcbn1cbmV4cG9ydHMuQmFzZSA9IEJhc2U7XG52YXIgdGVtcGxhdGVPYmplY3RfMTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIHN0eWxlc18xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvQ29kZUZyYW1lL3N0eWxlc1wiKTtcbnZhciBEaWFsb2dfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL0RpYWxvZ1wiKTtcbnZhciBzdHlsZXNfMiA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL0xlZnRSaWdodERpYWxvZ0hlYWRlci9zdHlsZXNcIik7XG52YXIgc3R5bGVzXzMgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9PdmVybGF5L3N0eWxlc1wiKTtcbnZhciBzdHlsZXNfNCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL1Rlcm1pbmFsL3N0eWxlc1wiKTtcbnZhciBUb2FzdF8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvVG9hc3RcIik7XG52YXIgQnVpbGRFcnJvcl8xID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9CdWlsZEVycm9yXCIpO1xudmFyIEVycm9yc18xID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9FcnJvcnNcIik7XG52YXIgUnVudGltZUVycm9yXzEgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL1J1bnRpbWVFcnJvclwiKTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuZnVuY3Rpb24gQ29tcG9uZW50U3R5bGVzKCkge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInN0eWxlXCIsIHsgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICAgIF9faHRtbDogbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcblxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgXCJdLCBbXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgIFwiXSkpLCBzdHlsZXNfMy5zdHlsZXMsIFRvYXN0XzEuc3R5bGVzLCBEaWFsb2dfMS5zdHlsZXMsIHN0eWxlc18yLnN0eWxlcywgc3R5bGVzXzEuc3R5bGVzLCBzdHlsZXNfNC5zdHlsZXMsIEJ1aWxkRXJyb3JfMS5zdHlsZXMsIEVycm9yc18xLnN0eWxlcywgUnVudGltZUVycm9yXzEuc3R5bGVzKVxuICAgICAgICB9IH0pKTtcbn1cbmV4cG9ydHMuQ29tcG9uZW50U3R5bGVzID0gQ29tcG9uZW50U3R5bGVzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21wb25lbnRTdHlsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XG5mdW5jdGlvbiBDc3NSZXNldCgpIHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICBfX2h0bWw6IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICAgIGFsbDogaW5pdGlhbDtcXG5cXG4gICAgICAgICAgICAvKiB0aGUgZGlyZWN0aW9uIHByb3BlcnR5IGlzIG5vdCByZXNldCBieSAnYWxsJyAqL1xcbiAgICAgICAgICAgIGRpcmVjdGlvbjogbHRyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIC8qIVxcbiAgICAgICAgICAgKiBCb290c3RyYXAgUmVib290IHY0LjQuMSAoaHR0cHM6Ly9nZXRib290c3RyYXAuY29tLylcXG4gICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEtMjAxOSBUaGUgQm9vdHN0cmFwIEF1dGhvcnNcXG4gICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEtMjAxOSBUd2l0dGVyLCBJbmMuXFxuICAgICAgICAgICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxuICAgICAgICAgICAqIEZvcmtlZCBmcm9tIE5vcm1hbGl6ZS5jc3MsIGxpY2Vuc2VkIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kKVxcbiAgICAgICAgICAgKi9cXG4gICAgICAgICAgKixcXG4gICAgICAgICAgKjo6YmVmb3JlLFxcbiAgICAgICAgICAqOjphZnRlciB7XFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuMTU7XFxuICAgICAgICAgICAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xcbiAgICAgICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhcnRpY2xlLFxcbiAgICAgICAgICBhc2lkZSxcXG4gICAgICAgICAgZmlnY2FwdGlvbixcXG4gICAgICAgICAgZmlndXJlLFxcbiAgICAgICAgICBmb290ZXIsXFxuICAgICAgICAgIGhlYWRlcixcXG4gICAgICAgICAgaGdyb3VwLFxcbiAgICAgICAgICBtYWluLFxcbiAgICAgICAgICBuYXYsXFxuICAgICAgICAgIHNlY3Rpb24ge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgUm9ib3RvLFxcbiAgICAgICAgICAgICAgJ0hlbHZldGljYSBOZXVlJywgQXJpYWwsICdOb3RvIFNhbnMnLCBzYW5zLXNlcmlmLFxcbiAgICAgICAgICAgICAgJ0FwcGxlIENvbG9yIEVtb2ppJywgJ1NlZ29lIFVJIEVtb2ppJywgJ1NlZ29lIFVJIFN5bWJvbCcsXFxuICAgICAgICAgICAgICAnTm90byBDb2xvciBFbW9qaSc7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxNnB4O1xcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuNTtcXG4gICAgICAgICAgICBjb2xvcjogIzIxMjUyOTtcXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3RhYmluZGV4PSctMSddOmZvY3VzOm5vdCg6Zm9jdXMtdmlzaWJsZSkge1xcbiAgICAgICAgICAgIG91dGxpbmU6IDAgIWltcG9ydGFudDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBociB7XFxuICAgICAgICAgICAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxuICAgICAgICAgICAgaGVpZ2h0OiAwO1xcbiAgICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxLFxcbiAgICAgICAgICBoMixcXG4gICAgICAgICAgaDMsXFxuICAgICAgICAgIGg0LFxcbiAgICAgICAgICBoNSxcXG4gICAgICAgICAgaDYge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHAge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhYmJyW3RpdGxlXSxcXG4gICAgICAgICAgYWJicltkYXRhLW9yaWdpbmFsLXRpdGxlXSB7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICAgICAgICAgICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgICAgICAgICAgIGN1cnNvcjogaGVscDtcXG4gICAgICAgICAgICBib3JkZXItYm90dG9tOiAwO1xcbiAgICAgICAgICAgIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uLXNraXAtaW5rOiBub25lO1xcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbi1za2lwLWluazogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhZGRyZXNzIHtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xcbiAgICAgICAgICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvbCxcXG4gICAgICAgICAgdWwsXFxuICAgICAgICAgIGRsIHtcXG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgb2wgb2wsXFxuICAgICAgICAgIHVsIHVsLFxcbiAgICAgICAgICBvbCB1bCxcXG4gICAgICAgICAgdWwgb2wge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZHQge1xcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZGQge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcXG4gICAgICAgICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBibG9ja3F1b3RlIHtcXG4gICAgICAgICAgICBtYXJnaW46IDAgMCAxNnB4O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGIsXFxuICAgICAgICAgIHN0cm9uZyB7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzbWFsbCB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiA4MCU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3ViLFxcbiAgICAgICAgICBzdXAge1xcbiAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgICAgICBmb250LXNpemU6IDc1JTtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMDtcXG4gICAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3ViIHtcXG4gICAgICAgICAgICBib3R0b206IC0wLjI1ZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3VwIHtcXG4gICAgICAgICAgICB0b3A6IC0wLjVlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhIHtcXG4gICAgICAgICAgICBjb2xvcjogIzAwN2JmZjtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYTpob3ZlciB7XFxuICAgICAgICAgICAgY29sb3I6ICMwMDU2YjM7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYTpub3QoW2hyZWZdKSB7XFxuICAgICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGE6bm90KFtocmVmXSk6aG92ZXIge1xcbiAgICAgICAgICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwcmUsXFxuICAgICAgICAgIGNvZGUsXFxuICAgICAgICAgIGtiZCxcXG4gICAgICAgICAgc2FtcCB7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IFNGTW9uby1SZWd1bGFyLCBNZW5sbywgTW9uYWNvLCBDb25zb2xhcyxcXG4gICAgICAgICAgICAgICdMaWJlcmF0aW9uIE1vbm8nLCAnQ291cmllciBOZXcnLCBtb25vc3BhY2U7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcHJlIHtcXG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZmlndXJlIHtcXG4gICAgICAgICAgICBtYXJnaW46IDAgMCAxNnB4O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGltZyB7XFxuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgICAgICAgICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3ZnIHtcXG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGFibGUge1xcbiAgICAgICAgICAgIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgY2FwdGlvbiB7XFxuICAgICAgICAgICAgcGFkZGluZy10b3A6IDEycHg7XFxuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206IDEycHg7XFxuICAgICAgICAgICAgY29sb3I6ICM2Yzc1N2Q7XFxuICAgICAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgICAgICAgICBjYXB0aW9uLXNpZGU6IGJvdHRvbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aCB7XFxuICAgICAgICAgICAgdGV4dC1hbGlnbjogaW5oZXJpdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBsYWJlbCB7XFxuICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24ge1xcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnV0dG9uOmZvY3VzIHtcXG4gICAgICAgICAgICBvdXRsaW5lOiAxcHggZG90dGVkO1xcbiAgICAgICAgICAgIG91dGxpbmU6IDVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnB1dCxcXG4gICAgICAgICAgYnV0dG9uLFxcbiAgICAgICAgICBzZWxlY3QsXFxuICAgICAgICAgIG9wdGdyb3VwLFxcbiAgICAgICAgICB0ZXh0YXJlYSB7XFxuICAgICAgICAgICAgbWFyZ2luOiAwO1xcbiAgICAgICAgICAgIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIGlucHV0IHtcXG4gICAgICAgICAgICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIHNlbGVjdCB7XFxuICAgICAgICAgICAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc2VsZWN0IHtcXG4gICAgICAgICAgICB3b3JkLXdyYXA6IG5vcm1hbDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIFt0eXBlPSdidXR0b24nXSxcXG4gICAgICAgICAgW3R5cGU9J3Jlc2V0J10sXFxuICAgICAgICAgIFt0eXBlPSdzdWJtaXQnXSB7XFxuICAgICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnV0dG9uOm5vdCg6ZGlzYWJsZWQpLFxcbiAgICAgICAgICBbdHlwZT0nYnV0dG9uJ106bm90KDpkaXNhYmxlZCksXFxuICAgICAgICAgIFt0eXBlPSdyZXNldCddOm5vdCg6ZGlzYWJsZWQpLFxcbiAgICAgICAgICBbdHlwZT0nc3VibWl0J106bm90KDpkaXNhYmxlZCkge1xcbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgICAgICAgIFt0eXBlPSdidXR0b24nXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgICAgW3R5cGU9J3Jlc2V0J106Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgICAgICAgIFt0eXBlPSdzdWJtaXQnXTo6LW1vei1mb2N1cy1pbm5lciB7XFxuICAgICAgICAgICAgcGFkZGluZzogMDtcXG4gICAgICAgICAgICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW5wdXRbdHlwZT0ncmFkaW8nXSxcXG4gICAgICAgICAgaW5wdXRbdHlwZT0nY2hlY2tib3gnXSB7XFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlucHV0W3R5cGU9J2RhdGUnXSxcXG4gICAgICAgICAgaW5wdXRbdHlwZT0ndGltZSddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdkYXRldGltZS1sb2NhbCddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdtb250aCddIHtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGxpc3Rib3g7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGV4dGFyZWEge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICAgICAgICAgIHJlc2l6ZTogdmVydGljYWw7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZmllbGRzZXQge1xcbiAgICAgICAgICAgIG1pbi13aWR0aDogMDtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbjogMDtcXG4gICAgICAgICAgICBib3JkZXI6IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbGVnZW5kIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgcGFkZGluZzogMDtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiA4cHg7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAyNHB4O1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgICAgICAgICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgICAgIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcHJvZ3Jlc3Mge1xcbiAgICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBbdHlwZT0nbnVtYmVyJ106Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuICAgICAgICAgIFt0eXBlPSdudW1iZXInXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XFxuICAgICAgICAgICAgaGVpZ2h0OiBhdXRvO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIFt0eXBlPSdzZWFyY2gnXSB7XFxuICAgICAgICAgICAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7XFxuICAgICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIFt0eXBlPSdzZWFyY2gnXTo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiB7XFxuICAgICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIDo6LXdlYmtpdC1maWxlLXVwbG9hZC1idXR0b24ge1xcbiAgICAgICAgICAgIGZvbnQ6IGluaGVyaXQ7XFxuICAgICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgb3V0cHV0IHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3VtbWFyeSB7XFxuICAgICAgICAgICAgZGlzcGxheTogbGlzdC1pdGVtO1xcbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0ZW1wbGF0ZSB7XFxuICAgICAgICAgICAgZGlzcGxheTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBbaGlkZGVuXSB7XFxuICAgICAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcbiAgICAgICAgICB9XFxuICAgICAgICBcIl0sIFtcIlxcbiAgICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgICAgYWxsOiBpbml0aWFsO1xcblxcbiAgICAgICAgICAgIC8qIHRoZSBkaXJlY3Rpb24gcHJvcGVydHkgaXMgbm90IHJlc2V0IGJ5ICdhbGwnICovXFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBsdHI7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgLyohXFxuICAgICAgICAgICAqIEJvb3RzdHJhcCBSZWJvb3QgdjQuNC4xIChodHRwczovL2dldGJvb3RzdHJhcC5jb20vKVxcbiAgICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMS0yMDE5IFRoZSBCb290c3RyYXAgQXV0aG9yc1xcbiAgICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMS0yMDE5IFR3aXR0ZXIsIEluYy5cXG4gICAgICAgICAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcXG4gICAgICAgICAgICogRm9ya2VkIGZyb20gTm9ybWFsaXplLmNzcywgbGljZW5zZWQgTUlUIChodHRwczovL2dpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQpXFxuICAgICAgICAgICAqL1xcbiAgICAgICAgICAqLFxcbiAgICAgICAgICAqOjpiZWZvcmUsXFxuICAgICAgICAgICo6OmFmdGVyIHtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMS4xNTtcXG4gICAgICAgICAgICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7XFxuICAgICAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFydGljbGUsXFxuICAgICAgICAgIGFzaWRlLFxcbiAgICAgICAgICBmaWdjYXB0aW9uLFxcbiAgICAgICAgICBmaWd1cmUsXFxuICAgICAgICAgIGZvb3RlcixcXG4gICAgICAgICAgaGVhZGVyLFxcbiAgICAgICAgICBoZ3JvdXAsXFxuICAgICAgICAgIG1haW4sXFxuICAgICAgICAgIG5hdixcXG4gICAgICAgICAgc2VjdGlvbiB7XFxuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICAgIG1hcmdpbjogMDtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCBSb2JvdG8sXFxuICAgICAgICAgICAgICAnSGVsdmV0aWNhIE5ldWUnLCBBcmlhbCwgJ05vdG8gU2FucycsIHNhbnMtc2VyaWYsXFxuICAgICAgICAgICAgICAnQXBwbGUgQ29sb3IgRW1vamknLCAnU2Vnb2UgVUkgRW1vamknLCAnU2Vnb2UgVUkgU3ltYm9sJyxcXG4gICAgICAgICAgICAgICdOb3RvIENvbG9yIEVtb2ppJztcXG4gICAgICAgICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICAgICAgICAgIGNvbG9yOiAjMjEyNTI5O1xcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBbdGFiaW5kZXg9Jy0xJ106Zm9jdXM6bm90KDpmb2N1cy12aXNpYmxlKSB7XFxuICAgICAgICAgICAgb3V0bGluZTogMCAhaW1wb3J0YW50O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGhyIHtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG4gICAgICAgICAgICBoZWlnaHQ6IDA7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IHZpc2libGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaDEsXFxuICAgICAgICAgIGgyLFxcbiAgICAgICAgICBoMyxcXG4gICAgICAgICAgaDQsXFxuICAgICAgICAgIGg1LFxcbiAgICAgICAgICBoNiB7XFxuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiA4cHg7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcCB7XFxuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxNnB4O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFiYnJbdGl0bGVdLFxcbiAgICAgICAgICBhYmJyW2RhdGEtb3JpZ2luYWwtdGl0bGVdIHtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgICAgICAgICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgICAgY3Vyc29yOiBoZWxwO1xcbiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDA7XFxuICAgICAgICAgICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb24tc2tpcC1pbms6IG5vbmU7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uLXNraXAtaW5rOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFkZHJlc3Mge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICAgICAgICAgICAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG9sLFxcbiAgICAgICAgICB1bCxcXG4gICAgICAgICAgZGwge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvbCBvbCxcXG4gICAgICAgICAgdWwgdWwsXFxuICAgICAgICAgIG9sIHVsLFxcbiAgICAgICAgICB1bCBvbCB7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkdCB7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkZCB7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbiAgICAgICAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJsb2NrcXVvdGUge1xcbiAgICAgICAgICAgIG1hcmdpbjogMCAwIDE2cHg7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYixcXG4gICAgICAgICAgc3Ryb25nIHtcXG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZGVyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHNtYWxsIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDgwJTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdWIsXFxuICAgICAgICAgIHN1cCB7XFxuICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogNzUlO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAwO1xcbiAgICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdWIge1xcbiAgICAgICAgICAgIGJvdHRvbTogLTAuMjVlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdXAge1xcbiAgICAgICAgICAgIHRvcDogLTAuNWVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGEge1xcbiAgICAgICAgICAgIGNvbG9yOiAjMDA3YmZmO1xcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhOmhvdmVyIHtcXG4gICAgICAgICAgICBjb2xvcjogIzAwNTZiMztcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhOm5vdChbaHJlZl0pIHtcXG4gICAgICAgICAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYTpub3QoW2hyZWZdKTpob3ZlciB7XFxuICAgICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHByZSxcXG4gICAgICAgICAgY29kZSxcXG4gICAgICAgICAga2JkLFxcbiAgICAgICAgICBzYW1wIHtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLFxcbiAgICAgICAgICAgICAgJ0xpYmVyYXRpb24gTW9ubycsICdDb3VyaWVyIE5ldycsIG1vbm9zcGFjZTtcXG4gICAgICAgICAgICBmb250LXNpemU6IDFlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwcmUge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG4gICAgICAgICAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmaWd1cmUge1xcbiAgICAgICAgICAgIG1hcmdpbjogMCAwIDE2cHg7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW1nIHtcXG4gICAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICAgICAgICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdmcge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0YWJsZSB7XFxuICAgICAgICAgICAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBjYXB0aW9uIHtcXG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMTJweDtcXG4gICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogMTJweDtcXG4gICAgICAgICAgICBjb2xvcjogIzZjNzU3ZDtcXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAgICAgICAgIGNhcHRpb24tc2lkZTogYm90dG9tO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRoIHtcXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBpbmhlcml0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGxhYmVsIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbiB7XFxuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b246Zm9jdXMge1xcbiAgICAgICAgICAgIG91dGxpbmU6IDFweCBkb3R0ZWQ7XFxuICAgICAgICAgICAgb3V0bGluZTogNXB4IGF1dG8gLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlucHV0LFxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIHNlbGVjdCxcXG4gICAgICAgICAgb3B0Z3JvdXAsXFxuICAgICAgICAgIHRleHRhcmVhIHtcXG4gICAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbixcXG4gICAgICAgICAgaW5wdXQge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbixcXG4gICAgICAgICAgc2VsZWN0IHtcXG4gICAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzZWxlY3Qge1xcbiAgICAgICAgICAgIHdvcmQtd3JhcDogbm9ybWFsO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbixcXG4gICAgICAgICAgW3R5cGU9J2J1dHRvbiddLFxcbiAgICAgICAgICBbdHlwZT0ncmVzZXQnXSxcXG4gICAgICAgICAgW3R5cGU9J3N1Ym1pdCddIHtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b246bm90KDpkaXNhYmxlZCksXFxuICAgICAgICAgIFt0eXBlPSdidXR0b24nXTpub3QoOmRpc2FibGVkKSxcXG4gICAgICAgICAgW3R5cGU9J3Jlc2V0J106bm90KDpkaXNhYmxlZCksXFxuICAgICAgICAgIFt0eXBlPSdzdWJtaXQnXTpub3QoOmRpc2FibGVkKSB7XFxuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgICAgW3R5cGU9J2J1dHRvbiddOjotbW96LWZvY3VzLWlubmVyLFxcbiAgICAgICAgICBbdHlwZT0ncmVzZXQnXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgICAgW3R5cGU9J3N1Ym1pdCddOjotbW96LWZvY3VzLWlubmVyIHtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdyYWRpbyddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdjaGVja2JveCddIHtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW5wdXRbdHlwZT0nZGF0ZSddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSd0aW1lJ10sXFxuICAgICAgICAgIGlucHV0W3R5cGU9J2RhdGV0aW1lLWxvY2FsJ10sXFxuICAgICAgICAgIGlucHV0W3R5cGU9J21vbnRoJ10ge1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbGlzdGJveDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0ZXh0YXJlYSB7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgICAgICAgICAgcmVzaXplOiB2ZXJ0aWNhbDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmaWVsZHNldCB7XFxuICAgICAgICAgICAgbWluLXdpZHRoOiAwO1xcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgICAgbWFyZ2luOiAwO1xcbiAgICAgICAgICAgIGJvcmRlcjogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBsZWdlbmQge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgIG1heC13aWR0aDogMTAwJTtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDhweDtcXG4gICAgICAgICAgICBmb250LXNpemU6IDI0cHg7XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICAgICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgICAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwcm9ncmVzcyB7XFxuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIFt0eXBlPSdudW1iZXInXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG4gICAgICAgICAgW3R5cGU9J251bWJlciddOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gICAgICAgICAgICBoZWlnaHQ6IGF1dG87XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3R5cGU9J3NlYXJjaCddIHtcXG4gICAgICAgICAgICBvdXRsaW5lLW9mZnNldDogLTJweDtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3R5cGU9J3NlYXJjaCddOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAgICAgICAgICAgZm9udDogaW5oZXJpdDtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvdXRwdXQge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdW1tYXJ5IHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRlbXBsYXRlIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIFtoaWRkZW5dIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIFwiXSkpKVxuICAgICAgICB9IH0pKTtcbn1cbmV4cG9ydHMuQ3NzUmVzZXQgPSBDc3NSZXNldDtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3NzUmVzZXQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICh7b25seUZpcnN0ID0gZmFsc2V9ID0ge30pID0+IHtcblx0Y29uc3QgcGF0dGVybiA9IFtcblx0XHQnW1xcXFx1MDAxQlxcXFx1MDA5Ql1bW1xcXFxdKCkjOz9dKig/Oig/Oig/OlthLXpBLVpcXFxcZF0qKD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKikqKT9cXFxcdTAwMDcpJyxcblx0XHQnKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1udHFyeT0+PH5dKSknXG5cdF0uam9pbignfCcpO1xuXG5cdHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIG9ubHlGaXJzdCA/IHVuZGVmaW5lZCA6ICdnJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgYW5zaVJlZ2V4ID0gcmVxdWlyZSgnYW5zaS1yZWdleCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZyA9PiB0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyA/IHN0cmluZy5yZXBsYWNlKGFuc2lSZWdleCgpLCAnJykgOiBzdHJpbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gVGhpcyBmaWxlIHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gYnkgQGRydWRydSAoaHR0cHM6Ly9naXRodWIuY29tL2RydWRydS9hbnNpX3VwKSwgTUlULCAyMDExXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBBTlNJX0NPTE9SUyA9IFtbeyBjb2xvcjogXCIwLCAwLCAwXCIsIFwiY2xhc3NcIjogXCJhbnNpLWJsYWNrXCIgfSwgeyBjb2xvcjogXCIxODcsIDAsIDBcIiwgXCJjbGFzc1wiOiBcImFuc2ktcmVkXCIgfSwgeyBjb2xvcjogXCIwLCAxODcsIDBcIiwgXCJjbGFzc1wiOiBcImFuc2ktZ3JlZW5cIiB9LCB7IGNvbG9yOiBcIjE4NywgMTg3LCAwXCIsIFwiY2xhc3NcIjogXCJhbnNpLXllbGxvd1wiIH0sIHsgY29sb3I6IFwiMCwgMCwgMTg3XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJsdWVcIiB9LCB7IGNvbG9yOiBcIjE4NywgMCwgMTg3XCIsIFwiY2xhc3NcIjogXCJhbnNpLW1hZ2VudGFcIiB9LCB7IGNvbG9yOiBcIjAsIDE4NywgMTg3XCIsIFwiY2xhc3NcIjogXCJhbnNpLWN5YW5cIiB9LCB7IGNvbG9yOiBcIjI1NSwyNTUsMjU1XCIsIFwiY2xhc3NcIjogXCJhbnNpLXdoaXRlXCIgfV0sIFt7IGNvbG9yOiBcIjg1LCA4NSwgODVcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LWJsYWNrXCIgfSwgeyBjb2xvcjogXCIyNTUsIDg1LCA4NVwiLCBcImNsYXNzXCI6IFwiYW5zaS1icmlnaHQtcmVkXCIgfSwgeyBjb2xvcjogXCIwLCAyNTUsIDBcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LWdyZWVuXCIgfSwgeyBjb2xvcjogXCIyNTUsIDI1NSwgODVcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LXllbGxvd1wiIH0sIHsgY29sb3I6IFwiODUsIDg1LCAyNTVcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LWJsdWVcIiB9LCB7IGNvbG9yOiBcIjI1NSwgODUsIDI1NVwiLCBcImNsYXNzXCI6IFwiYW5zaS1icmlnaHQtbWFnZW50YVwiIH0sIHsgY29sb3I6IFwiODUsIDI1NSwgMjU1XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC1jeWFuXCIgfSwgeyBjb2xvcjogXCIyNTUsIDI1NSwgMjU1XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC13aGl0ZVwiIH1dXTtcblxudmFyIEFuc2VyID0gZnVuY3Rpb24gKCkge1xuICAgIF9jcmVhdGVDbGFzcyhBbnNlciwgbnVsbCwgW3tcbiAgICAgICAga2V5OiBcImVzY2FwZUZvckh0bWxcIixcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbnNlci5lc2NhcGVGb3JIdG1sXG4gICAgICAgICAqIEVzY2FwZSB0aGUgaW5wdXQgSFRNTC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBkb2VzIHRoZSBtaW5pbXVtIGVzY2FwaW5nIG9mIHRleHQgdG8gbWFrZSBpdCBjb21wbGlhbnQgd2l0aCBIVE1MLlxuICAgICAgICAgKiBJbiBwYXJ0aWN1bGFyLCB0aGUgJyYnLCc8JywgYW5kICc+JyBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUaGlzIHNob3VsZFxuICAgICAgICAgKiBiZSBydW4gcHJpb3IgdG8gYGFuc2lUb0h0bWxgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBBbnNlci5lc2NhcGVGb3JIdG1sXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0IChjb250YWluaW5nIHRoZSBBTlNJIHNuaXBwZXRzKS5cbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGVzY2FwZWQgaHRtbC5cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlc2NhcGVGb3JIdG1sKHR4dCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbnNlcigpLmVzY2FwZUZvckh0bWwodHh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbnNlci5saW5raWZ5XG4gICAgICAgICAqIEFkZHMgdGhlIGxpbmtzIGluIHRoZSBIVE1MLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHJlcGxhY2VzIGFueSBsaW5rcyBpbiB0aGUgdGV4dCB3aXRoIGFuY2hvciB0YWdzIHRoYXQgZGlzcGxheSB0aGVcbiAgICAgICAgICogbGluay4gVGhlIGxpbmtzIHNob3VsZCBoYXZlIGF0IGxlYXN0IG9uZSB3aGl0ZXNwYWNlIGNoYXJhY3RlclxuICAgICAgICAgKiBzdXJyb3VuZGluZyBpdC4gQWxzbywgeW91IHNob3VsZCBhcHBseSB0aGlzIGFmdGVyIHlvdSBoYXZlIHJ1blxuICAgICAgICAgKiBgYW5zaVRvSHRtbGAgb24gdGhlIHRleHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIEFuc2VyLmxpbmtpZnlcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBIVE1MIGNvbnRhaW5pbmcgdGhlIDxhPiB0YWdzICh1bmVzY2FwZWQpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImxpbmtpZnlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmtpZnkodHh0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuc2VyKCkubGlua2lmeSh0eHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuc2VyLmFuc2lUb0h0bWxcbiAgICAgICAgICogVGhpcyByZXBsYWNlcyBBTlNJIHRlcm1pbmFsIGVzY2FwZSBjb2RlcyB3aXRoIFNQQU4gdGFncyB0aGF0IHdyYXAgdGhlXG4gICAgICAgICAqIGNvbnRlbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gb25seSBpbnRlcnByZXRzIEFOU0kgU0dSIChTZWxlY3QgR3JhcGhpYyBSZW5kaXRpb24pIGNvZGVzXG4gICAgICAgICAqIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGluIEhUTUwuXG4gICAgICAgICAqIEZvciBleGFtcGxlLCBjdXJzb3IgbW92ZW1lbnQgY29kZXMgYXJlIGlnbm9yZWQgYW5kIGhpZGRlbiBmcm9tIG91dHB1dC5cbiAgICAgICAgICogVGhlIGRlZmF1bHQgc3R5bGUgdXNlcyBjb2xvcnMgdGhhdCBhcmUgdmVyeSBjbG9zZSB0byB0aGUgcHJlc2NyaWJlZFxuICAgICAgICAgKiBzdGFuZGFyZC4gVGhlIHN0YW5kYXJkIGFzc3VtZXMgdGhhdCB0aGUgdGV4dCB3aWxsIGhhdmUgYSBibGFja1xuICAgICAgICAgKiBiYWNrZ3JvdW5kLiBUaGVzZSBjb2xvcnMgYXJlIHNldCBhcyBpbmxpbmUgc3R5bGVzIG9uIHRoZSBTUEFOIHRhZ3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFub3RoZXIgb3B0aW9uIGlzIHRvIHNldCBgdXNlX2NsYXNzZXM6IHRydWVgIGluIHRoZSBvcHRpb25zIGFyZ3VtZW50LlxuICAgICAgICAgKiBUaGlzIHdpbGwgaW5zdGVhZCBzZXQgY2xhc3NlcyBvbiB0aGUgc3BhbnMgc28gdGhlIGNvbG9ycyBjYW4gYmUgc2V0IHZpYVxuICAgICAgICAgKiBDU1MuIFRoZSBjbGFzcyBuYW1lcyB1c2VkIGFyZSBvZiB0aGUgZm9ybWF0IGBhbnNpLSotZmcvYmdgIGFuZFxuICAgICAgICAgKiBgYW5zaS1icmlnaHQtKi1mZy9iZ2Agd2hlcmUgYCpgIGlzIHRoZSBjb2xvciBuYW1lLFxuICAgICAgICAgKiBpLmUgYmxhY2svcmVkL2dyZWVuL3llbGxvdy9ibHVlL21hZ2VudGEvY3lhbi93aGl0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgQW5zZXIuYW5zaVRvSHRtbFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBhbnNpVG9IVE1MIG1ldGhvZC5cbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIEhUTUwgb3V0cHV0LlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFuc2lUb0h0bWxcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuc2lUb0h0bWwodHh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuc2VyKCkuYW5zaVRvSHRtbCh0eHQsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuc2VyLmFuc2lUb0pzb25cbiAgICAgICAgICogQ29udmVydHMgQU5TSSBpbnB1dCBpbnRvIEpTT04gb3V0cHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBBbnNlci5hbnNpVG9Kc29uXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIGFuc2lUb0hUTUwgbWV0aG9kLlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSFRNTCBvdXRwdXQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYW5zaVRvSnNvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5zaVRvSnNvbih0eHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5zZXIoKS5hbnNpVG9Kc29uKHR4dCwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQW5zZXIuYW5zaVRvVGV4dFxuICAgICAgICAgKiBDb252ZXJ0cyBBTlNJIGlucHV0IGludG8gdGV4dCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIEFuc2VyLmFuc2lUb1RleHRcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0ZXh0IG91dHB1dC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhbnNpVG9UZXh0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbnNpVG9UZXh0KHR4dCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbnNlcigpLmFuc2lUb1RleHQodHh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbnNlclxuICAgICAgICAgKiBUaGUgYEFuc2VyYCBjbGFzcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgQW5zZXJcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtBbnNlcn1cbiAgICAgICAgICovXG5cbiAgICB9XSk7XG5cbiAgICBmdW5jdGlvbiBBbnNlcigpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFuc2VyKTtcblxuICAgICAgICB0aGlzLmZnID0gdGhpcy5iZyA9IHRoaXMuZmdfdHJ1ZWNvbG9yID0gdGhpcy5iZ190cnVlY29sb3IgPSBudWxsO1xuICAgICAgICB0aGlzLmJyaWdodCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0dXBQYWxldHRlXG4gICAgICogU2V0cyB1cCB0aGUgcGFsZXR0ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHNldHVwUGFsZXR0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL1xuXG5cbiAgICBfY3JlYXRlQ2xhc3MoQW5zZXIsIFt7XG4gICAgICAgIGtleTogXCJzZXR1cFBhbGV0dGVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwUGFsZXR0ZSgpIHtcbiAgICAgICAgICAgIHRoaXMuUEFMRVRURV9DT0xPUlMgPSBbXTtcblxuICAgICAgICAgICAgLy8gSW5kZXggMC4uMTUgOiBTeXN0ZW0gY29sb3JcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5QQUxFVFRFX0NPTE9SUy5wdXNoKEFOU0lfQ09MT1JTW2ldW2pdLmNvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluZGV4IDE2Li4yMzEgOiBSR0IgNng2eDZcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2phc29ubTIzLzI4Njg5ODEjZmlsZS14dGVybS0yNTZjb2xvci15YW1sXG4gICAgICAgICAgICB2YXIgbGV2ZWxzID0gWzAsIDk1LCAxMzUsIDE3NSwgMjE1LCAyNTVdO1xuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChyLCBnLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxldmVsc1tyXSArIFwiLCBcIiArIGxldmVsc1tnXSArIFwiLCBcIiArIGxldmVsc1tiXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgciA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBnID0gdm9pZCAwLFxuICAgICAgICAgICAgICAgIGIgPSB2b2lkIDA7XG4gICAgICAgICAgICBmb3IgKHZhciBfciA9IDA7IF9yIDwgNjsgKytfcikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9nID0gMDsgX2cgPCA2OyArK19nKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMDsgX2IgPCA2OyArK19iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLlBBTEVUVEVfQ09MT1JTLnB1c2goZm9ybWF0KF9yLCBfZywgX2IpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW5kZXggMjMyLi4yNTUgOiBHcmF5c2NhbGVcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IDg7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgMjQ7ICsrX2ksIGxldmVsICs9IDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5QQUxFVFRFX0NPTE9SUy5wdXNoKGZvcm1hdChsZXZlbCwgbGV2ZWwsIGxldmVsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZXNjYXBlRm9ySHRtbFxuICAgICAgICAgKiBFc2NhcGVzIHRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBlc2NhcGVGb3JIdG1sXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZXNjcGFlZCBIVE1MIG91dHB1dC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJlc2NhcGVGb3JIdG1sXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlc2NhcGVGb3JIdG1sKHR4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHR4dC5yZXBsYWNlKC9bJjw+XS9nbSwgZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHIgPT0gXCImXCIgPyBcIiZhbXA7XCIgOiBzdHIgPT0gXCI8XCIgPyBcIiZsdDtcIiA6IHN0ciA9PSBcIj5cIiA/IFwiJmd0O1wiIDogXCJcIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGxpbmtpZnlcbiAgICAgICAgICogQWRkcyBIVE1MIGxpbmsgZWxlbWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIGxpbmtpZnlcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBIVE1MIG91dHB1dCBjb250YWluaW5nIGxpbmsgZWxlbWVudHMuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwibGlua2lmeVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGlua2lmeSh0eHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0eHQucmVwbGFjZSgvKGh0dHBzPzpcXC9cXC9bXlxcc10rKS9nbSwgZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIjxhIGhyZWY9XFxcIlwiICsgc3RyICsgXCJcXFwiPlwiICsgc3RyICsgXCI8L2E+XCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbnNpVG9IdG1sXG4gICAgICAgICAqIENvbnZlcnRzIEFOU0kgaW5wdXQgaW50byBIVE1MIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgYW5zaVRvSHRtbFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIG90IHRoZSBgcHJvY2Vzc2AgbWV0aG9kLlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSFRNTCBvdXRwdXQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYW5zaVRvSHRtbFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5zaVRvSHRtbCh0eHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3ModHh0LCBvcHRpb25zLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbnNpVG9Kc29uXG4gICAgICAgICAqIENvbnZlcnRzIEFOU0kgaW5wdXQgaW50byBIVE1MIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgYW5zaVRvSnNvblxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIG90IHRoZSBgcHJvY2Vzc2AgbWV0aG9kLlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSlNPTiBvdXRwdXQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYW5zaVRvSnNvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5zaVRvSnNvbih0eHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgb3B0aW9ucy5qc29uID0gdHJ1ZTtcbiAgICAgICAgICAgIG9wdGlvbnMuY2xlYXJMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzKHR4dCwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogYW5zaVRvVGV4dFxuICAgICAgICAgKiBDb252ZXJ0cyBBTlNJIGlucHV0IGludG8gSFRNTCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIGFuc2lUb1RleHRcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSB0ZXh0IG91dHB1dC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhbnNpVG9UZXh0XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbnNpVG9UZXh0KHR4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzcyh0eHQsIHt9LCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2Vzc1xuICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGlucHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBwcm9jZXNzXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgcGFzc2VkIHRvIGBwcm9jZXNzQ2h1bmtgIG1ldGhvZCwgZXh0ZW5kZWQgd2l0aDpcbiAgICAgICAgICpcbiAgICAgICAgICogIC0gYGpzb25gIChCb29sZWFuKTogSWYgYHRydWVgLCB0aGUgcmVzdWx0IHdpbGwgYmUgYW4gb2JqZWN0LlxuICAgICAgICAgKiAgLSBgdXNlX2NsYXNzZXNgIChCb29sZWFuKTogSWYgYHRydWVgLCBIVE1MIGNsYXNzZXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgSFRNTCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFya3VwXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwicHJvY2Vzc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzcyh0eHQsIG9wdGlvbnMsIG1hcmt1cCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHJhd190ZXh0X2NodW5rcyA9IHR4dC5zcGxpdCgvXFwwMzNcXFsvKTtcbiAgICAgICAgICAgIHZhciBmaXJzdF9jaHVuayA9IHJhd190ZXh0X2NodW5rcy5zaGlmdCgpOyAvLyB0aGUgZmlyc3QgY2h1bmsgaXMgbm90IHRoZSByZXN1bHQgb2YgdGhlIHNwbGl0XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMuY2xlYXJMaW5lID0gL1xcci8udGVzdCh0eHQpOyAvLyBjaGVjayBmb3IgQ2FycmlhZ2UgUmV0dXJuXG4gICAgICAgICAgICB2YXIgY29sb3JfY2h1bmtzID0gcmF3X3RleHRfY2h1bmtzLm1hcChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvY2Vzc0NodW5rKGNodW5rLCBvcHRpb25zLCBtYXJrdXApO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuanNvbikge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IHNlbGYucHJvY2Vzc0NodW5rSnNvbihcIlwiKTtcbiAgICAgICAgICAgICAgICBmaXJzdC5jb250ZW50ID0gZmlyc3RfY2h1bms7XG4gICAgICAgICAgICAgICAgZmlyc3QuY2xlYXJMaW5lID0gb3B0aW9ucy5jbGVhckxpbmU7XG4gICAgICAgICAgICAgICAgY29sb3JfY2h1bmtzLnVuc2hpZnQoZmlyc3QpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJlbW92ZV9lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcl9jaHVua3MgPSBjb2xvcl9jaHVua3MuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWMuaXNFbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbG9yX2NodW5rcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sb3JfY2h1bmtzLnVuc2hpZnQoZmlyc3RfY2h1bmspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY29sb3JfY2h1bmtzLmpvaW4oXCJcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2Vzc0NodW5rSnNvblxuICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGN1cnJlbnQgY2h1bmsgaW50byBqc29uIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgcHJvY2Vzc0NodW5rSnNvblxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgLSBganNvbmAgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIHRoZSByZXN1bHQgd2lsbCBiZSBhbiBvYmplY3QuXG4gICAgICAgICAqICAtIGB1c2VfY2xhc3Nlc2AgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIEhUTUwgY2xhc3NlcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBIVE1MIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBtYXJrdXAgSWYgZmFsc2UsIHRoZSBjb2xvcnMgd2lsbCBub3QgYmUgcGFyc2VkLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHQgb2JqZWN0OlxuICAgICAgICAgKlxuICAgICAgICAgKiAgLSBgY29udGVudGAgKFN0cmluZyk6IFRoZSB0ZXh0LlxuICAgICAgICAgKiAgLSBgZmdgIChTdHJpbmd8bnVsbCk6IFRoZSBmb3JlZ3JvdW5kIGNvbG9yLlxuICAgICAgICAgKiAgLSBgYmdgIChTdHJpbmd8bnVsbCk6IFRoZSBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgICAgICAgKiAgLSBgZmdfdHJ1ZWNvbG9yYCAoU3RyaW5nfG51bGwpOiBUaGUgZm9yZWdyb3VuZCB0cnVlIGNvbG9yIChpZiAxNm0gY29sb3IgaXMgZW5hYmxlZCkuXG4gICAgICAgICAqICAtIGBiZ190cnVlY29sb3JgIChTdHJpbmd8bnVsbCk6IFRoZSBiYWNrZ3JvdW5kIHRydWUgY29sb3IgKGlmIDE2bSBjb2xvciBpcyBlbmFibGVkKS5cbiAgICAgICAgICogIC0gYGNsZWFyTGluZWAgKEJvb2xlYW4pOiBgdHJ1ZWAgaWYgYSBjYXJyaWFnZVJldHVybiBcXHIgd2FzIGZvdW50IGF0IGVuZCBvZiBsaW5lLlxuICAgICAgICAgKiAgLSBgd2FzX3Byb2Nlc3NlZGAgKEJvbGVhbik6IGB0cnVlYCBpZiB0aGUgY29sb3JzIHdlcmUgcHJvY2Vzc2VkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgICAgICogIC0gYGlzRW1wdHlgIChGdW5jdGlvbik6IEEgZnVuY3Rpb24gcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgY29udGVudCBpcyBlbXB0eSwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwicHJvY2Vzc0NodW5rSnNvblwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0NodW5rSnNvbih0ZXh0LCBvcHRpb25zLCBtYXJrdXApIHtcblxuICAgICAgICAgICAgLy8gQXJlIHdlIHVzaW5nIGNsYXNzZXMgb3Igc3R5bGVzP1xuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09IFwidW5kZWZpbmVkXCIgPyB7fSA6IG9wdGlvbnM7XG4gICAgICAgICAgICB2YXIgdXNlX2NsYXNzZXMgPSBvcHRpb25zLnVzZV9jbGFzc2VzID0gdHlwZW9mIG9wdGlvbnMudXNlX2NsYXNzZXMgIT0gXCJ1bmRlZmluZWRcIiAmJiBvcHRpb25zLnVzZV9jbGFzc2VzO1xuICAgICAgICAgICAgdmFyIGtleSA9IG9wdGlvbnMua2V5ID0gdXNlX2NsYXNzZXMgPyBcImNsYXNzXCIgOiBcImNvbG9yXCI7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgY29udGVudDogdGV4dCxcbiAgICAgICAgICAgICAgICBmZzogbnVsbCxcbiAgICAgICAgICAgICAgICBiZzogbnVsbCxcbiAgICAgICAgICAgICAgICBmZ190cnVlY29sb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgYmdfdHJ1ZWNvbG9yOiBudWxsLFxuICAgICAgICAgICAgICAgIGNsZWFyTGluZTogb3B0aW9ucy5jbGVhckxpbmUsXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICB3YXNfcHJvY2Vzc2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXJlc3VsdC5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEVhY2ggXCJjaHVua1wiIGlzIHRoZSB0ZXh0IGFmdGVyIHRoZSBDU0kgKEVTQyArIFwiW1wiKSBhbmQgYmVmb3JlIHRoZSBuZXh0IENTSS9FT0YuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhpcyByZWdleCBtYXRjaGVzIGZvdXIgZ3JvdXBzIHdpdGhpbiBhIGNodW5rLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBhbmQgdGhpcmQgZ3JvdXBzIG1hdGNoIGNvZGUgdHlwZS5cbiAgICAgICAgICAgIC8vIFdlIHN1cHBvcnRlZCBvbmx5IFNHUiBjb21tYW5kLiBJdCBoYXMgZW1wdHkgZmlyc3QgZ3JvdXAgYW5kIFwibVwiIGluIHRoaXJkLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoZSBzZWNvbmQgZ3JvdXAgbWF0Y2hlcyBhbGwgb2YgdGhlIG51bWJlcitzZW1pY29sb24gY29tbWFuZCBzZXF1ZW5jZXNcbiAgICAgICAgICAgIC8vIGJlZm9yZSB0aGUgXCJtXCIgKG9yIG90aGVyIHRyYWlsaW5nKSBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgdGhlIGdyYXBoaWNzIG9yIFNHUiBjb21tYW5kcy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgbGFzdCBncm91cCBpcyB0aGUgdGV4dCAoaW5jbHVkaW5nIG5ld2xpbmVzKSB0aGF0IGlzIGNvbG9yZWQgYnlcbiAgICAgICAgICAgIC8vIHRoZSBvdGhlciBncm91cFwicyBjb21tYW5kcy5cbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gdGV4dC5tYXRjaCgvXihbIVxceDNjLVxceDNmXSopKFtcXGQ7XSopKFtcXHgyMC1cXHgyY10qW1xceDQwLVxceDdlXSkoW1xcc1xcU10qKS9tKTtcblxuICAgICAgICAgICAgaWYgKCFtYXRjaGVzKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgICAgICB2YXIgb3JpZ190eHQgPSByZXN1bHQuY29udGVudCA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgICB2YXIgbnVtcyA9IG1hdGNoZXNbMl0uc3BsaXQoXCI7XCIpO1xuXG4gICAgICAgICAgICAvLyBXZSBjdXJyZW50bHkgc3VwcG9ydCBvbmx5IFwiU0dSXCIgKFNlbGVjdCBHcmFwaGljIFJlbmRpdGlvbilcbiAgICAgICAgICAgIC8vIFNpbXBseSBpZ25vcmUgaWYgbm90IGEgU0dSIGNvbW1hbmQuXG4gICAgICAgICAgICBpZiAobWF0Y2hlc1sxXSAhPT0gXCJcIiB8fCBtYXRjaGVzWzNdICE9PSBcIm1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbWFya3VwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBudWxsO1xuXG4gICAgICAgICAgICB3aGlsZSAobnVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG51bV9zdHIgPSBudW1zLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdmFyIG51bSA9IHBhcnNlSW50KG51bV9zdHIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKG51bSkgfHwgbnVtID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBzZWxmLmJnID0gc2VsZi5kZWNvcmF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBcImJvbGRcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBcImRpbVwiO1xuICAgICAgICAgICAgICAgICAgICAvLyBFbmFibGUgY29kZSAyIHRvIGdldCBzdHJpbmdcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbiA9IFwiaXRhbGljXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBcInVuZGVybGluZVwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9uID0gXCJibGlua1wiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSA3KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbiA9IFwicmV2ZXJzZVwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbiA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuYWJsZSBjb2RlIDkgdG8gZ2V0IHN0cmlrZXRocm91Z2hcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gOSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBcInN0cmlrZXRocm91Z2hcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PSAzOSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PSA0OSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmJnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yZWdyb3VuZCBjb2xvclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID49IDMwICYmIG51bSA8IDM4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBBTlNJX0NPTE9SU1swXVtudW0gJSAxMF1ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yZWdyb3VuZCBicmlnaHQgY29sb3JcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSA5MCAmJiBudW0gPCA5OCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0gQU5TSV9DT0xPUlNbMV1bbnVtICUgMTBdW2tleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIEJhY2tncm91bmQgY29sb3JcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSA0MCAmJiBudW0gPCA0OCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmJnID0gQU5TSV9DT0xPUlNbMF1bbnVtICUgMTBdW2tleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIEJhY2tncm91bmQgYnJpZ2h0IGNvbG9yXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPj0gMTAwICYmIG51bSA8IDEwOCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmJnID0gQU5TSV9DT0xPUlNbMV1bbnVtICUgMTBdW2tleV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDM4IHx8IG51bSA9PT0gNDgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXh0ZW5kIGNvbG9yICgzOD1mZywgNDg9YmcpXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc19mb3JlZ3JvdW5kID0gbnVtID09PSAzODtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bXMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2RlID0gbnVtcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwiNVwiICYmIG51bXMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYWxldHRlIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhbGV0dGVfaW5kZXggPSBwYXJzZUludChudW1zLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWxldHRlX2luZGV4ID49IDAgJiYgcGFsZXR0ZV9pbmRleCA8PSAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VfY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLlBBTEVUVEVfQ09MT1JTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZXR1cFBhbGV0dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19mb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IHRoaXMuUEFMRVRURV9DT0xPUlNbcGFsZXR0ZV9pbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSB0aGlzLlBBTEVUVEVfQ09MT1JTW3BhbGV0dGVfaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtsYXNzID0gcGFsZXR0ZV9pbmRleCA+PSAxNiA/IFwiYW5zaS1wYWxldHRlLVwiICsgcGFsZXR0ZV9pbmRleCA6IEFOU0lfQ09MT1JTW3BhbGV0dGVfaW5kZXggPiA3ID8gMSA6IDBdW3BhbGV0dGVfaW5kZXggJSA4XVtcImNsYXNzXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2ZvcmVncm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0ga2xhc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBrbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gXCIyXCIgJiYgbnVtcy5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHBhcnNlSW50KG51bXMuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGcgPSBwYXJzZUludChudW1zLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gcGFyc2VJbnQobnVtcy5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAociA+PSAwICYmIHIgPD0gMjU1ICYmIGcgPj0gMCAmJiBnIDw9IDI1NSAmJiBiID49IDAgJiYgYiA8PSAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gciArIFwiLCBcIiArIGcgKyBcIiwgXCIgKyBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZV9jbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZm9yZWdyb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5iZyA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2ZvcmVncm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0gXCJhbnNpLXRydWVjb2xvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmdfdHJ1ZWNvbG9yID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBcImFuc2ktdHJ1ZWNvbG9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5iZ190cnVlY29sb3IgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGYuZmcgPT09IG51bGwgJiYgc2VsZi5iZyA9PT0gbnVsbCAmJiBzZWxmLmRlY29yYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0LmZnID0gc2VsZi5mZztcbiAgICAgICAgICAgICAgICByZXN1bHQuYmcgPSBzZWxmLmJnO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5mZ190cnVlY29sb3IgPSBzZWxmLmZnX3RydWVjb2xvcjtcbiAgICAgICAgICAgICAgICByZXN1bHQuYmdfdHJ1ZWNvbG9yID0gc2VsZi5iZ190cnVlY29sb3I7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRlY29yYXRpb24gPSBzZWxmLmRlY29yYXRpb247XG4gICAgICAgICAgICAgICAgcmVzdWx0Lndhc19wcm9jZXNzZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9jZXNzQ2h1bmtcbiAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBjdXJyZW50IGNodW5rIG9mIHRleHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIHByb2Nlc3NDaHVua1xuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgLSBganNvbmAgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIHRoZSByZXN1bHQgd2lsbCBiZSBhbiBvYmplY3QuXG4gICAgICAgICAqICAtIGB1c2VfY2xhc3Nlc2AgKEJvb2xlYW4pOiBJZiBgdHJ1ZWAsIEhUTUwgY2xhc3NlcyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBIVE1MIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSBtYXJrdXAgSWYgZmFsc2UsIHRoZSBjb2xvcnMgd2lsbCBub3QgYmUgcGFyc2VkLlxuICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R8U3RyaW5nfSBUaGUgcmVzdWx0IChvYmplY3QgaWYgYGpzb25gIGlzIHdhbnRlZCBiYWNrIG9yIHN0cmluZyBvdGhlcndpc2UpLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInByb2Nlc3NDaHVua1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc0NodW5rKHRleHQsIG9wdGlvbnMsIG1hcmt1cCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgdmFyIGpzb25DaHVuayA9IHRoaXMucHJvY2Vzc0NodW5rSnNvbih0ZXh0LCBvcHRpb25zLCBtYXJrdXApO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5qc29uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25DaHVuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWpzb25DaHVuay53YXNfcHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25DaHVuay5jb250ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdXNlX2NsYXNzZXMgPSBvcHRpb25zLnVzZV9jbGFzc2VzO1xuXG4gICAgICAgICAgICB2YXIgc3R5bGVzID0gW107XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgICAgIHZhciByZW5kZXJfZGF0YSA9IGZ1bmN0aW9uIHJlbmRlcl9kYXRhKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50cy5wdXNoKFwiZGF0YS1cIiArIGtleSArIFwiPVxcXCJcIiArIF90aGlzMi5lc2NhcGVGb3JIdG1sKGRhdGFba2V5XSkgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50cy5sZW5ndGggPiAwID8gXCIgXCIgKyBmcmFnbWVudHMuam9pbihcIiBcIikgOiBcIlwiO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGpzb25DaHVuay5mZykge1xuICAgICAgICAgICAgICAgIGlmICh1c2VfY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goanNvbkNodW5rLmZnICsgXCItZmdcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuZmdfdHJ1ZWNvbG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW1wiYW5zaS10cnVlY29sb3ItZmdcIl0gPSBqc29uQ2h1bmsuZmdfdHJ1ZWNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbkNodW5rLmZnX3RydWVjb2xvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChcImNvbG9yOnJnYihcIiArIGpzb25DaHVuay5mZyArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuYmcpIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlX2NsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGpzb25DaHVuay5iZyArIFwiLWJnXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbkNodW5rLmJnX3RydWVjb2xvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtcImFuc2ktdHJ1ZWNvbG9yLWJnXCJdID0ganNvbkNodW5rLmJnX3RydWVjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25DaHVuay5iZ190cnVlY29sb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goXCJiYWNrZ3JvdW5kLWNvbG9yOnJnYihcIiArIGpzb25DaHVuay5iZyArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuZGVjb3JhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICh1c2VfY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goXCJhbnNpLVwiICsganNvbkNodW5rLmRlY29yYXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoanNvbkNodW5rLmRlY29yYXRpb24gPT09IFwiYm9sZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwiZm9udC13ZWlnaHQ6Ym9sZFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpzb25DaHVuay5kZWNvcmF0aW9uID09PSBcImRpbVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwib3BhY2l0eTowLjVcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqc29uQ2h1bmsuZGVjb3JhdGlvbiA9PT0gXCJpdGFsaWNcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChcImZvbnQtc3R5bGU6aXRhbGljXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyB1bmRlcmxpbmUgYW5kIGJsaW5rIGFyZSB0cmVhdGVkIGJlbGxvd1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoanNvbkNodW5rLmRlY29yYXRpb24gPT09IFwicmV2ZXJzZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwiZmlsdGVyOmludmVydCgxMDAlKVwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpzb25DaHVuay5kZWNvcmF0aW9uID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwidmlzaWJpbGl0eTpoaWRkZW5cIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqc29uQ2h1bmsuZGVjb3JhdGlvbiA9PT0gXCJzdHJpa2V0aHJvdWdoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goXCJ0ZXh0LWRlY29yYXRpb246bGluZS10aHJvdWdoXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwidGV4dC1kZWNvcmF0aW9uOlwiICsganNvbkNodW5rLmRlY29yYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHVzZV9jbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiPHNwYW4gY2xhc3M9XFxcIlwiICsgY2xhc3Nlcy5qb2luKFwiIFwiKSArIFwiXFxcIlwiICsgcmVuZGVyX2RhdGEoZGF0YSkgKyBcIj5cIiArIGpzb25DaHVuay5jb250ZW50ICsgXCI8L3NwYW4+XCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIjxzcGFuIHN0eWxlPVxcXCJcIiArIHN0eWxlcy5qb2luKFwiO1wiKSArIFwiXFxcIlwiICsgcmVuZGVyX2RhdGEoZGF0YSkgKyBcIj5cIiArIGpzb25DaHVuay5jb250ZW50ICsgXCI8L3NwYW4+XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQW5zZXI7XG59KCk7XG5cbjtcblxubW9kdWxlLmV4cG9ydHMgPSBBbnNlcjsiLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL2Nzc2VzY2FwZSB2MS41LjEgYnkgQG1hdGhpYXMgfCBNSVQgbGljZW5zZSAqL1xuOyhmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91bWRqcy91bWQvYmxvYi9tYXN0ZXIvcmV0dXJuRXhwb3J0cy5qc1xuXHRpZiAodHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcpIHtcblx0XHQvLyBGb3IgTm9kZS5qcy5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnkocm9vdCk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyBGb3IgQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZShbXSwgZmFjdG9yeS5iaW5kKHJvb3QsIHJvb3QpKTtcblx0fSBlbHNlIHtcblx0XHQvLyBGb3IgYnJvd3NlciBnbG9iYWxzIChub3QgZXhwb3NpbmcgdGhlIGZ1bmN0aW9uIHNlcGFyYXRlbHkpLlxuXHRcdGZhY3Rvcnkocm9vdCk7XG5cdH1cbn0odHlwZW9mIGdsb2JhbCAhPSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHRoaXMsIGZ1bmN0aW9uKHJvb3QpIHtcblxuXHRpZiAocm9vdC5DU1MgJiYgcm9vdC5DU1MuZXNjYXBlKSB7XG5cdFx0cmV0dXJuIHJvb3QuQ1NTLmVzY2FwZTtcblx0fVxuXG5cdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jc2VyaWFsaXplLWFuLWlkZW50aWZpZXJcblx0dmFyIGNzc0VzY2FwZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignYENTUy5lc2NhcGVgIHJlcXVpcmVzIGFuIGFyZ3VtZW50LicpO1xuXHRcdH1cblx0XHR2YXIgc3RyaW5nID0gU3RyaW5nKHZhbHVlKTtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgY29kZVVuaXQ7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdHZhciBmaXJzdENvZGVVbml0ID0gc3RyaW5nLmNoYXJDb2RlQXQoMCk7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGNvZGVVbml0ID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuXHRcdFx0Ly8gTm90ZTogdGhlcmXigJlzIG5vIG5lZWQgdG8gc3BlY2lhbC1jYXNlIGFzdHJhbCBzeW1ib2xzLCBzdXJyb2dhdGVcblx0XHRcdC8vIHBhaXJzLCBvciBsb25lIHN1cnJvZ2F0ZXMuXG5cblx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgTlVMTCAoVSswMDAwKSwgdGhlbiB0aGUgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHQvLyAoVStGRkZEKS5cblx0XHRcdGlmIChjb2RlVW5pdCA9PSAweDAwMDApIHtcblx0XHRcdFx0cmVzdWx0ICs9ICdcXHVGRkZEJztcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyBpbiB0aGUgcmFuZ2UgW1xcMS1cXDFGXSAoVSswMDAxIHRvIFUrMDAxRikgb3IgaXNcblx0XHRcdFx0Ly8gVSswMDdGLCBb4oCmXVxuXHRcdFx0XHQoY29kZVVuaXQgPj0gMHgwMDAxICYmIGNvZGVVbml0IDw9IDB4MDAxRikgfHwgY29kZVVuaXQgPT0gMHgwMDdGIHx8XG5cdFx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXMgaW4gdGhlIHJhbmdlIFswLTldXG5cdFx0XHRcdC8vIChVKzAwMzAgdG8gVSswMDM5KSwgW+KApl1cblx0XHRcdFx0KGluZGV4ID09IDAgJiYgY29kZVVuaXQgPj0gMHgwMDMwICYmIGNvZGVVbml0IDw9IDB4MDAzOSkgfHxcblx0XHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyB0aGUgc2Vjb25kIGNoYXJhY3RlciBhbmQgaXMgaW4gdGhlIHJhbmdlIFswLTldXG5cdFx0XHRcdC8vIChVKzAwMzAgdG8gVSswMDM5KSBhbmQgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBhIGAtYCAoVSswMDJEKSwgW+KApl1cblx0XHRcdFx0KFxuXHRcdFx0XHRcdGluZGV4ID09IDEgJiZcblx0XHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwMzAgJiYgY29kZVVuaXQgPD0gMHgwMDM5ICYmXG5cdFx0XHRcdFx0Zmlyc3RDb2RlVW5pdCA9PSAweDAwMkRcblx0XHRcdFx0KVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jZXNjYXBlLWEtY2hhcmFjdGVyLWFzLWNvZGUtcG9pbnRcblx0XHRcdFx0cmVzdWx0ICs9ICdcXFxcJyArIGNvZGVVbml0LnRvU3RyaW5nKDE2KSArICcgJztcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpcyBhIGAtYCAoVSswMDJEKSwgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIG5vIHNlY29uZCBjaGFyYWN0ZXIsIFvigKZdXG5cdFx0XHRcdGluZGV4ID09IDAgJiZcblx0XHRcdFx0bGVuZ3RoID09IDEgJiZcblx0XHRcdFx0Y29kZVVuaXQgPT0gMHgwMDJEXG5cdFx0XHQpIHtcblx0XHRcdFx0cmVzdWx0ICs9ICdcXFxcJyArIHN0cmluZy5jaGFyQXQoaW5kZXgpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIGNoYXJhY3RlciBpcyBub3QgaGFuZGxlZCBieSBvbmUgb2YgdGhlIGFib3ZlIHJ1bGVzIGFuZCBpc1xuXHRcdFx0Ly8gZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIFUrMDA4MCwgaXMgYC1gIChVKzAwMkQpIG9yIGBfYCAoVSswMDVGKSwgb3Jcblx0XHRcdC8vIGlzIGluIG9uZSBvZiB0aGUgcmFuZ2VzIFswLTldIChVKzAwMzAgdG8gVSswMDM5KSwgW0EtWl0gKFUrMDA0MSB0b1xuXHRcdFx0Ly8gVSswMDVBKSwgb3IgW2Etel0gKFUrMDA2MSB0byBVKzAwN0EpLCBb4oCmXVxuXHRcdFx0aWYgKFxuXHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwODAgfHxcblx0XHRcdFx0Y29kZVVuaXQgPT0gMHgwMDJEIHx8XG5cdFx0XHRcdGNvZGVVbml0ID09IDB4MDA1RiB8fFxuXHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwMzAgJiYgY29kZVVuaXQgPD0gMHgwMDM5IHx8XG5cdFx0XHRcdGNvZGVVbml0ID49IDB4MDA0MSAmJiBjb2RlVW5pdCA8PSAweDAwNUEgfHxcblx0XHRcdFx0Y29kZVVuaXQgPj0gMHgwMDYxICYmIGNvZGVVbml0IDw9IDB4MDA3QVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIHRoZSBjaGFyYWN0ZXIgaXRzZWxmXG5cdFx0XHRcdHJlc3VsdCArPSBzdHJpbmcuY2hhckF0KGluZGV4KTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE90aGVyd2lzZSwgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuXHRcdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNlc2NhcGUtYS1jaGFyYWN0ZXJcblx0XHRcdHJlc3VsdCArPSAnXFxcXCcgKyBzdHJpbmcuY2hhckF0KGluZGV4KTtcblxuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGlmICghcm9vdC5DU1MpIHtcblx0XHRyb290LkNTUyA9IHt9O1xuXHR9XG5cblx0cm9vdC5DU1MuZXNjYXBlID0gY3NzRXNjYXBlO1xuXHRyZXR1cm4gY3NzRXNjYXBlO1xuXG59KSk7XG4iLCJpbXBvcnQgeyBXb3JrYm94IH0gZnJvbSAnd29ya2JveC13aW5kb3cnXG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yKSB7XG4gIHdpbmRvdy53b3JrYm94ID0gbmV3IFdvcmtib3goX19QV0FfU1dfXywgeyBzY29wZTogX19QV0FfU0NPUEVfXyB9KVxuICBcbiAgd2luZG93Lndvcmtib3guYWRkRXZlbnRMaXN0ZW5lcignYWN0aXZhdGVkJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LmlzVXBkYXRlKSB7XG4gICAgICBjYWNoZXMua2V5cygpLnRoZW4oZnVuY3Rpb24oYykge1xuICAgICAgICBpZiAoIWMuaW5jbHVkZXMoJ3N0YXJ0LXVybCcpKSB7XG4gICAgICAgICAgZmV0Y2goX19QV0FfU1RBUlRfVVJMX18pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIGlmKF9fUFdBX0VOQUJMRV9SRUdJU1RFUl9fKSB7XG4gICAgd2luZG93Lndvcmtib3gucmVnaXN0ZXIoKVxuICB9XG59XG4iLCJpbXBvcnQgeyBnZXRFdmVudFNvdXJjZVdyYXBwZXIgfSBmcm9tICcuL2Vycm9yLW92ZXJsYXkvZXZlbnRzb3VyY2UnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluaXRpYWxpemVCdWlsZFdhdGNoZXIodG9nZ2xlQ2FsbGJhY2spIHtcbiAgY29uc3Qgc2hhZG93SG9zdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIHNoYWRvd0hvc3QuaWQgPSAnX19uZXh0LWJ1aWxkLXdhdGNoZXInXG4gIC8vIE1ha2Ugc3VyZSBjb250YWluZXIgaXMgZml4ZWQgYW5kIG9uIGEgaGlnaCB6SW5kZXggc28gaXQgc2hvd3NcbiAgc2hhZG93SG9zdC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCdcbiAgc2hhZG93SG9zdC5zdHlsZS5ib3R0b20gPSAnMTBweCdcbiAgc2hhZG93SG9zdC5zdHlsZS5yaWdodCA9ICcyMHB4J1xuICBzaGFkb3dIb3N0LnN0eWxlLndpZHRoID0gMFxuICBzaGFkb3dIb3N0LnN0eWxlLmhlaWdodCA9IDBcbiAgc2hhZG93SG9zdC5zdHlsZS56SW5kZXggPSA5OTk5OVxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNoYWRvd0hvc3QpXG5cbiAgbGV0IHNoYWRvd1Jvb3RcbiAgbGV0IHByZWZpeCA9ICcnXG5cbiAgaWYgKHNoYWRvd0hvc3QuYXR0YWNoU2hhZG93KSB7XG4gICAgc2hhZG93Um9vdCA9IHNoYWRvd0hvc3QuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYXR0YWNoU2hhZG93IGlzIHVuZGVmaW5lZCB0aGVuIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnRcbiAgICAvLyB0aGUgU2hhZG93IERPTSwgd2UgbmVlZCB0byBwcmVmaXggYWxsIHRoZSBuYW1lcyBzbyB0aGVyZVxuICAgIC8vIHdpbGwgYmUgbm8gY29uZmxpY3RzXG4gICAgc2hhZG93Um9vdCA9IHNoYWRvd0hvc3RcbiAgICBwcmVmaXggPSAnX19uZXh0LWJ1aWxkLXdhdGNoZXItJ1xuICB9XG5cbiAgLy8gQ29udGFpbmVyXG4gIGNvbnN0IGNvbnRhaW5lciA9IGNyZWF0ZUNvbnRhaW5lcihwcmVmaXgpXG4gIHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoY29udGFpbmVyKVxuXG4gIC8vIENTU1xuICBjb25zdCBjc3MgPSBjcmVhdGVDc3MocHJlZml4KVxuICBzaGFkb3dSb290LmFwcGVuZENoaWxkKGNzcylcblxuICAvLyBTdGF0ZVxuICBsZXQgaXNWaXNpYmxlID0gZmFsc2VcbiAgbGV0IGlzQnVpbGRpbmcgPSBmYWxzZVxuICBsZXQgdGltZW91dElkID0gbnVsbFxuXG4gIC8vIEhhbmRsZSBldmVudHNcbiAgY29uc3QgZXZ0U291cmNlID0gZ2V0RXZlbnRTb3VyY2VXcmFwcGVyKHsgcGF0aDogJy9fbmV4dC93ZWJwYWNrLWhtcicgfSlcbiAgZXZ0U291cmNlLmFkZE1lc3NhZ2VMaXN0ZW5lcigoZXZlbnQpID0+IHtcbiAgICAvLyBUaGlzIGlzIHRoZSBoZWFydGJlYXQgZXZlbnRcbiAgICBpZiAoZXZlbnQuZGF0YSA9PT0gJ1xcdUQ4M0RcXHVEQzkzJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGhhbmRsZU1lc3NhZ2UoZXZlbnQpXG4gICAgfSBjYXRjaCB7fVxuICB9KVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1lc3NhZ2UoZXZlbnQpIHtcbiAgICBjb25zdCBvYmogPVxuICAgICAgdHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJyA/IHsgYWN0aW9uOiBldmVudCB9IDogSlNPTi5wYXJzZShldmVudC5kYXRhKVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgIHN3aXRjaCAob2JqLmFjdGlvbikge1xuICAgICAgY2FzZSAnYnVpbGRpbmcnOlxuICAgICAgICB0aW1lb3V0SWQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICAgICAgaXNWaXNpYmxlID0gdHJ1ZVxuICAgICAgICBpc0J1aWxkaW5nID0gdHJ1ZVxuICAgICAgICB1cGRhdGVDb250YWluZXIoKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnYnVpbHQnOlxuICAgICAgY2FzZSAnc3luYyc6XG4gICAgICAgIGlzQnVpbGRpbmcgPSBmYWxzZVxuICAgICAgICAvLyBXYWl0IGZvciB0aGUgZmFkZSBvdXQgdHJhbnN0aW9uIHRvIGNvbXBsZXRlXG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlzVmlzaWJsZSA9IGZhbHNlXG4gICAgICAgICAgdXBkYXRlQ29udGFpbmVyKClcbiAgICAgICAgfSwgMTAwKVxuICAgICAgICB1cGRhdGVDb250YWluZXIoKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIHRvZ2dsZUNhbGxiYWNrKGhhbmRsZU1lc3NhZ2UpXG5cbiAgZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKCkge1xuICAgIGlmIChpc0J1aWxkaW5nKSB7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChgJHtwcmVmaXh9YnVpbGRpbmdgKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShgJHtwcmVmaXh9YnVpbGRpbmdgKVxuICAgIH1cblxuICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGAke3ByZWZpeH12aXNpYmxlYClcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoYCR7cHJlZml4fXZpc2libGVgKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIocHJlZml4KSB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGNvbnRhaW5lci5pZCA9IGAke3ByZWZpeH1jb250YWluZXJgXG4gIGNvbnRhaW5lci5pbm5lckhUTUwgPSBgXG4gICAgPGRpdiBpZD1cIiR7cHJlZml4fWljb24td3JhcHBlclwiPlxuICAgICAgPHN2ZyB2aWV3Qm94PVwiMCAwIDIyNiAyMDBcIj5cbiAgICAgICAgPGRlZnM+XG4gICAgICAgICAgPGxpbmVhckdyYWRpZW50XG4gICAgICAgICAgICB4MT1cIjExNC43MjA3NzUlXCJcbiAgICAgICAgICAgIHkxPVwiMTgxLjI4MzI0NSVcIlxuICAgICAgICAgICAgeDI9XCIzOS41Mzk5MzA2JVwiXG4gICAgICAgICAgICB5Mj1cIjEwMCVcIlxuICAgICAgICAgICAgaWQ9XCIke3ByZWZpeH1saW5lYXItZ3JhZGllbnRcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxzdG9wIHN0b3AtY29sb3I9XCIjMDAwMDAwXCIgb2Zmc2V0PVwiMCVcIiAvPlxuICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cIiNGRkZGRkZcIiBvZmZzZXQ9XCIxMDAlXCIgLz5cbiAgICAgICAgICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgICA8L2RlZnM+XG4gICAgICAgIDxnIGlkPVwiJHtwcmVmaXh9aWNvbi1ncm91cFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwidXJsKCMke3ByZWZpeH1saW5lYXItZ3JhZGllbnQpXCIgc3Ryb2tlLXdpZHRoPVwiMThcIj5cbiAgICAgICAgICA8cGF0aCBkPVwiTTExMyw1LjA4MjE5MTE3IEw0LjI4MzkzODAxLDE5Ny41IEwyMjEuNzE2MDYyLDE5Ny41IEwxMTMsNS4wODIxOTExNyBaXCIgLz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gIGBcblxuICByZXR1cm4gY29udGFpbmVyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNzcyhwcmVmaXgpIHtcbiAgY29uc3QgY3NzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBjc3MudGV4dENvbnRlbnQgPSBgXG4gICAgIyR7cHJlZml4fWNvbnRhaW5lciB7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBib3R0b206IDEwcHg7XG4gICAgICByaWdodDogMzBweDtcblxuICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgICAgYmFja2dyb3VuZDogIzAwMDtcbiAgICAgIGNvbG9yOiAjZmZmO1xuICAgICAgZm9udDogaW5pdGlhbDtcbiAgICAgIGN1cnNvcjogaW5pdGlhbDtcbiAgICAgIGxldHRlci1zcGFjaW5nOiBpbml0aWFsO1xuICAgICAgdGV4dC1zaGFkb3c6IGluaXRpYWw7XG4gICAgICB0ZXh0LXRyYW5zZm9ybTogaW5pdGlhbDtcbiAgICAgIHZpc2liaWxpdHk6IGluaXRpYWw7XG5cbiAgICAgIHBhZGRpbmc6IDdweCAxMHB4IDhweCAxMHB4O1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGJveC1zaGFkb3c6IDAgMTFweCA0MHB4IDAgcmdiYSgwLCAwLCAwLCAwLjI1KSwgMCAycHggMTBweCAwIHJnYmEoMCwgMCwgMCwgMC4xMik7XG5cbiAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICBvcGFjaXR5OiAwO1xuICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzIGVhc2UsIGJvdHRvbSAwLjFzIGVhc2U7XG4gICAgICBhbmltYXRpb246ICR7cHJlZml4fWZhZGUtaW4gMC4xcyBlYXNlLWluLW91dDtcbiAgICB9XG5cbiAgICAjJHtwcmVmaXh9Y29udGFpbmVyLiR7cHJlZml4fXZpc2libGUge1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICB9XG5cbiAgICAjJHtwcmVmaXh9Y29udGFpbmVyLiR7cHJlZml4fWJ1aWxkaW5nIHtcbiAgICAgIGJvdHRvbTogMjBweDtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgfVxuXG4gICAgIyR7cHJlZml4fWljb24td3JhcHBlciB7XG4gICAgICB3aWR0aDogMTZweDtcbiAgICAgIGhlaWdodDogMTZweDtcbiAgICB9XG5cbiAgICAjJHtwcmVmaXh9aWNvbi13cmFwcGVyID4gc3ZnIHtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgIH1cblxuICAgICMke3ByZWZpeH1pY29uLWdyb3VwIHtcbiAgICAgIGFuaW1hdGlvbjogJHtwcmVmaXh9c3Ryb2tlZGFzaCAxcyBlYXNlLWluLW91dCBib3RoIGluZmluaXRlO1xuICAgIH1cblxuICAgIEBrZXlmcmFtZXMgJHtwcmVmaXh9ZmFkZS1pbiB7XG4gICAgICBmcm9tIHtcbiAgICAgICAgYm90dG9tOiAxMHB4O1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgfVxuICAgICAgdG8ge1xuICAgICAgICBib3R0b206IDIwcHg7XG4gICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQGtleWZyYW1lcyAke3ByZWZpeH1zdHJva2VkYXNoIHtcbiAgICAgIDAlIHtcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogMCAyMjY7XG4gICAgICB9XG4gICAgICA4MCUsXG4gICAgICAxMDAlIHtcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogNjU5IDIyNjtcbiAgICAgIH1cbiAgICB9XG4gIGBcblxuICByZXR1cm4gY3NzXG59XG4iLCJjb25zdCBldmVudENhbGxiYWNrcyA9IFtdXG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlV3JhcHBlcihvcHRpb25zKSB7XG4gIHZhciBzb3VyY2VcbiAgdmFyIGxhc3RBY3Rpdml0eSA9IG5ldyBEYXRlKClcbiAgdmFyIGxpc3RlbmVycyA9IFtdXG5cbiAgaWYgKCFvcHRpb25zLnRpbWVvdXQpIHtcbiAgICBvcHRpb25zLnRpbWVvdXQgPSAyMCAqIDEwMDBcbiAgfVxuXG4gIGluaXQoKVxuICB2YXIgdGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKG5ldyBEYXRlKCkgLSBsYXN0QWN0aXZpdHkgPiBvcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgIGhhbmRsZURpc2Nvbm5lY3QoKVxuICAgIH1cbiAgfSwgb3B0aW9ucy50aW1lb3V0IC8gMilcblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIHNvdXJjZSA9IG5ldyB3aW5kb3cuRXZlbnRTb3VyY2Uob3B0aW9ucy5wYXRoKVxuICAgIHNvdXJjZS5vbm9wZW4gPSBoYW5kbGVPbmxpbmVcbiAgICBzb3VyY2Uub25lcnJvciA9IGhhbmRsZURpc2Nvbm5lY3RcbiAgICBzb3VyY2Uub25tZXNzYWdlID0gaGFuZGxlTWVzc2FnZVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlT25saW5lKCkge1xuICAgIGlmIChvcHRpb25zLmxvZykgY29uc29sZS5sb2coJ1tITVJdIGNvbm5lY3RlZCcpXG4gICAgbGFzdEFjdGl2aXR5ID0gbmV3IERhdGUoKVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCkge1xuICAgIGxhc3RBY3Rpdml0eSA9IG5ldyBEYXRlKClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldKGV2ZW50KVxuICAgIH1cblxuICAgIGV2ZW50Q2FsbGJhY2tzLmZvckVhY2goKGNiKSA9PiB7XG4gICAgICBpZiAoIWNiLnVuZmlsdGVyZWQgJiYgZXZlbnQuZGF0YS5pbmRleE9mKCdhY3Rpb24nKSA9PT0gLTEpIHJldHVyblxuICAgICAgY2IoZXZlbnQpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZURpc2Nvbm5lY3QoKSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aW1lcilcbiAgICBzb3VyY2UuY2xvc2UoKVxuICAgIHNldFRpbWVvdXQoaW5pdCwgb3B0aW9ucy50aW1lb3V0KVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcilcbiAgICAgIHNvdXJjZS5jbG9zZSgpXG4gICAgfSxcbiAgICBhZGRNZXNzYWdlTGlzdGVuZXI6IGZ1bmN0aW9uIChmbikge1xuICAgICAgbGlzdGVuZXJzLnB1c2goZm4pXG4gICAgfSxcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnRTb3VyY2VXcmFwcGVyKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zLm9uZGVtYW5kKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZE1lc3NhZ2VMaXN0ZW5lcjogKGNiKSA9PiB7XG4gICAgICAgIGV2ZW50Q2FsbGJhY2tzLnB1c2goY2IpXG4gICAgICB9LFxuICAgIH1cbiAgfVxuICByZXR1cm4gRXZlbnRTb3VyY2VXcmFwcGVyKG9wdGlvbnMpXG59XG4iLCIvKipcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuU09GVFdBUkUuXG4qL1xuLy8gVGhpcyBmaWxlIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL2Jsb2IvN2IxYTMyYmU2ZWM5Zjk5YTZjOWEzYzY2ODEzZjNhYzA5YzQ3MzZiOS9wYWNrYWdlcy9yZWFjdC1kZXYtdXRpbHMvZm9ybWF0V2VicGFja01lc3NhZ2VzLmpzXG4vLyBJdCdzIGJlZW4gZWRpdGVkIHRvIHJlbW92ZSBjaGFsayBhbmQgQ1JBLXNwZWNpZmljIGxvZ2ljXG5cbmNvbnN0IGZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbCA9ICdTeW50YXggZXJyb3I6J1xuXG5mdW5jdGlvbiBpc0xpa2VseUFTeW50YXhFcnJvcihtZXNzYWdlKSB7XG4gIHJldHVybiBtZXNzYWdlLmluZGV4T2YoZnJpZW5kbHlTeW50YXhFcnJvckxhYmVsKSAhPT0gLTFcbn1cblxuLy8gQ2xlYW5zIHVwIHdlYnBhY2sgZXJyb3IgbWVzc2FnZXMuXG5mdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgLy8gVE9ETzogUmVwbGFjZSB0aGlzIG9uY2Ugd2VicGFjayA1IGlzIHN0YWJsZVxuICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnICYmIG1lc3NhZ2UubWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgPVxuICAgICAgKG1lc3NhZ2UubW9kdWxlTmFtZSA/IG1lc3NhZ2UubW9kdWxlTmFtZSArICdcXG4nIDogJycpICtcbiAgICAgIChtZXNzYWdlLmZpbGUgPyBtZXNzYWdlLmZpbGUgKyAnXFxuJyA6ICcnKSArXG4gICAgICBtZXNzYWdlLm1lc3NhZ2VcbiAgfVxuICBsZXQgbGluZXMgPSBtZXNzYWdlLnNwbGl0KCdcXG4nKVxuXG4gIC8vIFN0cmlwIFdlYnBhY2stYWRkZWQgaGVhZGVycyBvZmYgZXJyb3JzL3dhcm5pbmdzXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2svYmxvYi9tYXN0ZXIvbGliL01vZHVsZUVycm9yLmpzXG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKChsaW5lKSA9PiAhL01vZHVsZSBbQS16IF0rXFwoZnJvbS8udGVzdChsaW5lKSlcblxuICAvLyBUcmFuc2Zvcm0gcGFyc2luZyBlcnJvciBpbnRvIHN5bnRheCBlcnJvclxuICAvLyBUT0RPOiBtb3ZlIHRoaXMgdG8gb3VyIEVTTGludCBmb3JtYXR0ZXI/XG4gIGxpbmVzID0gbGluZXMubWFwKChsaW5lKSA9PiB7XG4gICAgY29uc3QgcGFyc2luZ0Vycm9yID0gL0xpbmUgKFxcZCspOig/OihcXGQrKTopP1xccypQYXJzaW5nIGVycm9yOiAoLispJC8uZXhlYyhcbiAgICAgIGxpbmVcbiAgICApXG4gICAgaWYgKCFwYXJzaW5nRXJyb3IpIHtcbiAgICAgIHJldHVybiBsaW5lXG4gICAgfVxuICAgIGNvbnN0IFssIGVycm9yTGluZSwgZXJyb3JDb2x1bW4sIGVycm9yTWVzc2FnZV0gPSBwYXJzaW5nRXJyb3JcbiAgICByZXR1cm4gYCR7ZnJpZW5kbHlTeW50YXhFcnJvckxhYmVsfSAke2Vycm9yTWVzc2FnZX0gKCR7ZXJyb3JMaW5lfToke2Vycm9yQ29sdW1ufSlgXG4gIH0pXG5cbiAgbWVzc2FnZSA9IGxpbmVzLmpvaW4oJ1xcbicpXG4gIC8vIFNtb29zaCBzeW50YXggZXJyb3JzIChjb21tb25seSBmb3VuZCBpbiBDU1MpXG4gIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoXG4gICAgL1N5bnRheEVycm9yXFxzK1xcKChcXGQrKTooXFxkKylcXClcXHMqKC4rPylcXG4vZyxcbiAgICBgJHtmcmllbmRseVN5bnRheEVycm9yTGFiZWx9ICQzICgkMTokMilcXG5gXG4gIClcbiAgLy8gQ2xlYW4gdXAgZXhwb3J0IGVycm9yc1xuICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKFxuICAgIC9eLipleHBvcnQgJyguKz8pJyB3YXMgbm90IGZvdW5kIGluICcoLis/KScuKiQvZ20sXG4gICAgYEF0dGVtcHRlZCBpbXBvcnQgZXJyb3I6ICckMScgaXMgbm90IGV4cG9ydGVkIGZyb20gJyQyJy5gXG4gIClcbiAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShcbiAgICAvXi4qZXhwb3J0ICdkZWZhdWx0JyBcXChpbXBvcnRlZCBhcyAnKC4rPyknXFwpIHdhcyBub3QgZm91bmQgaW4gJyguKz8pJy4qJC9nbSxcbiAgICBgQXR0ZW1wdGVkIGltcG9ydCBlcnJvcjogJyQyJyBkb2VzIG5vdCBjb250YWluIGEgZGVmYXVsdCBleHBvcnQgKGltcG9ydGVkIGFzICckMScpLmBcbiAgKVxuICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKFxuICAgIC9eLipleHBvcnQgJyguKz8pJyBcXChpbXBvcnRlZCBhcyAnKC4rPyknXFwpIHdhcyBub3QgZm91bmQgaW4gJyguKz8pJy4qJC9nbSxcbiAgICBgQXR0ZW1wdGVkIGltcG9ydCBlcnJvcjogJyQxJyBpcyBub3QgZXhwb3J0ZWQgZnJvbSAnJDMnIChpbXBvcnRlZCBhcyAnJDInKS5gXG4gIClcbiAgbGluZXMgPSBtZXNzYWdlLnNwbGl0KCdcXG4nKVxuXG4gIC8vIFJlbW92ZSBsZWFkaW5nIG5ld2xpbmVcbiAgaWYgKGxpbmVzLmxlbmd0aCA+IDIgJiYgbGluZXNbMV0udHJpbSgpID09PSAnJykge1xuICAgIGxpbmVzLnNwbGljZSgxLCAxKVxuICB9XG4gIC8vIENsZWFuIHVwIGZpbGUgbmFtZVxuICBsaW5lc1swXSA9IGxpbmVzWzBdLnJlcGxhY2UoL14oLiopIFxcZCs6XFxkKy1cXGQrJC8sICckMScpXG5cbiAgLy8gQ2xlYW5zIHVwIHZlcmJvc2UgXCJtb2R1bGUgbm90IGZvdW5kXCIgbWVzc2FnZXMgZm9yIGZpbGVzIGFuZCBwYWNrYWdlcy5cbiAgaWYgKGxpbmVzWzFdICYmIGxpbmVzWzFdLmluZGV4T2YoJ01vZHVsZSBub3QgZm91bmQ6ICcpID09PSAwKSB7XG4gICAgbGluZXMgPSBbXG4gICAgICBsaW5lc1swXSxcbiAgICAgIGxpbmVzWzFdXG4gICAgICAgIC5yZXBsYWNlKCdFcnJvcjogJywgJycpXG4gICAgICAgIC5yZXBsYWNlKCdNb2R1bGUgbm90IGZvdW5kOiBDYW5ub3QgZmluZCBmaWxlOicsICdDYW5ub3QgZmluZCBmaWxlOicpLFxuICAgICAgLi4ubGluZXMuc2xpY2UoMikuZmlsdGVyKChsaW5lKSA9PiBsaW5lLmluZGV4T2YoJyBAICcpICE9PSAwKSxcbiAgICBdXG4gIH1cblxuICAvLyBBZGQgaGVscGZ1bCBtZXNzYWdlIGZvciB1c2VycyB0cnlpbmcgdG8gdXNlIFNhc3MgZm9yIHRoZSBmaXJzdCB0aW1lXG4gIGlmIChsaW5lc1sxXSAmJiBsaW5lc1sxXS5tYXRjaCgvQ2Fubm90IGZpbmQgbW9kdWxlLitub2RlLXNhc3MvKSkge1xuICAgIC8vIC4vZmlsZS5tb2R1bGUuc2NzcyAoPDxsb2FkZXIgaW5mbz4+KSA9PiAuL2ZpbGUubW9kdWxlLnNjc3NcbiAgICBsaW5lc1swXSA9IGxpbmVzWzBdLnJlcGxhY2UoLyguKykgXFwoLis/KD89XFw/XFw/KS4rP1xcKS8sICckMScpXG5cbiAgICBsaW5lc1sxXSA9XG4gICAgICBcIlRvIHVzZSBOZXh0LmpzJyBidWlsdC1pbiBTYXNzIHN1cHBvcnQsIHlvdSBmaXJzdCBuZWVkIHRvIGluc3RhbGwgYHNhc3NgLlxcblwiXG4gICAgbGluZXNbMV0gKz0gJ1J1biBgbnBtIGkgc2Fzc2Agb3IgYHlhcm4gYWRkIHNhc3NgIGluc2lkZSB5b3VyIHdvcmtzcGFjZS5cXG4nXG4gICAgbGluZXNbMV0gKz0gJ1xcbkxlYXJuIG1vcmU6IGh0dHBzOi8vZXJyLnNoL25leHQuanMvaW5zdGFsbC1zYXNzJ1xuICB9XG5cbiAgbWVzc2FnZSA9IGxpbmVzLmpvaW4oJ1xcbicpXG4gIC8vIEludGVybmFsIHN0YWNrcyBhcmUgZ2VuZXJhbGx5IHVzZWxlc3Mgc28gd2Ugc3RyaXAgdGhlbS4uLiB3aXRoIHRoZVxuICAvLyBleGNlcHRpb24gb2Ygc3RhY2tzIGNvbnRhaW5pbmcgYHdlYnBhY2s6YCBiZWNhdXNlIHRoZXkncmUgbm9ybWFsbHlcbiAgLy8gZnJvbSB1c2VyIGNvZGUgZ2VuZXJhdGVkIGJ5IFdlYnBhY2suIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9wdWxsLzEwNTBcbiAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShcbiAgICAvXlxccyphdFxccygoPyF3ZWJwYWNrOikuKSo6XFxkKzpcXGQrW1xccyldKihcXG58JCkvZ20sXG4gICAgJydcbiAgKSAvLyBhdCAuLi4gLi4uOng6eVxuICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKC9eXFxzKmF0XFxzPGFub255bW91cz4oXFxufCQpL2dtLCAnJykgLy8gYXQgPGFub255bW91cz5cbiAgbGluZXMgPSBtZXNzYWdlLnNwbGl0KCdcXG4nKVxuXG4gIC8vIFJlbW92ZSBkdXBsaWNhdGVkIG5ld2xpbmVzXG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKFxuICAgIChsaW5lLCBpbmRleCwgYXJyKSA9PlxuICAgICAgaW5kZXggPT09IDAgfHwgbGluZS50cmltKCkgIT09ICcnIHx8IGxpbmUudHJpbSgpICE9PSBhcnJbaW5kZXggLSAxXS50cmltKClcbiAgKVxuXG4gIC8vIFJlYXNzZW1ibGUgdGhlIG1lc3NhZ2VcbiAgbWVzc2FnZSA9IGxpbmVzLmpvaW4oJ1xcbicpXG4gIHJldHVybiBtZXNzYWdlLnRyaW0oKVxufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWJwYWNrTWVzc2FnZXMoanNvbikge1xuICBjb25zdCBmb3JtYXR0ZWRFcnJvcnMgPSBqc29uLmVycm9ycy5tYXAoZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZm9ybWF0TWVzc2FnZShtZXNzYWdlLCB0cnVlKVxuICB9KVxuICBjb25zdCBmb3JtYXR0ZWRXYXJuaW5ncyA9IGpzb24ud2FybmluZ3MubWFwKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGZvcm1hdE1lc3NhZ2UobWVzc2FnZSwgZmFsc2UpXG4gIH0pXG4gIGNvbnN0IHJlc3VsdCA9IHsgZXJyb3JzOiBmb3JtYXR0ZWRFcnJvcnMsIHdhcm5pbmdzOiBmb3JtYXR0ZWRXYXJuaW5ncyB9XG4gIGlmIChyZXN1bHQuZXJyb3JzLnNvbWUoaXNMaWtlbHlBU3ludGF4RXJyb3IpKSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIGFueSBzeW50YXggZXJyb3JzLCBzaG93IGp1c3QgdGhlbS5cbiAgICByZXN1bHQuZXJyb3JzID0gcmVzdWx0LmVycm9ycy5maWx0ZXIoaXNMaWtlbHlBU3ludGF4RXJyb3IpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvcm1hdFdlYnBhY2tNZXNzYWdlc1xuIiwiLyoqXG4gKiBNSVQgTGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuLy8gVGhpcyBmaWxlIGlzIGEgbW9kaWZpZWQgdmVyc2lvbiBvZiB0aGUgQ3JlYXRlIFJlYWN0IEFwcCBITVIgZGV2IGNsaWVudCB0aGF0XG4vLyBjYW4gYmUgZm91bmQgaGVyZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9jcmVhdGUtcmVhY3QtYXBwL2Jsb2IvdjMuNC4xL3BhY2thZ2VzL3JlYWN0LWRldi11dGlscy93ZWJwYWNrSG90RGV2Q2xpZW50LmpzXG5cbmltcG9ydCAqIGFzIERldk92ZXJsYXkgZnJvbSAnQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2NsaWVudCdcbmltcG9ydCBzdHJpcEFuc2kgZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3N0cmlwLWFuc2knXG5pbXBvcnQgeyBnZXRFdmVudFNvdXJjZVdyYXBwZXIgfSBmcm9tICcuL2V2ZW50c291cmNlJ1xuaW1wb3J0IGZvcm1hdFdlYnBhY2tNZXNzYWdlcyBmcm9tICcuL2Zvcm1hdC13ZWJwYWNrLW1lc3NhZ2VzJ1xuXG4vLyBUaGlzIGFsdGVybmF0aXZlIFdlYnBhY2tEZXZTZXJ2ZXIgY29tYmluZXMgdGhlIGZ1bmN0aW9uYWxpdHkgb2Y6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvYmxvYi93ZWJwYWNrLTEvY2xpZW50L2luZGV4LmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrL2Jsb2Ivd2VicGFjay0xL2hvdC9kZXYtc2VydmVyLmpzXG5cbi8vIEl0IG9ubHkgc3VwcG9ydHMgdGhlaXIgc2ltcGxlc3QgY29uZmlndXJhdGlvbiAoaG90IHVwZGF0ZXMgb24gc2FtZSBzZXJ2ZXIpLlxuLy8gSXQgbWFrZXMgc29tZSBvcGluaW9uYXRlZCBjaG9pY2VzIG9uIHRvcCwgbGlrZSBhZGRpbmcgYSBzeW50YXggZXJyb3Igb3ZlcmxheVxuLy8gdGhhdCBsb29rcyBzaW1pbGFyIHRvIG91ciBjb25zb2xlIG91dHB1dC4gVGhlIGVycm9yIG92ZXJsYXkgaXMgaW5zcGlyZWQgYnk6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ2xlbmphbWluL3dlYnBhY2staG90LW1pZGRsZXdhcmVcblxubGV0IGhhZFJ1bnRpbWVFcnJvciA9IGZhbHNlXG5sZXQgY3VzdG9tSG1yRXZlbnRIYW5kbGVyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb25uZWN0KG9wdGlvbnMpIHtcbiAgRGV2T3ZlcmxheS5yZWdpc3RlcigpXG5cbiAgZ2V0RXZlbnRTb3VyY2VXcmFwcGVyKG9wdGlvbnMpLmFkZE1lc3NhZ2VMaXN0ZW5lcigoZXZlbnQpID0+IHtcbiAgICAvLyBUaGlzIGlzIHRoZSBoZWFydGJlYXQgZXZlbnRcbiAgICBpZiAoZXZlbnQuZGF0YSA9PT0gJ1xcdUQ4M0RcXHVEQzkzJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBwcm9jZXNzTWVzc2FnZShldmVudClcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIEhNUiBtZXNzYWdlOiAnICsgZXZlbnQuZGF0YSArICdcXG4nICsgZXgpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiB7XG4gICAgc3Vic2NyaWJlVG9IbXJFdmVudChoYW5kbGVyKSB7XG4gICAgICBjdXN0b21IbXJFdmVudEhhbmRsZXIgPSBoYW5kbGVyXG4gICAgfSxcbiAgICBvblVucmVjb3ZlcmFibGVFcnJvcigpIHtcbiAgICAgIGhhZFJ1bnRpbWVFcnJvciA9IHRydWVcbiAgICB9LFxuICB9XG59XG5cbi8vIFJlbWVtYmVyIHNvbWUgc3RhdGUgcmVsYXRlZCB0byBob3QgbW9kdWxlIHJlcGxhY2VtZW50LlxudmFyIGlzRmlyc3RDb21waWxhdGlvbiA9IHRydWVcbnZhciBtb3N0UmVjZW50Q29tcGlsYXRpb25IYXNoID0gbnVsbFxudmFyIGhhc0NvbXBpbGVFcnJvcnMgPSBmYWxzZVxuXG5mdW5jdGlvbiBjbGVhck91dGRhdGVkRXJyb3JzKCkge1xuICAvLyBDbGVhbiB1cCBvdXRkYXRlZCBjb21waWxlIGVycm9ycywgaWYgYW55LlxuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmNsZWFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGhhc0NvbXBpbGVFcnJvcnMpIHtcbiAgICAgIGNvbnNvbGUuY2xlYXIoKVxuICAgIH1cbiAgfVxufVxuXG4vLyBTdWNjZXNzZnVsIGNvbXBpbGF0aW9uLlxuZnVuY3Rpb24gaGFuZGxlU3VjY2VzcygpIHtcbiAgY2xlYXJPdXRkYXRlZEVycm9ycygpXG5cbiAgY29uc3QgaXNIb3RVcGRhdGUgPSAhaXNGaXJzdENvbXBpbGF0aW9uXG4gIGlzRmlyc3RDb21waWxhdGlvbiA9IGZhbHNlXG4gIGhhc0NvbXBpbGVFcnJvcnMgPSBmYWxzZVxuXG4gIC8vIEF0dGVtcHQgdG8gYXBwbHkgaG90IHVwZGF0ZXMgb3IgcmVsb2FkLlxuICBpZiAoaXNIb3RVcGRhdGUpIHtcbiAgICB0cnlBcHBseVVwZGF0ZXMoZnVuY3Rpb24gb25TdWNjZXNzZnVsSG90VXBkYXRlKGhhc1VwZGF0ZXMpIHtcbiAgICAgIC8vIE9ubHkgZGlzbWlzcyBpdCB3aGVuIHdlJ3JlIHN1cmUgaXQncyBhIGhvdCB1cGRhdGUuXG4gICAgICAvLyBPdGhlcndpc2UgaXQgd291bGQgZmxpY2tlciByaWdodCBiZWZvcmUgdGhlIHJlbG9hZC5cbiAgICAgIG9uRmFzdFJlZnJlc2goaGFzVXBkYXRlcylcbiAgICB9KVxuICB9XG59XG5cbi8vIENvbXBpbGF0aW9uIHdpdGggd2FybmluZ3MgKGUuZy4gRVNMaW50KS5cbmZ1bmN0aW9uIGhhbmRsZVdhcm5pbmdzKHdhcm5pbmdzKSB7XG4gIGNsZWFyT3V0ZGF0ZWRFcnJvcnMoKVxuXG4gIGNvbnN0IGlzSG90VXBkYXRlID0gIWlzRmlyc3RDb21waWxhdGlvblxuICBpc0ZpcnN0Q29tcGlsYXRpb24gPSBmYWxzZVxuICBoYXNDb21waWxlRXJyb3JzID0gZmFsc2VcblxuICBmdW5jdGlvbiBwcmludFdhcm5pbmdzKCkge1xuICAgIC8vIFByaW50IHdhcm5pbmdzIHRvIHRoZSBjb25zb2xlLlxuICAgIGNvbnN0IGZvcm1hdHRlZCA9IGZvcm1hdFdlYnBhY2tNZXNzYWdlcyh7XG4gICAgICB3YXJuaW5nczogd2FybmluZ3MsXG4gICAgICBlcnJvcnM6IFtdLFxuICAgIH0pXG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9ybWF0dGVkLndhcm5pbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSA1KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ1RoZXJlIHdlcmUgbW9yZSB3YXJuaW5ncyBpbiBvdGhlciBmaWxlcy5cXG4nICtcbiAgICAgICAgICAgICAgJ1lvdSBjYW4gZmluZCBhIGNvbXBsZXRlIGxvZyBpbiB0aGUgdGVybWluYWwuJ1xuICAgICAgICAgIClcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybihzdHJpcEFuc2koZm9ybWF0dGVkLndhcm5pbmdzW2ldKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcmludFdhcm5pbmdzKClcblxuICAvLyBBdHRlbXB0IHRvIGFwcGx5IGhvdCB1cGRhdGVzIG9yIHJlbG9hZC5cbiAgaWYgKGlzSG90VXBkYXRlKSB7XG4gICAgdHJ5QXBwbHlVcGRhdGVzKGZ1bmN0aW9uIG9uU3VjY2Vzc2Z1bEhvdFVwZGF0ZShoYXNVcGRhdGVzKSB7XG4gICAgICAvLyBPbmx5IGRpc21pc3MgaXQgd2hlbiB3ZSdyZSBzdXJlIGl0J3MgYSBob3QgdXBkYXRlLlxuICAgICAgLy8gT3RoZXJ3aXNlIGl0IHdvdWxkIGZsaWNrZXIgcmlnaHQgYmVmb3JlIHRoZSByZWxvYWQuXG4gICAgICBvbkZhc3RSZWZyZXNoKGhhc1VwZGF0ZXMpXG4gICAgfSlcbiAgfVxufVxuXG4vLyBDb21waWxhdGlvbiB3aXRoIGVycm9ycyAoZS5nLiBzeW50YXggZXJyb3Igb3IgbWlzc2luZyBtb2R1bGVzKS5cbmZ1bmN0aW9uIGhhbmRsZUVycm9ycyhlcnJvcnMpIHtcbiAgY2xlYXJPdXRkYXRlZEVycm9ycygpXG5cbiAgaXNGaXJzdENvbXBpbGF0aW9uID0gZmFsc2VcbiAgaGFzQ29tcGlsZUVycm9ycyA9IHRydWVcblxuICAvLyBcIk1hc3NhZ2VcIiB3ZWJwYWNrIG1lc3NhZ2VzLlxuICB2YXIgZm9ybWF0dGVkID0gZm9ybWF0V2VicGFja01lc3NhZ2VzKHtcbiAgICBlcnJvcnM6IGVycm9ycyxcbiAgICB3YXJuaW5nczogW10sXG4gIH0pXG5cbiAgLy8gT25seSBzaG93IHRoZSBmaXJzdCBlcnJvci5cbiAgRGV2T3ZlcmxheS5vbkJ1aWxkRXJyb3IoZm9ybWF0dGVkLmVycm9yc1swXSlcblxuICAvLyBBbHNvIGxvZyB0aGVtIHRvIHRoZSBjb25zb2xlLlxuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JtYXR0ZWQuZXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zb2xlLmVycm9yKHN0cmlwQW5zaShmb3JtYXR0ZWQuZXJyb3JzW2ldKSlcbiAgICB9XG4gIH1cblxuICAvLyBEbyBub3QgYXR0ZW1wdCB0byByZWxvYWQgbm93LlxuICAvLyBXZSB3aWxsIHJlbG9hZCBvbiBuZXh0IHN1Y2Nlc3MgaW5zdGVhZC5cbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpIHtcbiAgICBpZiAoc2VsZi5fX05FWFRfSE1SX0NCKSB7XG4gICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IoZm9ybWF0dGVkLmVycm9yc1swXSlcbiAgICAgIHNlbGYuX19ORVhUX0hNUl9DQiA9IG51bGxcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25GYXN0UmVmcmVzaChoYXNVcGRhdGVzKSB7XG4gIERldk92ZXJsYXkub25CdWlsZE9rKClcbiAgaWYgKGhhc1VwZGF0ZXMpIHtcbiAgICBEZXZPdmVybGF5Lm9uUmVmcmVzaCgpXG4gIH1cblxuICBjb25zb2xlLmxvZygnW0Zhc3QgUmVmcmVzaF0gZG9uZScpXG59XG5cbi8vIFRoZXJlIGlzIGEgbmV3ZXIgdmVyc2lvbiBvZiB0aGUgY29kZSBhdmFpbGFibGUuXG5mdW5jdGlvbiBoYW5kbGVBdmFpbGFibGVIYXNoKGhhc2gpIHtcbiAgLy8gVXBkYXRlIGxhc3Qga25vd24gY29tcGlsYXRpb24gaGFzaC5cbiAgbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCA9IGhhc2hcbn1cblxuLy8gSGFuZGxlIG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlci5cbmZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlKGUpIHtcbiAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShlLmRhdGEpXG4gIHN3aXRjaCAob2JqLmFjdGlvbikge1xuICAgIGNhc2UgJ2J1aWxkaW5nJzoge1xuICAgICAgY29uc29sZS5sb2coJ1tGYXN0IFJlZnJlc2hdIHJlYnVpbGRpbmcnKVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSAnYnVpbHQnOlxuICAgIGNhc2UgJ3N5bmMnOiB7XG4gICAgICBpZiAob2JqLmhhc2gpIHtcbiAgICAgICAgaGFuZGxlQXZhaWxhYmxlSGFzaChvYmouaGFzaClcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBlcnJvcnMsIHdhcm5pbmdzIH0gPSBvYmpcbiAgICAgIGNvbnN0IGhhc0Vycm9ycyA9IEJvb2xlYW4oZXJyb3JzICYmIGVycm9ycy5sZW5ndGgpXG4gICAgICBpZiAoaGFzRXJyb3JzKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVFcnJvcnMoZXJyb3JzKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBoYXNXYXJuaW5ncyA9IEJvb2xlYW4od2FybmluZ3MgJiYgd2FybmluZ3MubGVuZ3RoKVxuICAgICAgaWYgKGhhc1dhcm5pbmdzKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVXYXJuaW5ncyh3YXJuaW5ncylcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhbmRsZVN1Y2Nlc3MoKVxuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBpZiAoY3VzdG9tSG1yRXZlbnRIYW5kbGVyKSB7XG4gICAgICAgIGN1c3RvbUhtckV2ZW50SGFuZGxlcihvYmopXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vLyBJcyB0aGVyZSBhIG5ld2VyIHZlcnNpb24gb2YgdGhpcyBjb2RlIGF2YWlsYWJsZT9cbmZ1bmN0aW9uIGlzVXBkYXRlQXZhaWxhYmxlKCkge1xuICAvKiBnbG9iYWxzIF9fd2VicGFja19oYXNoX18gKi9cbiAgLy8gX193ZWJwYWNrX2hhc2hfXyBpcyB0aGUgaGFzaCBvZiB0aGUgY3VycmVudCBjb21waWxhdGlvbi5cbiAgLy8gSXQncyBhIGdsb2JhbCB2YXJpYWJsZSBpbmplY3RlZCBieSBXZWJwYWNrLlxuICByZXR1cm4gbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCAhPT0gX193ZWJwYWNrX2hhc2hfX1xufVxuXG4vLyBXZWJwYWNrIGRpc2FsbG93cyB1cGRhdGVzIGluIG90aGVyIHN0YXRlcy5cbmZ1bmN0aW9uIGNhbkFwcGx5VXBkYXRlcygpIHtcbiAgcmV0dXJuIG1vZHVsZS5ob3Quc3RhdHVzKCkgPT09ICdpZGxlJ1xufVxuZnVuY3Rpb24gYWZ0ZXJBcHBseVVwZGF0ZXMoZm4pIHtcbiAgaWYgKGNhbkFwcGx5VXBkYXRlcygpKSB7XG4gICAgZm4oKVxuICB9IGVsc2Uge1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoc3RhdHVzKSB7XG4gICAgICBpZiAoc3RhdHVzID09PSAnaWRsZScpIHtcbiAgICAgICAgbW9kdWxlLmhvdC5yZW1vdmVTdGF0dXNIYW5kbGVyKGhhbmRsZXIpXG4gICAgICAgIGZuKClcbiAgICAgIH1cbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hZGRTdGF0dXNIYW5kbGVyKGhhbmRsZXIpXG4gIH1cbn1cblxuLy8gQXR0ZW1wdCB0byB1cGRhdGUgY29kZSBvbiB0aGUgZmx5LCBmYWxsIGJhY2sgdG8gYSBoYXJkIHJlbG9hZC5cbmZ1bmN0aW9uIHRyeUFwcGx5VXBkYXRlcyhvbkhvdFVwZGF0ZVN1Y2Nlc3MpIHtcbiAgaWYgKCFtb2R1bGUuaG90KSB7XG4gICAgLy8gSG90TW9kdWxlUmVwbGFjZW1lbnRQbHVnaW4gaXMgbm90IGluIFdlYnBhY2sgY29uZmlndXJhdGlvbi5cbiAgICBjb25zb2xlLmVycm9yKCdIb3RNb2R1bGVSZXBsYWNlbWVudFBsdWdpbiBpcyBub3QgaW4gV2VicGFjayBjb25maWd1cmF0aW9uLicpXG4gICAgLy8gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKCFpc1VwZGF0ZUF2YWlsYWJsZSgpIHx8ICFjYW5BcHBseVVwZGF0ZXMoKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQXBwbHlVcGRhdGVzKGVyciwgdXBkYXRlZE1vZHVsZXMpIHtcbiAgICBpZiAoZXJyIHx8IGhhZFJ1bnRpbWVFcnJvciB8fCAhdXBkYXRlZE1vZHVsZXMpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdbRmFzdCBSZWZyZXNoXSBwZXJmb3JtaW5nIGZ1bGwgcmVsb2FkXFxuXFxuJyArXG4gICAgICAgICAgICBcIkZhc3QgUmVmcmVzaCB3aWxsIHBlcmZvcm0gYSBmdWxsIHJlbG9hZCB3aGVuIHlvdSBlZGl0IGEgZmlsZSB0aGF0J3MgaW1wb3J0ZWQgYnkgbW9kdWxlcyBvdXRzaWRlIG9mIHRoZSBSZWFjdCByZW5kZXJpbmcgdHJlZS5cXG5cIiArXG4gICAgICAgICAgICAnWW91IG1pZ2h0IGhhdmUgYSBmaWxlIHdoaWNoIGV4cG9ydHMgYSBSZWFjdCBjb21wb25lbnQgYnV0IGFsc28gZXhwb3J0cyBhIHZhbHVlIHRoYXQgaXMgaW1wb3J0ZWQgYnkgYSBub24tUmVhY3QgY29tcG9uZW50IGZpbGUuXFxuJyArXG4gICAgICAgICAgICAnQ29uc2lkZXIgbWlncmF0aW5nIHRoZSBub24tUmVhY3QgY29tcG9uZW50IGV4cG9ydCB0byBhIHNlcGFyYXRlIGZpbGUgYW5kIGltcG9ydGluZyBpdCBpbnRvIGJvdGggZmlsZXMuXFxuXFxuJyArXG4gICAgICAgICAgICAnSXQgaXMgYWxzbyBwb3NzaWJsZSB0aGUgcGFyZW50IGNvbXBvbmVudCBvZiB0aGUgY29tcG9uZW50IHlvdSBlZGl0ZWQgaXMgYSBjbGFzcyBjb21wb25lbnQsIHdoaWNoIGRpc2FibGVzIEZhc3QgUmVmcmVzaC5cXG4nICtcbiAgICAgICAgICAgICdGYXN0IFJlZnJlc2ggcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHBhcmVudCBmdW5jdGlvbiBjb21wb25lbnQgaW4geW91ciBSZWFjdCB0cmVlLidcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIGlmIChoYWRSdW50aW1lRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdbRmFzdCBSZWZyZXNoXSBwZXJmb3JtaW5nIGZ1bGwgcmVsb2FkIGJlY2F1c2UgeW91ciBhcHBsaWNhdGlvbiBoYWQgYW4gdW5yZWNvdmVyYWJsZSBlcnJvcidcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBoYXNVcGRhdGVzID0gQm9vbGVhbih1cGRhdGVkTW9kdWxlcy5sZW5ndGgpXG4gICAgaWYgKHR5cGVvZiBvbkhvdFVwZGF0ZVN1Y2Nlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIE1heWJlIHdlIHdhbnQgdG8gZG8gc29tZXRoaW5nLlxuICAgICAgb25Ib3RVcGRhdGVTdWNjZXNzKGhhc1VwZGF0ZXMpXG4gICAgfVxuXG4gICAgaWYgKGlzVXBkYXRlQXZhaWxhYmxlKCkpIHtcbiAgICAgIC8vIFdoaWxlIHdlIHdlcmUgdXBkYXRpbmcsIHRoZXJlIHdhcyBhIG5ldyB1cGRhdGUhIERvIGl0IGFnYWluLlxuICAgICAgdHJ5QXBwbHlVcGRhdGVzKGhhc1VwZGF0ZXMgPyB1bmRlZmluZWQgOiBvbkhvdFVwZGF0ZVN1Y2Nlc3MpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgICAgIGFmdGVyQXBwbHlVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICBpZiAoc2VsZi5fX05FWFRfSE1SX0NCKSB7XG4gICAgICAgICAgICBzZWxmLl9fTkVYVF9ITVJfQ0IoKVxuICAgICAgICAgICAgc2VsZi5fX05FWFRfSE1SX0NCID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBodHRwczovL3dlYnBhY2suanMub3JnL2FwaS9ob3QtbW9kdWxlLXJlcGxhY2VtZW50LyNjaGVja1xuICBtb2R1bGUuaG90LmNoZWNrKC8qIGF1dG9BcHBseSAqLyB0cnVlKS50aGVuKFxuICAgICh1cGRhdGVkTW9kdWxlcykgPT4ge1xuICAgICAgaGFuZGxlQXBwbHlVcGRhdGVzKG51bGwsIHVwZGF0ZWRNb2R1bGVzKVxuICAgIH0sXG4gICAgKGVycikgPT4ge1xuICAgICAgaGFuZGxlQXBwbHlVcGRhdGVzKGVyciwgbnVsbClcbiAgICB9XG4gIClcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBJbXByb3ZlZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9ZYWZmbGUvRXZlbnRTb3VyY2UvXG4vLyBBdmFpbGFibGUgdW5kZXIgTUlUIExpY2Vuc2UgKE1JVClcbi8vIE9ubHkgdHJpZXMgdG8gc3VwcG9ydCBJRTExIGFuZCBub3RoaW5nIGJlbG93XG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnRcbnZhciBSZXNwb25zZSA9IHdpbmRvdy5SZXNwb25zZVxudmFyIFRleHREZWNvZGVyID0gd2luZG93LlRleHREZWNvZGVyXG52YXIgVGV4dEVuY29kZXIgPSB3aW5kb3cuVGV4dEVuY29kZXJcbnZhciBBYm9ydENvbnRyb2xsZXIgPSB3aW5kb3cuQWJvcnRDb250cm9sbGVyXG5cbmlmIChBYm9ydENvbnRyb2xsZXIgPT0gdW5kZWZpbmVkKSB7XG4gIEFib3J0Q29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNpZ25hbCA9IG51bGxcbiAgICB0aGlzLmFib3J0ID0gZnVuY3Rpb24gKCkge31cbiAgfVxufVxuXG5mdW5jdGlvbiBUZXh0RGVjb2RlclBvbHlmaWxsKCkge1xuICB0aGlzLmJpdHNOZWVkZWQgPSAwXG4gIHRoaXMuY29kZVBvaW50ID0gMFxufVxuXG5UZXh0RGVjb2RlclBvbHlmaWxsLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAob2N0ZXRzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkKGNvZGVQb2ludCwgc2hpZnQsIG9jdGV0c0NvdW50KSB7XG4gICAgaWYgKG9jdGV0c0NvdW50ID09PSAxKSB7XG4gICAgICByZXR1cm4gY29kZVBvaW50ID49IDB4MDA4MCA+PiBzaGlmdCAmJiBjb2RlUG9pbnQgPDwgc2hpZnQgPD0gMHgwN2ZmXG4gICAgfVxuICAgIGlmIChvY3RldHNDb3VudCA9PT0gMikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGNvZGVQb2ludCA+PSAweDA4MDAgPj4gc2hpZnQgJiYgY29kZVBvaW50IDw8IHNoaWZ0IDw9IDB4ZDdmZikgfHxcbiAgICAgICAgKGNvZGVQb2ludCA+PSAweGUwMDAgPj4gc2hpZnQgJiYgY29kZVBvaW50IDw8IHNoaWZ0IDw9IDB4ZmZmZilcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKG9jdGV0c0NvdW50ID09PSAzKSB7XG4gICAgICByZXR1cm4gY29kZVBvaW50ID49IDB4MDEwMDAwID4+IHNoaWZ0ICYmIGNvZGVQb2ludCA8PCBzaGlmdCA8PSAweDEwZmZmZlxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoKVxuICB9XG4gIGZ1bmN0aW9uIG9jdGV0c0NvdW50KGJpdHNOZWVkZWQsIGNvZGVQb2ludCkge1xuICAgIGlmIChiaXRzTmVlZGVkID09PSA2ICogMSkge1xuICAgICAgcmV0dXJuIGNvZGVQb2ludCA+PiA2ID4gMTUgPyAzIDogY29kZVBvaW50ID4gMzEgPyAyIDogMVxuICAgIH1cbiAgICBpZiAoYml0c05lZWRlZCA9PT0gNiAqIDIpIHtcbiAgICAgIHJldHVybiBjb2RlUG9pbnQgPiAxNSA/IDMgOiAyXG4gICAgfVxuICAgIGlmIChiaXRzTmVlZGVkID09PSA2ICogMykge1xuICAgICAgcmV0dXJuIDNcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKClcbiAgfVxuICB2YXIgUkVQTEFDRVIgPSAweGZmZmRcbiAgdmFyIHN0cmluZyA9ICcnXG4gIHZhciBiaXRzTmVlZGVkID0gdGhpcy5iaXRzTmVlZGVkXG4gIHZhciBjb2RlUG9pbnQgPSB0aGlzLmNvZGVQb2ludFxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9jdGV0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBvY3RldCA9IG9jdGV0c1tpXVxuICAgIGlmIChiaXRzTmVlZGVkICE9PSAwKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG9jdGV0IDwgMTI4IHx8XG4gICAgICAgIG9jdGV0ID4gMTkxIHx8XG4gICAgICAgICF2YWxpZChcbiAgICAgICAgICAoY29kZVBvaW50IDw8IDYpIHwgKG9jdGV0ICYgNjMpLFxuICAgICAgICAgIGJpdHNOZWVkZWQgLSA2LFxuICAgICAgICAgIG9jdGV0c0NvdW50KGJpdHNOZWVkZWQsIGNvZGVQb2ludClcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIGJpdHNOZWVkZWQgPSAwXG4gICAgICAgIGNvZGVQb2ludCA9IFJFUExBQ0VSXG4gICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJpdHNOZWVkZWQgPT09IDApIHtcbiAgICAgIGlmIChvY3RldCA+PSAwICYmIG9jdGV0IDw9IDEyNykge1xuICAgICAgICBiaXRzTmVlZGVkID0gMFxuICAgICAgICBjb2RlUG9pbnQgPSBvY3RldFxuICAgICAgfSBlbHNlIGlmIChvY3RldCA+PSAxOTIgJiYgb2N0ZXQgPD0gMjIzKSB7XG4gICAgICAgIGJpdHNOZWVkZWQgPSA2ICogMVxuICAgICAgICBjb2RlUG9pbnQgPSBvY3RldCAmIDMxXG4gICAgICB9IGVsc2UgaWYgKG9jdGV0ID49IDIyNCAmJiBvY3RldCA8PSAyMzkpIHtcbiAgICAgICAgYml0c05lZWRlZCA9IDYgKiAyXG4gICAgICAgIGNvZGVQb2ludCA9IG9jdGV0ICYgMTVcbiAgICAgIH0gZWxzZSBpZiAob2N0ZXQgPj0gMjQwICYmIG9jdGV0IDw9IDI0Nykge1xuICAgICAgICBiaXRzTmVlZGVkID0gNiAqIDNcbiAgICAgICAgY29kZVBvaW50ID0gb2N0ZXQgJiA3XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaXRzTmVlZGVkID0gMFxuICAgICAgICBjb2RlUG9pbnQgPSBSRVBMQUNFUlxuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBiaXRzTmVlZGVkICE9PSAwICYmXG4gICAgICAgICF2YWxpZChjb2RlUG9pbnQsIGJpdHNOZWVkZWQsIG9jdGV0c0NvdW50KGJpdHNOZWVkZWQsIGNvZGVQb2ludCkpXG4gICAgICApIHtcbiAgICAgICAgYml0c05lZWRlZCA9IDBcbiAgICAgICAgY29kZVBvaW50ID0gUkVQTEFDRVJcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYml0c05lZWRlZCAtPSA2XG4gICAgICBjb2RlUG9pbnQgPSAoY29kZVBvaW50IDw8IDYpIHwgKG9jdGV0ICYgNjMpXG4gICAgfVxuICAgIGlmIChiaXRzTmVlZGVkID09PSAwKSB7XG4gICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MDAgKyAoKGNvZGVQb2ludCAtIDB4ZmZmZiAtIDEpID4+IDEwKSlcbiAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgICAgMHhkYzAwICsgKChjb2RlUG9pbnQgLSAweGZmZmYgLSAxKSAmIDB4M2ZmKVxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMuYml0c05lZWRlZCA9IGJpdHNOZWVkZWRcbiAgdGhpcy5jb2RlUG9pbnQgPSBjb2RlUG9pbnRcbiAgcmV0dXJuIHN0cmluZ1xufVxuXG4vLyBGaXJlZm94IDwgMzggdGhyb3dzIGFuIGVycm9yIHdpdGggc3RyZWFtIG9wdGlvblxudmFyIHN1cHBvcnRzU3RyZWFtT3B0aW9uID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHJldHVybiAoXG4gICAgICBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCd0ZXN0JyksIHtcbiAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgfSkgPT09ICd0ZXN0J1xuICAgIClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmxvZyhlcnJvcilcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gSUUsIEVkZ2VcbmlmIChcbiAgVGV4dERlY29kZXIgPT0gdW5kZWZpbmVkIHx8XG4gIFRleHRFbmNvZGVyID09IHVuZGVmaW5lZCB8fFxuICAhc3VwcG9ydHNTdHJlYW1PcHRpb24oKVxuKSB7XG4gIFRleHREZWNvZGVyID0gVGV4dERlY29kZXJQb2x5ZmlsbFxufVxuXG52YXIgayA9IGZ1bmN0aW9uICgpIHt9XG5cbmZ1bmN0aW9uIFhIUldyYXBwZXIoeGhyKSB7XG4gIHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2VcbiAgdGhpcy5yZXNwb25zZVR5cGUgPSAnJ1xuICB0aGlzLnJlYWR5U3RhdGUgPSAwXG4gIHRoaXMuc3RhdHVzID0gMFxuICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICB0aGlzLnJlc3BvbnNlVGV4dCA9ICcnXG4gIHRoaXMub25wcm9ncmVzcyA9IGtcbiAgdGhpcy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBrXG4gIHRoaXMuX2NvbnRlbnRUeXBlID0gJydcbiAgdGhpcy5feGhyID0geGhyXG4gIHRoaXMuX3NlbmRUaW1lb3V0ID0gMFxuICB0aGlzLl9hYm9ydCA9IGtcbn1cblxuWEhSV3JhcHBlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCkge1xuICB0aGlzLl9hYm9ydCh0cnVlKVxuXG4gIHZhciB0aGF0ID0gdGhpc1xuICB2YXIgeGhyID0gdGhpcy5feGhyXG4gIHZhciBzdGF0ZSA9IDFcbiAgdmFyIHRpbWVvdXQgPSAwXG5cbiAgdGhpcy5fYWJvcnQgPSBmdW5jdGlvbiAoc2lsZW50KSB7XG4gICAgaWYgKHRoYXQuX3NlbmRUaW1lb3V0ICE9PSAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhhdC5fc2VuZFRpbWVvdXQpXG4gICAgICB0aGF0Ll9zZW5kVGltZW91dCA9IDBcbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSAxIHx8IHN0YXRlID09PSAyIHx8IHN0YXRlID09PSAzKSB7XG4gICAgICBzdGF0ZSA9IDRcbiAgICAgIHhoci5vbmxvYWQgPSBrXG4gICAgICB4aHIub25lcnJvciA9IGtcbiAgICAgIHhoci5vbmFib3J0ID0ga1xuICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBrXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0ga1xuICAgICAgLy8gSUUgOCAtIDk6IFhEb21haW5SZXF1ZXN0I2Fib3J0KCkgZG9lcyBub3QgZmlyZSBhbnkgZXZlbnRcbiAgICAgIC8vIE9wZXJhIDwgMTA6IFhNTEh0dHBSZXF1ZXN0I2Fib3J0KCkgZG9lcyBub3QgZmlyZSBhbnkgZXZlbnRcbiAgICAgIHhoci5hYm9ydCgpXG4gICAgICBpZiAodGltZW91dCAhPT0gMCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICAgICAgdGltZW91dCA9IDBcbiAgICAgIH1cbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHRoYXQucmVhZHlTdGF0ZSA9IDRcbiAgICAgICAgdGhhdC5vbnJlYWR5c3RhdGVjaGFuZ2UoKVxuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZSA9IDBcbiAgfVxuXG4gIHZhciBvblN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzdGF0ZSA9PT0gMSkge1xuICAgICAgLy8gc3RhdGUgPSAyO1xuICAgICAgdmFyIHN0YXR1cyA9IDBcbiAgICAgIHZhciBzdGF0dXNUZXh0ID0gJydcbiAgICAgIHZhciBjb250ZW50VHlwZSA9IHVuZGVmaW5lZFxuICAgICAgaWYgKCEoJ2NvbnRlbnRUeXBlJyBpbiB4aHIpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhdHVzID0geGhyLnN0YXR1c1xuICAgICAgICAgIHN0YXR1c1RleHQgPSB4aHIuc3RhdHVzVGV4dFxuICAgICAgICAgIGNvbnRlbnRUeXBlID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIC8vIElFIDwgMTAgdGhyb3dzIGV4Y2VwdGlvbiBmb3IgYHhoci5zdGF0dXNgIHdoZW4geGhyLnJlYWR5U3RhdGUgPT09IDIgfHwgeGhyLnJlYWR5U3RhdGUgPT09IDNcbiAgICAgICAgICAvLyBPcGVyYSA8IDExIHRocm93cyBleGNlcHRpb24gZm9yIGB4aHIuc3RhdHVzYCB3aGVuIHhoci5yZWFkeVN0YXRlID09PSAyXG4gICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MTIxXG4gICAgICAgICAgc3RhdHVzID0gMFxuICAgICAgICAgIHN0YXR1c1RleHQgPSAnJ1xuICAgICAgICAgIGNvbnRlbnRUeXBlID0gdW5kZWZpbmVkXG4gICAgICAgICAgLy8gRmlyZWZveCA8IDE0LCBDaHJvbWUgPywgU2FmYXJpID9cbiAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Mjk2NThcbiAgICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Nzc4NTRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gMjAwXG4gICAgICAgIHN0YXR1c1RleHQgPSAnT0snXG4gICAgICAgIGNvbnRlbnRUeXBlID0geGhyLmNvbnRlbnRUeXBlXG4gICAgICB9XG4gICAgICBpZiAoc3RhdHVzICE9PSAwKSB7XG4gICAgICAgIHN0YXRlID0gMlxuICAgICAgICB0aGF0LnJlYWR5U3RhdGUgPSAyXG4gICAgICAgIHRoYXQuc3RhdHVzID0gc3RhdHVzXG4gICAgICAgIHRoYXQuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHRcbiAgICAgICAgdGhhdC5fY29udGVudFR5cGUgPSBjb250ZW50VHlwZVxuICAgICAgICB0aGF0Lm9ucmVhZHlzdGF0ZWNoYW5nZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBvblByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIG9uU3RhcnQoKVxuICAgIGlmIChzdGF0ZSA9PT0gMiB8fCBzdGF0ZSA9PT0gMykge1xuICAgICAgc3RhdGUgPSAzXG4gICAgICB2YXIgcmVzcG9uc2VUZXh0ID0gJydcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlVGV4dCA9IHhoci5yZXNwb25zZVRleHRcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElFIDggLSA5IHdpdGggWE1MSHR0cFJlcXVlc3RcbiAgICAgIH1cbiAgICAgIHRoYXQucmVhZHlTdGF0ZSA9IDNcbiAgICAgIHRoYXQucmVzcG9uc2VUZXh0ID0gcmVzcG9uc2VUZXh0XG4gICAgICB0aGF0Lm9ucHJvZ3Jlc3MoKVxuICAgIH1cbiAgfVxuICB2YXIgb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRmlyZWZveCA1MiBmaXJlcyBcInJlYWR5c3RhdGVjaGFuZ2VcIiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHdpdGhvdXQgZmluYWwgXCJyZWFkeXN0YXRlY2hhbmdlXCIgKHhoci5yZWFkeVN0YXRlID09PSAzKVxuICAgIC8vIElFIDggZmlyZXMgXCJvbmxvYWRcIiB3aXRob3V0IFwib25wcm9ncmVzc1wiXG4gICAgb25Qcm9ncmVzcygpXG4gICAgaWYgKHN0YXRlID09PSAxIHx8IHN0YXRlID09PSAyIHx8IHN0YXRlID09PSAzKSB7XG4gICAgICBzdGF0ZSA9IDRcbiAgICAgIGlmICh0aW1lb3V0ICE9PSAwKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgICAgICB0aW1lb3V0ID0gMFxuICAgICAgfVxuICAgICAgdGhhdC5yZWFkeVN0YXRlID0gNFxuICAgICAgdGhhdC5vbnJlYWR5c3RhdGVjaGFuZ2UoKVxuICAgIH1cbiAgfVxuICB2YXIgb25SZWFkeVN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh4aHIgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBPcGVyYSAxMlxuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIG9uRmluaXNoKClcbiAgICAgIH0gZWxzZSBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDMpIHtcbiAgICAgICAgb25Qcm9ncmVzcygpXG4gICAgICB9IGVsc2UgaWYgKHhoci5yZWFkeVN0YXRlID09PSAyKSB7XG4gICAgICAgIG9uU3RhcnQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgb25UaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uVGltZW91dCgpXG4gICAgfSwgNTAwKVxuICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gMykge1xuICAgICAgb25Qcm9ncmVzcygpXG4gICAgfVxuICB9XG5cbiAgLy8gWERvbWFpblJlcXVlc3QjYWJvcnQgcmVtb3ZlcyBvbnByb2dyZXNzLCBvbmVycm9yLCBvbmxvYWRcbiAgeGhyLm9ubG9hZCA9IG9uRmluaXNoXG4gIHhoci5vbmVycm9yID0gb25GaW5pc2hcbiAgLy8gaW1wcm9wZXIgZml4IHRvIG1hdGNoIEZpcmVmb3ggYmVoYXZpb3IsIGJ1dCBpdCBpcyBiZXR0ZXIgdGhhbiBqdXN0IGlnbm9yZSBhYm9ydFxuICAvLyBzZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzY4NTk2XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4MDIwMFxuICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTUzNTcwXG4gIC8vIElFIDggZmlyZXMgXCJvbmxvYWRcIiB3aXRob3V0IFwib25wcm9ncmVzc1xuICB4aHIub25hYm9ydCA9IG9uRmluaXNoXG5cbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NzM2NzIzXG4gIGlmIChcbiAgICAhKCdzZW5kQXNCaW5hcnknIGluIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZSkgJiZcbiAgICAhKCdtb3pBbm9uJyBpbiBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUpXG4gICkge1xuICAgIHhoci5vbnByb2dyZXNzID0gb25Qcm9ncmVzc1xuICB9XG5cbiAgLy8gSUUgOCAtIDkgKFhNTEhUVFBSZXF1ZXN0KVxuICAvLyBPcGVyYSA8IDEyXG4gIC8vIEZpcmVmb3ggPCAzLjVcbiAgLy8gRmlyZWZveCAzLjUgLSAzLjYgLSA/IDwgOS4wXG4gIC8vIG9ucHJvZ3Jlc3MgaXMgbm90IGZpcmVkIHNvbWV0aW1lcyBvciBkZWxheWVkXG4gIC8vIHNlZSBhbHNvICM2NFxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gb25SZWFkeVN0YXRlQ2hhbmdlXG5cbiAgaWYgKCdjb250ZW50VHlwZScgaW4geGhyKSB7XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyAncGFkZGluZz10cnVlJ1xuICB9XG4gIHhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKVxuXG4gIGlmICgncmVhZHlTdGF0ZScgaW4geGhyKSB7XG4gICAgLy8gd29ya2Fyb3VuZCBmb3IgT3BlcmEgMTIgaXNzdWUgd2l0aCBcInByb2dyZXNzXCIgZXZlbnRzXG4gICAgLy8gIzkxXG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgb25UaW1lb3V0KClcbiAgICB9LCAwKVxuICB9XG59XG5YSFJXcmFwcGVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYWJvcnQoZmFsc2UpXG59XG5YSFJXcmFwcGVyLnByb3RvdHlwZS5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB0aGlzLl9jb250ZW50VHlwZVxufVxuWEhSV3JhcHBlci5wcm90b3R5cGUuc2V0UmVxdWVzdEhlYWRlciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICB2YXIgeGhyID0gdGhpcy5feGhyXG4gIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4geGhyKSB7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpXG4gIH1cbn1cblhIUldyYXBwZXIucHJvdG90eXBlLmdldEFsbFJlc3BvbnNlSGVhZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3hoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMgIT0gdW5kZWZpbmVkXG4gICAgPyB0aGlzLl94aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICA6ICcnXG59XG5YSFJXcmFwcGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICAvLyBsb2FkaW5nIGluZGljYXRvciBpbiBTYWZhcmkgPCA/ICg2KSwgQ2hyb21lIDwgMTQsIEZpcmVmb3hcbiAgaWYgKFxuICAgICEoJ29udGltZW91dCcgaW4gWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlKSAmJlxuICAgIGRvY3VtZW50ICE9IHVuZGVmaW5lZCAmJlxuICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgIT0gdW5kZWZpbmVkICYmXG4gICAgZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJ1xuICApIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICB0aGF0Ll9zZW5kVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC5fc2VuZFRpbWVvdXQgPSAwXG4gICAgICB0aGF0LnNlbmQoKVxuICAgIH0sIDQpXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgeGhyID0gdGhpcy5feGhyXG4gIC8vIHdpdGhDcmVkZW50aWFscyBzaG91bGQgYmUgc2V0IGFmdGVyIFwib3BlblwiIGZvciBTYWZhcmkgYW5kIENocm9tZSAoPCAxOSA/KVxuICB4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHNcbiAgeGhyLnJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlXG4gIHRyeSB7XG4gICAgLy8geGhyLnNlbmQoKTsgdGhyb3dzIFwiTm90IGVub3VnaCBhcmd1bWVudHNcIiBpbiBGaXJlZm94IDMuMFxuICAgIHhoci5zZW5kKHVuZGVmaW5lZClcbiAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgLy8gU2FmYXJpIDUuMS43LCBPcGVyYSAxMlxuICAgIHRocm93IGVycm9yMVxuICB9XG59XG5cbmZ1bmN0aW9uIHRvTG93ZXJDYXNlKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSgvW0EtWl0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjLmNoYXJDb2RlQXQoMCkgKyAweDIwKVxuICB9KVxufVxuXG5mdW5jdGlvbiBIZWFkZXJzUG9seWZpbGwoYWxsKSB7XG4gIC8vIEdldCBoZWFkZXJzOiBpbXBsZW1lbnRlZCBhY2NvcmRpbmcgdG8gbW96aWxsYSdzIGV4YW1wbGUgY29kZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L2dldEFsbFJlc3BvbnNlSGVhZGVycyNFeGFtcGxlXG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHZhciBhcnJheSA9IGFsbC5zcGxpdCgnXFxyXFxuJylcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBsaW5lID0gYXJyYXlbaV1cbiAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6ICcpXG4gICAgdmFyIG5hbWUgPSBwYXJ0cy5zaGlmdCgpXG4gICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOiAnKVxuICAgIG1hcFt0b0xvd2VyQ2FzZShuYW1lKV0gPSB2YWx1ZVxuICB9XG4gIHRoaXMuX21hcCA9IG1hcFxufVxuSGVhZGVyc1BvbHlmaWxsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gdGhpcy5fbWFwW3RvTG93ZXJDYXNlKG5hbWUpXVxufVxuXG5mdW5jdGlvbiBYSFJUcmFuc3BvcnQoKSB7fVxuXG5YSFJUcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoXG4gIHhocixcbiAgb25TdGFydENhbGxiYWNrLFxuICBvblByb2dyZXNzQ2FsbGJhY2ssXG4gIG9uRmluaXNoQ2FsbGJhY2ssXG4gIHVybCxcbiAgd2l0aENyZWRlbnRpYWxzLFxuICBoZWFkZXJzXG4pIHtcbiAgeGhyLm9wZW4oJ0dFVCcsIHVybClcbiAgdmFyIG9mZnNldCA9IDBcbiAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3BvbnNlVGV4dCA9IHhoci5yZXNwb25zZVRleHRcbiAgICB2YXIgY2h1bmsgPSByZXNwb25zZVRleHQuc2xpY2Uob2Zmc2V0KVxuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGhcbiAgICBvblByb2dyZXNzQ2FsbGJhY2soY2h1bmspXG4gIH1cbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDIpIHtcbiAgICAgIHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzXG4gICAgICB2YXIgc3RhdHVzVGV4dCA9IHhoci5zdGF0dXNUZXh0XG4gICAgICB2YXIgY29udGVudFR5cGUgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpXG4gICAgICB2YXIgaGVhZGVycyA9IHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuICAgICAgb25TdGFydENhbGxiYWNrKFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQsXG4gICAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgICBuZXcgSGVhZGVyc1BvbHlmaWxsKGhlYWRlcnMpLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgeGhyLmFib3J0KClcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgIG9uRmluaXNoQ2FsbGJhY2soKVxuICAgIH1cbiAgfVxuICB4aHIud2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzXG4gIHhoci5yZXNwb25zZVR5cGUgPSAndGV4dCdcbiAgZm9yICh2YXIgbmFtZSBpbiBoZWFkZXJzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoZWFkZXJzLCBuYW1lKSkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgaGVhZGVyc1tuYW1lXSlcbiAgICB9XG4gIH1cbiAgeGhyLnNlbmQoKVxufVxuXG5mdW5jdGlvbiBIZWFkZXJzV3JhcHBlcihoZWFkZXJzKSB7XG4gIHRoaXMuX2hlYWRlcnMgPSBoZWFkZXJzXG59XG5IZWFkZXJzV3JhcHBlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuX2hlYWRlcnMuZ2V0KG5hbWUpXG59XG5cbmZ1bmN0aW9uIEZldGNoVHJhbnNwb3J0KCkge31cblxuRmV0Y2hUcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoXG4gIHhocixcbiAgb25TdGFydENhbGxiYWNrLFxuICBvblByb2dyZXNzQ2FsbGJhY2ssXG4gIG9uRmluaXNoQ2FsbGJhY2ssXG4gIHVybCxcbiAgd2l0aENyZWRlbnRpYWxzLFxuICBoZWFkZXJzXG4pIHtcbiAgdmFyIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgdmFyIHNpZ25hbCA9IGNvbnRyb2xsZXIuc2lnbmFsIC8vIHNlZSAjMTIwXG4gIHZhciB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG4gIGZldGNoKHVybCwge1xuICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgY3JlZGVudGlhbHM6IHdpdGhDcmVkZW50aWFscyA/ICdpbmNsdWRlJyA6ICdzYW1lLW9yaWdpbicsXG4gICAgc2lnbmFsOiBzaWduYWwsXG4gICAgY2FjaGU6ICduby1zdG9yZScsXG4gIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICB2YXIgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKVxuICAgICAgb25TdGFydENhbGxiYWNrKFxuICAgICAgICByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSxcbiAgICAgICAgbmV3IEhlYWRlcnNXcmFwcGVyKHJlc3BvbnNlLmhlYWRlcnMpLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpXG4gICAgICAgICAgcmVhZGVyLmNhbmNlbCgpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZWFkTmV4dENodW5rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlYWRlclxuICAgICAgICAgICAgLnJlYWQoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBieXRlcyBpbiB0ZXh0RGVjb2RlciBhcmUgaWdub3JlZFxuICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjaHVuayA9IHRleHREZWNvZGVyLmRlY29kZShyZXN1bHQudmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzc0NhbGxiYWNrKGNodW5rKVxuICAgICAgICAgICAgICAgIHJlYWROZXh0Q2h1bmsoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgWydjYXRjaCddKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHJlYWROZXh0Q2h1bmsoKVxuICAgICAgfSlcbiAgICB9KVxuICAgIC50aGVuKFxuICAgICAgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBvbkZpbmlzaENhbGxiYWNrKClcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBvbkZpbmlzaENhbGxiYWNrKClcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKVxuICAgICAgfVxuICAgIClcbn1cblxuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gIHRoaXMuX2xpc3RlbmVycyA9IE9iamVjdC5jcmVhdGUobnVsbClcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihlKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHRocm93IGVcbiAgfSwgMClcbn1cblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgZXZlbnQudGFyZ2V0ID0gdGhpc1xuICB2YXIgdHlwZUxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldmVudC50eXBlXVxuICBpZiAodHlwZUxpc3RlbmVycyAhPSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbGVuZ3RoID0gdHlwZUxpc3RlbmVycy5sZW5ndGhcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSB0eXBlTGlzdGVuZXJzW2ldXG4gICAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyLmhhbmRsZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbGlzdGVuZXIuaGFuZGxlRXZlbnQoZXZlbnQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudClcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvd0Vycm9yKGUpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuICB0eXBlID0gU3RyaW5nKHR5cGUpXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNcbiAgdmFyIHR5cGVMaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbdHlwZV1cbiAgaWYgKHR5cGVMaXN0ZW5lcnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgdHlwZUxpc3RlbmVycyA9IFtdXG4gICAgbGlzdGVuZXJzW3R5cGVdID0gdHlwZUxpc3RlbmVyc1xuICB9XG4gIHZhciBmb3VuZCA9IGZhbHNlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZUxpc3RlbmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmICh0eXBlTGlzdGVuZXJzW2ldID09PSBsaXN0ZW5lcikge1xuICAgICAgZm91bmQgPSB0cnVlXG4gICAgfVxuICB9XG4gIGlmICghZm91bmQpIHtcbiAgICB0eXBlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpXG4gIH1cbn1cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHR5cGUgPSBTdHJpbmcodHlwZSlcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1xuICB2YXIgdHlwZUxpc3RlbmVycyA9IGxpc3RlbmVyc1t0eXBlXVxuICBpZiAodHlwZUxpc3RlbmVycyAhPSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZmlsdGVyZWQgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZUxpc3RlbmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKHR5cGVMaXN0ZW5lcnNbaV0gIT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGZpbHRlcmVkLnB1c2godHlwZUxpc3RlbmVyc1tpXSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpbHRlcmVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIGxpc3RlbmVyc1t0eXBlXVxuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBmaWx0ZXJlZFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBFdmVudCh0eXBlKSB7XG4gIHRoaXMudHlwZSA9IHR5cGVcbiAgdGhpcy50YXJnZXQgPSB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gTWVzc2FnZUV2ZW50KHR5cGUsIG9wdGlvbnMpIHtcbiAgRXZlbnQuY2FsbCh0aGlzLCB0eXBlKVxuICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGFcbiAgdGhpcy5sYXN0RXZlbnRJZCA9IG9wdGlvbnMubGFzdEV2ZW50SWRcbn1cblxuTWVzc2FnZUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKVxuXG5mdW5jdGlvbiBDb25uZWN0aW9uRXZlbnQodHlwZSwgb3B0aW9ucykge1xuICBFdmVudC5jYWxsKHRoaXMsIHR5cGUpXG4gIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXNcbiAgdGhpcy5zdGF0dXNUZXh0ID0gb3B0aW9ucy5zdGF0dXNUZXh0XG4gIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVyc1xufVxuXG5Db25uZWN0aW9uRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudC5wcm90b3R5cGUpXG5cbnZhciBXQUlUSU5HID0gLTFcbnZhciBDT05ORUNUSU5HID0gMFxudmFyIE9QRU4gPSAxXG52YXIgQ0xPU0VEID0gMlxuXG52YXIgQUZURVJfQ1IgPSAtMVxudmFyIEZJRUxEX1NUQVJUID0gMFxudmFyIEZJRUxEID0gMVxudmFyIFZBTFVFX1NUQVJUID0gMlxudmFyIFZBTFVFID0gM1xuXG52YXIgY29udGVudFR5cGVSZWdFeHAgPSAvXnRleHRcXC9ldmVudFxcLXN0cmVhbTs/KFxccypjaGFyc2V0XFw9dXRmXFwtOCk/JC9pXG5cbnZhciBNSU5JTVVNX0RVUkFUSU9OID0gMTAwMFxudmFyIE1BWElNVU1fRFVSQVRJT04gPSAxODAwMDAwMFxuXG52YXIgcGFyc2VEdXJhdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVmKSB7XG4gIHZhciBuID0gcGFyc2VJbnQodmFsdWUsIDEwKVxuICBpZiAobiAhPT0gbikge1xuICAgIG4gPSBkZWZcbiAgfVxuICByZXR1cm4gY2xhbXBEdXJhdGlvbihuKVxufVxudmFyIGNsYW1wRHVyYXRpb24gPSBmdW5jdGlvbiAobikge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgTUlOSU1VTV9EVVJBVElPTiksIE1BWElNVU1fRFVSQVRJT04pXG59XG5cbnZhciBmaXJlID0gZnVuY3Rpb24gKHRoYXQsIGYsIGV2ZW50KSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmLmNhbGwodGhhdCwgZXZlbnQpXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3dFcnJvcihlKVxuICB9XG59XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlUG9seWZpbGwodXJsLCBvcHRpb25zKSB7XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcylcblxuICB0aGlzLm9ub3BlbiA9IHVuZGVmaW5lZFxuICB0aGlzLm9ubWVzc2FnZSA9IHVuZGVmaW5lZFxuICB0aGlzLm9uZXJyb3IgPSB1bmRlZmluZWRcblxuICB0aGlzLnVybCA9IHVuZGVmaW5lZFxuICB0aGlzLnJlYWR5U3RhdGUgPSB1bmRlZmluZWRcbiAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSB1bmRlZmluZWRcblxuICB0aGlzLl9jbG9zZSA9IHVuZGVmaW5lZFxuXG4gIHN0YXJ0KHRoaXMsIHVybCwgb3B0aW9ucylcbn1cblxudmFyIGlzRmV0Y2hTdXBwb3J0ZWQgPVxuICBmZXRjaCAhPSB1bmRlZmluZWQgJiYgUmVzcG9uc2UgIT0gdW5kZWZpbmVkICYmICdib2R5JyBpbiBSZXNwb25zZS5wcm90b3R5cGVcblxuZnVuY3Rpb24gc3RhcnQoZXMsIHVybCwgb3B0aW9ucykge1xuICB1cmwgPSBTdHJpbmcodXJsKVxuICB2YXIgd2l0aENyZWRlbnRpYWxzID0gb3B0aW9ucyAhPSB1bmRlZmluZWQgJiYgQm9vbGVhbihvcHRpb25zLndpdGhDcmVkZW50aWFscylcblxuICB2YXIgaW5pdGlhbFJldHJ5ID0gY2xhbXBEdXJhdGlvbigxMDAwKVxuICB2YXIgaGVhcnRiZWF0VGltZW91dCA9XG4gICAgb3B0aW9ucyAhPSB1bmRlZmluZWQgJiYgb3B0aW9ucy5oZWFydGJlYXRUaW1lb3V0ICE9IHVuZGVmaW5lZFxuICAgICAgPyBwYXJzZUR1cmF0aW9uKG9wdGlvbnMuaGVhcnRiZWF0VGltZW91dCwgNDUwMDApXG4gICAgICA6IGNsYW1wRHVyYXRpb24oNDUwMDApXG5cbiAgdmFyIGxhc3RFdmVudElkID0gJydcbiAgdmFyIHJldHJ5ID0gaW5pdGlhbFJldHJ5XG4gIHZhciB3YXNBY3Rpdml0eSA9IGZhbHNlXG4gIHZhciBoZWFkZXJzID1cbiAgICBvcHRpb25zICE9IHVuZGVmaW5lZCAmJiBvcHRpb25zLmhlYWRlcnMgIT0gdW5kZWZpbmVkXG4gICAgICA/IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5oZWFkZXJzKSlcbiAgICAgIDogdW5kZWZpbmVkXG4gIHZhciBDdXJyZW50VHJhbnNwb3J0ID1cbiAgICBvcHRpb25zICE9IHVuZGVmaW5lZCAmJiBvcHRpb25zLlRyYW5zcG9ydCAhPSB1bmRlZmluZWRcbiAgICAgID8gb3B0aW9ucy5UcmFuc3BvcnRcbiAgICAgIDogWE1MSHR0cFJlcXVlc3RcbiAgdmFyIHhociA9XG4gICAgaXNGZXRjaFN1cHBvcnRlZCAmJlxuICAgICEob3B0aW9ucyAhPSB1bmRlZmluZWQgJiYgb3B0aW9ucy5UcmFuc3BvcnQgIT0gdW5kZWZpbmVkKVxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogbmV3IFhIUldyYXBwZXIobmV3IEN1cnJlbnRUcmFuc3BvcnQoKSlcbiAgdmFyIHRyYW5zcG9ydCA9IHhociA9PSB1bmRlZmluZWQgPyBuZXcgRmV0Y2hUcmFuc3BvcnQoKSA6IG5ldyBYSFJUcmFuc3BvcnQoKVxuICB2YXIgY2FuY2VsRnVuY3Rpb24gPSB1bmRlZmluZWRcbiAgdmFyIHRpbWVvdXQgPSAwXG4gIHZhciBjdXJyZW50U3RhdGUgPSBXQUlUSU5HXG4gIHZhciBkYXRhQnVmZmVyID0gJydcbiAgdmFyIGxhc3RFdmVudElkQnVmZmVyID0gJydcbiAgdmFyIGV2ZW50VHlwZUJ1ZmZlciA9ICcnXG5cbiAgdmFyIHRleHRCdWZmZXIgPSAnJ1xuICB2YXIgc3RhdGUgPSBGSUVMRF9TVEFSVFxuICB2YXIgZmllbGRTdGFydCA9IDBcbiAgdmFyIHZhbHVlU3RhcnQgPSAwXG5cbiAgdmFyIG9uU3RhcnQgPSBmdW5jdGlvbiAoc3RhdHVzLCBzdGF0dXNUZXh0LCBjb250ZW50VHlwZSwgaGVhZGVycywgY2FuY2VsKSB7XG4gICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gQ09OTkVDVElORykge1xuICAgICAgY2FuY2VsRnVuY3Rpb24gPSBjYW5jZWxcbiAgICAgIGlmIChcbiAgICAgICAgc3RhdHVzID09PSAyMDAgJiZcbiAgICAgICAgY29udGVudFR5cGUgIT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGNvbnRlbnRUeXBlUmVnRXhwLnRlc3QoY29udGVudFR5cGUpXG4gICAgICApIHtcbiAgICAgICAgY3VycmVudFN0YXRlID0gT1BFTlxuICAgICAgICB3YXNBY3Rpdml0eSA9IHRydWVcbiAgICAgICAgcmV0cnkgPSBpbml0aWFsUmV0cnlcbiAgICAgICAgZXMucmVhZHlTdGF0ZSA9IE9QRU5cbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IENvbm5lY3Rpb25FdmVudCgnb3BlbicsIHtcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiBzdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIH0pXG4gICAgICAgIGVzLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gICAgICAgIGZpcmUoZXMsIGVzLm9ub3BlbiwgZXZlbnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICcnXG4gICAgICAgIGlmIChzdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgIGlmIChzdGF0dXNUZXh0KSB7XG4gICAgICAgICAgICBzdGF0dXNUZXh0ID0gc3RhdHVzVGV4dC5yZXBsYWNlKC9cXHMrL2csICcgJylcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgICBcIkV2ZW50U291cmNlJ3MgcmVzcG9uc2UgaGFzIGEgc3RhdHVzIFwiICtcbiAgICAgICAgICAgIHN0YXR1cyArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgc3RhdHVzVGV4dCArXG4gICAgICAgICAgICAnIHRoYXQgaXMgbm90IDIwMC4gQWJvcnRpbmcgdGhlIGNvbm5lY3Rpb24uJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAgICAgXCJFdmVudFNvdXJjZSdzIHJlc3BvbnNlIGhhcyBhIENvbnRlbnQtVHlwZSBzcGVjaWZ5aW5nIGFuIHVuc3VwcG9ydGVkIHR5cGU6IFwiICtcbiAgICAgICAgICAgIChjb250ZW50VHlwZSA9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAnLSdcbiAgICAgICAgICAgICAgOiBjb250ZW50VHlwZS5yZXBsYWNlKC9cXHMrL2csICcgJykpICtcbiAgICAgICAgICAgICcuIEFib3J0aW5nIHRoZSBjb25uZWN0aW9uLidcbiAgICAgICAgfVxuICAgICAgICB0aHJvd0Vycm9yKG5ldyBFcnJvcihtZXNzYWdlKSlcbiAgICAgICAgY2xvc2UoKVxuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ29ubmVjdGlvbkV2ZW50KCdlcnJvcicsIHtcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiBzdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIH0pXG4gICAgICAgIGVzLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gICAgICAgIGZpcmUoZXMsIGVzLm9uZXJyb3IsIGV2ZW50KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBvblByb2dyZXNzID0gZnVuY3Rpb24gKHRleHRDaHVuaykge1xuICAgIGlmIChjdXJyZW50U3RhdGUgPT09IE9QRU4pIHtcbiAgICAgIHZhciBuID0gLTFcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dENodW5rLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjID0gdGV4dENodW5rLmNoYXJDb2RlQXQoaSlcbiAgICAgICAgaWYgKGMgPT09ICdcXG4nLmNoYXJDb2RlQXQoMCkgfHwgYyA9PT0gJ1xccicuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAgIG4gPSBpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaHVuayA9IChuICE9PSAtMSA/IHRleHRCdWZmZXIgOiAnJykgKyB0ZXh0Q2h1bmsuc2xpY2UoMCwgbiArIDEpXG4gICAgICB0ZXh0QnVmZmVyID0gKG4gPT09IC0xID8gdGV4dEJ1ZmZlciA6ICcnKSArIHRleHRDaHVuay5zbGljZShuICsgMSlcbiAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgd2FzQWN0aXZpdHkgPSB0cnVlXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBwb3NpdGlvbiA9IDA7IHBvc2l0aW9uIDwgY2h1bmsubGVuZ3RoOyBwb3NpdGlvbiArPSAxKSB7XG4gICAgICAgIHZhciBjID0gY2h1bmsuY2hhckNvZGVBdChwb3NpdGlvbilcbiAgICAgICAgaWYgKHN0YXRlID09PSBBRlRFUl9DUiAmJiBjID09PSAnXFxuJy5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgc3RhdGUgPSBGSUVMRF9TVEFSVFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gQUZURVJfQ1IpIHtcbiAgICAgICAgICAgIHN0YXRlID0gRklFTERfU1RBUlRcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGMgPT09ICdcXHInLmNoYXJDb2RlQXQoMCkgfHwgYyA9PT0gJ1xcbicuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlICE9PSBGSUVMRF9TVEFSVCkge1xuICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IEZJRUxEKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVTdGFydCA9IHBvc2l0aW9uICsgMVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBmaWVsZCA9IGNodW5rLnNsaWNlKGZpZWxkU3RhcnQsIHZhbHVlU3RhcnQgLSAxKVxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjaHVuay5zbGljZShcbiAgICAgICAgICAgICAgICB2YWx1ZVN0YXJ0ICtcbiAgICAgICAgICAgICAgICAgICh2YWx1ZVN0YXJ0IDwgcG9zaXRpb24gJiZcbiAgICAgICAgICAgICAgICAgIGNodW5rLmNoYXJDb2RlQXQodmFsdWVTdGFydCkgPT09ICcgJy5jaGFyQ29kZUF0KDApXG4gICAgICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgICAgICA6IDApLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgaWYgKGZpZWxkID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgICAgICBkYXRhQnVmZmVyICs9ICdcXG4nXG4gICAgICAgICAgICAgICAgZGF0YUJ1ZmZlciArPSB2YWx1ZVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkID09PSAnaWQnKSB7XG4gICAgICAgICAgICAgICAgbGFzdEV2ZW50SWRCdWZmZXIgPSB2YWx1ZVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkID09PSAnZXZlbnQnKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRUeXBlQnVmZmVyID0gdmFsdWVcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZCA9PT0gJ3JldHJ5Jykge1xuICAgICAgICAgICAgICAgIGluaXRpYWxSZXRyeSA9IHBhcnNlRHVyYXRpb24odmFsdWUsIGluaXRpYWxSZXRyeSlcbiAgICAgICAgICAgICAgICByZXRyeSA9IGluaXRpYWxSZXRyeVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkID09PSAnaGVhcnRiZWF0VGltZW91dCcpIHtcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRUaW1lb3V0ID0gcGFyc2VEdXJhdGlvbih2YWx1ZSwgaGVhcnRiZWF0VGltZW91dClcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uVGltZW91dCgpXG4gICAgICAgICAgICAgICAgICB9LCBoZWFydGJlYXRUaW1lb3V0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBGSUVMRF9TVEFSVCkge1xuICAgICAgICAgICAgICBpZiAoZGF0YUJ1ZmZlciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBsYXN0RXZlbnRJZCA9IGxhc3RFdmVudElkQnVmZmVyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50VHlwZUJ1ZmZlciA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZUJ1ZmZlciA9ICdtZXNzYWdlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KGV2ZW50VHlwZUJ1ZmZlciwge1xuICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YUJ1ZmZlci5zbGljZSgxKSxcbiAgICAgICAgICAgICAgICAgIGxhc3RFdmVudElkOiBsYXN0RXZlbnRJZEJ1ZmZlcixcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIGVzLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50VHlwZUJ1ZmZlciA9PT0gJ21lc3NhZ2UnKSB7XG4gICAgICAgICAgICAgICAgICBmaXJlKGVzLCBlcy5vbm1lc3NhZ2UsIGV2ZW50KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSBDTE9TRUQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhQnVmZmVyID0gJydcbiAgICAgICAgICAgICAgZXZlbnRUeXBlQnVmZmVyID0gJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlID0gYyA9PT0gJ1xccicuY2hhckNvZGVBdCgwKSA/IEFGVEVSX0NSIDogRklFTERfU1RBUlRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBGSUVMRF9TVEFSVCkge1xuICAgICAgICAgICAgICBmaWVsZFN0YXJ0ID0gcG9zaXRpb25cbiAgICAgICAgICAgICAgc3RhdGUgPSBGSUVMRFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBGSUVMRCkge1xuICAgICAgICAgICAgICBpZiAoYyA9PT0gJzonLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVN0YXJ0ID0gcG9zaXRpb24gKyAxXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBWQUxVRV9TVEFSVFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBWQUxVRV9TVEFSVCkge1xuICAgICAgICAgICAgICBzdGF0ZSA9IFZBTFVFXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG9uRmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjdXJyZW50U3RhdGUgPT09IE9QRU4gfHwgY3VycmVudFN0YXRlID09PSBDT05ORUNUSU5HKSB7XG4gICAgICBjdXJyZW50U3RhdGUgPSBXQUlUSU5HXG4gICAgICBpZiAodGltZW91dCAhPT0gMCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICAgICAgdGltZW91dCA9IDBcbiAgICAgIH1cbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb25UaW1lb3V0KClcbiAgICAgIH0sIHJldHJ5KVxuICAgICAgcmV0cnkgPSBjbGFtcER1cmF0aW9uKE1hdGgubWluKGluaXRpYWxSZXRyeSAqIDE2LCByZXRyeSAqIDIpKVxuXG4gICAgICBlcy5yZWFkeVN0YXRlID0gQ09OTkVDVElOR1xuICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdlcnJvcicpXG4gICAgICBlcy5kaXNwYXRjaEV2ZW50KGV2ZW50KVxuICAgICAgZmlyZShlcywgZXMub25lcnJvciwgZXZlbnQpXG4gICAgfVxuICB9XG5cbiAgdmFyIGNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGN1cnJlbnRTdGF0ZSA9IENMT1NFRFxuICAgIGlmIChjYW5jZWxGdW5jdGlvbiAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbmNlbEZ1bmN0aW9uKClcbiAgICAgIGNhbmNlbEZ1bmN0aW9uID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIGlmICh0aW1lb3V0ICE9PSAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICAgIHRpbWVvdXQgPSAwXG4gICAgfVxuICAgIGVzLnJlYWR5U3RhdGUgPSBDTE9TRURcbiAgfVxuXG4gIHZhciBvblRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGltZW91dCA9IDBcblxuICAgIGlmIChjdXJyZW50U3RhdGUgIT09IFdBSVRJTkcpIHtcbiAgICAgIGlmICghd2FzQWN0aXZpdHkgJiYgY2FuY2VsRnVuY3Rpb24gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93RXJyb3IoXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ05vIGFjdGl2aXR5IHdpdGhpbiAnICtcbiAgICAgICAgICAgICAgaGVhcnRiZWF0VGltZW91dCArXG4gICAgICAgICAgICAgICcgbWlsbGlzZWNvbmRzLiBSZWNvbm5lY3RpbmcuJ1xuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICBjYW5jZWxGdW5jdGlvbigpXG4gICAgICAgIGNhbmNlbEZ1bmN0aW9uID0gdW5kZWZpbmVkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXNBY3Rpdml0eSA9IGZhbHNlXG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvblRpbWVvdXQoKVxuICAgICAgICB9LCBoZWFydGJlYXRUaW1lb3V0KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgd2FzQWN0aXZpdHkgPSBmYWxzZVxuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIG9uVGltZW91dCgpXG4gICAgfSwgaGVhcnRiZWF0VGltZW91dClcblxuICAgIGN1cnJlbnRTdGF0ZSA9IENPTk5FQ1RJTkdcbiAgICBkYXRhQnVmZmVyID0gJydcbiAgICBldmVudFR5cGVCdWZmZXIgPSAnJ1xuICAgIGxhc3RFdmVudElkQnVmZmVyID0gbGFzdEV2ZW50SWRcbiAgICB0ZXh0QnVmZmVyID0gJydcbiAgICBmaWVsZFN0YXJ0ID0gMFxuICAgIHZhbHVlU3RhcnQgPSAwXG4gICAgc3RhdGUgPSBGSUVMRF9TVEFSVFxuXG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDI4OTE2XG4gICAgLy8gUmVxdWVzdCBoZWFkZXIgZmllbGQgTGFzdC1FdmVudC1JRCBpcyBub3QgYWxsb3dlZCBieSBBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzLlxuICAgIHZhciByZXF1ZXN0VVJMID0gdXJsXG4gICAgaWYgKHVybC5zbGljZSgwLCA1KSAhPT0gJ2RhdGE6JyAmJiB1cmwuc2xpY2UoMCwgNSkgIT09ICdibG9iOicpIHtcbiAgICAgIGlmIChsYXN0RXZlbnRJZCAhPT0gJycpIHtcbiAgICAgICAgcmVxdWVzdFVSTCArPVxuICAgICAgICAgICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgK1xuICAgICAgICAgICdsYXN0RXZlbnRJZD0nICtcbiAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQobGFzdEV2ZW50SWQpXG4gICAgICB9XG4gICAgfVxuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IHt9XG4gICAgcmVxdWVzdEhlYWRlcnNbJ0FjY2VwdCddID0gJ3RleHQvZXZlbnQtc3RyZWFtJ1xuICAgIGlmIChoZWFkZXJzICE9IHVuZGVmaW5lZCkge1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBoZWFkZXJzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGVhZGVycywgbmFtZSkpIHtcbiAgICAgICAgICByZXF1ZXN0SGVhZGVyc1tuYW1lXSA9IGhlYWRlcnNbbmFtZV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgdHJhbnNwb3J0Lm9wZW4oXG4gICAgICAgIHhocixcbiAgICAgICAgb25TdGFydCxcbiAgICAgICAgb25Qcm9ncmVzcyxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIHJlcXVlc3RVUkwsXG4gICAgICAgIHdpdGhDcmVkZW50aWFscyxcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNcbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2xvc2UoKVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG4gIH1cblxuICBlcy51cmwgPSB1cmxcbiAgZXMucmVhZHlTdGF0ZSA9IENPTk5FQ1RJTkdcbiAgZXMud2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzXG4gIGVzLl9jbG9zZSA9IGNsb3NlXG5cbiAgb25UaW1lb3V0KClcbn1cblxuRXZlbnRTb3VyY2VQb2x5ZmlsbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50VGFyZ2V0LnByb3RvdHlwZSlcbkV2ZW50U291cmNlUG9seWZpbGwucHJvdG90eXBlLkNPTk5FQ1RJTkcgPSBDT05ORUNUSU5HXG5FdmVudFNvdXJjZVBvbHlmaWxsLnByb3RvdHlwZS5PUEVOID0gT1BFTlxuRXZlbnRTb3VyY2VQb2x5ZmlsbC5wcm90b3R5cGUuQ0xPU0VEID0gQ0xPU0VEXG5FdmVudFNvdXJjZVBvbHlmaWxsLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fY2xvc2UoKVxufVxuXG5FdmVudFNvdXJjZVBvbHlmaWxsLkNPTk5FQ1RJTkcgPSBDT05ORUNUSU5HXG5FdmVudFNvdXJjZVBvbHlmaWxsLk9QRU4gPSBPUEVOXG5FdmVudFNvdXJjZVBvbHlmaWxsLkNMT1NFRCA9IENMT1NFRFxuRXZlbnRTb3VyY2VQb2x5ZmlsbC5wcm90b3R5cGUud2l0aENyZWRlbnRpYWxzID0gdW5kZWZpbmVkXG5cbmV4cG9ydCBkZWZhdWx0IEV2ZW50U291cmNlUG9seWZpbGxcbiIsIi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZW1vdmUgTmV4dC5qcycgbm8tRk9VQyBzdHlsZXMgd29ya2Fyb3VuZCBmb3IgdXNpbmdcbi8vIGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50LiBJdCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgaHlkcmF0aW9uLCBvciBlbHNlXG4vLyByZW5kZXJpbmcgd29uJ3QgaGF2ZSB0aGUgY29ycmVjdCBjb21wdXRlZCB2YWx1ZXMgaW4gZWZmZWN0cy5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5Q29udGVudChjYWxsYmFjaykge1xuICA7KHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgc2V0VGltZW91dCkoZnVuY3Rpb24gKCkge1xuICAgIGZvciAoXG4gICAgICB2YXIgeCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLW5leHQtaGlkZS1mb3VjXScpLCBpID0geC5sZW5ndGg7XG4gICAgICBpLS07XG5cbiAgICApIHtcbiAgICAgIHhbaV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh4W2ldKVxuICAgIH1cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH0pXG59XG4iLCJpbXBvcnQgUm91dGVyIGZyb20gJ25leHQvcm91dGVyJ1xuaW1wb3J0IHsgc2V0dXBQaW5nLCBjdXJyZW50UGFnZSwgY2xvc2VQaW5nIH0gZnJvbSAnLi9vbi1kZW1hbmQtZW50cmllcy11dGlscydcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKHsgYXNzZXRQcmVmaXggfSkgPT4ge1xuICBSb3V0ZXIucmVhZHkoKCkgPT4ge1xuICAgIFJvdXRlci5ldmVudHMub24oXG4gICAgICAncm91dGVDaGFuZ2VDb21wbGV0ZScsXG4gICAgICBzZXR1cFBpbmcuYmluZCh0aGlzLCBhc3NldFByZWZpeCwgKCkgPT4gUm91dGVyLnBhdGhuYW1lKVxuICAgIClcbiAgfSlcblxuICBzZXR1cFBpbmcoYXNzZXRQcmVmaXgsICgpID0+IFJvdXRlci5wYXRobmFtZSwgY3VycmVudFBhZ2UpXG5cbiAgLy8gcHJldmVudCBITVIgY29ubmVjdGlvbiBmcm9tIGJlaW5nIGNsb3NlZCB3aGVuIHJ1bm5pbmcgdGVzdHNcbiAgaWYgKCFwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIChfZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlXG4gICAgICBpZiAoc3RhdGUgPT09ICd2aXNpYmxlJykge1xuICAgICAgICBzZXR1cFBpbmcoYXNzZXRQcmVmaXgsICgpID0+IFJvdXRlci5wYXRobmFtZSwgdHJ1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsb3NlUGluZygpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCAoKSA9PiB7XG4gICAgICBjbG9zZVBpbmcoKVxuICAgIH0pXG4gIH1cbn1cbiIsIi8qIGdsb2JhbCBsb2NhdGlvbiAqL1xuaW1wb3J0IHsgZ2V0RXZlbnRTb3VyY2VXcmFwcGVyIH0gZnJvbSAnLi9lcnJvci1vdmVybGF5L2V2ZW50c291cmNlJ1xuXG5sZXQgZXZ0U291cmNlXG5leHBvcnQgbGV0IGN1cnJlbnRQYWdlXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZVBpbmcoKSB7XG4gIGlmIChldnRTb3VyY2UpIGV2dFNvdXJjZS5jbG9zZSgpXG4gIGV2dFNvdXJjZSA9IG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldHVwUGluZyhhc3NldFByZWZpeCwgcGF0aG5hbWVGbiwgcmV0cnkpIHtcbiAgY29uc3QgcGF0aG5hbWUgPSBwYXRobmFtZUZuKClcblxuICAvLyBNYWtlIHN1cmUgdG8gb25seSBjcmVhdGUgbmV3IEV2ZW50U291cmNlIHJlcXVlc3QgaWYgcGFnZSBoYXMgY2hhbmdlZFxuICBpZiAocGF0aG5hbWUgPT09IGN1cnJlbnRQYWdlICYmICFyZXRyeSkgcmV0dXJuXG4gIGN1cnJlbnRQYWdlID0gcGF0aG5hbWVcbiAgLy8gY2xvc2UgY3VycmVudCBFdmVudFNvdXJjZSBjb25uZWN0aW9uXG4gIGNsb3NlUGluZygpXG5cbiAgY29uc3QgdXJsID0gYCR7YXNzZXRQcmVmaXh9L19uZXh0L3dlYnBhY2staG1yP3BhZ2U9JHtjdXJyZW50UGFnZX1gXG4gIGV2dFNvdXJjZSA9IGdldEV2ZW50U291cmNlV3JhcHBlcih7IHBhdGg6IHVybCwgdGltZW91dDogNTAwMCwgb25kZW1hbmQ6IDEgfSlcblxuICBldnRTb3VyY2UuYWRkTWVzc2FnZUxpc3RlbmVyKChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5kYXRhLmluZGV4T2YoJ3snKSA9PT0gLTEpIHJldHVyblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShldmVudC5kYXRhKVxuICAgICAgaWYgKHBheWxvYWQuaW52YWxpZCkge1xuICAgICAgICAvLyBQYXlsb2FkIGNhbiBiZSBpbnZhbGlkIGV2ZW4gaWYgdGhlIHBhZ2UgZG9lcyBub3QgZXhpc3QuXG4gICAgICAgIC8vIFNvLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBpdCBleGlzdHMgYmVmb3JlIHJlbG9hZGluZy5cbiAgICAgICAgZmV0Y2gobG9jYXRpb24uaHJlZiwge1xuICAgICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgICAgICB9KS50aGVuKChwYWdlUmVzKSA9PiB7XG4gICAgICAgICAgaWYgKHBhZ2VSZXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignb24tZGVtYW5kLWVudHJpZXMgZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlJywgZXJyKVxuICAgIH1cbiAgfSlcbn1cbiIsImltcG9ydCBjb25uZWN0IGZyb20gJy4vZXJyb3Itb3ZlcmxheS9ob3QtZGV2LWNsaWVudCdcblxuZXhwb3J0IGRlZmF1bHQgKHsgYXNzZXRQcmVmaXggfSkgPT4ge1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIHBhdGg6IGAke2Fzc2V0UHJlZml4fS9fbmV4dC93ZWJwYWNrLWhtcmAsXG4gIH1cblxuICBjb25zdCBkZXZDbGllbnQgPSBjb25uZWN0KG9wdGlvbnMpXG5cbiAgZGV2Q2xpZW50LnN1YnNjcmliZVRvSG1yRXZlbnQoKG9iaikgPT4ge1xuICAgIGlmIChvYmouYWN0aW9uID09PSAncmVsb2FkUGFnZScpIHtcbiAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICB9XG4gICAgaWYgKG9iai5hY3Rpb24gPT09ICdyZW1vdmVkUGFnZScpIHtcbiAgICAgIGNvbnN0IFtwYWdlXSA9IG9iai5kYXRhXG4gICAgICBpZiAocGFnZSA9PT0gd2luZG93Lm5leHQucm91dGVyLnBhdGhuYW1lKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAob2JqLmFjdGlvbiA9PT0gJ2FkZGVkUGFnZScpIHtcbiAgICAgIGNvbnN0IFtwYWdlXSA9IG9iai5kYXRhXG4gICAgICBpZiAoXG4gICAgICAgIHBhZ2UgPT09IHdpbmRvdy5uZXh0LnJvdXRlci5wYXRobmFtZSAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93Lm5leHQucm91dGVyLmNvbXBvbmVudHNbcGFnZV0gPT09ICd1bmRlZmluZWQnXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBhY3Rpb24gJyArIG9iai5hY3Rpb24pXG4gIH0pXG5cbiAgcmV0dXJuIGRldkNsaWVudFxufVxuIiwiZXhwb3J0IGNvbnN0IERPTUF0dHJpYnV0ZU5hbWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICBjbGFzc05hbWU6ICdjbGFzcycsXG4gIGh0bWxGb3I6ICdmb3InLFxuICBodHRwRXF1aXY6ICdodHRwLWVxdWl2JyxcbiAgbm9Nb2R1bGU6ICdub01vZHVsZScsXG59XG5cbmZ1bmN0aW9uIHJlYWN0RWxlbWVudFRvRE9NKHsgdHlwZSwgcHJvcHMgfTogSlNYLkVsZW1lbnQpOiBIVE1MRWxlbWVudCB7XG4gIGNvbnN0IGVsOiBIVE1MRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSlcbiAgZm9yIChjb25zdCBwIGluIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWVcbiAgICBpZiAocCA9PT0gJ2NoaWxkcmVuJyB8fCBwID09PSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnKSBjb250aW51ZVxuXG4gICAgLy8gd2UgZG9uJ3QgcmVuZGVyIHVuZGVmaW5lZCBwcm9wcyB0byB0aGUgRE9NXG4gICAgaWYgKHByb3BzW3BdID09PSB1bmRlZmluZWQpIGNvbnRpbnVlXG5cbiAgICBjb25zdCBhdHRyID0gRE9NQXR0cmlidXRlTmFtZXNbcF0gfHwgcC50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKFxuICAgICAgdHlwZSA9PT0gJ3NjcmlwdCcgJiZcbiAgICAgIChhdHRyID09PSAnYXN5bmMnIHx8IGF0dHIgPT09ICdkZWZlcicgfHwgYXR0ciA9PT0gJ25vTW9kdWxlJylcbiAgICApIHtcbiAgICAgIDsoZWwgYXMgSFRNTFNjcmlwdEVsZW1lbnQpW2F0dHJdID0gISFwcm9wc1twXVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgcHJvcHNbcF0pXG4gICAgfVxuICB9XG5cbiAgY29uc3QgeyBjaGlsZHJlbiwgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgfSA9IHByb3BzXG4gIGlmIChkYW5nZXJvdXNseVNldElubmVySFRNTCkge1xuICAgIGVsLmlubmVySFRNTCA9IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCB8fCAnJ1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuKSB7XG4gICAgZWwudGV4dENvbnRlbnQgPVxuICAgICAgdHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGNoaWxkcmVuXG4gICAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgICAgPyBjaGlsZHJlbi5qb2luKCcnKVxuICAgICAgICA6ICcnXG4gIH1cbiAgcmV0dXJuIGVsXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRzKHR5cGU6IHN0cmluZywgY29tcG9uZW50czogSlNYLkVsZW1lbnRbXSk6IHZvaWQge1xuICBjb25zdCBoZWFkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdXG4gIGNvbnN0IGhlYWRDb3VudEVsOiBIVE1MTWV0YUVsZW1lbnQgPSBoZWFkRWwucXVlcnlTZWxlY3RvcihcbiAgICAnbWV0YVtuYW1lPW5leHQtaGVhZC1jb3VudF0nXG4gICkgYXMgSFRNTE1ldGFFbGVtZW50XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKCFoZWFkQ291bnRFbCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ1dhcm5pbmc6IG5leHQtaGVhZC1jb3VudCBpcyBtaXNzaW5nLiBodHRwczovL2Vyci5zaC9uZXh0LmpzL25leHQtaGVhZC1jb3VudC1taXNzaW5nJ1xuICAgICAgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgY29uc3QgaGVhZENvdW50ID0gTnVtYmVyKGhlYWRDb3VudEVsLmNvbnRlbnQpXG4gIGNvbnN0IG9sZFRhZ3M6IEVsZW1lbnRbXSA9IFtdXG5cbiAgZm9yIChcbiAgICBsZXQgaSA9IDAsIGogPSBoZWFkQ291bnRFbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgIGkgPCBoZWFkQ291bnQ7XG4gICAgaSsrLCBqID0gaiEucHJldmlvdXNFbGVtZW50U2libGluZ1xuICApIHtcbiAgICBpZiAoaiEudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0eXBlKSB7XG4gICAgICBvbGRUYWdzLnB1c2goaiEpXG4gICAgfVxuICB9XG4gIGNvbnN0IG5ld1RhZ3MgPSAoY29tcG9uZW50cy5tYXAocmVhY3RFbGVtZW50VG9ET00pIGFzIEhUTUxFbGVtZW50W10pLmZpbHRlcihcbiAgICAobmV3VGFnKSA9PiB7XG4gICAgICBmb3IgKGxldCBrID0gMCwgbGVuID0gb2xkVGFncy5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgICAgICBjb25zdCBvbGRUYWcgPSBvbGRUYWdzW2tdXG4gICAgICAgIGlmIChvbGRUYWcuaXNFcXVhbE5vZGUobmV3VGFnKSkge1xuICAgICAgICAgIG9sZFRhZ3Muc3BsaWNlKGssIDEpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICApXG5cbiAgb2xkVGFncy5mb3JFYWNoKCh0KSA9PiB0LnBhcmVudE5vZGUhLnJlbW92ZUNoaWxkKHQpKVxuICBuZXdUYWdzLmZvckVhY2goKHQpID0+IGhlYWRFbC5pbnNlcnRCZWZvcmUodCwgaGVhZENvdW50RWwpKVxuICBoZWFkQ291bnRFbC5jb250ZW50ID0gKGhlYWRDb3VudCAtIG9sZFRhZ3MubGVuZ3RoICsgbmV3VGFncy5sZW5ndGgpLnRvU3RyaW5nKClcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdEhlYWRNYW5hZ2VyKCk6IHtcbiAgbW91bnRlZEluc3RhbmNlczogU2V0PHVua25vd24+XG4gIHVwZGF0ZUhlYWQ6IChoZWFkOiBKU1guRWxlbWVudFtdKSA9PiB2b2lkXG59IHtcbiAgbGV0IHVwZGF0ZVByb21pc2U6IFByb21pc2U8dm9pZD4gfCBudWxsID0gbnVsbFxuXG4gIHJldHVybiB7XG4gICAgbW91bnRlZEluc3RhbmNlczogbmV3IFNldCgpLFxuICAgIHVwZGF0ZUhlYWQ6IChoZWFkOiBKU1guRWxlbWVudFtdKSA9PiB7XG4gICAgICBjb25zdCBwcm9taXNlID0gKHVwZGF0ZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHByb21pc2UgIT09IHVwZGF0ZVByb21pc2UpIHJldHVyblxuXG4gICAgICAgIHVwZGF0ZVByb21pc2UgPSBudWxsXG4gICAgICAgIGNvbnN0IHRhZ3M6IFJlY29yZDxzdHJpbmcsIEpTWC5FbGVtZW50W10+ID0ge31cblxuICAgICAgICBoZWFkLmZvckVhY2goKGgpID0+IHtcbiAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gdGFnc1toLnR5cGVdIHx8IFtdXG4gICAgICAgICAgY29tcG9uZW50cy5wdXNoKGgpXG4gICAgICAgICAgdGFnc1toLnR5cGVdID0gY29tcG9uZW50c1xuICAgICAgICB9KVxuXG4gICAgICAgIGNvbnN0IHRpdGxlQ29tcG9uZW50ID0gdGFncy50aXRsZSA/IHRhZ3MudGl0bGVbMF0gOiBudWxsXG4gICAgICAgIGxldCB0aXRsZSA9ICcnXG4gICAgICAgIGlmICh0aXRsZUNvbXBvbmVudCkge1xuICAgICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRpdGxlQ29tcG9uZW50LnByb3BzXG4gICAgICAgICAgdGl0bGUgPVxuICAgICAgICAgICAgdHlwZW9mIGNoaWxkcmVuID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICA/IGNoaWxkcmVuXG4gICAgICAgICAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgICAgICAgICAgPyBjaGlsZHJlbi5qb2luKCcnKVxuICAgICAgICAgICAgICA6ICcnXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpdGxlICE9PSBkb2N1bWVudC50aXRsZSkgZG9jdW1lbnQudGl0bGUgPSB0aXRsZVxuICAgICAgICA7WydtZXRhJywgJ2Jhc2UnLCAnbGluaycsICdzdHlsZScsICdzY3JpcHQnXS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgICAgdXBkYXRlRWxlbWVudHModHlwZSwgdGFnc1t0eXBlXSB8fCBbXSlcbiAgICAgICAgfSlcbiAgICAgIH0pKVxuICAgIH0sXG4gIH1cbn1cbiIsIi8qIGdsb2JhbCBsb2NhdGlvbiAqL1xuaW1wb3J0ICdAbmV4dC9wb2x5ZmlsbC1tb2R1bGUnXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJ1xuaW1wb3J0IHsgSGVhZE1hbmFnZXJDb250ZXh0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL2hlYWQtbWFuYWdlci1jb250ZXh0J1xuaW1wb3J0IG1pdHQgZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL21pdHQnXG5pbXBvcnQgeyBSb3V0ZXJDb250ZXh0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0J1xuaW1wb3J0IFJvdXRlciwge1xuICBBcHBDb21wb25lbnQsXG4gIEFwcFByb3BzLFxuICBkZWxCYXNlUGF0aCxcbiAgaGFzQmFzZVBhdGgsXG4gIFByaXZhdGVSb3V0ZUluZm8sXG59IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHsgaXNEeW5hbWljUm91dGUgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMnXG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0ICogYXMgZW52Q29uZmlnIGZyb20gJy4uL25leHQtc2VydmVyL2xpYi9ydW50aW1lLWNvbmZpZydcbmltcG9ydCB7XG4gIGdldFVSTCxcbiAgbG9hZEdldEluaXRpYWxQcm9wcyxcbiAgTkVYVF9EQVRBLFxuICBTVCxcbn0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3V0aWxzJ1xuaW1wb3J0IGluaXRIZWFkTWFuYWdlciBmcm9tICcuL2hlYWQtbWFuYWdlcidcbmltcG9ydCBQYWdlTG9hZGVyLCB7IFN0eWxlU2hlZXRUdXBsZSB9IGZyb20gJy4vcGFnZS1sb2FkZXInXG5pbXBvcnQgbWVhc3VyZVdlYlZpdGFscyBmcm9tICcuL3BlcmZvcm1hbmNlLXJlbGF5ZXInXG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXIsIG1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSB9IGZyb20gJy4vcm91dGVyJ1xuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cInJlYWN0LWRvbS9leHBlcmltZW50YWxcIiAvPlxuXG5kZWNsYXJlIGxldCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXzogc3RyaW5nXG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgLyogdGVzdCBmbnMgKi9cbiAgICBfX05FWFRfSFlEUkFURUQ/OiBib29sZWFuXG4gICAgX19ORVhUX0hZRFJBVEVEX0NCPzogKCkgPT4gdm9pZFxuXG4gICAgLyogcHJvZCAqL1xuICAgIF9fTkVYVF9QUkVMT0FEUkVBRFk/OiAoaWRzPzogc3RyaW5nW10pID0+IHZvaWRcbiAgICBfX05FWFRfREFUQV9fOiBORVhUX0RBVEFcbiAgICBfX05FWFRfUDogYW55W11cbiAgfVxufVxuXG50eXBlIFJlbmRlclJvdXRlSW5mbyA9IFByaXZhdGVSb3V0ZUluZm8gJiB7XG4gIEFwcDogQXBwQ29tcG9uZW50XG4gIHNjcm9sbD86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB8IG51bGxcbn1cbnR5cGUgUmVuZGVyRXJyb3JQcm9wcyA9IE9taXQ8UmVuZGVyUm91dGVJbmZvLCAnQ29tcG9uZW50JyB8ICdzdHlsZVNoZWV0cyc+XG5cbmNvbnN0IGRhdGE6IHR5cGVvZiB3aW5kb3dbJ19fTkVYVF9EQVRBX18nXSA9IEpTT04ucGFyc2UoXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX05FWFRfREFUQV9fJykhLnRleHRDb250ZW50IVxuKVxud2luZG93Ll9fTkVYVF9EQVRBX18gPSBkYXRhXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gcHJvY2Vzcy5lbnYuX19ORVhUX1ZFUlNJT05cblxuY29uc3QgbG9vc2VUb0FycmF5ID0gPFQgZXh0ZW5kcyB7fT4oaW5wdXQ6IGFueSk6IFRbXSA9PiBbXS5zbGljZS5jYWxsKGlucHV0KVxuXG5jb25zdCB7XG4gIHByb3BzOiBoeWRyYXRlUHJvcHMsXG4gIGVycjogaHlkcmF0ZUVycixcbiAgcGFnZSxcbiAgcXVlcnksXG4gIGJ1aWxkSWQsXG4gIGFzc2V0UHJlZml4LFxuICBydW50aW1lQ29uZmlnLFxuICBkeW5hbWljSWRzLFxuICBpc0ZhbGxiYWNrLFxuICBsb2NhbGVzLFxuICBkb21haW5Mb2NhbGVzLFxufSA9IGRhdGFcblxubGV0IHsgbG9jYWxlLCBkZWZhdWx0TG9jYWxlIH0gPSBkYXRhXG5cbmNvbnN0IHByZWZpeCA9IGFzc2V0UHJlZml4IHx8ICcnXG5cbi8vIFdpdGggZHluYW1pYyBhc3NldFByZWZpeCBpdCdzIG5vIGxvbmdlciBwb3NzaWJsZSB0byBzZXQgYXNzZXRQcmVmaXggYXQgdGhlIGJ1aWxkIHRpbWVcbi8vIFNvLCB0aGlzIGlzIGhvdyB3ZSBkbyBpdCBpbiB0aGUgY2xpZW50IHNpZGUgYXQgcnVudGltZVxuX193ZWJwYWNrX3B1YmxpY19wYXRoX18gPSBgJHtwcmVmaXh9L19uZXh0L2AgLy9lc2xpbnQtZGlzYWJsZS1saW5lXG4vLyBJbml0aWFsaXplIG5leHQvY29uZmlnIHdpdGggdGhlIGVudmlyb25tZW50IGNvbmZpZ3VyYXRpb25cbmVudkNvbmZpZy5zZXRDb25maWcoe1xuICBzZXJ2ZXJSdW50aW1lQ29uZmlnOiB7fSxcbiAgcHVibGljUnVudGltZUNvbmZpZzogcnVudGltZUNvbmZpZyB8fCB7fSxcbn0pXG5cbmxldCBhc1BhdGggPSBnZXRVUkwoKVxuXG4vLyBtYWtlIHN1cmUgbm90IHRvIGF0dGVtcHQgc3RyaXBwaW5nIGJhc2VQYXRoIGZvciA0MDRzXG5pZiAoaGFzQmFzZVBhdGgoYXNQYXRoKSkge1xuICBhc1BhdGggPSBkZWxCYXNlUGF0aChhc1BhdGgpXG59XG5cbmlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gIGNvbnN0IHtcbiAgICBub3JtYWxpemVMb2NhbGVQYXRoLFxuICB9ID0gcmVxdWlyZSgnLi4vbmV4dC1zZXJ2ZXIvbGliL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vbmV4dC1zZXJ2ZXIvbGliL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJylcblxuICBjb25zdCB7XG4gICAgZGV0ZWN0RG9tYWluTG9jYWxlLFxuICB9ID0gcmVxdWlyZSgnLi4vbmV4dC1zZXJ2ZXIvbGliL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9uZXh0LXNlcnZlci9saWIvaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZScpXG5cbiAgY29uc3Qge1xuICAgIHBhcnNlUmVsYXRpdmVVcmwsXG4gIH0gPSByZXF1aXJlKCcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJylcblxuICBjb25zdCB7XG4gICAgZm9ybWF0VXJsLFxuICB9ID0gcmVxdWlyZSgnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsJylcblxuICBpZiAobG9jYWxlcykge1xuICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChhc1BhdGgpXG4gICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9IG5vcm1hbGl6ZUxvY2FsZVBhdGgocGFyc2VkQXMucGF0aG5hbWUsIGxvY2FsZXMpXG5cbiAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBsb2NhbGVQYXRoUmVzdWx0LnBhdGhuYW1lXG4gICAgICBhc1BhdGggPSBmb3JtYXRVcmwocGFyc2VkQXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRlcml2ZSB0aGUgZGVmYXVsdCBsb2NhbGUgaWYgaXQgd2Fzbid0IGRldGVjdGVkIGluIHRoZSBhc1BhdGhcbiAgICAgIC8vIHNpbmNlIHdlIGRvbid0IHByZXJlbmRlciBzdGF0aWMgcGFnZXMgd2l0aCBhbGwgcG9zc2libGUgZGVmYXVsdFxuICAgICAgLy8gbG9jYWxlc1xuICAgICAgZGVmYXVsdExvY2FsZSA9IGxvY2FsZVxuICAgIH1cblxuICAgIC8vIGF0dGVtcHQgZGV0ZWN0aW5nIGRlZmF1bHQgbG9jYWxlIGJhc2VkIG9uIGhvc3RuYW1lXG4gICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUoXG4gICAgICBwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9ET01BSU5TIGFzIGFueSxcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZVxuICAgIClcblxuICAgIC8vIFRPRE86IGludmVzdGlnYXRlIGlmIGRlZmF1bHRMb2NhbGUgbmVlZHMgdG8gYmUgcG9wdWxhdGVkIGFmdGVyXG4gICAgLy8gaHlkcmF0aW9uIHRvIHByZXZlbnQgbWlzbWF0Y2hlZCByZW5kZXJzXG4gICAgaWYgKGRldGVjdGVkRG9tYWluKSB7XG4gICAgICBkZWZhdWx0TG9jYWxlID0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZVxuICAgIH1cbiAgfVxufVxuXG50eXBlIFJlZ2lzdGVyRm4gPSAoaW5wdXQ6IFtzdHJpbmcsICgpID0+IHZvaWRdKSA9PiB2b2lkXG5cbmNvbnN0IHBhZ2VMb2FkZXIgPSBuZXcgUGFnZUxvYWRlcihidWlsZElkLCBwcmVmaXgpXG5jb25zdCByZWdpc3RlcjogUmVnaXN0ZXJGbiA9IChbciwgZl0pID0+XG4gIHBhZ2VMb2FkZXIucm91dGVMb2FkZXIub25FbnRyeXBvaW50KHIsIGYpXG5pZiAod2luZG93Ll9fTkVYVF9QKSB7XG4gIC8vIERlZmVyIHBhZ2UgcmVnaXN0cmF0aW9uIGZvciBhbm90aGVyIHRpY2suIFRoaXMgd2lsbCBpbmNyZWFzZSB0aGUgb3ZlcmFsbFxuICAvLyBsYXRlbmN5IGluIGh5ZHJhdGluZyB0aGUgcGFnZSwgYnV0IHJlZHVjZSB0aGUgdG90YWwgYmxvY2tpbmcgdGltZS5cbiAgd2luZG93Ll9fTkVYVF9QLm1hcCgocCkgPT4gc2V0VGltZW91dCgoKSA9PiByZWdpc3RlcihwKSwgMCkpXG59XG53aW5kb3cuX19ORVhUX1AgPSBbXVxuOyh3aW5kb3cuX19ORVhUX1AgYXMgYW55KS5wdXNoID0gcmVnaXN0ZXJcblxuY29uc3QgaGVhZE1hbmFnZXIgPSBpbml0SGVhZE1hbmFnZXIoKVxuY29uc3QgYXBwRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX25leHQnKVxuXG5sZXQgbGFzdEFwcFByb3BzOiBBcHBQcm9wc1xubGV0IGxhc3RSZW5kZXJSZWplY3Q6ICgoKSA9PiB2b2lkKSB8IG51bGxcbmxldCB3ZWJwYWNrSE1SOiBhbnlcbmV4cG9ydCBsZXQgcm91dGVyOiBSb3V0ZXJcbmxldCBDYWNoZWRDb21wb25lbnQ6IFJlYWN0LkNvbXBvbmVudFR5cGVcbmxldCBDYWNoZWRBcHA6IEFwcENvbXBvbmVudCwgb25QZXJmRW50cnk6IChtZXRyaWM6IGFueSkgPT4gdm9pZFxuXG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8e1xuICBmbjogKGVycjogRXJyb3IsIGluZm8/OiBhbnkpID0+IHZvaWRcbn0+IHtcbiAgY29tcG9uZW50RGlkQ2F0Y2goY29tcG9uZW50RXJyOiBFcnJvciwgaW5mbzogYW55KSB7XG4gICAgdGhpcy5wcm9wcy5mbihjb21wb25lbnRFcnIsIGluZm8pXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnNjcm9sbFRvSGFzaCgpXG5cbiAgICAvLyBXZSBuZWVkIHRvIHJlcGxhY2UgdGhlIHJvdXRlciBzdGF0ZSBpZjpcbiAgICAvLyAtIHRoZSBwYWdlIHdhcyAoYXV0bykgZXhwb3J0ZWQgYW5kIGhhcyBhIHF1ZXJ5IHN0cmluZyBvciBzZWFyY2ggKGhhc2gpXG4gICAgLy8gLSBpdCB3YXMgYXV0byBleHBvcnRlZCBhbmQgaXMgYSBkeW5hbWljIHJvdXRlICh0byBwcm92aWRlIHBhcmFtcylcbiAgICAvLyAtIGlmIGl0IGlzIGEgY2xpZW50LXNpZGUgc2tlbGV0b24gKGZhbGxiYWNrIHJlbmRlcilcbiAgICBpZiAoXG4gICAgICByb3V0ZXIuaXNTc3IgJiZcbiAgICAgIChpc0ZhbGxiYWNrIHx8XG4gICAgICAgIChkYXRhLm5leHRFeHBvcnQgJiZcbiAgICAgICAgICAoaXNEeW5hbWljUm91dGUocm91dGVyLnBhdGhuYW1lKSB8fCBsb2NhdGlvbi5zZWFyY2gpKSB8fFxuICAgICAgICAoaHlkcmF0ZVByb3BzICYmIGh5ZHJhdGVQcm9wcy5fX05fU1NHICYmIGxvY2F0aW9uLnNlYXJjaCkpXG4gICAgKSB7XG4gICAgICAvLyB1cGRhdGUgcXVlcnkgb24gbW91bnQgZm9yIGV4cG9ydGVkIHBhZ2VzXG4gICAgICByb3V0ZXIucmVwbGFjZShcbiAgICAgICAgcm91dGVyLnBhdGhuYW1lICtcbiAgICAgICAgICAnPycgK1xuICAgICAgICAgIFN0cmluZyhcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nLmFzc2lnbihcbiAgICAgICAgICAgICAgcXVlcnlzdHJpbmcudXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhyb3V0ZXIucXVlcnkpLFxuICAgICAgICAgICAgICBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApLFxuICAgICAgICBhc1BhdGgsXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qc1xuICAgICAgICAgIC8vIGNsaWVudC1zaWRlIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuXG4gICAgICAgICAgLy8gSXQgbWF5IGNoYW5nZSBhdCBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICAgICAgICBfaDogMSxcbiAgICAgICAgICAvLyBGYWxsYmFjayBwYWdlcyBtdXN0IHRyaWdnZXIgdGhlIGRhdGEgZmV0Y2gsIHNvIHRoZSB0cmFuc2l0aW9uIGlzXG4gICAgICAgICAgLy8gbm90IHNoYWxsb3cuXG4gICAgICAgICAgLy8gT3RoZXIgcGFnZXMgKHN0cmljdGx5IHVwZGF0aW5nIHF1ZXJ5KSBoYXBwZW5zIHNoYWxsb3dseSwgYXMgZGF0YVxuICAgICAgICAgIC8vIHJlcXVpcmVtZW50cyB3b3VsZCBhbHJlYWR5IGJlIHByZXNlbnQuXG4gICAgICAgICAgc2hhbGxvdzogIWlzRmFsbGJhY2ssXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy5zY3JvbGxUb0hhc2goKVxuICB9XG5cbiAgc2Nyb2xsVG9IYXNoKCkge1xuICAgIGxldCB7IGhhc2ggfSA9IGxvY2F0aW9uXG4gICAgaGFzaCA9IGhhc2ggJiYgaGFzaC5zdWJzdHJpbmcoMSlcbiAgICBpZiAoIWhhc2gpIHJldHVyblxuXG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKVxuICAgIGlmICghZWwpIHJldHVyblxuXG4gICAgLy8gSWYgd2UgY2FsbCBzY3JvbGxJbnRvVmlldygpIGluIGhlcmUgd2l0aG91dCBhIHNldFRpbWVvdXRcbiAgICAvLyBpdCB3b24ndCBzY3JvbGwgcHJvcGVybHkuXG4gICAgc2V0VGltZW91dCgoKSA9PiBlbC5zY3JvbGxJbnRvVmlldygpLCAwKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IFJlYWN0RGV2T3ZlcmxheSB9ID0gcmVxdWlyZSgnQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2NsaWVudCcpXG4gICAgICByZXR1cm4gPFJlYWN0RGV2T3ZlcmxheT57dGhpcy5wcm9wcy5jaGlsZHJlbn08L1JlYWN0RGV2T3ZlcmxheT5cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGVtaXR0ZXIgPSBtaXR0KClcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKG9wdHM6IHsgd2VicGFja0hNUj86IGFueSB9ID0ge30pID0+IHtcbiAgLy8gVGhpcyBtYWtlcyBzdXJlIHRoaXMgc3BlY2lmaWMgbGluZXMgYXJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICB3ZWJwYWNrSE1SID0gb3B0cy53ZWJwYWNrSE1SXG4gIH1cblxuICBjb25zdCBhcHBFbnRyeXBvaW50ID0gYXdhaXQgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci53aGVuRW50cnlwb2ludCgnL19hcHAnKVxuICBpZiAoJ2Vycm9yJyBpbiBhcHBFbnRyeXBvaW50KSB7XG4gICAgdGhyb3cgYXBwRW50cnlwb2ludC5lcnJvclxuICB9XG5cbiAgY29uc3QgeyBjb21wb25lbnQ6IGFwcCwgZXhwb3J0czogbW9kIH0gPSBhcHBFbnRyeXBvaW50XG4gIENhY2hlZEFwcCA9IGFwcCBhcyBBcHBDb21wb25lbnRcblxuICBpZiAobW9kICYmIG1vZC5yZXBvcnRXZWJWaXRhbHMpIHtcbiAgICBvblBlcmZFbnRyeSA9ICh7XG4gICAgICBpZCxcbiAgICAgIG5hbWUsXG4gICAgICBzdGFydFRpbWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgZW50cnlUeXBlLFxuICAgICAgZW50cmllcyxcbiAgICB9KSA9PiB7XG4gICAgICAvLyBDb21iaW5lcyB0aW1lc3RhbXAgd2l0aCByYW5kb20gbnVtYmVyIGZvciB1bmlxdWUgSURcbiAgICAgIGNvbnN0IHVuaXF1ZUlEID0gYCR7RGF0ZS5ub3coKX0tJHtcbiAgICAgICAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDllMTIgLSAxKSkgKyAxZTEyXG4gICAgICB9YFxuICAgICAgbGV0IHBlcmZTdGFydEVudHJ5XG5cbiAgICAgIGlmIChlbnRyaWVzICYmIGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgIHBlcmZTdGFydEVudHJ5ID0gZW50cmllc1swXS5zdGFydFRpbWVcbiAgICAgIH1cblxuICAgICAgbW9kLnJlcG9ydFdlYlZpdGFscyh7XG4gICAgICAgIGlkOiBpZCB8fCB1bmlxdWVJRCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUgfHwgcGVyZlN0YXJ0RW50cnksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSA9PSBudWxsID8gZHVyYXRpb24gOiB2YWx1ZSxcbiAgICAgICAgbGFiZWw6XG4gICAgICAgICAgZW50cnlUeXBlID09PSAnbWFyaycgfHwgZW50cnlUeXBlID09PSAnbWVhc3VyZSdcbiAgICAgICAgICAgID8gJ2N1c3RvbSdcbiAgICAgICAgICAgIDogJ3dlYi12aXRhbCcsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGxldCBpbml0aWFsRXJyID0gaHlkcmF0ZUVyclxuXG4gIHRyeSB7XG4gICAgY29uc3QgcGFnZUVudHJ5cG9pbnQgPVxuICAgICAgLy8gVGhlIGRldiBzZXJ2ZXIgZmFpbHMgdG8gc2VydmUgc2NyaXB0IGFzc2V0cyB3aGVuIHRoZXJlJ3MgYSBoeWRyYXRpb25cbiAgICAgIC8vIGVycm9yLCBzbyB3ZSBuZWVkIHRvIHNraXAgd2FpdGluZyBmb3IgdGhlIGVudHJ5cG9pbnQuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBoeWRyYXRlRXJyXG4gICAgICAgID8geyBlcnJvcjogaHlkcmF0ZUVyciB9XG4gICAgICAgIDogYXdhaXQgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci53aGVuRW50cnlwb2ludChwYWdlKVxuICAgIGlmICgnZXJyb3InIGluIHBhZ2VFbnRyeXBvaW50KSB7XG4gICAgICB0aHJvdyBwYWdlRW50cnlwb2ludC5lcnJvclxuICAgIH1cbiAgICBDYWNoZWRDb21wb25lbnQgPSBwYWdlRW50cnlwb2ludC5jb21wb25lbnRcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjb25zdCB7IGlzVmFsaWRFbGVtZW50VHlwZSB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKVxuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUoQ2FjaGVkQ29tcG9uZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke3BhZ2V9XCJgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gVGhpcyBjYXRjaGVzIGVycm9ycyBsaWtlIHRocm93aW5nIGluIHRoZSB0b3AgbGV2ZWwgb2YgYSBtb2R1bGVcbiAgICBpbml0aWFsRXJyID0gZXJyb3JcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGNvbnN0IHsgZ2V0Tm9kZUVycm9yIH0gPSByZXF1aXJlKCdAbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvY2xpZW50JylcbiAgICAvLyBTZXJ2ZXItc2lkZSBydW50aW1lIGVycm9ycyBuZWVkIHRvIGJlIHJlLXRocm93biBvbiB0aGUgY2xpZW50LXNpZGUgc29cbiAgICAvLyB0aGF0IHRoZSBvdmVybGF5IGlzIHJlbmRlcmVkLlxuICAgIGlmIChpbml0aWFsRXJyKSB7XG4gICAgICBpZiAoaW5pdGlhbEVyciA9PT0gaHlkcmF0ZUVycikge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBsZXQgZXJyb3JcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgZXJyb3Igb2JqZWN0LiBXZSBgdGhyb3dgIGl0IGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgICAgICAgICAgLy8gd2lsbCBzZXQgdGhlIGBzdGFja2Agd2hlbiB0aHJvd24sIGFuZCB3ZSB3YW50IHRvIGVuc3VyZSBvdXJzIGlzXG4gICAgICAgICAgICAvLyBub3Qgb3ZlcnJpZGRlbiB3aGVuIHdlIHJlLXRocm93IGl0IGJlbG93LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGluaXRpYWxFcnIhLm1lc3NhZ2UpXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IgPSBlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IubmFtZSA9IGluaXRpYWxFcnIhLm5hbWVcbiAgICAgICAgICBlcnJvci5zdGFjayA9IGluaXRpYWxFcnIhLnN0YWNrXG5cbiAgICAgICAgICBjb25zdCBub2RlID0gZ2V0Tm9kZUVycm9yKGVycm9yKVxuICAgICAgICAgIHRocm93IG5vZGVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIC8vIFdlIHJlcGxhY2VkIHRoZSBzZXJ2ZXItc2lkZSBlcnJvciB3aXRoIGEgY2xpZW50LXNpZGUgZXJyb3IsIGFuZCBzaG91bGRcbiAgICAgIC8vIG5vIGxvbmdlciByZXdyaXRlIHRoZSBzdGFjayB0cmFjZSB0byBhIE5vZGUgZXJyb3IuXG4gICAgICBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgaW5pdGlhbEVyclxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWSkge1xuICAgIGF3YWl0IHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZKGR5bmFtaWNJZHMpXG4gIH1cblxuICByb3V0ZXIgPSBjcmVhdGVSb3V0ZXIocGFnZSwgcXVlcnksIGFzUGF0aCwge1xuICAgIGluaXRpYWxQcm9wczogaHlkcmF0ZVByb3BzLFxuICAgIHBhZ2VMb2FkZXIsXG4gICAgQXBwOiBDYWNoZWRBcHAsXG4gICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgd3JhcEFwcCxcbiAgICBlcnI6IGluaXRpYWxFcnIsXG4gICAgaXNGYWxsYmFjazogQm9vbGVhbihpc0ZhbGxiYWNrKSxcbiAgICBzdWJzY3JpcHRpb246IChpbmZvLCBBcHAsIHNjcm9sbCkgPT5cbiAgICAgIHJlbmRlcihcbiAgICAgICAgT2JqZWN0LmFzc2lnbjxcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBPbWl0PFJlbmRlclJvdXRlSW5mbywgJ0FwcCcgfCAnc2Nyb2xsJz4sXG4gICAgICAgICAgUGljazxSZW5kZXJSb3V0ZUluZm8sICdBcHAnIHwgJ3Njcm9sbCc+XG4gICAgICAgID4oe30sIGluZm8sIHtcbiAgICAgICAgICBBcHAsXG4gICAgICAgICAgc2Nyb2xsLFxuICAgICAgICB9KSBhcyBSZW5kZXJSb3V0ZUluZm9cbiAgICAgICksXG4gICAgbG9jYWxlLFxuICAgIGxvY2FsZXMsXG4gICAgZGVmYXVsdExvY2FsZSxcbiAgICBkb21haW5Mb2NhbGVzLFxuICB9KVxuXG4gIC8vIGNhbGwgaW5pdC1jbGllbnQgbWlkZGxld2FyZVxuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1BMVUdJTlMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgaW1wb3J0KCduZXh0LXBsdWdpbi1sb2FkZXI/bWlkZGxld2FyZT1vbi1pbml0LWNsaWVudCEnKVxuICAgICAgLnRoZW4oKGluaXRDbGllbnRNb2R1bGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGluaXRDbGllbnRNb2R1bGUuZGVmYXVsdCh7IHJvdXRlciB9KVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoaW5pdENsaWVudEVycikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjYWxsaW5nIGNsaWVudC1pbml0IGZvciBwbHVnaW5zJywgaW5pdENsaWVudEVycilcbiAgICAgIH0pXG4gIH1cblxuICBjb25zdCByZW5kZXJDdHg6IFJlbmRlclJvdXRlSW5mbyA9IHtcbiAgICBBcHA6IENhY2hlZEFwcCxcbiAgICBpbml0aWFsOiB0cnVlLFxuICAgIENvbXBvbmVudDogQ2FjaGVkQ29tcG9uZW50LFxuICAgIHByb3BzOiBoeWRyYXRlUHJvcHMsXG4gICAgZXJyOiBpbml0aWFsRXJyLFxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICByZW5kZXIocmVuZGVyQ3R4KVxuICAgIHJldHVybiBlbWl0dGVyXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgZW1pdHRlciwgcmVuZGVyLCByZW5kZXJDdHggfVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW5kZXIocmVuZGVyaW5nUHJvcHM6IFJlbmRlclJvdXRlSW5mbykge1xuICBpZiAocmVuZGVyaW5nUHJvcHMuZXJyKSB7XG4gICAgYXdhaXQgcmVuZGVyRXJyb3IocmVuZGVyaW5nUHJvcHMpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0cnkge1xuICAgIGF3YWl0IGRvUmVuZGVyKHJlbmRlcmluZ1Byb3BzKVxuICB9IGNhdGNoIChyZW5kZXJFcnIpIHtcbiAgICAvLyBidWJibGUgdXAgY2FuY2VsYXRpb24gZXJyb3JzXG4gICAgaWYgKHJlbmRlckVyci5jYW5jZWxsZWQpIHtcbiAgICAgIHRocm93IHJlbmRlckVyclxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgLy8gRW5zdXJlIHRoaXMgZXJyb3IgaXMgZGlzcGxheWVkIGluIHRoZSBvdmVybGF5IGluIGRldmVsb3BtZW50XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhyb3cgcmVuZGVyRXJyXG4gICAgICB9KVxuICAgIH1cbiAgICBhd2FpdCByZW5kZXJFcnJvcih7IC4uLnJlbmRlcmluZ1Byb3BzLCBlcnI6IHJlbmRlckVyciB9KVxuICB9XG59XG5cbi8vIFRoaXMgbWV0aG9kIGhhbmRsZXMgYWxsIHJ1bnRpbWUgYW5kIGRlYnVnIGVycm9ycy5cbi8vIDQwNCBhbmQgNTAwIGVycm9ycyBhcmUgc3BlY2lhbCBraW5kIG9mIGVycm9yc1xuLy8gYW5kIHRoZXkgYXJlIHN0aWxsIGhhbmRsZSB2aWEgdGhlIG1haW4gcmVuZGVyIG1ldGhvZC5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJFcnJvcihyZW5kZXJFcnJvclByb3BzOiBSZW5kZXJFcnJvclByb3BzKSB7XG4gIGNvbnN0IHsgQXBwLCBlcnIgfSA9IHJlbmRlckVycm9yUHJvcHNcblxuICAvLyBJbiBkZXZlbG9wbWVudCBydW50aW1lIGVycm9ycyBhcmUgY2F1Z2h0IGJ5IG91ciBvdmVybGF5XG4gIC8vIEluIHByb2R1Y3Rpb24gd2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gQSBOZXh0LmpzIHJlbmRlcmluZyBydW50aW1lIGVycm9yIGlzIGFsd2F5cyB1bnJlY292ZXJhYmxlXG4gICAgLy8gRklYTUU6IGxldCdzIG1ha2UgdGhpcyByZWNvdmVyYWJsZSAoZXJyb3IgaW4gR0lQIGNsaWVudC10cmFuc2l0aW9uKVxuICAgIHdlYnBhY2tITVIub25VbnJlY292ZXJhYmxlRXJyb3IoKVxuXG4gICAgLy8gV2UgbmVlZCB0byByZW5kZXIgYW4gZW1wdHkgPEFwcD4gc28gdGhhdCB0aGUgYDxSZWFjdERldk92ZXJsYXk+YCBjYW5cbiAgICAvLyByZW5kZXIgaXRzZWxmLlxuICAgIHJldHVybiBkb1JlbmRlcih7XG4gICAgICBBcHA6ICgpID0+IG51bGwsXG4gICAgICBwcm9wczoge30sXG4gICAgICBDb21wb25lbnQ6ICgpID0+IG51bGwsXG4gICAgICBzdHlsZVNoZWV0czogW10sXG4gICAgfSlcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1BMVUdJTlMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgaW1wb3J0KCduZXh0LXBsdWdpbi1sb2FkZXI/bWlkZGxld2FyZT1vbi1lcnJvci1jbGllbnQhJylcbiAgICAgIC50aGVuKChvbkNsaWVudEVycm9yTW9kdWxlKSA9PiB7XG4gICAgICAgIHJldHVybiBvbkNsaWVudEVycm9yTW9kdWxlLmRlZmF1bHQoeyBlcnIgfSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKG9uQ2xpZW50RXJyb3JFcnIpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnZXJyb3IgY2FsbGluZyBvbi1lcnJvci1jbGllbnQgZm9yIHBsdWdpbnMnLFxuICAgICAgICAgIG9uQ2xpZW50RXJyb3JFcnJcbiAgICAgICAgKVxuICAgICAgfSlcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBsb2cgdGhlIGVycm9yIHRvIHRoZSBjb25zb2xlLCBvdGhlcndpc2UgdXNlcnMgY2FuJ3QgdHJhY2sgZG93biBpc3N1ZXMuXG4gIGNvbnNvbGUuZXJyb3IoZXJyKVxuICByZXR1cm4gcGFnZUxvYWRlclxuICAgIC5sb2FkUGFnZSgnL19lcnJvcicpXG4gICAgLnRoZW4oKHsgcGFnZTogRXJyb3JDb21wb25lbnQsIHN0eWxlU2hlZXRzIH0pID0+IHtcbiAgICAgIC8vIEluIHByb2R1Y3Rpb24gd2UgZG8gYSBub3JtYWwgcmVuZGVyIHdpdGggdGhlIGBFcnJvckNvbXBvbmVudGAgYXMgY29tcG9uZW50LlxuICAgICAgLy8gSWYgd2UndmUgZ290dGVuIGhlcmUgdXBvbiBpbml0aWFsIHJlbmRlciwgd2UgY2FuIHVzZSB0aGUgcHJvcHMgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGNhbGwgYGdldEluaXRpYWxQcm9wc2Agb24gYEFwcGAgYmVmb3JlIG1vdW50aW5nLlxuICAgICAgY29uc3QgQXBwVHJlZSA9IHdyYXBBcHAoQXBwKVxuICAgICAgY29uc3QgYXBwQ3R4ID0ge1xuICAgICAgICBDb21wb25lbnQ6IEVycm9yQ29tcG9uZW50LFxuICAgICAgICBBcHBUcmVlLFxuICAgICAgICByb3V0ZXIsXG4gICAgICAgIGN0eDogeyBlcnIsIHBhdGhuYW1lOiBwYWdlLCBxdWVyeSwgYXNQYXRoLCBBcHBUcmVlIH0sXG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICByZW5kZXJFcnJvclByb3BzLnByb3BzXG4gICAgICAgICAgPyByZW5kZXJFcnJvclByb3BzLnByb3BzXG4gICAgICAgICAgOiBsb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwgYXBwQ3R4KVxuICAgICAgKS50aGVuKChpbml0UHJvcHMpID0+XG4gICAgICAgIGRvUmVuZGVyKHtcbiAgICAgICAgICAuLi5yZW5kZXJFcnJvclByb3BzLFxuICAgICAgICAgIGVycixcbiAgICAgICAgICBDb21wb25lbnQ6IEVycm9yQ29tcG9uZW50LFxuICAgICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICAgIHByb3BzOiBpbml0UHJvcHMsXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSlcbn1cblxubGV0IHJlYWN0Um9vdDogYW55ID0gbnVsbFxubGV0IHNob3VsZFVzZUh5ZHJhdGUgPSB0eXBlb2YgUmVhY3RET00uaHlkcmF0ZSA9PT0gJ2Z1bmN0aW9uJ1xuZnVuY3Rpb24gcmVuZGVyUmVhY3RFbGVtZW50KHJlYWN0RWw6IEpTWC5FbGVtZW50LCBkb21FbDogSFRNTEVsZW1lbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9SRUFDVF9NT0RFICE9PSAnbGVnYWN5Jykge1xuICAgIGlmICghcmVhY3RSb290KSB7XG4gICAgICBjb25zdCBvcHRzID0geyBoeWRyYXRlOiB0cnVlIH1cbiAgICAgIHJlYWN0Um9vdCA9XG4gICAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9SRUFDVF9NT0RFID09PSAnY29uY3VycmVudCdcbiAgICAgICAgICA/IChSZWFjdERPTSBhcyBhbnkpLnVuc3RhYmxlX2NyZWF0ZVJvb3QoZG9tRWwsIG9wdHMpXG4gICAgICAgICAgOiAoUmVhY3RET00gYXMgYW55KS51bnN0YWJsZV9jcmVhdGVCbG9ja2luZ1Jvb3QoZG9tRWwsIG9wdHMpXG4gICAgfVxuICAgIHJlYWN0Um9vdC5yZW5kZXIocmVhY3RFbClcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHN0YXJ0IG9mIGh5ZHJhdGUvcmVuZGVyXG4gICAgaWYgKFNUKSB7XG4gICAgICBwZXJmb3JtYW5jZS5tYXJrKCdiZWZvcmVSZW5kZXInKVxuICAgIH1cblxuICAgIC8vIFRoZSBjaGVjayBmb3IgYC5oeWRyYXRlYCBpcyB0aGVyZSB0byBzdXBwb3J0IFJlYWN0IGFsdGVybmF0aXZlcyBsaWtlIHByZWFjdFxuICAgIGlmIChzaG91bGRVc2VIeWRyYXRlKSB7XG4gICAgICBSZWFjdERPTS5oeWRyYXRlKHJlYWN0RWwsIGRvbUVsLCBtYXJrSHlkcmF0ZUNvbXBsZXRlKVxuICAgICAgc2hvdWxkVXNlSHlkcmF0ZSA9IGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RE9NLnJlbmRlcihyZWFjdEVsLCBkb21FbCwgbWFya1JlbmRlckNvbXBsZXRlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrSHlkcmF0ZUNvbXBsZXRlKCkge1xuICBpZiAoIVNUKSByZXR1cm5cblxuICBwZXJmb3JtYW5jZS5tYXJrKCdhZnRlckh5ZHJhdGUnKSAvLyBtYXJrIGVuZCBvZiBoeWRyYXRpb25cblxuICBwZXJmb3JtYW5jZS5tZWFzdXJlKFxuICAgICdOZXh0LmpzLWJlZm9yZS1oeWRyYXRpb24nLFxuICAgICduYXZpZ2F0aW9uU3RhcnQnLFxuICAgICdiZWZvcmVSZW5kZXInXG4gIClcbiAgcGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1oeWRyYXRpb24nLCAnYmVmb3JlUmVuZGVyJywgJ2FmdGVySHlkcmF0ZScpXG5cbiAgaWYgKG9uUGVyZkVudHJ5KSB7XG4gICAgcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1oeWRyYXRpb24nKS5mb3JFYWNoKG9uUGVyZkVudHJ5KVxuICB9XG4gIGNsZWFyTWFya3MoKVxufVxuXG5mdW5jdGlvbiBtYXJrUmVuZGVyQ29tcGxldGUoKSB7XG4gIGlmICghU1QpIHJldHVyblxuXG4gIHBlcmZvcm1hbmNlLm1hcmsoJ2FmdGVyUmVuZGVyJykgLy8gbWFyayBlbmQgb2YgcmVuZGVyXG4gIGNvbnN0IG5hdlN0YXJ0RW50cmllcyA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoJ3JvdXRlQ2hhbmdlJywgJ21hcmsnKVxuXG4gIGlmICghbmF2U3RhcnRFbnRyaWVzLmxlbmd0aCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgcGVyZm9ybWFuY2UubWVhc3VyZShcbiAgICAnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJyxcbiAgICBuYXZTdGFydEVudHJpZXNbMF0ubmFtZSxcbiAgICAnYmVmb3JlUmVuZGVyJ1xuICApXG4gIHBlcmZvcm1hbmNlLm1lYXN1cmUoJ05leHQuanMtcmVuZGVyJywgJ2JlZm9yZVJlbmRlcicsICdhZnRlclJlbmRlcicpXG4gIGlmIChvblBlcmZFbnRyeSkge1xuICAgIHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoJ05leHQuanMtcmVuZGVyJykuZm9yRWFjaChvblBlcmZFbnRyeSlcbiAgICBwZXJmb3JtYW5jZVxuICAgICAgLmdldEVudHJpZXNCeU5hbWUoJ05leHQuanMtcm91dGUtY2hhbmdlLXRvLXJlbmRlcicpXG4gICAgICAuZm9yRWFjaChvblBlcmZFbnRyeSlcbiAgfVxuICBjbGVhck1hcmtzKClcbiAgO1snTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJywgJ05leHQuanMtcmVuZGVyJ10uZm9yRWFjaCgobWVhc3VyZSkgPT5cbiAgICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG1lYXN1cmUpXG4gIClcbn1cblxuZnVuY3Rpb24gY2xlYXJNYXJrcygpIHtcbiAgO1tcbiAgICAnYmVmb3JlUmVuZGVyJyxcbiAgICAnYWZ0ZXJIeWRyYXRlJyxcbiAgICAnYWZ0ZXJSZW5kZXInLFxuICAgICdyb3V0ZUNoYW5nZScsXG4gIF0uZm9yRWFjaCgobWFyaykgPT4gcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhtYXJrKSlcbn1cblxuZnVuY3Rpb24gQXBwQ29udGFpbmVyKHtcbiAgY2hpbGRyZW4sXG59OiBSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjx7fT4pOiBSZWFjdC5SZWFjdEVsZW1lbnQge1xuICByZXR1cm4gKFxuICAgIDxDb250YWluZXJcbiAgICAgIGZuPXsoZXJyb3IpID0+XG4gICAgICAgIHJlbmRlckVycm9yKHsgQXBwOiBDYWNoZWRBcHAsIGVycjogZXJyb3IgfSkuY2F0Y2goKGVycikgPT5cbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW5kZXJpbmcgcGFnZTogJywgZXJyKVxuICAgICAgICApXG4gICAgICB9XG4gICAgPlxuICAgICAgPFJvdXRlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e21ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZShyb3V0ZXIpfT5cbiAgICAgICAgPEhlYWRNYW5hZ2VyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17aGVhZE1hbmFnZXJ9PlxuICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgPC9IZWFkTWFuYWdlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgICA8L1JvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgPC9Db250YWluZXI+XG4gIClcbn1cblxuY29uc3Qgd3JhcEFwcCA9IChBcHA6IEFwcENvbXBvbmVudCkgPT4gKFxuICB3cmFwcGVkQXBwUHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT5cbikgPT4ge1xuICBjb25zdCBhcHBQcm9wczogQXBwUHJvcHMgPSB7XG4gICAgLi4ud3JhcHBlZEFwcFByb3BzLFxuICAgIENvbXBvbmVudDogQ2FjaGVkQ29tcG9uZW50LFxuICAgIGVycjogaHlkcmF0ZUVycixcbiAgICByb3V0ZXIsXG4gIH1cbiAgcmV0dXJuIChcbiAgICA8QXBwQ29udGFpbmVyPlxuICAgICAgPEFwcCB7Li4uYXBwUHJvcHN9IC8+XG4gICAgPC9BcHBDb250YWluZXI+XG4gIClcbn1cblxuZnVuY3Rpb24gZG9SZW5kZXIoaW5wdXQ6IFJlbmRlclJvdXRlSW5mbyk6IFByb21pc2U8YW55PiB7XG4gIGxldCB7IEFwcCwgQ29tcG9uZW50LCBwcm9wcywgZXJyIH0gPSBpbnB1dFxuICBsZXQgc3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdIHwgdW5kZWZpbmVkID1cbiAgICAnaW5pdGlhbCcgaW4gaW5wdXQgPyB1bmRlZmluZWQgOiBpbnB1dC5zdHlsZVNoZWV0c1xuICBDb21wb25lbnQgPSBDb21wb25lbnQgfHwgbGFzdEFwcFByb3BzLkNvbXBvbmVudFxuICBwcm9wcyA9IHByb3BzIHx8IGxhc3RBcHBQcm9wcy5wcm9wc1xuXG4gIGNvbnN0IGFwcFByb3BzOiBBcHBQcm9wcyA9IHtcbiAgICAuLi5wcm9wcyxcbiAgICBDb21wb25lbnQsXG4gICAgZXJyLFxuICAgIHJvdXRlcixcbiAgfVxuICAvLyBsYXN0QXBwUHJvcHMgaGFzIHRvIGJlIHNldCBiZWZvcmUgUmVhY3REb20ucmVuZGVyIHRvIGFjY291bnQgZm9yIFJlYWN0RG9tIHRocm93aW5nIGFuIGVycm9yLlxuICBsYXN0QXBwUHJvcHMgPSBhcHBQcm9wc1xuXG4gIGxldCBjYW5jZWxlZCA9IGZhbHNlXG4gIGxldCByZXNvbHZlUHJvbWlzZTogKCkgPT4gdm9pZFxuICBjb25zdCByZW5kZXJQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmIChsYXN0UmVuZGVyUmVqZWN0KSB7XG4gICAgICBsYXN0UmVuZGVyUmVqZWN0KClcbiAgICB9XG4gICAgcmVzb2x2ZVByb21pc2UgPSAoKSA9PiB7XG4gICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbFxuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuICAgIGxhc3RSZW5kZXJSZWplY3QgPSAoKSA9PiB7XG4gICAgICBjYW5jZWxlZCA9IHRydWVcbiAgICAgIGxhc3RSZW5kZXJSZWplY3QgPSBudWxsXG5cbiAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoJ0NhbmNlbCByZW5kZXJpbmcgcm91dGUnKVxuICAgICAgZXJyb3IuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgcmVqZWN0KGVycm9yKVxuICAgIH1cbiAgfSlcblxuICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyBhIHJldHVybiB0eXBlIHRvIGVuc3VyZSBpdCBkb2Vzbid0IHN0YXJ0IHJldHVybmluZyBhXG4gIC8vIFByb21pc2UuIEl0IHNob3VsZCByZW1haW4gc3luY2hyb25vdXMuXG4gIGZ1bmN0aW9uIG9uU3RhcnQoKTogYm9vbGVhbiB7XG4gICAgaWYgKFxuICAgICAgIXN0eWxlU2hlZXRzIHx8XG4gICAgICAvLyBXZSB1c2UgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQsIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcbiAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudFN0eWxlVGFncyA9IGxvb3NlVG9BcnJheTxIVE1MU3R5bGVFbGVtZW50PihcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlW2RhdGEtbi1ocmVmXScpXG4gICAgKVxuICAgIGNvbnN0IGN1cnJlbnRIcmVmcyA9IG5ldyBTZXQoXG4gICAgICBjdXJyZW50U3R5bGVUYWdzLm1hcCgodGFnKSA9PiB0YWcuZ2V0QXR0cmlidXRlKCdkYXRhLW4taHJlZicpKVxuICAgIClcblxuICAgIGNvbnN0IG5vc2NyaXB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignbm9zY3JpcHRbZGF0YS1uLWNzc10nKVxuICAgIGNvbnN0IG5vbmNlID0gbm9zY3JpcHQ/LmdldEF0dHJpYnV0ZSgnZGF0YS1uLWNzcycpXG5cbiAgICBzdHlsZVNoZWV0cy5mb3JFYWNoKCh7IGhyZWYsIHRleHQgfSkgPT4ge1xuICAgICAgaWYgKCFjdXJyZW50SHJlZnMuaGFzKGhyZWYpKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlVGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICAgICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoJ2RhdGEtbi1ocmVmJywgaHJlZilcbiAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCdtZWRpYScsICd4JylcblxuICAgICAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpXG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlVGFnKVxuICAgICAgICBzdHlsZVRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBvbkhlYWRDb21taXQoKSB7XG4gICAgaWYgKFxuICAgICAgLy8gV2UgdXNlIGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAvLyB1bmxlc3Mgd2UncmUgaW4gcHJvZHVjdGlvbjpcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIC8vIFdlIGNhbiBza2lwIHRoaXMgZHVyaW5nIGh5ZHJhdGlvbi4gUnVubmluZyBpdCB3b250IGNhdXNlIGFueSBoYXJtLCBidXRcbiAgICAgIC8vIHdlIG1heSBhcyB3ZWxsIHNhdmUgdGhlIENQVSBjeWNsZXM6XG4gICAgICBzdHlsZVNoZWV0cyAmJlxuICAgICAgLy8gRW5zdXJlIHRoaXMgcmVuZGVyIHdhcyBub3QgY2FuY2VsZWRcbiAgICAgICFjYW5jZWxlZFxuICAgICkge1xuICAgICAgY29uc3QgZGVzaXJlZEhyZWZzID0gbmV3IFNldChzdHlsZVNoZWV0cy5tYXAoKHMpID0+IHMuaHJlZikpXG4gICAgICBjb25zdCBjdXJyZW50U3R5bGVUYWdzID0gbG9vc2VUb0FycmF5PEhUTUxTdHlsZUVsZW1lbnQ+KFxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZVtkYXRhLW4taHJlZl0nKVxuICAgICAgKVxuICAgICAgY29uc3QgY3VycmVudEhyZWZzID0gY3VycmVudFN0eWxlVGFncy5tYXAoXG4gICAgICAgICh0YWcpID0+IHRhZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtbi1ocmVmJykhXG4gICAgICApXG5cbiAgICAgIC8vIFRvZ2dsZSBgPHN0eWxlPmAgdGFncyBvbiBvciBvZmYgZGVwZW5kaW5nIG9uIGlmIHRoZXkncmUgbmVlZGVkOlxuICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgY3VycmVudEhyZWZzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgaWYgKGRlc2lyZWRIcmVmcy5oYXMoY3VycmVudEhyZWZzW2lkeF0pKSB7XG4gICAgICAgICAgY3VycmVudFN0eWxlVGFnc1tpZHhdLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRTdHlsZVRhZ3NbaWR4XS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgJ3gnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlb3JkZXIgc3R5bGVzIGludG8gaW50ZW5kZWQgb3JkZXI6XG4gICAgICBsZXQgcmVmZXJlbmNlTm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ25vc2NyaXB0W2RhdGEtbi1jc3NdJylcbiAgICAgIGlmIChcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgYW4gaW52YXJpYW50OlxuICAgICAgICByZWZlcmVuY2VOb2RlXG4gICAgICApIHtcbiAgICAgICAgc3R5bGVTaGVldHMuZm9yRWFjaCgoeyBocmVmIH0pID0+IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRUYWcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgYHN0eWxlW2RhdGEtbi1ocmVmPVwiJHtocmVmfVwiXWBcbiAgICAgICAgICApXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgYW4gaW52YXJpYW50OlxuICAgICAgICAgICAgdGFyZ2V0VGFnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VOb2RlIS5wYXJlbnROb2RlIS5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICAgIHRhcmdldFRhZyxcbiAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSEubmV4dFNpYmxpbmdcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUgPSB0YXJnZXRUYWdcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmFsbHksIGNsZWFuIHVwIHNlcnZlciByZW5kZXJlZCBzdHlsZXNoZWV0czpcbiAgICAgIGxvb3NlVG9BcnJheTxIVE1MTGlua0VsZW1lbnQ+KFxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rW2RhdGEtbi1wXScpXG4gICAgICApLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGVsLnBhcmVudE5vZGUhLnJlbW92ZUNoaWxkKGVsKVxuICAgICAgfSlcblxuICAgICAgLy8gRm9yY2UgYnJvd3NlciB0byByZWNvbXB1dGUgbGF5b3V0LCB3aGljaCBzaG91bGQgcHJldmVudCBhIGZsYXNoIG9mXG4gICAgICAvLyB1bnN0eWxlZCBjb250ZW50OlxuICAgICAgZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5LCAnaGVpZ2h0JylcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQuc2Nyb2xsKSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oaW5wdXQuc2Nyb2xsLngsIGlucHV0LnNjcm9sbC55KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUm9vdENvbW1pdCgpIHtcbiAgICByZXNvbHZlUHJvbWlzZSgpXG4gIH1cblxuICBjb25zdCBlbGVtID0gKFxuICAgIDxSb290IGNhbGxiYWNrPXtvblJvb3RDb21taXR9PlxuICAgICAgPEhlYWQgY2FsbGJhY2s9e29uSGVhZENvbW1pdH0gLz5cbiAgICAgIDxBcHBDb250YWluZXI+XG4gICAgICAgIDxBcHAgey4uLmFwcFByb3BzfSAvPlxuICAgICAgPC9BcHBDb250YWluZXI+XG4gICAgPC9Sb290PlxuICApXG5cbiAgb25TdGFydCgpXG5cbiAgLy8gV2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG4gIHJlbmRlclJlYWN0RWxlbWVudChcbiAgICBwcm9jZXNzLmVudi5fX05FWFRfU1RSSUNUX01PREUgPyAoXG4gICAgICA8UmVhY3QuU3RyaWN0TW9kZT57ZWxlbX08L1JlYWN0LlN0cmljdE1vZGU+XG4gICAgKSA6IChcbiAgICAgIGVsZW1cbiAgICApLFxuICAgIGFwcEVsZW1lbnQhXG4gIClcblxuICByZXR1cm4gcmVuZGVyUHJvbWlzZVxufVxuXG5mdW5jdGlvbiBSb290KHtcbiAgY2FsbGJhY2ssXG4gIGNoaWxkcmVuLFxufTogUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48e1xuICBjYWxsYmFjazogKCkgPT4gdm9pZFxufT4pOiBSZWFjdC5SZWFjdEVsZW1lbnQge1xuICAvLyBXZSB1c2UgYHVzZUxheW91dEVmZmVjdGAgdG8gZ3VhcmFudGVlIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZFxuICAvLyBhcyBzb29uIGFzIFJlYWN0IGZsdXNoZXMgdGhlIHVwZGF0ZS5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGNhbGxiYWNrKCksIFtjYWxsYmFja10pXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURUQgPSB0cnVlXG5cbiAgICAgIGlmICh3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IoKVxuICAgICAgfVxuICAgIH0sIFtdKVxuICB9XG4gIC8vIFdlIHNob3VsZCBhc2sgdG8gbWVhc3VyZSB0aGUgV2ViIFZpdGFscyBhZnRlciByZW5kZXJpbmcgY29tcGxldGVzIHNvIHdlXG4gIC8vIGRvbid0IGNhdXNlIGFueSBoeWRyYXRpb24gZGVsYXk6XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbWVhc3VyZVdlYlZpdGFscyhvblBlcmZFbnRyeSlcbiAgfSwgW10pXG4gIHJldHVybiBjaGlsZHJlbiBhcyBSZWFjdC5SZWFjdEVsZW1lbnRcbn1cblxuLy8gRHVtbXkgY29tcG9uZW50IHRoYXQgd2UgcmVuZGVyIGFzIGEgY2hpbGQgb2YgUm9vdCBzbyB0aGF0IHdlIGNhblxuLy8gdG9nZ2xlIHRoZSBjb3JyZWN0IHN0eWxlcyBiZWZvcmUgdGhlIHBhZ2UgaXMgcmVuZGVyZWQuXG5mdW5jdGlvbiBIZWFkKHsgY2FsbGJhY2sgfTogeyBjYWxsYmFjazogKCkgPT4gdm9pZCB9KSB7XG4gIC8vIFdlIHVzZSBgdXNlTGF5b3V0RWZmZWN0YCB0byBndWFyYW50ZWUgdGhlIGNhbGxiYWNrIGlzIGV4ZWN1dGVkXG4gIC8vIGFzIHNvb24gYXMgUmVhY3QgZmx1c2hlcyB0aGUgdXBkYXRlLlxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gY2FsbGJhY2soKSwgW2NhbGxiYWNrXSlcbiAgcmV0dXJuIG51bGxcbn1cbiIsIi8qIGdsb2JhbHMgX19SRVBMQUNFX05PT1BfSU1QT1JUX18gKi9cbmltcG9ydCBpbml0TmV4dCwgKiBhcyBuZXh0IGZyb20gJy4vJ1xuaW1wb3J0IEV2ZW50U291cmNlUG9seWZpbGwgZnJvbSAnLi9kZXYvZXZlbnQtc291cmNlLXBvbHlmaWxsJ1xuaW1wb3J0IGluaXRPbkRlbWFuZEVudHJpZXMgZnJvbSAnLi9kZXYvb24tZGVtYW5kLWVudHJpZXMtY2xpZW50J1xuaW1wb3J0IGluaXRXZWJwYWNrSE1SIGZyb20gJy4vZGV2L3dlYnBhY2staG90LW1pZGRsZXdhcmUtY2xpZW50J1xuaW1wb3J0IGluaXRpYWxpemVCdWlsZFdhdGNoZXIgZnJvbSAnLi9kZXYvZGV2LWJ1aWxkLXdhdGNoZXInXG5pbXBvcnQgeyBkaXNwbGF5Q29udGVudCB9IGZyb20gJy4vZGV2L2ZvdWMnXG5pbXBvcnQgeyBnZXRFdmVudFNvdXJjZVdyYXBwZXIgfSBmcm9tICcuL2Rldi9lcnJvci1vdmVybGF5L2V2ZW50c291cmNlJ1xuaW1wb3J0ICogYXMgcXVlcnlzdHJpbmcgZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZydcblxuLy8gVGVtcG9yYXJ5IHdvcmthcm91bmQgZm9yIHRoZSBpc3N1ZSBkZXNjcmliZWQgaGVyZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9pc3N1ZXMvMzc3NSNpc3N1ZWNvbW1lbnQtNDA3NDM4MTIzXG4vLyBUaGUgcnVudGltZUNodW5rIGRvZXNuJ3QgaGF2ZSBkeW5hbWljIGltcG9ydCBoYW5kbGluZyBjb2RlIHdoZW4gdGhlcmUgaGFzbid0IGJlZW4gYSBkeW5hbWljIGltcG9ydFxuLy8gVGhlIHJ1bnRpbWVDaHVuayBjYW4ndCBob3QgcmVsb2FkIGl0c2VsZiBjdXJyZW50bHkgdG8gY29ycmVjdCBpdCB3aGVuIGFkZGluZyBwYWdlcyB1c2luZyBvbi1kZW1hbmQtZW50cmllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuX19SRVBMQUNFX05PT1BfSU1QT1JUX19cblxuLy8gU3VwcG9ydCBFdmVudFNvdXJjZSBvbiBJbnRlcm5ldCBFeHBsb3JlciAxMVxuaWYgKCF3aW5kb3cuRXZlbnRTb3VyY2UpIHtcbiAgd2luZG93LkV2ZW50U291cmNlID0gRXZlbnRTb3VyY2VQb2x5ZmlsbFxufVxuXG5jb25zdCB7XG4gIF9fTkVYVF9EQVRBX186IHsgYXNzZXRQcmVmaXggfSxcbn0gPSB3aW5kb3dcblxuY29uc3QgcHJlZml4ID0gYXNzZXRQcmVmaXggfHwgJydcbmNvbnN0IHdlYnBhY2tITVIgPSBpbml0V2VicGFja0hNUih7IGFzc2V0UHJlZml4OiBwcmVmaXggfSlcblxud2luZG93Lm5leHQgPSBuZXh0XG5pbml0TmV4dCh7IHdlYnBhY2tITVIgfSlcbiAgLnRoZW4oKHsgcmVuZGVyQ3R4LCByZW5kZXIgfSkgPT4ge1xuICAgIGluaXRPbkRlbWFuZEVudHJpZXMoeyBhc3NldFByZWZpeDogcHJlZml4IH0pXG5cbiAgICBsZXQgYnVpbGRJbmRpY2F0b3JIYW5kbGVyID0gKCkgPT4ge31cblxuICAgIGZ1bmN0aW9uIGRldlBhZ2VzTWFuaWZlc3RMaXN0ZW5lcihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmRhdGEuaW5kZXhPZignZGV2UGFnZXNNYW5pZmVzdCcpICE9PSAtMSkge1xuICAgICAgICBmZXRjaChgJHtwcmVmaXh9L19uZXh0L3N0YXRpYy9kZXZlbG9wbWVudC9fZGV2UGFnZXNNYW5pZmVzdC5qc29uYClcbiAgICAgICAgICAudGhlbigocmVzKSA9PiByZXMuanNvbigpKVxuICAgICAgICAgIC50aGVuKChtYW5pZmVzdCkgPT4ge1xuICAgICAgICAgICAgd2luZG93Ll9fREVWX1BBR0VTX01BTklGRVNUID0gbWFuaWZlc3RcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgRmFpbGVkIHRvIGZldGNoIGRldlBhZ2VzTWFuaWZlc3RgLCBlcnIpXG4gICAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YS5pbmRleE9mKCdzZXJ2ZXJPbmx5Q2hhbmdlcycpICE9PSAtMSkge1xuICAgICAgICBjb25zdCB7IHBhZ2VzIH0gPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpXG4gICAgICAgIGNvbnN0IHJvdXRlciA9IHdpbmRvdy5uZXh0LnJvdXRlclxuXG4gICAgICAgIGlmIChwYWdlcy5pbmNsdWRlcyhyb3V0ZXIucGF0aG5hbWUpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1JlZnJlc2hpbmcgcGFnZSBkYXRhIGR1ZSB0byBzZXJ2ZXItc2lkZSBjaGFuZ2UnKVxuXG4gICAgICAgICAgYnVpbGRJbmRpY2F0b3JIYW5kbGVyKCdidWlsZGluZycpXG5cbiAgICAgICAgICBjb25zdCBjbGVhckluZGljYXRvciA9ICgpID0+IGJ1aWxkSW5kaWNhdG9ySGFuZGxlcignYnVpbHQnKVxuXG4gICAgICAgICAgcm91dGVyXG4gICAgICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICAgICAgcm91dGVyLnBhdGhuYW1lICtcbiAgICAgICAgICAgICAgICAnPycgK1xuICAgICAgICAgICAgICAgIFN0cmluZyhcbiAgICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nLmFzc2lnbihcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlzdHJpbmcudXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhyb3V0ZXIucXVlcnkpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaClcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICByb3V0ZXIuYXNQYXRoXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuZmluYWxseShjbGVhckluZGljYXRvcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkZXZQYWdlc01hbmlmZXN0TGlzdGVuZXIudW5maWx0ZXJlZCA9IHRydWVcbiAgICBnZXRFdmVudFNvdXJjZVdyYXBwZXIoe30pLmFkZE1lc3NhZ2VMaXN0ZW5lcihkZXZQYWdlc01hbmlmZXN0TGlzdGVuZXIpXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0JVSUxEX0lORElDQVRPUikge1xuICAgICAgaW5pdGlhbGl6ZUJ1aWxkV2F0Y2hlcigoaGFuZGxlcikgPT4ge1xuICAgICAgICBidWlsZEluZGljYXRvckhhbmRsZXIgPSBoYW5kbGVyXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIGRlbGF5IHJlbmRlcmluZyB1bnRpbCBhZnRlciBzdHlsZXMgaGF2ZSBiZWVuIGFwcGxpZWQgaW4gZGV2ZWxvcG1lbnRcbiAgICBkaXNwbGF5Q29udGVudCgoKSA9PiB7XG4gICAgICByZW5kZXIocmVuZGVyQ3R4KVxuICAgIH0pXG4gIH0pXG4gIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igd2FzIG5vdCBjYXVnaHQnLCBlcnIpXG4gIH0pXG4iLCIvKipcbiAqIFJlbW92ZXMgdGhlIHRyYWlsaW5nIHNsYXNoIG9mIGEgcGF0aCBpZiB0aGVyZSBpcyBvbmUuIFByZXNlcnZlcyB0aGUgcm9vdCBwYXRoIGAvYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBwYXRoLmVuZHNXaXRoKCcvJykgJiYgcGF0aCAhPT0gJy8nID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoXG59XG5cbi8qKlxuICogTm9ybWFsaXplcyB0aGUgdHJhaWxpbmcgc2xhc2ggb2YgYSBwYXRoIGFjY29yZGluZyB0byB0aGUgYHRyYWlsaW5nU2xhc2hgIG9wdGlvblxuICogaW4gYG5leHQuY29uZmlnLmpzYC5cbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIXG4gID8gKHBhdGg6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICBpZiAoL1xcLlteL10rXFwvPyQvLnRlc3QocGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGgpXG4gICAgICB9IGVsc2UgaWYgKHBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICByZXR1cm4gcGF0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhdGggKyAnLydcbiAgICAgIH1cbiAgICB9XG4gIDogcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2hcbiIsImltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IENsaWVudFNzZ01hbmlmZXN0IH0gZnJvbSAnLi4vYnVpbGQnXG5pbXBvcnQge1xuICBhZGRCYXNlUGF0aCxcbiAgYWRkTG9jYWxlLFxuICBpbnRlcnBvbGF0ZUFzLFxufSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCBnZXRBc3NldFBhdGhGcm9tUm91dGUgZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9nZXQtYXNzZXQtcGF0aC1mcm9tLXJvdXRlJ1xuaW1wb3J0IHsgaXNEeW5hbWljUm91dGUgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMnXG5pbXBvcnQgeyBwYXJzZVJlbGF0aXZlVXJsIH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmwnXG5pbXBvcnQgY3JlYXRlUm91dGVMb2FkZXIsIHtcbiAgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCxcbiAgUm91dGVMb2FkZXIsXG59IGZyb20gJy4vcm91dGUtbG9hZGVyJ1xuXG5mdW5jdGlvbiBub3JtYWxpemVSb3V0ZShyb3V0ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKHJvdXRlWzBdICE9PSAnLycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJvdXRlIG5hbWUgc2hvdWxkIHN0YXJ0IHdpdGggYSBcIi9cIiwgZ290IFwiJHtyb3V0ZX1cImApXG4gIH1cblxuICBpZiAocm91dGUgPT09ICcvJykgcmV0dXJuIHJvdXRlXG4gIHJldHVybiByb3V0ZS5yZXBsYWNlKC9cXC8kLywgJycpXG59XG5cbmV4cG9ydCB0eXBlIFN0eWxlU2hlZXRUdXBsZSA9IHsgaHJlZjogc3RyaW5nOyB0ZXh0OiBzdHJpbmcgfVxuZXhwb3J0IHR5cGUgR29vZFBhZ2VDYWNoZSA9IHtcbiAgcGFnZTogQ29tcG9uZW50VHlwZVxuICBtb2Q6IGFueVxuICBzdHlsZVNoZWV0czogU3R5bGVTaGVldFR1cGxlW11cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFnZUxvYWRlciB7XG4gIHByaXZhdGUgYnVpbGRJZDogc3RyaW5nXG4gIHByaXZhdGUgYXNzZXRQcmVmaXg6IHN0cmluZ1xuXG4gIHByaXZhdGUgcHJvbWlzZWRTc2dNYW5pZmVzdD86IFByb21pc2U8Q2xpZW50U3NnTWFuaWZlc3Q+XG4gIHByaXZhdGUgcHJvbWlzZWREZXZQYWdlc01hbmlmZXN0PzogUHJvbWlzZTxhbnk+XG4gIHB1YmxpYyByb3V0ZUxvYWRlcjogUm91dGVMb2FkZXJcblxuICBjb25zdHJ1Y3RvcihidWlsZElkOiBzdHJpbmcsIGFzc2V0UHJlZml4OiBzdHJpbmcpIHtcbiAgICB0aGlzLnJvdXRlTG9hZGVyID0gY3JlYXRlUm91dGVMb2FkZXIoYXNzZXRQcmVmaXgpXG5cbiAgICB0aGlzLmJ1aWxkSWQgPSBidWlsZElkXG4gICAgdGhpcy5hc3NldFByZWZpeCA9IGFzc2V0UHJlZml4XG5cbiAgICAvKiogQHR5cGUge1Byb21pc2U8U2V0PHN0cmluZz4+fSAqL1xuICAgIHRoaXMucHJvbWlzZWRTc2dNYW5pZmVzdCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBpZiAoKHdpbmRvdyBhcyBhbnkpLl9fU1NHX01BTklGRVNUKSB7XG4gICAgICAgIHJlc29sdmUoKHdpbmRvdyBhcyBhbnkpLl9fU1NHX01BTklGRVNUKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgOyh3aW5kb3cgYXMgYW55KS5fX1NTR19NQU5JRkVTVF9DQiA9ICgpID0+IHtcbiAgICAgICAgICByZXNvbHZlKCh3aW5kb3cgYXMgYW55KS5fX1NTR19NQU5JRkVTVClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBnZXRQYWdlTGlzdCgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuIGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKS50aGVuKChtYW5pZmVzdCkgPT4gbWFuaWZlc3Quc29ydGVkUGFnZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgod2luZG93IGFzIGFueSkuX19ERVZfUEFHRVNfTUFOSUZFU1QpIHtcbiAgICAgICAgcmV0dXJuICh3aW5kb3cgYXMgYW55KS5fX0RFVl9QQUdFU19NQU5JRkVTVC5wYWdlc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb21pc2VkRGV2UGFnZXNNYW5pZmVzdCkge1xuICAgICAgICAgIHRoaXMucHJvbWlzZWREZXZQYWdlc01hbmlmZXN0ID0gZmV0Y2goXG4gICAgICAgICAgICBgJHt0aGlzLmFzc2V0UHJlZml4fS9fbmV4dC9zdGF0aWMvZGV2ZWxvcG1lbnQvX2RldlBhZ2VzTWFuaWZlc3QuanNvbmBcbiAgICAgICAgICApXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiByZXMuanNvbigpKVxuICAgICAgICAgICAgLnRoZW4oKG1hbmlmZXN0KSA9PiB7XG4gICAgICAgICAgICAgIDsod2luZG93IGFzIGFueSkuX19ERVZfUEFHRVNfTUFOSUZFU1QgPSBtYW5pZmVzdFxuICAgICAgICAgICAgICByZXR1cm4gbWFuaWZlc3QucGFnZXNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRmFpbGVkIHRvIGZldGNoIGRldlBhZ2VzTWFuaWZlc3RgLCBlcnIpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2VkRGV2UGFnZXNNYW5pZmVzdFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZiB0aGUgcm91dGUgaHJlZiAoZmlsZS1zeXN0ZW0gcGF0aClcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFzUGF0aCB0aGUgVVJMIGFzIHNob3duIGluIGJyb3dzZXIgKHZpcnR1YWwgcGF0aCk7IHVzZWQgZm9yIGR5bmFtaWMgcm91dGVzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXREYXRhSHJlZihcbiAgICBocmVmOiBzdHJpbmcsXG4gICAgYXNQYXRoOiBzdHJpbmcsXG4gICAgc3NnOiBib29sZWFuLFxuICAgIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBwYXRobmFtZTogaHJlZlBhdGhuYW1lLCBxdWVyeSwgc2VhcmNoIH0gPSBwYXJzZVJlbGF0aXZlVXJsKGhyZWYpXG4gICAgY29uc3QgeyBwYXRobmFtZTogYXNQYXRobmFtZSB9ID0gcGFyc2VSZWxhdGl2ZVVybChhc1BhdGgpXG4gICAgY29uc3Qgcm91dGUgPSBub3JtYWxpemVSb3V0ZShocmVmUGF0aG5hbWUpXG5cbiAgICBjb25zdCBnZXRIcmVmRm9yU2x1ZyA9IChwYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFSb3V0ZSA9IGdldEFzc2V0UGF0aEZyb21Sb3V0ZShhZGRMb2NhbGUocGF0aCwgbG9jYWxlKSwgJy5qc29uJylcbiAgICAgIHJldHVybiBhZGRCYXNlUGF0aChcbiAgICAgICAgYC9fbmV4dC9kYXRhLyR7dGhpcy5idWlsZElkfSR7ZGF0YVJvdXRlfSR7c3NnID8gJycgOiBzZWFyY2h9YFxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IGlzRHluYW1pYzogYm9vbGVhbiA9IGlzRHluYW1pY1JvdXRlKHJvdXRlKVxuICAgIGNvbnN0IGludGVycG9sYXRlZFJvdXRlID0gaXNEeW5hbWljXG4gICAgICA/IGludGVycG9sYXRlQXMoaHJlZlBhdGhuYW1lLCBhc1BhdGhuYW1lLCBxdWVyeSkucmVzdWx0XG4gICAgICA6ICcnXG5cbiAgICByZXR1cm4gaXNEeW5hbWljXG4gICAgICA/IGludGVycG9sYXRlZFJvdXRlICYmIGdldEhyZWZGb3JTbHVnKGludGVycG9sYXRlZFJvdXRlKVxuICAgICAgOiBnZXRIcmVmRm9yU2x1Zyhyb3V0ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZiB0aGUgcm91dGUgaHJlZiAoZmlsZS1zeXN0ZW0gcGF0aClcbiAgICovXG4gIF9pc1NzZyhocmVmOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCB7IHBhdGhuYW1lOiBocmVmUGF0aG5hbWUgfSA9IHBhcnNlUmVsYXRpdmVVcmwoaHJlZilcbiAgICBjb25zdCByb3V0ZSA9IG5vcm1hbGl6ZVJvdXRlKGhyZWZQYXRobmFtZSlcbiAgICByZXR1cm4gdGhpcy5wcm9taXNlZFNzZ01hbmlmZXN0IS50aGVuKChzOiBDbGllbnRTc2dNYW5pZmVzdCkgPT5cbiAgICAgIHMuaGFzKHJvdXRlKVxuICAgIClcbiAgfVxuXG4gIGxvYWRQYWdlKHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPEdvb2RQYWdlQ2FjaGU+IHtcbiAgICByZXR1cm4gdGhpcy5yb3V0ZUxvYWRlci5sb2FkUm91dGUocm91dGUpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgaWYgKCdjb21wb25lbnQnIGluIHJlcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhZ2U6IHJlcy5jb21wb25lbnQsXG4gICAgICAgICAgbW9kOiByZXMuZXhwb3J0cyxcbiAgICAgICAgICBzdHlsZVNoZWV0czogcmVzLnN0eWxlcy5tYXAoKG8pID0+ICh7XG4gICAgICAgICAgICBocmVmOiBvLmhyZWYsXG4gICAgICAgICAgICB0ZXh0OiBvLmNvbnRlbnQsXG4gICAgICAgICAgfSkpLFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyByZXMuZXJyb3JcbiAgICB9KVxuICB9XG5cbiAgcHJlZmV0Y2gocm91dGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnJvdXRlTG9hZGVyLnByZWZldGNoKHJvdXRlKVxuICB9XG59XG4iLCJpbXBvcnQge1xuICBnZXRDTFMsXG4gIGdldEZDUCxcbiAgZ2V0RklELFxuICBnZXRMQ1AsXG4gIGdldFRURkIsXG4gIE1ldHJpYyxcbiAgUmVwb3J0SGFuZGxlcixcbn0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3dlYi12aXRhbHMnXG5cbmNvbnN0IGluaXRpYWxIcmVmID0gbG9jYXRpb24uaHJlZlxubGV0IGlzUmVnaXN0ZXJlZCA9IGZhbHNlXG5sZXQgdXNlclJlcG9ydEhhbmRsZXI6IFJlcG9ydEhhbmRsZXIgfCB1bmRlZmluZWRcblxuZnVuY3Rpb24gb25SZXBvcnQobWV0cmljOiBNZXRyaWMpOiB2b2lkIHtcbiAgaWYgKHVzZXJSZXBvcnRIYW5kbGVyKSB7XG4gICAgdXNlclJlcG9ydEhhbmRsZXIobWV0cmljKVxuICB9XG5cbiAgLy8gVGhpcyBjb2RlIGlzIG5vdCBzaGlwcGVkLCBleGVjdXRlZCwgb3IgcHJlc2VudCBpbiB0aGUgY2xpZW50LXNpZGVcbiAgLy8gSmF2YVNjcmlwdCBidW5kbGUgdW5sZXNzIGV4cGxpY2l0bHkgZW5hYmxlZCBpbiB5b3VyIGFwcGxpY2F0aW9uLlxuICAvL1xuICAvLyBXaGVuIHRoaXMgZmVhdHVyZSBpcyBlbmFibGVkLCB3ZSdsbCBtYWtlIGl0IHZlcnkgY2xlYXIgYnkgcHJpbnRpbmcgYVxuICAvLyBtZXNzYWdlIGR1cmluZyB0aGUgYnVpbGQgKGBuZXh0IGJ1aWxkYCkuXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgLy8gVGhpcyBmaWVsZCBpcyBlbXB0eSB1bmxlc3MgeW91IGV4cGxpY2l0bHkgY29uZmlndXJlIGl0OlxuICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9BTkFMWVRJQ1NfSURcbiAgKSB7XG4gICAgY29uc3QgYm9keTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgIGRzbjogcHJvY2Vzcy5lbnYuX19ORVhUX0FOQUxZVElDU19JRCxcbiAgICAgIGlkOiBtZXRyaWMuaWQsXG4gICAgICBwYWdlOiB3aW5kb3cuX19ORVhUX0RBVEFfXy5wYWdlLFxuICAgICAgaHJlZjogaW5pdGlhbEhyZWYsXG4gICAgICBldmVudF9uYW1lOiBtZXRyaWMubmFtZSxcbiAgICAgIHZhbHVlOiBtZXRyaWMudmFsdWUudG9TdHJpbmcoKSxcbiAgICAgIHNwZWVkOlxuICAgICAgICAnY29ubmVjdGlvbicgaW4gbmF2aWdhdG9yICYmXG4gICAgICAgIG5hdmlnYXRvclsnY29ubmVjdGlvbiddICYmXG4gICAgICAgICdlZmZlY3RpdmVUeXBlJyBpbiBuYXZpZ2F0b3JbJ2Nvbm5lY3Rpb24nXVxuICAgICAgICAgID8gKG5hdmlnYXRvclsnY29ubmVjdGlvbiddWydlZmZlY3RpdmVUeXBlJ10gYXMgc3RyaW5nKVxuICAgICAgICAgIDogJycsXG4gICAgfVxuXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtuZXcgVVJMU2VhcmNoUGFyYW1zKGJvZHkpLnRvU3RyaW5nKCldLCB7XG4gICAgICAvLyBUaGlzIGNvbnRlbnQgdHlwZSBpcyBuZWNlc3NhcnkgZm9yIGBzZW5kQmVhY29uYDpcbiAgICAgIHR5cGU6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgIH0pXG4gICAgY29uc3Qgdml0YWxzVXJsID0gJ2h0dHBzOi8vdml0YWxzLnZlcmNlbC1pbnNpZ2h0cy5jb20vdjEvdml0YWxzJ1xuICAgIDsobmF2aWdhdG9yLnNlbmRCZWFjb24gJiYgbmF2aWdhdG9yLnNlbmRCZWFjb24odml0YWxzVXJsLCBibG9iKSkgfHxcbiAgICAgIGZldGNoKHZpdGFsc1VybCwge1xuICAgICAgICBib2R5OiBibG9iLFxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgY3JlZGVudGlhbHM6ICdvbWl0JyxcbiAgICAgICAga2VlcGFsaXZlOiB0cnVlLFxuICAgICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCAob25QZXJmRW50cnk/OiBSZXBvcnRIYW5kbGVyKTogdm9pZCA9PiB7XG4gIC8vIFVwZGF0ZSBmdW5jdGlvbiBpZiBpdCBjaGFuZ2VzOlxuICB1c2VyUmVwb3J0SGFuZGxlciA9IG9uUGVyZkVudHJ5XG5cbiAgLy8gT25seSByZWdpc3RlciBsaXN0ZW5lcnMgb25jZTpcbiAgaWYgKGlzUmVnaXN0ZXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIGlzUmVnaXN0ZXJlZCA9IHRydWVcblxuICBnZXRDTFMob25SZXBvcnQpXG4gIGdldEZJRChvblJlcG9ydClcbiAgZ2V0RkNQKG9uUmVwb3J0KVxuICBnZXRMQ1Aob25SZXBvcnQpXG4gIGdldFRURkIob25SZXBvcnQpXG59XG4iLCJ0eXBlIFJlcXVlc3RJZGxlQ2FsbGJhY2tIYW5kbGUgPSBhbnlcbnR5cGUgUmVxdWVzdElkbGVDYWxsYmFja09wdGlvbnMgPSB7XG4gIHRpbWVvdXQ6IG51bWJlclxufVxudHlwZSBSZXF1ZXN0SWRsZUNhbGxiYWNrRGVhZGxpbmUgPSB7XG4gIHJlYWRvbmx5IGRpZFRpbWVvdXQ6IGJvb2xlYW5cbiAgdGltZVJlbWFpbmluZzogKCkgPT4gbnVtYmVyXG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjazogKFxuICAgICAgY2FsbGJhY2s6IChkZWFkbGluZTogUmVxdWVzdElkbGVDYWxsYmFja0RlYWRsaW5lKSA9PiB2b2lkLFxuICAgICAgb3B0cz86IFJlcXVlc3RJZGxlQ2FsbGJhY2tPcHRpb25zXG4gICAgKSA9PiBSZXF1ZXN0SWRsZUNhbGxiYWNrSGFuZGxlXG4gIH1cbn1cblxuY29uc3QgcmVxdWVzdElkbGVDYWxsYmFjayA9XG4gICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5yZXF1ZXN0SWRsZUNhbGxiYWNrKSB8fFxuICBmdW5jdGlvbiAoXG4gICAgY2I6IChkZWFkbGluZTogUmVxdWVzdElkbGVDYWxsYmFja0RlYWRsaW5lKSA9PiB2b2lkXG4gICk6IE5vZGVKUy5UaW1lb3V0IHtcbiAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpXG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY2Ioe1xuICAgICAgICBkaWRUaW1lb3V0OiBmYWxzZSxcbiAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCA1MCAtIChEYXRlLm5vdygpIC0gc3RhcnQpKVxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9LCAxKVxuICB9XG5cbmV4cG9ydCBkZWZhdWx0IHJlcXVlc3RJZGxlQ2FsbGJhY2tcbiIsImltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IENsaWVudEJ1aWxkTWFuaWZlc3QgfSBmcm9tICcuLi9idWlsZC93ZWJwYWNrL3BsdWdpbnMvYnVpbGQtbWFuaWZlc3QtcGx1Z2luJ1xuaW1wb3J0IGdldEFzc2V0UGF0aEZyb21Sb3V0ZSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2dldC1hc3NldC1wYXRoLWZyb20tcm91dGUnXG5pbXBvcnQgcmVxdWVzdElkbGVDYWxsYmFjayBmcm9tICcuL3JlcXVlc3QtaWRsZS1jYWxsYmFjaydcblxuLy8gMy44cyB3YXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGl0J3Mgd2hhdCBodHRwczovL3dlYi5kZXYvaW50ZXJhY3RpdmVcbi8vIGNvbnNpZGVycyBhcyBcIkdvb2RcIiB0aW1lLXRvLWludGVyYWN0aXZlLiBXZSBtdXN0IGFzc3VtZSBzb21ldGhpbmcgd2VudFxuLy8gd3JvbmcgYmV5b25kIHRoaXMgcG9pbnQsIGFuZCB0aGVuIGZhbGwtYmFjayB0byBhIGZ1bGwgcGFnZSB0cmFuc2l0aW9uIHRvXG4vLyBzaG93IHRoZSB1c2VyIHNvbWV0aGluZyBvZiB2YWx1ZS5cbmNvbnN0IE1TX01BWF9JRExFX0RFTEFZID0gMzgwMFxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIF9fQlVJTERfTUFOSUZFU1Q/OiBDbGllbnRCdWlsZE1hbmlmZXN0XG4gICAgX19CVUlMRF9NQU5JRkVTVF9DQj86IEZ1bmN0aW9uXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2FkZWRFbnRyeXBvaW50U3VjY2VzcyB7XG4gIGNvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICBleHBvcnRzOiBhbnlcbn1cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVkRW50cnlwb2ludEZhaWx1cmUge1xuICBlcnJvcjogdW5rbm93blxufVxuZXhwb3J0IHR5cGUgUm91dGVFbnRyeXBvaW50ID0gTG9hZGVkRW50cnlwb2ludFN1Y2Nlc3MgfCBMb2FkZWRFbnRyeXBvaW50RmFpbHVyZVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlU3R5bGVTaGVldCB7XG4gIGhyZWY6IHN0cmluZ1xuICBjb250ZW50OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2FkZWRSb3V0ZVN1Y2Nlc3MgZXh0ZW5kcyBMb2FkZWRFbnRyeXBvaW50U3VjY2VzcyB7XG4gIHN0eWxlczogUm91dGVTdHlsZVNoZWV0W11cbn1cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZGVkUm91dGVGYWlsdXJlIHtcbiAgZXJyb3I6IHVua25vd25cbn1cbmV4cG9ydCB0eXBlIFJvdXRlTG9hZGVyRW50cnkgPSBMb2FkZWRSb3V0ZVN1Y2Nlc3MgfCBMb2FkZWRSb3V0ZUZhaWx1cmVcblxuZXhwb3J0IHR5cGUgRnV0dXJlPFY+ID0ge1xuICByZXNvbHZlOiAoZW50cnlwb2ludDogVikgPT4gdm9pZFxuICBmdXR1cmU6IFByb21pc2U8Vj5cbn1cbmZ1bmN0aW9uIHdpdGhGdXR1cmU8VD4oXG4gIGtleTogc3RyaW5nLFxuICBtYXA6IE1hcDxzdHJpbmcsIEZ1dHVyZTxUPiB8IFQ+LFxuICBnZW5lcmF0b3I/OiAoKSA9PiBQcm9taXNlPFQ+XG4pOiBQcm9taXNlPFQ+IHtcbiAgbGV0IGVudHJ5OiBGdXR1cmU8VD4gfCBUIHwgdW5kZWZpbmVkID0gbWFwLmdldChrZXkpXG4gIGlmIChlbnRyeSkge1xuICAgIGlmICgnZnV0dXJlJyBpbiBlbnRyeSkge1xuICAgICAgcmV0dXJuIGVudHJ5LmZ1dHVyZVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVudHJ5KVxuICB9XG4gIGxldCByZXNvbHZlcjogKGVudHJ5cG9pbnQ6IFQpID0+IHZvaWRcbiAgY29uc3QgcHJvbTogUHJvbWlzZTxUPiA9IG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlKSA9PiB7XG4gICAgcmVzb2x2ZXIgPSByZXNvbHZlXG4gIH0pXG4gIG1hcC5zZXQoa2V5LCAoZW50cnkgPSB7IHJlc29sdmU6IHJlc29sdmVyISwgZnV0dXJlOiBwcm9tIH0pKVxuICByZXR1cm4gZ2VuZXJhdG9yXG4gICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICBnZW5lcmF0b3IoKS50aGVuKCh2YWx1ZSkgPT4gKHJlc29sdmVyKHZhbHVlKSwgdmFsdWUpKVxuICAgIDogcHJvbVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlTG9hZGVyIHtcbiAgd2hlbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZyk6IFByb21pc2U8Um91dGVFbnRyeXBvaW50PlxuICBvbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZywgZXhlY3V0ZTogKCkgPT4gdW5rbm93bik6IHZvaWRcbiAgbG9hZFJvdXRlKHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPFJvdXRlTG9hZGVyRW50cnk+XG4gIHByZWZldGNoKHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+XG59XG5cbmZ1bmN0aW9uIGhhc1ByZWZldGNoKGxpbms/OiBIVE1MTGlua0VsZW1lbnQpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpXG4gICAgcmV0dXJuIChcbiAgICAgIC8vIGRldGVjdCBJRTExIHNpbmNlIGl0IHN1cHBvcnRzIHByZWZldGNoIGJ1dCBpc24ndCBkZXRlY3RlZFxuICAgICAgLy8gd2l0aCByZWxMaXN0LnN1cHBvcnRcbiAgICAgICghIXdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiAhIShkb2N1bWVudCBhcyBhbnkpLmRvY3VtZW50TW9kZSkgfHxcbiAgICAgIGxpbmsucmVsTGlzdC5zdXBwb3J0cygncHJlZmV0Y2gnKVxuICAgIClcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuY29uc3QgY2FuUHJlZmV0Y2g6IGJvb2xlYW4gPSBoYXNQcmVmZXRjaCgpXG5cbmZ1bmN0aW9uIHByZWZldGNoVmlhRG9tKFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIGxpbms/OiBIVE1MTGlua0VsZW1lbnRcbik6IFByb21pc2U8YW55PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgbGlua1tyZWw9XCJwcmVmZXRjaFwiXVtocmVmXj1cIiR7aHJlZn1cIl1gKSkge1xuICAgICAgcmV0dXJuIHJlcygpXG4gICAgfVxuXG4gICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKVxuXG4gICAgLy8gVGhlIG9yZGVyIG9mIHByb3BlcnR5IGFzc2lnbm1lbnQgaGVyZSBpcyBpbnRlbnRpb25hbDpcbiAgICBpZiAoYXMpIGxpbmshLmFzID0gYXNcbiAgICBsaW5rIS5yZWwgPSBgcHJlZmV0Y2hgXG4gICAgbGluayEuY3Jvc3NPcmlnaW4gPSBwcm9jZXNzLmVudi5fX05FWFRfQ1JPU1NfT1JJR0lOIVxuICAgIGxpbmshLm9ubG9hZCA9IHJlc1xuICAgIGxpbmshLm9uZXJyb3IgPSByZWpcblxuICAgIC8vIGBocmVmYCBzaG91bGQgYWx3YXlzIGJlIGxhc3Q6XG4gICAgbGluayEuaHJlZiA9IGhyZWZcblxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGluaylcbiAgfSlcbn1cblxuY29uc3QgQVNTRVRfTE9BRF9FUlJPUiA9IFN5bWJvbCgnQVNTRVRfTE9BRF9FUlJPUicpXG4vLyBUT0RPOiB1bmV4cG9ydFxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtBc3NldEVycm9yKGVycjogRXJyb3IpOiBFcnJvciB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCBBU1NFVF9MT0FEX0VSUk9SLCB7fSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXNzZXRFcnJvcihlcnI/OiBFcnJvcik6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICByZXR1cm4gZXJyICYmIEFTU0VUX0xPQURfRVJST1IgaW4gZXJyXG59XG5cbmZ1bmN0aW9uIGFwcGVuZFNjcmlwdChcbiAgc3JjOiBzdHJpbmcsXG4gIHNjcmlwdD86IEhUTUxTY3JpcHRFbGVtZW50XG4pOiBQcm9taXNlPHVua25vd24+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuXG4gICAgLy8gVGhlIG9yZGVyIG9mIHByb3BlcnR5IGFzc2lnbm1lbnQgaGVyZSBpcyBpbnRlbnRpb25hbC5cbiAgICAvLyAxLiBTZXR1cCBzdWNjZXNzL2ZhaWx1cmUgaG9va3MgaW4gY2FzZSB0aGUgYnJvd3NlciBzeW5jaHJvbm91c2x5XG4gICAgLy8gICAgZXhlY3V0ZXMgd2hlbiBgc3JjYCBpcyBzZXQuXG4gICAgc2NyaXB0Lm9ubG9hZCA9IHJlc29sdmVcbiAgICBzY3JpcHQub25lcnJvciA9ICgpID0+XG4gICAgICByZWplY3QobWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzY3JpcHQ6ICR7c3JjfWApKSlcblxuICAgIC8vIDIuIENvbmZpZ3VyZSB0aGUgY3Jvc3Mtb3JpZ2luIGF0dHJpYnV0ZSBiZWZvcmUgc2V0dGluZyBgc3JjYCBpbiBjYXNlIHRoZVxuICAgIC8vICAgIGJyb3dzZXIgYmVnaW5zIHRvIGZldGNoLlxuICAgIHNjcmlwdC5jcm9zc09yaWdpbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DUk9TU19PUklHSU4hXG5cbiAgICAvLyAzLiBGaW5hbGx5LCBzZXQgdGhlIHNvdXJjZSBhbmQgaW5qZWN0IGludG8gdGhlIERPTSBpbiBjYXNlIHRoZSBjaGlsZFxuICAgIC8vICAgIG11c3QgYmUgYXBwZW5kZWQgZm9yIGZldGNoaW5nIHRvIHN0YXJ0LlxuICAgIHNjcmlwdC5zcmMgPSBzcmNcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdClcbiAgfSlcbn1cblxuZnVuY3Rpb24gaWRsZVRpbWVvdXQ8VD4obXM6IG51bWJlciwgZXJyOiBFcnJvcik6IFByb21pc2U8VD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKF9yZXNvbHZlLCByZWplY3QpID0+XG4gICAgcmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChlcnIpLCBtcykpXG4gIClcbn1cblxuLy8gVE9ETzogc3RvcCBleHBvcnRpbmcgb3IgY2FjaGUgdGhlIGZhaWx1cmVcbi8vIEl0J2QgYmUgYmVzdCB0byBzdG9wIGV4cG9ydGluZyB0aGlzLiBJdCdzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbC4gV2UncmVcbi8vIG9ubHkgZXhwb3J0aW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbHR5IHdpdGggdGhlIGBwYWdlLWxvYWRlcmAuXG4vLyBPbmx5IGNhY2hlIHRoaXMgcmVzcG9uc2UgYXMgYSBsYXN0IHJlc29ydCBpZiB3ZSBjYW5ub3QgZWxpbWluYXRlIGFsbCBvdGhlclxuLy8gY29kZSBicmFuY2hlcyB0aGF0IHVzZSB0aGUgQnVpbGQgTWFuaWZlc3QgQ2FsbGJhY2sgYW5kIHB1c2ggdGhlbSB0aHJvdWdoXG4vLyB0aGUgUm91dGUgTG9hZGVyIGludGVyZmFjZS5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCk6IFByb21pc2U8Q2xpZW50QnVpbGRNYW5pZmVzdD4ge1xuICBpZiAoc2VsZi5fX0JVSUxEX01BTklGRVNUKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzZWxmLl9fQlVJTERfTUFOSUZFU1QpXG4gIH1cblxuICBjb25zdCBvbkJ1aWxkTWFuaWZlc3Q6IFByb21pc2U8Q2xpZW50QnVpbGRNYW5pZmVzdD4gPSBuZXcgUHJvbWlzZTxcbiAgICBDbGllbnRCdWlsZE1hbmlmZXN0XG4gID4oKHJlc29sdmUpID0+IHtcbiAgICAvLyBNYW5kYXRvcnkgYmVjYXVzZSB0aGlzIGlzIG5vdCBjb25jdXJyZW50IHNhZmU6XG4gICAgY29uc3QgY2IgPSBzZWxmLl9fQlVJTERfTUFOSUZFU1RfQ0JcbiAgICBzZWxmLl9fQlVJTERfTUFOSUZFU1RfQ0IgPSAoKSA9PiB7XG4gICAgICByZXNvbHZlKHNlbGYuX19CVUlMRF9NQU5JRkVTVClcbiAgICAgIGNiICYmIGNiKClcbiAgICB9XG4gIH0pXG4gIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgIG9uQnVpbGRNYW5pZmVzdCxcbiAgICBpZGxlVGltZW91dDxDbGllbnRCdWlsZE1hbmlmZXN0PihcbiAgICAgIE1TX01BWF9JRExFX0RFTEFZLFxuICAgICAgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjbGllbnQgYnVpbGQgbWFuaWZlc3QnKSlcbiAgICApLFxuICBdKVxufVxuXG5pbnRlcmZhY2UgUm91dGVGaWxlcyB7XG4gIHNjcmlwdHM6IHN0cmluZ1tdXG4gIGNzczogc3RyaW5nW11cbn1cbmZ1bmN0aW9uIGdldEZpbGVzRm9yUm91dGUoXG4gIGFzc2V0UHJlZml4OiBzdHJpbmcsXG4gIHJvdXRlOiBzdHJpbmdcbik6IFByb21pc2U8Um91dGVGaWxlcz4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIHNjcmlwdHM6IFtcbiAgICAgICAgYXNzZXRQcmVmaXggK1xuICAgICAgICAgICcvX25leHQvc3RhdGljL2NodW5rcy9wYWdlcycgK1xuICAgICAgICAgIGVuY29kZVVSSShnZXRBc3NldFBhdGhGcm9tUm91dGUocm91dGUsICcuanMnKSksXG4gICAgICBdLFxuICAgICAgLy8gU3R5bGVzIGFyZSBoYW5kbGVkIGJ5IGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50OlxuICAgICAgY3NzOiBbXSxcbiAgICB9KVxuICB9XG4gIHJldHVybiBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkudGhlbigobWFuaWZlc3QpID0+IHtcbiAgICBpZiAoIShyb3V0ZSBpbiBtYW5pZmVzdCkpIHtcbiAgICAgIHRocm93IG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvb2t1cCByb3V0ZTogJHtyb3V0ZX1gKSlcbiAgICB9XG4gICAgY29uc3QgYWxsRmlsZXMgPSBtYW5pZmVzdFtyb3V0ZV0ubWFwKFxuICAgICAgKGVudHJ5KSA9PiBhc3NldFByZWZpeCArICcvX25leHQvJyArIGVuY29kZVVSSShlbnRyeSlcbiAgICApXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmlwdHM6IGFsbEZpbGVzLmZpbHRlcigodikgPT4gdi5lbmRzV2l0aCgnLmpzJykpLFxuICAgICAgY3NzOiBhbGxGaWxlcy5maWx0ZXIoKHYpID0+IHYuZW5kc1dpdGgoJy5jc3MnKSksXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZUxvYWRlcihhc3NldFByZWZpeDogc3RyaW5nKTogUm91dGVMb2FkZXIge1xuICBjb25zdCBlbnRyeXBvaW50czogTWFwPFxuICAgIHN0cmluZyxcbiAgICBGdXR1cmU8Um91dGVFbnRyeXBvaW50PiB8IFJvdXRlRW50cnlwb2ludFxuICA+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IGxvYWRlZFNjcmlwdHM6IE1hcDxzdHJpbmcsIFByb21pc2U8dW5rbm93bj4+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IHN0eWxlU2hlZXRzOiBNYXA8c3RyaW5nLCBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4+ID0gbmV3IE1hcCgpXG4gIGNvbnN0IHJvdXRlczogTWFwPFxuICAgIHN0cmluZyxcbiAgICBGdXR1cmU8Um91dGVMb2FkZXJFbnRyeT4gfCBSb3V0ZUxvYWRlckVudHJ5XG4gID4gPSBuZXcgTWFwKClcblxuICBmdW5jdGlvbiBtYXliZUV4ZWN1dGVTY3JpcHQoc3JjOiBzdHJpbmcpOiBQcm9taXNlPHVua25vd24+IHtcbiAgICBsZXQgcHJvbTogUHJvbWlzZTx1bmtub3duPiB8IHVuZGVmaW5lZCA9IGxvYWRlZFNjcmlwdHMuZ2V0KHNyYylcbiAgICBpZiAocHJvbSkge1xuICAgICAgcmV0dXJuIHByb21cbiAgICB9XG5cbiAgICAvLyBTa2lwIGV4ZWN1dGluZyBzY3JpcHQgaWYgaXQncyBhbHJlYWR5IGluIHRoZSBET006XG4gICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHNjcmlwdFtzcmNePVwiJHtzcmN9XCJdYCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH1cblxuICAgIGxvYWRlZFNjcmlwdHMuc2V0KHNyYywgKHByb20gPSBhcHBlbmRTY3JpcHQoc3JjKSkpXG4gICAgcmV0dXJuIHByb21cbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoU3R5bGVTaGVldChocmVmOiBzdHJpbmcpOiBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4ge1xuICAgIGxldCBwcm9tOiBQcm9taXNlPFJvdXRlU3R5bGVTaGVldD4gfCB1bmRlZmluZWQgPSBzdHlsZVNoZWV0cy5nZXQoaHJlZilcbiAgICBpZiAocHJvbSkge1xuICAgICAgcmV0dXJuIHByb21cbiAgICB9XG5cbiAgICBzdHlsZVNoZWV0cy5zZXQoXG4gICAgICBocmVmLFxuICAgICAgKHByb20gPSBmZXRjaChocmVmKVxuICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3R5bGVzaGVldDogJHtocmVmfWApXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXMudGV4dCgpLnRoZW4oKHRleHQpID0+ICh7IGhyZWY6IGhyZWYsIGNvbnRlbnQ6IHRleHQgfSkpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IoZXJyKVxuICAgICAgICB9KSlcbiAgICApXG4gICAgcmV0dXJuIHByb21cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2hlbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZykge1xuICAgICAgcmV0dXJuIHdpdGhGdXR1cmUocm91dGUsIGVudHJ5cG9pbnRzKVxuICAgIH0sXG4gICAgb25FbnRyeXBvaW50KHJvdXRlOiBzdHJpbmcsIGV4ZWN1dGU6ICgpID0+IHVua25vd24pIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZShleGVjdXRlKVxuICAgICAgICAudGhlbigoZm4pID0+IGZuKCkpXG4gICAgICAgIC50aGVuKFxuICAgICAgICAgIChleHBvcnRzOiBhbnkpID0+ICh7XG4gICAgICAgICAgICBjb21wb25lbnQ6IChleHBvcnRzICYmIGV4cG9ydHMuZGVmYXVsdCkgfHwgZXhwb3J0cyxcbiAgICAgICAgICAgIGV4cG9ydHM6IGV4cG9ydHMsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgKGVycikgPT4gKHsgZXJyb3I6IGVyciB9KVxuICAgICAgICApXG4gICAgICAgIC50aGVuKChpbnB1dDogUm91dGVFbnRyeXBvaW50KSA9PiB7XG4gICAgICAgICAgY29uc3Qgb2xkID0gZW50cnlwb2ludHMuZ2V0KHJvdXRlKVxuICAgICAgICAgIGVudHJ5cG9pbnRzLnNldChyb3V0ZSwgaW5wdXQpXG4gICAgICAgICAgaWYgKG9sZCAmJiAncmVzb2x2ZScgaW4gb2xkKSBvbGQucmVzb2x2ZShpbnB1dClcbiAgICAgICAgfSlcbiAgICB9LFxuICAgIGxvYWRSb3V0ZShyb3V0ZTogc3RyaW5nKSB7XG4gICAgICByZXR1cm4gd2l0aEZ1dHVyZTxSb3V0ZUxvYWRlckVudHJ5Pihyb3V0ZSwgcm91dGVzLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBzY3JpcHRzLCBjc3MgfSA9IGF3YWl0IGdldEZpbGVzRm9yUm91dGUoYXNzZXRQcmVmaXgsIHJvdXRlKVxuICAgICAgICAgIGNvbnN0IFssIHN0eWxlc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBlbnRyeXBvaW50cy5oYXMocm91dGUpXG4gICAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgICAgOiBQcm9taXNlLmFsbChzY3JpcHRzLm1hcChtYXliZUV4ZWN1dGVTY3JpcHQpKSxcbiAgICAgICAgICAgIFByb21pc2UuYWxsKGNzcy5tYXAoZmV0Y2hTdHlsZVNoZWV0KSksXG4gICAgICAgICAgXSBhcyBjb25zdClcblxuICAgICAgICAgIGNvbnN0IGVudHJ5cG9pbnQ6IFJvdXRlRW50cnlwb2ludCA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICB0aGlzLndoZW5FbnRyeXBvaW50KHJvdXRlKSxcbiAgICAgICAgICAgIGlkbGVUaW1lb3V0PFJvdXRlTG9hZGVyRW50cnk+KFxuICAgICAgICAgICAgICBNU19NQVhfSURMRV9ERUxBWSxcbiAgICAgICAgICAgICAgbWFya0Fzc2V0RXJyb3IoXG4gICAgICAgICAgICAgICAgbmV3IEVycm9yKGBSb3V0ZSBkaWQgbm90IGNvbXBsZXRlIGxvYWRpbmc6ICR7cm91dGV9YClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBdKVxuICAgICAgICAgIGNvbnN0IHJlczogUm91dGVMb2FkZXJFbnRyeSA9IE9iamVjdC5hc3NpZ248XG4gICAgICAgICAgICB7IHN0eWxlczogUm91dGVTdHlsZVNoZWV0W10gfSxcbiAgICAgICAgICAgIFJvdXRlRW50cnlwb2ludFxuICAgICAgICAgID4oeyBzdHlsZXMgfSwgZW50cnlwb2ludClcbiAgICAgICAgICByZXR1cm4gJ2Vycm9yJyBpbiBlbnRyeXBvaW50ID8gZW50cnlwb2ludCA6IHJlc1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4geyBlcnJvcjogZXJyIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuICAgIHByZWZldGNoKHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWVMYWJzL3F1aWNrbGluay9ibG9iLzQ1M2E2NjFmYTFmYTk0MGUyZDJlMDQ0NDUyMzk4ZTM4YzY3YTk4ZmIvc3JjL2luZGV4Lm1qcyNMMTE1LUwxMThcbiAgICAgIC8vIExpY2Vuc2U6IEFwYWNoZSAyLjBcbiAgICAgIGxldCBjblxuICAgICAgaWYgKChjbiA9IChuYXZpZ2F0b3IgYXMgYW55KS5jb25uZWN0aW9uKSkge1xuICAgICAgICAvLyBEb24ndCBwcmVmZXRjaCBpZiB1c2luZyAyRyBvciBpZiBTYXZlLURhdGEgaXMgZW5hYmxlZC5cbiAgICAgICAgaWYgKGNuLnNhdmVEYXRhIHx8IC8yZy8udGVzdChjbi5lZmZlY3RpdmVUeXBlKSkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpXG4gICAgICAgIC50aGVuKChvdXRwdXQpID0+XG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBjYW5QcmVmZXRjaFxuICAgICAgICAgICAgICA/IG91dHB1dC5zY3JpcHRzLm1hcCgoc2NyaXB0KSA9PiBwcmVmZXRjaFZpYURvbShzY3JpcHQsICdzY3JpcHQnKSlcbiAgICAgICAgICAgICAgOiBbXVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiB0aGlzLmxvYWRSb3V0ZShyb3V0ZSkpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChcbiAgICAgICAgICAvLyBzd2FsbG93IHByZWZldGNoIGVycm9yc1xuICAgICAgICAgICgpID0+IHt9XG4gICAgICAgIClcbiAgICB9LFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVJvdXRlTG9hZGVyXG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUm91dGVyLCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IFJvdXRlckNvbnRleHQgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyLWNvbnRleHQnXG5cbnR5cGUgQ2xhc3NBcmd1bWVudHM8VD4gPSBUIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBpbmZlciBVKSA9PiBhbnkgPyBVIDogYW55XG5cbnR5cGUgUm91dGVyQXJncyA9IENsYXNzQXJndW1lbnRzPHR5cGVvZiBSb3V0ZXI+XG5cbnR5cGUgU2luZ2xldG9uUm91dGVyQmFzZSA9IHtcbiAgcm91dGVyOiBSb3V0ZXIgfCBudWxsXG4gIHJlYWR5Q2FsbGJhY2tzOiBBcnJheTwoKSA9PiBhbnk+XG4gIHJlYWR5KGNiOiAoKSA9PiBhbnkpOiB2b2lkXG59XG5cbmV4cG9ydCB7IFJvdXRlciwgTmV4dFJvdXRlciB9XG5cbmV4cG9ydCB0eXBlIFNpbmdsZXRvblJvdXRlciA9IFNpbmdsZXRvblJvdXRlckJhc2UgJiBOZXh0Um91dGVyXG5cbmNvbnN0IHNpbmdsZXRvblJvdXRlcjogU2luZ2xldG9uUm91dGVyQmFzZSA9IHtcbiAgcm91dGVyOiBudWxsLCAvLyBob2xkcyB0aGUgYWN0dWFsIHJvdXRlciBpbnN0YW5jZVxuICByZWFkeUNhbGxiYWNrczogW10sXG4gIHJlYWR5KGNiOiAoKSA9PiB2b2lkKSB7XG4gICAgaWYgKHRoaXMucm91dGVyKSByZXR1cm4gY2IoKVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5yZWFkeUNhbGxiYWNrcy5wdXNoKGNiKVxuICAgIH1cbiAgfSxcbn1cblxuLy8gQ3JlYXRlIHB1YmxpYyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIG9mIHRoZSByb3V0ZXIgaW4gdGhlIHNpbmdsZXRvblJvdXRlclxuY29uc3QgdXJsUHJvcGVydHlGaWVsZHMgPSBbXG4gICdwYXRobmFtZScsXG4gICdyb3V0ZScsXG4gICdxdWVyeScsXG4gICdhc1BhdGgnLFxuICAnY29tcG9uZW50cycsXG4gICdpc0ZhbGxiYWNrJyxcbiAgJ2Jhc2VQYXRoJyxcbiAgJ2xvY2FsZScsXG4gICdsb2NhbGVzJyxcbiAgJ2RlZmF1bHRMb2NhbGUnLFxuICAnaXNSZWFkeScsXG5dXG5jb25zdCByb3V0ZXJFdmVudHMgPSBbXG4gICdyb3V0ZUNoYW5nZVN0YXJ0JyxcbiAgJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLFxuICAncm91dGVDaGFuZ2VDb21wbGV0ZScsXG4gICdyb3V0ZUNoYW5nZUVycm9yJyxcbiAgJ2hhc2hDaGFuZ2VTdGFydCcsXG4gICdoYXNoQ2hhbmdlQ29tcGxldGUnLFxuXVxuY29uc3QgY29yZU1ldGhvZEZpZWxkcyA9IFtcbiAgJ3B1c2gnLFxuICAncmVwbGFjZScsXG4gICdyZWxvYWQnLFxuICAnYmFjaycsXG4gICdwcmVmZXRjaCcsXG4gICdiZWZvcmVQb3BTdGF0ZScsXG5dXG5cbi8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsICdldmVudHMnLCB7XG4gIGdldCgpIHtcbiAgICByZXR1cm4gUm91dGVyLmV2ZW50c1xuICB9LFxufSlcblxudXJsUHJvcGVydHlGaWVsZHMuZm9yRWFjaCgoZmllbGQ6IHN0cmluZykgPT4ge1xuICAvLyBIZXJlIHdlIG5lZWQgdG8gdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBiZWNhdXNlLCB3ZSBuZWVkIHRvIHJldHVyblxuICAvLyB0aGUgcHJvcGVydHkgYXNzaWduZWQgdG8gdGhlIGFjdHVhbCByb3V0ZXJcbiAgLy8gVGhlIHZhbHVlIG1pZ2h0IGdldCBjaGFuZ2VkIGFzIHdlIGNoYW5nZSByb3V0ZXMgYW5kIHRoaXMgaXMgdGhlXG4gIC8vIHByb3BlciB3YXkgdG8gYWNjZXNzIGl0XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsIGZpZWxkLCB7XG4gICAgZ2V0KCkge1xuICAgICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCkgYXMgYW55XG4gICAgICByZXR1cm4gcm91dGVyW2ZpZWxkXSBhcyBzdHJpbmdcbiAgICB9LFxuICB9KVxufSlcblxuY29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKChmaWVsZDogc3RyaW5nKSA9PiB7XG4gIC8vIFdlIGRvbid0IHJlYWxseSBrbm93IHRoZSB0eXBlcyBoZXJlLCBzbyB3ZSBhZGQgdGhlbSBsYXRlciBpbnN0ZWFkXG4gIDsoc2luZ2xldG9uUm91dGVyIGFzIGFueSlbZmllbGRdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCkgYXMgYW55XG4gICAgcmV0dXJuIHJvdXRlcltmaWVsZF0oLi4uYXJncylcbiAgfVxufSlcblxucm91dGVyRXZlbnRzLmZvckVhY2goKGV2ZW50OiBzdHJpbmcpID0+IHtcbiAgc2luZ2xldG9uUm91dGVyLnJlYWR5KCgpID0+IHtcbiAgICBSb3V0ZXIuZXZlbnRzLm9uKGV2ZW50LCAoLi4uYXJncykgPT4ge1xuICAgICAgY29uc3QgZXZlbnRGaWVsZCA9IGBvbiR7ZXZlbnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHtldmVudC5zdWJzdHJpbmcoXG4gICAgICAgIDFcbiAgICAgICl9YFxuICAgICAgY29uc3QgX3NpbmdsZXRvblJvdXRlciA9IHNpbmdsZXRvblJvdXRlciBhcyBhbnlcbiAgICAgIGlmIChfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgX3NpbmdsZXRvblJvdXRlcltldmVudEZpZWxkXSguLi5hcmdzKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciB3aGVuIHJ1bm5pbmcgdGhlIFJvdXRlciBldmVudDogJHtldmVudEZpZWxkfWApXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgJHtlcnIubWVzc2FnZX1cXG4ke2Vyci5zdGFja31gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIGdldFJvdXRlcigpOiBSb3V0ZXIge1xuICBpZiAoIXNpbmdsZXRvblJvdXRlci5yb3V0ZXIpIHtcbiAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICdObyByb3V0ZXIgaW5zdGFuY2UgZm91bmQuXFxuJyArXG4gICAgICAnWW91IHNob3VsZCBvbmx5IHVzZSBcIm5leHQvcm91dGVyXCIgaW5zaWRlIHRoZSBjbGllbnQgc2lkZSBvZiB5b3VyIGFwcC5cXG4nXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gRXhwb3J0IHRoZSBzaW5nbGV0b25Sb3V0ZXIgYW5kIHRoaXMgaXMgdGhlIHB1YmxpYyBBUEkuXG5leHBvcnQgZGVmYXVsdCBzaW5nbGV0b25Sb3V0ZXIgYXMgU2luZ2xldG9uUm91dGVyXG5cbi8vIFJlZXhwb3J0IHRoZSB3aXRoUm91dGUgSE9DXG5leHBvcnQgeyBkZWZhdWx0IGFzIHdpdGhSb3V0ZXIgfSBmcm9tICcuL3dpdGgtcm91dGVyJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVyKCk6IE5leHRSb3V0ZXIge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChSb3V0ZXJDb250ZXh0KVxufVxuXG4vLyBJTlRFUk5BTCBBUElTXG4vLyAtLS0tLS0tLS0tLS0tXG4vLyAoZG8gbm90IHVzZSBmb2xsb3dpbmcgZXhwb3J0cyBpbnNpZGUgdGhlIGFwcClcblxuLy8gQ3JlYXRlIGEgcm91dGVyIGFuZCBhc3NpZ24gaXQgYXMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZS5cbi8vIFRoaXMgaXMgdXNlZCBpbiBjbGllbnQgc2lkZSB3aGVuIHdlIGFyZSBpbml0aWxpemluZyB0aGUgYXBwLlxuLy8gVGhpcyBzaG91bGQgKipub3QqKiB1c2UgaW5zaWRlIHRoZSBzZXJ2ZXIuXG5leHBvcnQgY29uc3QgY3JlYXRlUm91dGVyID0gKC4uLmFyZ3M6IFJvdXRlckFyZ3MpOiBSb3V0ZXIgPT4ge1xuICBzaW5nbGV0b25Sb3V0ZXIucm91dGVyID0gbmV3IFJvdXRlciguLi5hcmdzKVxuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3MuZm9yRWFjaCgoY2IpID0+IGNiKCkpXG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcyA9IFtdXG5cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgYHdpdGhSb3V0ZXJgIHJvdXRlciBpbnN0YW5jZVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZShyb3V0ZXI6IFJvdXRlcik6IE5leHRSb3V0ZXIge1xuICBjb25zdCBfcm91dGVyID0gcm91dGVyIGFzIGFueVxuICBjb25zdCBpbnN0YW5jZSA9IHt9IGFzIGFueVxuXG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgdXJsUHJvcGVydHlGaWVsZHMpIHtcbiAgICBpZiAodHlwZW9mIF9yb3V0ZXJbcHJvcGVydHldID09PSAnb2JqZWN0Jykge1xuICAgICAgaW5zdGFuY2VbcHJvcGVydHldID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgQXJyYXkuaXNBcnJheShfcm91dGVyW3Byb3BlcnR5XSkgPyBbXSA6IHt9LFxuICAgICAgICBfcm91dGVyW3Byb3BlcnR5XVxuICAgICAgKSAvLyBtYWtlcyBzdXJlIHF1ZXJ5IGlzIG5vdCBzdGF0ZWZ1bFxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpbnN0YW5jZVtwcm9wZXJ0eV0gPSBfcm91dGVyW3Byb3BlcnR5XVxuICB9XG5cbiAgLy8gRXZlbnRzIGlzIGEgc3RhdGljIHByb3BlcnR5IG9uIHRoZSByb3V0ZXIsIHRoZSByb3V0ZXIgZG9lc24ndCBoYXZlIHRvIGJlIGluaXRpYWxpemVkIHRvIHVzZSBpdFxuICBpbnN0YW5jZS5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzXG5cbiAgY29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgIGluc3RhbmNlW2ZpZWxkXSA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgICAgcmV0dXJuIF9yb3V0ZXJbZmllbGRdKC4uLmFyZ3MpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBpbnN0YW5jZVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgTmV4dENvbXBvbmVudFR5cGUsIE5leHRQYWdlQ29udGV4dCB9IGZyb20gJy4uL25leHQtc2VydmVyL2xpYi91dGlscydcbmltcG9ydCB7IE5leHRSb3V0ZXIsIHVzZVJvdXRlciB9IGZyb20gJy4vcm91dGVyJ1xuXG5leHBvcnQgdHlwZSBXaXRoUm91dGVyUHJvcHMgPSB7XG4gIHJvdXRlcjogTmV4dFJvdXRlclxufVxuXG5leHBvcnQgdHlwZSBFeGNsdWRlUm91dGVyUHJvcHM8UD4gPSBQaWNrPFxuICBQLFxuICBFeGNsdWRlPGtleW9mIFAsIGtleW9mIFdpdGhSb3V0ZXJQcm9wcz5cbj5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2l0aFJvdXRlcjxcbiAgUCBleHRlbmRzIFdpdGhSb3V0ZXJQcm9wcyxcbiAgQyA9IE5leHRQYWdlQ29udGV4dFxuPihcbiAgQ29tcG9zZWRDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPEMsIGFueSwgUD5cbik6IFJlYWN0LkNvbXBvbmVudFR5cGU8RXhjbHVkZVJvdXRlclByb3BzPFA+PiB7XG4gIGZ1bmN0aW9uIFdpdGhSb3V0ZXJXcmFwcGVyKHByb3BzOiBhbnkpOiBKU1guRWxlbWVudCB7XG4gICAgcmV0dXJuIDxDb21wb3NlZENvbXBvbmVudCByb3V0ZXI9e3VzZVJvdXRlcigpfSB7Li4ucHJvcHN9IC8+XG4gIH1cblxuICBXaXRoUm91dGVyV3JhcHBlci5nZXRJbml0aWFsUHJvcHMgPSBDb21wb3NlZENvbXBvbmVudC5nZXRJbml0aWFsUHJvcHNcbiAgLy8gVGhpcyBpcyBuZWVkZWQgdG8gYWxsb3cgY2hlY2tpbmcgZm9yIGN1c3RvbSBnZXRJbml0aWFsUHJvcHMgaW4gX2FwcFxuICA7KFdpdGhSb3V0ZXJXcmFwcGVyIGFzIGFueSkub3JpZ0dldEluaXRpYWxQcm9wcyA9IChDb21wb3NlZENvbXBvbmVudCBhcyBhbnkpLm9yaWdHZXRJbml0aWFsUHJvcHNcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBuYW1lID1cbiAgICAgIENvbXBvc2VkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvc2VkQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nXG4gICAgV2l0aFJvdXRlcldyYXBwZXIuZGlzcGxheU5hbWUgPSBgd2l0aFJvdXRlcigke25hbWV9KWBcbiAgfVxuXG4gIHJldHVybiBXaXRoUm91dGVyV3JhcHBlclxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFRva2VuaXplIGlucHV0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gbGV4ZXIoc3RyKSB7XG4gICAgdmFyIHRva2VucyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBzdHJbaV07XG4gICAgICAgIGlmIChjaGFyID09PSBcIipcIiB8fCBjaGFyID09PSBcIitcIiB8fCBjaGFyID09PSBcIj9cIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk1PRElGSUVSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJFU0NBUEVEX0NIQVJcIiwgaW5kZXg6IGkrKywgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwie1wiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiT1BFTlwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwifVwiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiQ0xPU0VcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIjpcIikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIGAwLTlgXG4gICAgICAgICAgICAgICAgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYEEtWmBcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYGEtemBcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGBfYFxuICAgICAgICAgICAgICAgICAgICBjb2RlID09PSA5NSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lICs9IHN0cltqKytdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pc3NpbmcgcGFyYW1ldGVyIG5hbWUgYXQgXCIgKyBpKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJOQU1FXCIsIGluZGV4OiBpLCB2YWx1ZTogbmFtZSB9KTtcbiAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAxO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdHRlcm4gY2Fubm90IHN0YXJ0IHdpdGggXFxcIj9cXFwiIGF0IFwiICsgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdICsgc3RyW2orK107XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0cltqXSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cltqICsgMV0gIT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FwdHVyaW5nIGdyb3VwcyBhcmUgbm90IGFsbG93ZWQgYXQgXCIgKyBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmJhbGFuY2VkIHBhdHRlcm4gYXQgXCIgKyBpKTtcbiAgICAgICAgICAgIGlmICghcGF0dGVybilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBwYXR0ZXJuIGF0IFwiICsgaSk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiUEFUVEVSTlwiLCBpbmRleDogaSwgdmFsdWU6IHBhdHRlcm4gfSk7XG4gICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJDSEFSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgfVxuICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJFTkRcIiwgaW5kZXg6IGksIHZhbHVlOiBcIlwiIH0pO1xuICAgIHJldHVybiB0b2tlbnM7XG59XG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgdG9rZW5zID0gbGV4ZXIoc3RyKTtcbiAgICB2YXIgX2EgPSBvcHRpb25zLnByZWZpeGVzLCBwcmVmaXhlcyA9IF9hID09PSB2b2lkIDAgPyBcIi4vXCIgOiBfYTtcbiAgICB2YXIgZGVmYXVsdFBhdHRlcm4gPSBcIlteXCIgKyBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgXCIvIz9cIikgKyBcIl0rP1wiO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5ID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHBhdGggPSBcIlwiO1xuICAgIHZhciB0cnlDb25zdW1lID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKGkgPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tpXS50eXBlID09PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1tpKytdLnZhbHVlO1xuICAgIH07XG4gICAgdmFyIG11c3RDb25zdW1lID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdHJ5Q29uc3VtZSh0eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhciBfYSA9IHRva2Vuc1tpXSwgbmV4dFR5cGUgPSBfYS50eXBlLCBpbmRleCA9IF9hLmluZGV4O1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBcIiArIG5leHRUeXBlICsgXCIgYXQgXCIgKyBpbmRleCArIFwiLCBleHBlY3RlZCBcIiArIHR5cGUpO1xuICAgIH07XG4gICAgdmFyIGNvbnN1bWVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgd2hpbGUgKCh2YWx1ZSA9IHRyeUNvbnN1bWUoXCJDSEFSXCIpIHx8IHRyeUNvbnN1bWUoXCJFU0NBUEVEX0NIQVJcIikpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHdoaWxlIChpIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB2YXIgY2hhciA9IHRyeUNvbnN1bWUoXCJDSEFSXCIpO1xuICAgICAgICB2YXIgbmFtZSA9IHRyeUNvbnN1bWUoXCJOQU1FXCIpO1xuICAgICAgICB2YXIgcGF0dGVybiA9IHRyeUNvbnN1bWUoXCJQQVRURVJOXCIpO1xuICAgICAgICBpZiAobmFtZSB8fCBwYXR0ZXJuKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY2hhciB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHByZWZpeGVzLmluZGV4T2YocHJlZml4KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IHByZWZpeDtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICBwYXRoID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogXCJcIixcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuIHx8IGRlZmF1bHRQYXR0ZXJuLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiB0cnlDb25zdW1lKFwiTU9ESUZJRVJcIikgfHwgXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBjaGFyIHx8IHRyeUNvbnN1bWUoXCJFU0NBUEVEX0NIQVJcIik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcGF0aCArPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVuID0gdHJ5Q29uc3VtZShcIk9QRU5cIik7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0cnlDb25zdW1lKFwiTkFNRVwiKSB8fCBcIlwiO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm5fMSA9IHRyeUNvbnN1bWUoXCJQQVRURVJOXCIpIHx8IFwiXCI7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIG11c3RDb25zdW1lKFwiQ0xPU0VcIik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZV8xIHx8IChwYXR0ZXJuXzEgPyBrZXkrKyA6IFwiXCIpLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IG5hbWVfMSAmJiAhcGF0dGVybl8xID8gZGVmYXVsdFBhdHRlcm4gOiBwYXR0ZXJuXzEsXG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBzdWZmaXgsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IHRyeUNvbnN1bWUoXCJNT0RJRklFUlwiKSB8fCBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG11c3RDb25zdW1lKFwiRU5EXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICovXG5mdW5jdGlvbiBjb21waWxlKHN0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucyksIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZTtcbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24odG9rZW5zLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgcmVGbGFncyA9IGZsYWdzKG9wdGlvbnMpO1xuICAgIHZhciBfYSA9IG9wdGlvbnMuZW5jb2RlLCBlbmNvZGUgPSBfYSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOiBfYSwgX2IgPSBvcHRpb25zLnZhbGlkYXRlLCB2YWxpZGF0ZSA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XG4gICAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gICAgdmFyIG1hdGNoZXMgPSB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHRva2VuLnBhdHRlcm4gKyBcIikkXCIsIHJlRmxhZ3MpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBwYXRoID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YSA/IGRhdGFbdG9rZW4ubmFtZV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgb3B0aW9uYWwgPSB0b2tlbi5tb2RpZmllciA9PT0gXCI/XCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiO1xuICAgICAgICAgICAgdmFyIHJlcGVhdCA9IHRva2VuLm1vZGlmaWVyID09PSBcIipcIiB8fCB0b2tlbi5tb2RpZmllciA9PT0gXCIrXCI7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcGVhdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBub3QgcmVwZWF0LCBidXQgZ290IGFuIGFycmF5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBub3QgYmUgZW1wdHlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0sIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlICYmICFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhbGwgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBtYXRjaCBcXFwiXCIgKyB0b2tlbi5wYXR0ZXJuICsgXCJcXFwiLCBidXQgZ290IFxcXCJcIiArIHNlZ21lbnQgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50ICsgdG9rZW4uc3VmZml4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbmNvZGUoU3RyaW5nKHZhbHVlKSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZSAmJiAhbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG1hdGNoIFxcXCJcIiArIHRva2VuLnBhdHRlcm4gKyBcIlxcXCIsIGJ1dCBnb3QgXFxcIlwiICsgc2VnbWVudCArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50ICsgdG9rZW4uc3VmZml4O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHR5cGVPZk1lc3NhZ2UgPSByZXBlYXQgPyBcImFuIGFycmF5XCIgOiBcImEgc3RyaW5nXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBiZSBcIiArIHR5cGVPZk1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG59XG5leHBvcnRzLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uO1xuLyoqXG4gKiBDcmVhdGUgcGF0aCBtYXRjaCBmdW5jdGlvbiBmcm9tIGBwYXRoLXRvLXJlZ2V4cGAgc3BlYy5cbiAqL1xuZnVuY3Rpb24gbWF0Y2goc3RyLCBvcHRpb25zKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICB2YXIgcmUgPSBwYXRoVG9SZWdleHAoc3RyLCBrZXlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVnZXhwVG9GdW5jdGlvbihyZSwga2V5cywgb3B0aW9ucyk7XG59XG5leHBvcnRzLm1hdGNoID0gbWF0Y2g7XG4vKipcbiAqIENyZWF0ZSBhIHBhdGggbWF0Y2ggZnVuY3Rpb24gZnJvbSBgcGF0aC10by1yZWdleHBgIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9GdW5jdGlvbihyZSwga2V5cywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIF9hID0gb3B0aW9ucy5kZWNvZGUsIGRlY29kZSA9IF9hID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9hO1xuICAgIHJldHVybiBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgdmFyIG0gPSByZS5leGVjKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgcGF0aCA9IG1bMF0sIGluZGV4ID0gbS5pbmRleDtcbiAgICAgICAgdmFyIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgaWYgKG1baV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKGtleS5tb2RpZmllciA9PT0gXCIqXCIgfHwga2V5Lm1vZGlmaWVyID09PSBcIitcIikge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSBtW2ldLnNwbGl0KGtleS5wcmVmaXggKyBrZXkuc3VmZml4KS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUodmFsdWUsIGtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gZGVjb2RlKG1baV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwYXRoOiBwYXRoLCBpbmRleDogaW5kZXgsIHBhcmFtczogcGFyYW1zIH07XG4gICAgfTtcbn1cbmV4cG9ydHMucmVnZXhwVG9GdW5jdGlvbiA9IHJlZ2V4cFRvRnVuY3Rpb247XG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18L1xcXFxdKS9nLCBcIlxcXFwkMVwiKTtcbn1cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZmxhZ3Mob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuc2Vuc2l0aXZlID8gXCJcIiA6IFwiaVwiO1xufVxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIGtleXMpIHtcbiAgICBpZiAoIWtleXMpXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gICAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpO1xuICAgIGlmIChncm91cHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGtleXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogaSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IFwiXCIsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiBcIlwiLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cChwYXRocywga2V5cywgb3B0aW9ucykge1xuICAgIHZhciBwYXJ0cyA9IHBhdGhzLm1hcChmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpLnNvdXJjZTsgfSk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpcIiArIHBhcnRzLmpvaW4oXCJ8XCIpICsgXCIpXCIsIGZsYWdzKG9wdGlvbnMpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9rZW5zVG9SZWdleHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ2V4cCh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMuc3RyaWN0LCBzdHJpY3QgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYSwgX2IgPSBvcHRpb25zLnN0YXJ0LCBzdGFydCA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIF9jID0gb3B0aW9ucy5lbmQsIGVuZCA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gb3B0aW9ucy5lbmNvZGUsIGVuY29kZSA9IF9kID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9kO1xuICAgIHZhciBlbmRzV2l0aCA9IFwiW1wiICsgZXNjYXBlU3RyaW5nKG9wdGlvbnMuZW5kc1dpdGggfHwgXCJcIikgKyBcIl18JFwiO1xuICAgIHZhciBkZWxpbWl0ZXIgPSBcIltcIiArIGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCBcIi8jP1wiKSArIFwiXVwiO1xuICAgIHZhciByb3V0ZSA9IHN0YXJ0ID8gXCJeXCIgOiBcIlwiO1xuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gICAgZm9yICh2YXIgX2kgPSAwLCB0b2tlbnNfMSA9IHRva2VuczsgX2kgPCB0b2tlbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zXzFbX2ldO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKGVuY29kZSh0b2tlbi5wcmVmaXgpKTtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuLnN1ZmZpeCkpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cylcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZml4IHx8IHN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4ubW9kaWZpZXIgPT09IFwiK1wiIHx8IHRva2VuLm1vZGlmaWVyID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZCA9IHRva2VuLm1vZGlmaWVyID09PSBcIipcIiA/IFwiP1wiIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBwcmVmaXggKyBcIigoPzpcIiArIHRva2VuLnBhdHRlcm4gKyBcIikoPzpcIiArIHN1ZmZpeCArIHByZWZpeCArIFwiKD86XCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpKSopXCIgKyBzdWZmaXggKyBcIilcIiArIG1vZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBwcmVmaXggKyBcIihcIiArIHRva2VuLnBhdHRlcm4gKyBcIilcIiArIHN1ZmZpeCArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKFwiICsgdG9rZW4ucGF0dGVybiArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIiArIHByZWZpeCArIHN1ZmZpeCArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZCkge1xuICAgICAgICBpZiAoIXN0cmljdClcbiAgICAgICAgICAgIHJvdXRlICs9IGRlbGltaXRlciArIFwiP1wiO1xuICAgICAgICByb3V0ZSArPSAhb3B0aW9ucy5lbmRzV2l0aCA/IFwiJFwiIDogXCIoPz1cIiArIGVuZHNXaXRoICsgXCIpXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZW5kVG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgaXNFbmREZWxpbWl0ZWQgPSB0eXBlb2YgZW5kVG9rZW4gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gZGVsaW1pdGVyLmluZGV4T2YoZW5kVG9rZW5bZW5kVG9rZW4ubGVuZ3RoIC0gMV0pID4gLTFcbiAgICAgICAgICAgIDogLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgZW5kVG9rZW4gPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBkZWxpbWl0ZXIgKyBcIig/PVwiICsgZW5kc1dpdGggKyBcIikpP1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFbmREZWxpbWl0ZWQpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD89XCIgKyBkZWxpbWl0ZXIgKyBcInxcIiArIGVuZHNXaXRoICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocm91dGUsIGZsYWdzKG9wdGlvbnMpKTtcbn1cbmV4cG9ydHMudG9rZW5zVG9SZWdleHAgPSB0b2tlbnNUb1JlZ2V4cDtcbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIGtleXMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKVxuICAgICAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gc3RyaW5nVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG59XG5leHBvcnRzLnBhdGhUb1JlZ2V4cCA9IHBhdGhUb1JlZ2V4cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzPSgoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXszMDE6KGUscix0KT0+e2NvbnN0IF89dCg5NzkpO2UuZXhwb3J0cz0oZT0+dHlwZW9mIGU9PT1cInN0cmluZ1wiP2UucmVwbGFjZShfKCksXCJcIik6ZSl9LDk3OTplPT57ZS5leHBvcnRzPSgoe29ubHlGaXJzdDplPWZhbHNlfT17fSk9Pntjb25zdCByPVtcIltcXFxcdTAwMUJcXFxcdTAwOUJdW1tcXFxcXSgpIzs/XSooPzooPzooPzpbYS16QS1aXFxcXGRdKig/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSopKik/XFxcXHUwMDA3KVwiLFwiKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1udHFyeT0+PH5dKSlcIl0uam9pbihcInxcIik7cmV0dXJuIG5ldyBSZWdFeHAocixlP3VuZGVmaW5lZDpcImdcIil9KX19O3ZhciByPXt9O2Z1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18odCl7aWYoclt0XSl7cmV0dXJuIHJbdF0uZXhwb3J0c312YXIgXz1yW3RdPXtleHBvcnRzOnt9fTt2YXIgbj10cnVlO3RyeXtlW3RdKF8sXy5leHBvcnRzLF9fd2VicGFja19yZXF1aXJlX18pO249ZmFsc2V9ZmluYWxseXtpZihuKWRlbGV0ZSByW3RdfXJldHVybiBfLmV4cG9ydHN9X193ZWJwYWNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMzAxKX0pKCk7IiwibW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oKXt2YXIgdD17NTk5OmZ1bmN0aW9uKHQsZSl7IWZ1bmN0aW9uKHQsbil7dHJ1ZT9uKGUpOjB9KHRoaXMsZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGUsbixpPWZ1bmN0aW9uKCl7cmV0dXJuXCJcIi5jb25jYXQoRGF0ZS5ub3coKSxcIi1cIikuY29uY2F0KE1hdGguZmxvb3IoODk5OTk5OTk5OTk5OSpNYXRoLnJhbmRvbSgpKSsxZTEyKX0sYT1mdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06LTE7cmV0dXJue25hbWU6dCx2YWx1ZTplLGRlbHRhOjAsZW50cmllczpbXSxpZDppKCksaXNGaW5hbDohMX19LHI9ZnVuY3Rpb24odCxlKXt0cnl7aWYoUGVyZm9ybWFuY2VPYnNlcnZlci5zdXBwb3J0ZWRFbnRyeVR5cGVzLmluY2x1ZGVzKHQpKXt2YXIgbj1uZXcgUGVyZm9ybWFuY2VPYnNlcnZlcihmdW5jdGlvbih0KXtyZXR1cm4gdC5nZXRFbnRyaWVzKCkubWFwKGUpfSk7cmV0dXJuIG4ub2JzZXJ2ZSh7dHlwZTp0LGJ1ZmZlcmVkOiEwfSksbn19Y2F0Y2godCl7fX0sbz0hMSx1PSExLHM9ZnVuY3Rpb24odCl7bz0hdC5wZXJzaXN0ZWR9LGM9ZnVuY3Rpb24oKXthZGRFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIixzKSxhZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsZnVuY3Rpb24oKXt9KX0scD1mdW5jdGlvbih0KXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdO3V8fChjKCksdT0hMCksYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIixmdW5jdGlvbihlKXt2YXIgbj1lLnRpbWVTdGFtcDtcImhpZGRlblwiPT09ZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlJiZ0KHt0aW1lU3RhbXA6bixpc1VubG9hZGluZzpvfSl9LHtjYXB0dXJlOiEwLG9uY2U6ZX0pfSxsPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciBhO3JldHVybiBmdW5jdGlvbigpe24mJmUuaXNGaW5hbCYmbi5kaXNjb25uZWN0KCksZS52YWx1ZT49MCYmKGl8fGUuaXNGaW5hbHx8XCJoaWRkZW5cIj09PWRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSkmJihlLmRlbHRhPWUudmFsdWUtKGF8fDApLChlLmRlbHRhfHxlLmlzRmluYWx8fHZvaWQgMD09PWEpJiYodChlKSxhPWUudmFsdWUpKX19LGY9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9XCJoaWRkZW5cIj09PWRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZT8wOjEvMCxwKGZ1bmN0aW9uKHQpe3ZhciBuPXQudGltZVN0YW1wO3JldHVybiBlPW59LCEwKSkse2dldCB0aW1lU3RhbXAoKXtyZXR1cm4gZX19fSxkPWZ1bmN0aW9uKCl7cmV0dXJuIG58fChuPW5ldyBQcm9taXNlKGZ1bmN0aW9uKHQpe3JldHVybltcInNjcm9sbFwiLFwia2V5ZG93blwiLFwicG9pbnRlcmRvd25cIl0ubWFwKGZ1bmN0aW9uKGUpe2FkZEV2ZW50TGlzdGVuZXIoZSx0LHtvbmNlOiEwLHBhc3NpdmU6ITAsY2FwdHVyZTohMH0pfSl9KSksbn07dC5nZXRDTFM9ZnVuY3Rpb24odCl7dmFyIGUsbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdLGk9YShcIkNMU1wiLDApLG89ZnVuY3Rpb24odCl7dC5oYWRSZWNlbnRJbnB1dHx8KGkudmFsdWUrPXQudmFsdWUsaS5lbnRyaWVzLnB1c2godCksZSgpKX0sdT1yKFwibGF5b3V0LXNoaWZ0XCIsbyk7dSYmKGU9bCh0LGksdSxuKSxwKGZ1bmN0aW9uKHQpe3ZhciBuPXQuaXNVbmxvYWRpbmc7dS50YWtlUmVjb3JkcygpLm1hcChvKSxuJiYoaS5pc0ZpbmFsPSEwKSxlKCl9KSl9LHQuZ2V0RkNQPWZ1bmN0aW9uKHQpe3ZhciBlLG49YShcIkZDUFwiKSxpPWYoKSxvPXIoXCJwYWludFwiLGZ1bmN0aW9uKHQpe1wiZmlyc3QtY29udGVudGZ1bC1wYWludFwiPT09dC5uYW1lJiZ0LnN0YXJ0VGltZTxpLnRpbWVTdGFtcCYmKG4udmFsdWU9dC5zdGFydFRpbWUsbi5pc0ZpbmFsPSEwLG4uZW50cmllcy5wdXNoKHQpLGUoKSl9KTtvJiYoZT1sKHQsbixvKSl9LHQuZ2V0RklEPWZ1bmN0aW9uKHQpe3ZhciBlPWEoXCJGSURcIiksbj1mKCksaT1mdW5jdGlvbih0KXt0LnN0YXJ0VGltZTxuLnRpbWVTdGFtcCYmKGUudmFsdWU9dC5wcm9jZXNzaW5nU3RhcnQtdC5zdGFydFRpbWUsZS5lbnRyaWVzLnB1c2godCksZS5pc0ZpbmFsPSEwLHUoKSl9LG89cihcImZpcnN0LWlucHV0XCIsaSksdT1sKHQsZSxvKTtvP3AoZnVuY3Rpb24oKXtvLnRha2VSZWNvcmRzKCkubWFwKGkpLG8uZGlzY29ubmVjdCgpfSwhMCk6d2luZG93LnBlcmZNZXRyaWNzJiZ3aW5kb3cucGVyZk1ldHJpY3Mub25GaXJzdElucHV0RGVsYXkmJndpbmRvdy5wZXJmTWV0cmljcy5vbkZpcnN0SW5wdXREZWxheShmdW5jdGlvbih0LGkpe2kudGltZVN0YW1wPG4udGltZVN0YW1wJiYoZS52YWx1ZT10LGUuaXNGaW5hbD0hMCxlLmVudHJpZXM9W3tlbnRyeVR5cGU6XCJmaXJzdC1pbnB1dFwiLG5hbWU6aS50eXBlLHRhcmdldDppLnRhcmdldCxjYW5jZWxhYmxlOmkuY2FuY2VsYWJsZSxzdGFydFRpbWU6aS50aW1lU3RhbXAscHJvY2Vzc2luZ1N0YXJ0OmkudGltZVN0YW1wK3R9XSx1KCkpfSl9LHQuZ2V0TENQPWZ1bmN0aW9uKHQpe3ZhciBlLG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXSxpPWEoXCJMQ1BcIiksbz1mKCksdT1mdW5jdGlvbih0KXt2YXIgbj10LnN0YXJ0VGltZTtuPG8udGltZVN0YW1wPyhpLnZhbHVlPW4saS5lbnRyaWVzLnB1c2godCkpOmkuaXNGaW5hbD0hMCxlKCl9LHM9cihcImxhcmdlc3QtY29udGVudGZ1bC1wYWludFwiLHUpO2lmKHMpe2U9bCh0LGkscyxuKTt2YXIgYz1mdW5jdGlvbigpe2kuaXNGaW5hbHx8KHMudGFrZVJlY29yZHMoKS5tYXAodSksaS5pc0ZpbmFsPSEwLGUoKSl9O2QoKS50aGVuKGMpLHAoYywhMCl9fSx0LmdldFRURkI9ZnVuY3Rpb24odCl7dmFyIGUsbj1hKFwiVFRGQlwiKTtlPWZ1bmN0aW9uKCl7dHJ5e3ZhciBlPXBlcmZvcm1hbmNlLmdldEVudHJpZXNCeVR5cGUoXCJuYXZpZ2F0aW9uXCIpWzBdfHxmdW5jdGlvbigpe3ZhciB0PXBlcmZvcm1hbmNlLnRpbWluZyxlPXtlbnRyeVR5cGU6XCJuYXZpZ2F0aW9uXCIsc3RhcnRUaW1lOjB9O2Zvcih2YXIgbiBpbiB0KVwibmF2aWdhdGlvblN0YXJ0XCIhPT1uJiZcInRvSlNPTlwiIT09biYmKGVbbl09TWF0aC5tYXgodFtuXS10Lm5hdmlnYXRpb25TdGFydCwwKSk7cmV0dXJuIGV9KCk7bi52YWx1ZT1uLmRlbHRhPWUucmVzcG9uc2VTdGFydCxuLmVudHJpZXM9W2VdLG4uaXNGaW5hbD0hMCx0KG4pfWNhdGNoKHQpe319LFwiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGU/c2V0VGltZW91dChlLDApOmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLGUpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pfX07dmFyIGU9e307ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhuKXtpZihlW25dKXtyZXR1cm4gZVtuXS5leHBvcnRzfXZhciBpPWVbbl09e2V4cG9ydHM6e319O3ZhciBhPXRydWU7dHJ5e3Rbbl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsX193ZWJwYWNrX3JlcXVpcmVfXyk7YT1mYWxzZX1maW5hbGx5e2lmKGEpZGVsZXRlIGVbbl19cmV0dXJuIGkuZXhwb3J0c31fX3dlYnBhY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjtyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTkpfSgpOyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IEhlYWRNYW5hZ2VyQ29udGV4dDogUmVhY3QuQ29udGV4dDx7XG4gIHVwZGF0ZUhlYWQ/OiAoc3RhdGU6IGFueSkgPT4gdm9pZFxuICBtb3VudGVkSW5zdGFuY2VzPzogYW55XG4gIHVwZGF0ZVNjcmlwdHM/OiAoc3RhdGU6IGFueSkgPT4gdm9pZFxuICBzY3JpcHRzPzogYW55XG59PiA9IFJlYWN0LmNyZWF0ZUNvbnRleHQoe30pXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIEhlYWRNYW5hZ2VyQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdIZWFkTWFuYWdlckNvbnRleHQnXG59XG4iLCJleHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgcGF0aG5hbWU6IHN0cmluZyxcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4pOiB7XG4gIGRldGVjdGVkTG9jYWxlPzogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbn0ge1xuICBsZXQgZGV0ZWN0ZWRMb2NhbGU6IHN0cmluZyB8IHVuZGVmaW5lZFxuICAvLyBmaXJzdCBpdGVtIHdpbGwgYmUgZW1wdHkgc3RyaW5nIGZyb20gc3BsaXR0aW5nIGF0IGZpcnN0IGNoYXJcbiAgY29uc3QgcGF0aG5hbWVQYXJ0cyA9IHBhdGhuYW1lLnNwbGl0KCcvJylcblxuICA7KGxvY2FsZXMgfHwgW10pLnNvbWUoKGxvY2FsZSkgPT4ge1xuICAgIGlmIChwYXRobmFtZVBhcnRzWzFdLnRvTG93ZXJDYXNlKCkgPT09IGxvY2FsZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBkZXRlY3RlZExvY2FsZSA9IGxvY2FsZVxuICAgICAgcGF0aG5hbWVQYXJ0cy5zcGxpY2UoMSwgMSlcbiAgICAgIHBhdGhuYW1lID0gcGF0aG5hbWVQYXJ0cy5qb2luKCcvJykgfHwgJy8nXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfSlcblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lLFxuICAgIGRldGVjdGVkTG9jYWxlLFxuICB9XG59XG4iLCIvKlxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSBKYXNvbiBNaWxsZXIgKGh0dHBzOi8vamFzb25mb3JtYXQuY29tLylcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxuLy8gVGhpcyBmaWxlIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvbWl0dC9ibG9iL3YxLjEuMy9zcmMvaW5kZXguanNcbi8vIEl0J3MgYmVlbiBlZGl0ZWQgZm9yIHRoZSBuZWVkcyBvZiB0aGlzIHNjcmlwdFxuLy8gU2VlIHRoZSBMSUNFTlNFIGF0IHRoZSB0b3Agb2YgdGhlIGZpbGVcblxudHlwZSBIYW5kbGVyID0gKC4uLmV2dHM6IGFueVtdKSA9PiB2b2lkXG5cbmV4cG9ydCB0eXBlIE1pdHRFbWl0dGVyID0ge1xuICBvbih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpOiB2b2lkXG4gIG9mZih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpOiB2b2lkXG4gIGVtaXQodHlwZTogc3RyaW5nLCAuLi5ldnRzOiBhbnlbXSk6IHZvaWRcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWl0dCgpOiBNaXR0RW1pdHRlciB7XG4gIGNvbnN0IGFsbDogeyBbczogc3RyaW5nXTogSGFuZGxlcltdIH0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgcmV0dXJuIHtcbiAgICBvbih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpIHtcbiAgICAgIDsoYWxsW3R5cGVdIHx8IChhbGxbdHlwZV0gPSBbXSkpLnB1c2goaGFuZGxlcilcbiAgICB9LFxuXG4gICAgb2ZmKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcikge1xuICAgICAgaWYgKGFsbFt0eXBlXSkge1xuICAgICAgICBhbGxbdHlwZV0uc3BsaWNlKGFsbFt0eXBlXS5pbmRleE9mKGhhbmRsZXIpID4+PiAwLCAxKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbWl0KHR5cGU6IHN0cmluZywgLi4uZXZ0czogYW55W10pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgIDsoYWxsW3R5cGVdIHx8IFtdKS5zbGljZSgpLm1hcCgoaGFuZGxlcjogSGFuZGxlcikgPT4ge1xuICAgICAgICBoYW5kbGVyKC4uLmV2dHMpXG4gICAgICB9KVxuICAgIH0sXG4gIH1cbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuL3JvdXRlci9yb3V0ZXInXG5cbmV4cG9ydCBjb25zdCBSb3V0ZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxOZXh0Um91dGVyPihudWxsIGFzIGFueSlcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdSb3V0ZXJDb250ZXh0J1xufVxuIiwiLyogZ2xvYmFsIF9fTkVYVF9EQVRBX18gKi9cbi8vIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGVcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQge1xuICBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCxcbiAgcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gsXG59IGZyb20gJy4uLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gnXG5pbXBvcnQgeyBHb29kUGFnZUNhY2hlLCBTdHlsZVNoZWV0VHVwbGUgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcGFnZS1sb2FkZXInXG5pbXBvcnQge1xuICBnZXRDbGllbnRCdWlsZE1hbmlmZXN0LFxuICBpc0Fzc2V0RXJyb3IsXG4gIG1hcmtBc3NldEVycm9yLFxufSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyJ1xuaW1wb3J0IHsgRG9tYWluTG9jYWxlcyB9IGZyb20gJy4uLy4uL3NlcnZlci9jb25maWcnXG5pbXBvcnQgeyBkZW5vcm1hbGl6ZVBhZ2VQYXRoIH0gZnJvbSAnLi4vLi4vc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aCdcbmltcG9ydCB7IG5vcm1hbGl6ZUxvY2FsZVBhdGggfSBmcm9tICcuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCdcbmltcG9ydCBtaXR0LCB7IE1pdHRFbWl0dGVyIH0gZnJvbSAnLi4vbWl0dCdcbmltcG9ydCB7XG4gIEFwcENvbnRleHRUeXBlLFxuICBmb3JtYXRXaXRoVmFsaWRhdGlvbixcbiAgZ2V0TG9jYXRpb25PcmlnaW4sXG4gIGdldFVSTCxcbiAgbG9hZEdldEluaXRpYWxQcm9wcyxcbiAgTmV4dFBhZ2VDb250ZXh0LFxuICBTVCxcbiAgTkVYVF9EQVRBLFxufSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IGlzRHluYW1pY1JvdXRlIH0gZnJvbSAnLi91dGlscy9pcy1keW5hbWljJ1xuaW1wb3J0IHsgcGFyc2VSZWxhdGl2ZVVybCB9IGZyb20gJy4vdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJ1xuaW1wb3J0IHsgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeSB9IGZyb20gJy4vdXRpbHMvcXVlcnlzdHJpbmcnXG5pbXBvcnQgcmVzb2x2ZVJld3JpdGVzIGZyb20gJy4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlcydcbmltcG9ydCB7IGdldFJvdXRlTWF0Y2hlciB9IGZyb20gJy4vdXRpbHMvcm91dGUtbWF0Y2hlcidcbmltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3V0aWxzL3JvdXRlLXJlZ2V4J1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIC8qIHByb2QgKi9cbiAgICBfX05FWFRfREFUQV9fOiBORVhUX0RBVEFcbiAgfVxufVxuXG5pbnRlcmZhY2UgUm91dGVQcm9wZXJ0aWVzIHtcbiAgc2hhbGxvdzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgVHJhbnNpdGlvbk9wdGlvbnMge1xuICBzaGFsbG93PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxuICBzY3JvbGw/OiBib29sZWFuXG59XG5cbmludGVyZmFjZSBOZXh0SGlzdG9yeVN0YXRlIHtcbiAgdXJsOiBzdHJpbmdcbiAgYXM6IHN0cmluZ1xuICBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9uc1xufVxuXG50eXBlIEhpc3RvcnlTdGF0ZSA9XG4gIHwgbnVsbFxuICB8IHsgX19OOiBmYWxzZSB9XG4gIHwgKHsgX19OOiB0cnVlOyBpZHg6IG51bWJlciB9ICYgTmV4dEhpc3RvcnlTdGF0ZSlcblxubGV0IGRldGVjdERvbWFpbkxvY2FsZTogdHlwZW9mIGltcG9ydCgnLi4vaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZScpLmRldGVjdERvbWFpbkxvY2FsZVxuXG5pZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICBkZXRlY3REb21haW5Mb2NhbGUgPSByZXF1aXJlKCcuLi9pMThuL2RldGVjdC1kb21haW4tbG9jYWxlJylcbiAgICAuZGV0ZWN0RG9tYWluTG9jYWxlXG59XG5cbmNvbnN0IGJhc2VQYXRoID0gKHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggYXMgc3RyaW5nKSB8fCAnJ1xuXG5mdW5jdGlvbiBidWlsZENhbmNlbGxhdGlvbkVycm9yKCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoJ1JvdXRlIENhbmNlbGxlZCcpLCB7XG4gICAgY2FuY2VsbGVkOiB0cnVlLFxuICB9KVxufVxuXG5mdW5jdGlvbiBhZGRQYXRoUHJlZml4KHBhdGg6IHN0cmluZywgcHJlZml4Pzogc3RyaW5nKSB7XG4gIHJldHVybiBwcmVmaXggJiYgcGF0aC5zdGFydHNXaXRoKCcvJylcbiAgICA/IHBhdGggPT09ICcvJ1xuICAgICAgPyBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaChwcmVmaXgpXG4gICAgICA6IGAke3ByZWZpeH0ke3BhdGhOb1F1ZXJ5SGFzaChwYXRoKSA9PT0gJy8nID8gcGF0aC5zdWJzdHJpbmcoMSkgOiBwYXRofWBcbiAgICA6IHBhdGhcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERvbWFpbkxvY2FsZShcbiAgcGF0aDogc3RyaW5nLFxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZSxcbiAgbG9jYWxlcz86IHN0cmluZ1tdLFxuICBkb21haW5Mb2NhbGVzPzogRG9tYWluTG9jYWxlc1xuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgbG9jYWxlID0gbG9jYWxlIHx8IG5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aCwgbG9jYWxlcykuZGV0ZWN0ZWRMb2NhbGVcblxuICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgbG9jYWxlKVxuXG4gICAgaWYgKGRldGVjdGVkRG9tYWluKSB7XG4gICAgICByZXR1cm4gYGh0dHAke2RldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly8ke2RldGVjdGVkRG9tYWluLmRvbWFpbn0ke1xuICAgICAgICBiYXNlUGF0aCB8fCAnJ1xuICAgICAgfSR7bG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gJycgOiBgLyR7bG9jYWxlfWB9JHtwYXRofWBcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZExvY2FsZShcbiAgcGF0aDogc3RyaW5nLFxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZSxcbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgcmV0dXJuIGxvY2FsZSAmJlxuICAgICAgbG9jYWxlICE9PSBkZWZhdWx0TG9jYWxlICYmXG4gICAgICAhcGF0aC5zdGFydHNXaXRoKCcvJyArIGxvY2FsZSArICcvJykgJiZcbiAgICAgIHBhdGggIT09ICcvJyArIGxvY2FsZVxuICAgICAgPyBhZGRQYXRoUHJlZml4KHBhdGgsICcvJyArIGxvY2FsZSlcbiAgICAgIDogcGF0aFxuICB9XG4gIHJldHVybiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxMb2NhbGUocGF0aDogc3RyaW5nLCBsb2NhbGU/OiBzdHJpbmcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gbG9jYWxlICYmXG4gICAgICAocGF0aC5zdGFydHNXaXRoKCcvJyArIGxvY2FsZSArICcvJykgfHwgcGF0aCA9PT0gJy8nICsgbG9jYWxlKVxuICAgICAgPyBwYXRoLnN1YnN0cihsb2NhbGUubGVuZ3RoICsgMSkgfHwgJy8nXG4gICAgICA6IHBhdGhcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG5mdW5jdGlvbiBwYXRoTm9RdWVyeUhhc2gocGF0aDogc3RyaW5nKSB7XG4gIGNvbnN0IHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKVxuICBjb25zdCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKVxuXG4gIGlmIChxdWVyeUluZGV4ID4gLTEgfHwgaGFzaEluZGV4ID4gLTEpIHtcbiAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgcXVlcnlJbmRleCA+IC0xID8gcXVlcnlJbmRleCA6IGhhc2hJbmRleClcbiAgfVxuICByZXR1cm4gcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzQmFzZVBhdGgocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHBhdGggPSBwYXRoTm9RdWVyeUhhc2gocGF0aClcbiAgcmV0dXJuIHBhdGggPT09IGJhc2VQYXRoIHx8IHBhdGguc3RhcnRzV2l0aChiYXNlUGF0aCArICcvJylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEJhc2VQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIHdlIG9ubHkgYWRkIHRoZSBiYXNlcGF0aCBvbiByZWxhdGl2ZSB1cmxzXG4gIHJldHVybiBhZGRQYXRoUHJlZml4KHBhdGgsIGJhc2VQYXRoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsQmFzZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZVBhdGgubGVuZ3RoKVxuICBpZiAoIXBhdGguc3RhcnRzV2l0aCgnLycpKSBwYXRoID0gYC8ke3BhdGh9YFxuICByZXR1cm4gcGF0aFxufVxuXG4vKipcbiAqIERldGVjdHMgd2hldGhlciBhIGdpdmVuIHVybCBpcyByb3V0YWJsZSBieSB0aGUgTmV4dC5qcyByb3V0ZXIgKGJyb3dzZXIgb25seSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xvY2FsVVJMKHVybDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnLycpKSByZXR1cm4gdHJ1ZVxuICB0cnkge1xuICAgIC8vIGFic29sdXRlIHVybHMgY2FuIGJlIGxvY2FsIGlmIHRoZXkgYXJlIG9uIHRoZSBzYW1lIG9yaWdpblxuICAgIGNvbnN0IGxvY2F0aW9uT3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICAgIGNvbnN0IHJlc29sdmVkID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uT3JpZ2luKVxuICAgIHJldHVybiByZXNvbHZlZC5vcmlnaW4gPT09IGxvY2F0aW9uT3JpZ2luICYmIGhhc0Jhc2VQYXRoKHJlc29sdmVkLnBhdGhuYW1lKVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxudHlwZSBVcmwgPSBVcmxPYmplY3QgfCBzdHJpbmdcblxuZXhwb3J0IGZ1bmN0aW9uIGludGVycG9sYXRlQXMoXG4gIHJvdXRlOiBzdHJpbmcsXG4gIGFzUGF0aG5hbWU6IHN0cmluZyxcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4pIHtcbiAgbGV0IGludGVycG9sYXRlZFJvdXRlID0gJydcblxuICBjb25zdCBkeW5hbWljUmVnZXggPSBnZXRSb3V0ZVJlZ2V4KHJvdXRlKVxuICBjb25zdCBkeW5hbWljR3JvdXBzID0gZHluYW1pY1JlZ2V4Lmdyb3Vwc1xuICBjb25zdCBkeW5hbWljTWF0Y2hlcyA9XG4gICAgLy8gVHJ5IHRvIG1hdGNoIHRoZSBkeW5hbWljIHJvdXRlIGFnYWluc3QgdGhlIGFzUGF0aFxuICAgIChhc1BhdGhuYW1lICE9PSByb3V0ZSA/IGdldFJvdXRlTWF0Y2hlcihkeW5hbWljUmVnZXgpKGFzUGF0aG5hbWUpIDogJycpIHx8XG4gICAgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBocmVmXG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgdGFrZSBwcmlvcml0eTsgYWxzbyBuZWVkIHRvIGNoYW5nZSBpbiB0aGUgcm91dGVyLlxuICAgIHF1ZXJ5XG5cbiAgaW50ZXJwb2xhdGVkUm91dGUgPSByb3V0ZVxuICBjb25zdCBwYXJhbXMgPSBPYmplY3Qua2V5cyhkeW5hbWljR3JvdXBzKVxuXG4gIGlmIChcbiAgICAhcGFyYW1zLmV2ZXJ5KChwYXJhbSkgPT4ge1xuICAgICAgbGV0IHZhbHVlID0gZHluYW1pY01hdGNoZXNbcGFyYW1dIHx8ICcnXG4gICAgICBjb25zdCB7IHJlcGVhdCwgb3B0aW9uYWwgfSA9IGR5bmFtaWNHcm91cHNbcGFyYW1dXG5cbiAgICAgIC8vIHN1cHBvcnQgc2luZ2xlLWxldmVsIGNhdGNoLWFsbFxuICAgICAgLy8gVE9ETzogbW9yZSByb2J1c3QgaGFuZGxpbmcgZm9yIHVzZXItZXJyb3IgKHBhc3NpbmcgYC9gKVxuICAgICAgbGV0IHJlcGxhY2VkID0gYFske3JlcGVhdCA/ICcuLi4nIDogJyd9JHtwYXJhbX1dYFxuICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgIHJlcGxhY2VkID0gYCR7IXZhbHVlID8gJy8nIDogJyd9WyR7cmVwbGFjZWR9XWBcbiAgICAgIH1cbiAgICAgIGlmIChyZXBlYXQgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB2YWx1ZSA9IFt2YWx1ZV1cblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKG9wdGlvbmFsIHx8IHBhcmFtIGluIGR5bmFtaWNNYXRjaGVzKSAmJlxuICAgICAgICAvLyBJbnRlcnBvbGF0ZSBncm91cCBpbnRvIGRhdGEgVVJMIGlmIHByZXNlbnRcbiAgICAgICAgKGludGVycG9sYXRlZFJvdXRlID1cbiAgICAgICAgICBpbnRlcnBvbGF0ZWRSb3V0ZSEucmVwbGFjZShcbiAgICAgICAgICAgIHJlcGxhY2VkLFxuICAgICAgICAgICAgcmVwZWF0XG4gICAgICAgICAgICAgID8gKHZhbHVlIGFzIHN0cmluZ1tdKVxuICAgICAgICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2UgdmFsdWVzIHNob3VsZCBiZSBmdWxseSBlbmNvZGVkIGluc3RlYWQgb2YganVzdFxuICAgICAgICAgICAgICAgICAgICAvLyBwYXRoIGRlbGltaXRlciBlc2NhcGVkIHNpbmNlIHRoZXkgYXJlIGJlaW5nIGluc2VydGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGludG8gdGhlIFVSTCBhbmQgd2UgZXhwZWN0IFVSTCBlbmNvZGVkIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gcGFyc2luZyBkeW5hbWljIHJvdXRlIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAoc2VnbWVudCkgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHNlZ21lbnQpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAuam9pbignLycpXG4gICAgICAgICAgICAgIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlIGFzIHN0cmluZylcbiAgICAgICAgICApIHx8ICcvJylcbiAgICAgIClcbiAgICB9KVxuICApIHtcbiAgICBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnIC8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG5cbiAgICAvLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxuICAgIC8vIGRldmVsb3BtZW50IGluIHRoZSBgPExpbms+YCBjb21wb25lbnQgZGlyZWN0bHkuXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYXJhbXMsXG4gICAgcmVzdWx0OiBpbnRlcnBvbGF0ZWRSb3V0ZSxcbiAgfVxufVxuXG5mdW5jdGlvbiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnk6IFBhcnNlZFVybFF1ZXJ5LCBwYXJhbXM6IHN0cmluZ1tdKSB7XG4gIGNvbnN0IGZpbHRlcmVkUXVlcnk6IFBhcnNlZFVybFF1ZXJ5ID0ge31cblxuICBPYmplY3Qua2V5cyhxdWVyeSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKCFwYXJhbXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgZmlsdGVyZWRRdWVyeVtrZXldID0gcXVlcnlba2V5XVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIGZpbHRlcmVkUXVlcnlcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBhIGdpdmVuIGh5cGVybGluayB3aXRoIGEgY2VydGFpbiByb3V0ZXIgc3RhdGUgKGJhc2VQYXRoIG5vdCBpbmNsdWRlZCkuXG4gKiBQcmVzZXJ2ZXMgYWJzb2x1dGUgdXJscy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVIcmVmKFxuICBjdXJyZW50UGF0aDogc3RyaW5nLFxuICBocmVmOiBVcmwsXG4gIHJlc29sdmVBcz86IGJvb2xlYW5cbik6IHN0cmluZyB7XG4gIC8vIHdlIHVzZSBhIGR1bW15IGJhc2UgdXJsIGZvciByZWxhdGl2ZSB1cmxzXG4gIGNvbnN0IGJhc2UgPSBuZXcgVVJMKGN1cnJlbnRQYXRoLCAnaHR0cDovL24nKVxuICBjb25zdCB1cmxBc1N0cmluZyA9XG4gICAgdHlwZW9mIGhyZWYgPT09ICdzdHJpbmcnID8gaHJlZiA6IGZvcm1hdFdpdGhWYWxpZGF0aW9uKGhyZWYpXG4gIC8vIFJldHVybiBiZWNhdXNlIGl0IGNhbm5vdCBiZSByb3V0ZWQgYnkgdGhlIE5leHQuanMgcm91dGVyXG4gIGlmICghaXNMb2NhbFVSTCh1cmxBc1N0cmluZykpIHtcbiAgICByZXR1cm4gKHJlc29sdmVBcyA/IFt1cmxBc1N0cmluZ10gOiB1cmxBc1N0cmluZykgYXMgc3RyaW5nXG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBmaW5hbFVybCA9IG5ldyBVUkwodXJsQXNTdHJpbmcsIGJhc2UpXG4gICAgZmluYWxVcmwucGF0aG5hbWUgPSBub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaChmaW5hbFVybC5wYXRobmFtZSlcbiAgICBsZXQgaW50ZXJwb2xhdGVkQXMgPSAnJ1xuXG4gICAgaWYgKFxuICAgICAgaXNEeW5hbWljUm91dGUoZmluYWxVcmwucGF0aG5hbWUpICYmXG4gICAgICBmaW5hbFVybC5zZWFyY2hQYXJhbXMgJiZcbiAgICAgIHJlc29sdmVBc1xuICAgICkge1xuICAgICAgY29uc3QgcXVlcnkgPSBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KGZpbmFsVXJsLnNlYXJjaFBhcmFtcylcblxuICAgICAgY29uc3QgeyByZXN1bHQsIHBhcmFtcyB9ID0gaW50ZXJwb2xhdGVBcyhcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUsXG4gICAgICAgIGZpbmFsVXJsLnBhdGhuYW1lLFxuICAgICAgICBxdWVyeVxuICAgICAgKVxuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGludGVycG9sYXRlZEFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgIHBhdGhuYW1lOiByZXN1bHQsXG4gICAgICAgICAgaGFzaDogZmluYWxVcmwuaGFzaCxcbiAgICAgICAgICBxdWVyeTogb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5LCBwYXJhbXMpLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBvcmlnaW4gZGlkbid0IGNoYW5nZSwgaXQgbWVhbnMgd2UgcmVjZWl2ZWQgYSByZWxhdGl2ZSBocmVmXG4gICAgY29uc3QgcmVzb2x2ZWRIcmVmID1cbiAgICAgIGZpbmFsVXJsLm9yaWdpbiA9PT0gYmFzZS5vcmlnaW5cbiAgICAgICAgPyBmaW5hbFVybC5ocmVmLnNsaWNlKGZpbmFsVXJsLm9yaWdpbi5sZW5ndGgpXG4gICAgICAgIDogZmluYWxVcmwuaHJlZlxuXG4gICAgcmV0dXJuIChyZXNvbHZlQXNcbiAgICAgID8gW3Jlc29sdmVkSHJlZiwgaW50ZXJwb2xhdGVkQXMgfHwgcmVzb2x2ZWRIcmVmXVxuICAgICAgOiByZXNvbHZlZEhyZWYpIGFzIHN0cmluZ1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIChyZXNvbHZlQXMgPyBbdXJsQXNTdHJpbmddIDogdXJsQXNTdHJpbmcpIGFzIHN0cmluZ1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmlwT3JpZ2luKHVybDogc3RyaW5nKSB7XG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcblxuICByZXR1cm4gdXJsLnN0YXJ0c1dpdGgob3JpZ2luKSA/IHVybC5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aCkgOiB1cmxcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVVybEFzKHJvdXRlcjogTmV4dFJvdXRlciwgdXJsOiBVcmwsIGFzPzogVXJsKSB7XG4gIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICBsZXQgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSByZXNvbHZlSHJlZihyb3V0ZXIucGF0aG5hbWUsIHVybCwgdHJ1ZSlcbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICBjb25zdCBocmVmSGFkT3JpZ2luID0gcmVzb2x2ZWRIcmVmLnN0YXJ0c1dpdGgob3JpZ2luKVxuICBjb25zdCBhc0hhZE9yaWdpbiA9IHJlc29sdmVkQXMgJiYgcmVzb2x2ZWRBcy5zdGFydHNXaXRoKG9yaWdpbilcblxuICByZXNvbHZlZEhyZWYgPSBzdHJpcE9yaWdpbihyZXNvbHZlZEhyZWYpXG4gIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzXG5cbiAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmSGFkT3JpZ2luID8gcmVzb2x2ZWRIcmVmIDogYWRkQmFzZVBhdGgocmVzb2x2ZWRIcmVmKVxuICBjb25zdCBwcmVwYXJlZEFzID0gYXNcbiAgICA/IHN0cmlwT3JpZ2luKHJlc29sdmVIcmVmKHJvdXRlci5wYXRobmFtZSwgYXMpKVxuICAgIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWZcblxuICByZXR1cm4ge1xuICAgIHVybDogcHJlcGFyZWRVcmwsXG4gICAgYXM6IGFzSGFkT3JpZ2luID8gcHJlcGFyZWRBcyA6IGFkZEJhc2VQYXRoKHByZXBhcmVkQXMpLFxuICB9XG59XG5cbmV4cG9ydCB0eXBlIEJhc2VSb3V0ZXIgPSB7XG4gIHJvdXRlOiBzdHJpbmdcbiAgcGF0aG5hbWU6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYXNQYXRoOiBzdHJpbmdcbiAgYmFzZVBhdGg6IHN0cmluZ1xuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZXNcbn1cblxuZXhwb3J0IHR5cGUgTmV4dFJvdXRlciA9IEJhc2VSb3V0ZXIgJlxuICBQaWNrPFxuICAgIFJvdXRlcixcbiAgICB8ICdwdXNoJ1xuICAgIHwgJ3JlcGxhY2UnXG4gICAgfCAncmVsb2FkJ1xuICAgIHwgJ2JhY2snXG4gICAgfCAncHJlZmV0Y2gnXG4gICAgfCAnYmVmb3JlUG9wU3RhdGUnXG4gICAgfCAnZXZlbnRzJ1xuICAgIHwgJ2lzRmFsbGJhY2snXG4gICAgfCAnaXNSZWFkeSdcbiAgPlxuXG5leHBvcnQgdHlwZSBQcmVmZXRjaE9wdGlvbnMgPSB7XG4gIHByaW9yaXR5PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxufVxuXG5leHBvcnQgdHlwZSBQcml2YXRlUm91dGVJbmZvID1cbiAgfCAoT21pdDxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8sICdzdHlsZVNoZWV0cyc+ICYgeyBpbml0aWFsOiB0cnVlIH0pXG4gIHwgQ29tcGxldGVQcml2YXRlUm91dGVJbmZvXG5cbmV4cG9ydCB0eXBlIENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyA9IHtcbiAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gIHN0eWxlU2hlZXRzOiBTdHlsZVNoZWV0VHVwbGVbXVxuICBfX05fU1NHPzogYm9vbGVhblxuICBfX05fU1NQPzogYm9vbGVhblxuICBwcm9wcz86IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgZXJyPzogRXJyb3JcbiAgZXJyb3I/OiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgQXBwUHJvcHMgPSBQaWNrPENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbywgJ0NvbXBvbmVudCcgfCAnZXJyJz4gJiB7XG4gIHJvdXRlcjogUm91dGVyXG59ICYgUmVjb3JkPHN0cmluZywgYW55PlxuZXhwb3J0IHR5cGUgQXBwQ29tcG9uZW50ID0gQ29tcG9uZW50VHlwZTxBcHBQcm9wcz5cblxudHlwZSBTdWJzY3JpcHRpb24gPSAoXG4gIGRhdGE6IFByaXZhdGVSb3V0ZUluZm8sXG4gIEFwcDogQXBwQ29tcG9uZW50LFxuICByZXNldFNjcm9sbDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgbnVsbFxuKSA9PiBQcm9taXNlPHZvaWQ+XG5cbnR5cGUgQmVmb3JlUG9wU3RhdGVDYWxsYmFjayA9IChzdGF0ZTogTmV4dEhpc3RvcnlTdGF0ZSkgPT4gYm9vbGVhblxuXG50eXBlIENvbXBvbmVudExvYWRDYW5jZWwgPSAoKCkgPT4gdm9pZCkgfCBudWxsXG5cbnR5cGUgSGlzdG9yeU1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnIHwgJ3B1c2hTdGF0ZSdcblxuY29uc3QgbWFudWFsU2Nyb2xsUmVzdG9yYXRpb24gPVxuICBwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OICYmXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICdzY3JvbGxSZXN0b3JhdGlvbicgaW4gd2luZG93Lmhpc3RvcnkgJiZcbiAgISEoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgdiA9ICdfX25leHQnXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh2LCB2KSwgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh2KSwgdHJ1ZVxuICAgIH0gY2F0Y2ggKG4pIHt9XG4gIH0pKClcblxuY29uc3QgU1NHX0RBVEFfTk9UX0ZPVU5EID0gU3ltYm9sKCdTU0dfREFUQV9OT1RfRk9VTkQnKVxuXG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybDogc3RyaW5nLCBhdHRlbXB0czogbnVtYmVyKTogUHJvbWlzZTxhbnk+IHtcbiAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgIC8vIENvb2tpZXMgbWF5IGFsc28gYmUgcmVxdWlyZWQgZm9yIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLlxuICAgIC8vXG4gICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgIC8vID4gb3B0aW9uLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAvL1xuICAgIC8vID4gRm9yIG1heGltdW0gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdoZW4gaXQgY29tZXMgdG8gc2VuZGluZyAmXG4gICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoI2NhdmVhdHNcbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgfSkudGhlbigocmVzKSA9PiB7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIGlmIChhdHRlbXB0cyA+IDEgJiYgcmVzLnN0YXR1cyA+PSA1MDApIHtcbiAgICAgICAgcmV0dXJuIGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cyAtIDEpXG4gICAgICB9XG4gICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgIHJldHVybiByZXMuanNvbigpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoZGF0YS5ub3RGb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbm90Rm91bmQ6IFNTR19EQVRBX05PVF9GT1VORCB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzYClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzYClcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5qc29uKClcbiAgfSlcbn1cblxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZjogc3RyaW5nLCBpc1NlcnZlclJlbmRlcjogYm9vbGVhbikge1xuICByZXR1cm4gZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSkuY2F0Y2goKGVycjogRXJyb3IpID0+IHtcbiAgICAvLyBXZSBzaG91bGQgb25seSB0cmlnZ2VyIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbiBpZiB0aGlzIHdhcyBjYXVzZWRcbiAgICAvLyBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50byBhbiBpbmZpbml0ZVxuICAgIC8vIGxvb3AuXG5cbiAgICBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICBtYXJrQXNzZXRFcnJvcihlcnIpXG4gICAgfVxuICAgIHRocm93IGVyclxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3V0ZXIgaW1wbGVtZW50cyBCYXNlUm91dGVyIHtcbiAgcm91dGU6IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBhc1BhdGg6IHN0cmluZ1xuICBiYXNlUGF0aDogc3RyaW5nXG5cbiAgLyoqXG4gICAqIE1hcCBvZiBhbGwgY29tcG9uZW50cyBsb2FkZWQgaW4gYFJvdXRlcmBcbiAgICovXG4gIGNvbXBvbmVudHM6IHsgW3BhdGhuYW1lOiBzdHJpbmddOiBQcml2YXRlUm91dGVJbmZvIH1cbiAgLy8gU3RhdGljIERhdGEgQ2FjaGVcbiAgc2RjOiB7IFthc1BhdGg6IHN0cmluZ106IG9iamVjdCB9ID0ge31cbiAgc3ViOiBTdWJzY3JpcHRpb25cbiAgY2xjOiBDb21wb25lbnRMb2FkQ2FuY2VsXG4gIHBhZ2VMb2FkZXI6IGFueVxuICBfYnBzOiBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrIHwgdW5kZWZpbmVkXG4gIGV2ZW50czogTWl0dEVtaXR0ZXJcbiAgX3dyYXBBcHA6IChBcHA6IEFwcENvbXBvbmVudCkgPT4gYW55XG4gIGlzU3NyOiBib29sZWFuXG4gIGlzRmFsbGJhY2s6IGJvb2xlYW5cbiAgX2luRmxpZ2h0Um91dGU/OiBzdHJpbmdcbiAgX3NoYWxsb3c/OiBib29sZWFuXG4gIGxvY2FsZT86IHN0cmluZ1xuICBsb2NhbGVzPzogc3RyaW5nW11cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICBkb21haW5Mb2NhbGVzPzogRG9tYWluTG9jYWxlc1xuICBpc1JlYWR5OiBib29sZWFuXG5cbiAgcHJpdmF0ZSBfaWR4OiBudW1iZXIgPSAwXG5cbiAgc3RhdGljIGV2ZW50czogTWl0dEVtaXR0ZXIgPSBtaXR0KClcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgICBhczogc3RyaW5nLFxuICAgIHtcbiAgICAgIGluaXRpYWxQcm9wcyxcbiAgICAgIHBhZ2VMb2FkZXIsXG4gICAgICBBcHAsXG4gICAgICB3cmFwQXBwLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgZXJyLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgaXNGYWxsYmFjayxcbiAgICAgIGxvY2FsZSxcbiAgICAgIGxvY2FsZXMsXG4gICAgICBkZWZhdWx0TG9jYWxlLFxuICAgICAgZG9tYWluTG9jYWxlcyxcbiAgICB9OiB7XG4gICAgICBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvblxuICAgICAgaW5pdGlhbFByb3BzOiBhbnlcbiAgICAgIHBhZ2VMb2FkZXI6IGFueVxuICAgICAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gICAgICBBcHA6IEFwcENvbXBvbmVudFxuICAgICAgd3JhcEFwcDogKEFwcDogQXBwQ29tcG9uZW50KSA9PiBhbnlcbiAgICAgIGVycj86IEVycm9yXG4gICAgICBpc0ZhbGxiYWNrOiBib29sZWFuXG4gICAgICBsb2NhbGU/OiBzdHJpbmdcbiAgICAgIGxvY2FsZXM/OiBzdHJpbmdbXVxuICAgICAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICAgICAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZXNcbiAgICB9XG4gICkge1xuICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxuICAgIHRoaXMucm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcblxuICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxuICAgIHRoaXMuY29tcG9uZW50cyA9IHt9XG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgIGlmIChwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0gPSB7XG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgZXJyLFxuICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10gPSB7XG4gICAgICBDb21wb25lbnQ6IEFwcCBhcyBDb21wb25lbnRUeXBlLFxuICAgICAgc3R5bGVTaGVldHM6IFtcbiAgICAgICAgLyogL19hcHAgZG9lcyBub3QgbmVlZCBpdHMgc3R5bGVzaGVldHMgbWFuYWdlZCAqL1xuICAgICAgXSxcbiAgICB9XG5cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzXG5cbiAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyXG4gICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5XG4gICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgIGNvbnN0IGF1dG9FeHBvcnREeW5hbWljID1cbiAgICAgIGlzRHluYW1pY1JvdXRlKHBhdGhuYW1lKSAmJiBzZWxmLl9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydFxuXG4gICAgdGhpcy5hc1BhdGggPSBhdXRvRXhwb3J0RHluYW1pYyA/IHBhdGhuYW1lIDogYXNcbiAgICB0aGlzLmJhc2VQYXRoID0gYmFzZVBhdGhcbiAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvblxuICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIHRoaXMuX3dyYXBBcHAgPSB3cmFwQXBwXG4gICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgIC8vIGJhY2sgZnJvbSBleHRlcm5hbCBzaXRlXG4gICAgdGhpcy5pc1NzciA9IHRydWVcblxuICAgIHRoaXMuaXNGYWxsYmFjayA9IGlzRmFsbGJhY2tcblxuICAgIHRoaXMuaXNSZWFkeSA9ICEhKFxuICAgICAgc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHxcbiAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5naXAgfHxcbiAgICAgICghYXV0b0V4cG9ydER5bmFtaWMgJiYgIXNlbGYubG9jYXRpb24uc2VhcmNoKVxuICAgIClcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZVxuICAgICAgdGhpcy5sb2NhbGVzID0gbG9jYWxlc1xuICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZVxuICAgICAgdGhpcy5kb21haW5Mb2NhbGVzID0gZG9tYWluTG9jYWxlc1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gbWFrZSBzdXJlIFwiYXNcIiBkb2Vzbid0IHN0YXJ0IHdpdGggZG91YmxlIHNsYXNoZXMgb3IgZWxzZSBpdCBjYW5cbiAgICAgIC8vIHRocm93IGFuIGVycm9yIGFzIGl0J3MgY29uc2lkZXJlZCBpbnZhbGlkXG4gICAgICBpZiAoYXMuc3Vic3RyKDAsIDIpICE9PSAnLy8nKSB7XG4gICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKHBhdGhuYW1lKSwgcXVlcnkgfSksXG4gICAgICAgICAgZ2V0VVJMKCksXG4gICAgICAgICAgeyBsb2NhbGUgfVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSlcblxuICAgICAgLy8gZW5hYmxlIGN1c3RvbSBzY3JvbGwgcmVzdG9yYXRpb24gaGFuZGxpbmcgd2hlbiBhdmFpbGFibGVcbiAgICAgIC8vIG90aGVyd2lzZSBmYWxsYmFjayB0byBicm93c2VyJ3MgZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Qb3BTdGF0ZSA9IChlOiBQb3BTdGF0ZUV2ZW50KTogdm9pZCA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBlLnN0YXRlIGFzIEhpc3RvcnlTdGF0ZVxuXG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgIC8vXG4gICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSB0aGlzXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUpLCBxdWVyeSB9KSxcbiAgICAgICAgZ2V0VVJMKClcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgZm9yY2VkU2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCB1bmRlZmluZWRcbiAgICBjb25zdCB7IHVybCwgYXMsIG9wdGlvbnMsIGlkeCB9ID0gc3RhdGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9pZHggIT09IGlkeCkge1xuICAgICAgICAgIC8vIFNuYXBzaG90IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgICAnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5faWR4LFxuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7IHg6IHNlbGYucGFnZVhPZmZzZXQsIHk6IHNlbGYucGFnZVlPZmZzZXQgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGNhdGNoIHt9XG5cbiAgICAgICAgICAvLyBSZXN0b3JlIG9sZCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyBpZHgpXG4gICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYhKVxuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0geyB4OiAwLCB5OiAwIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faWR4ID0gaWR4XG5cbiAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxuICAgIGlmICh0aGlzLmlzU3NyICYmIGFzID09PSB0aGlzLmFzUGF0aCAmJiBwYXRobmFtZSA9PT0gdGhpcy5wYXRobmFtZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGRvd25zdHJlYW0gYXBwbGljYXRpb24gcmV0dXJucyBmYWxzeSwgcmV0dXJuLlxuICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jaGFuZ2UoXG4gICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgIHVybCxcbiAgICAgIGFzLFxuICAgICAgT2JqZWN0LmFzc2lnbjx7fSwgVHJhbnNpdGlvbk9wdGlvbnMsIFRyYW5zaXRpb25PcHRpb25zPih7fSwgb3B0aW9ucywge1xuICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcbiAgICAgICAgbG9jYWxlOiBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGUsXG4gICAgICB9KSxcbiAgICAgIGZvcmNlZFNjcm9sbFxuICAgIClcbiAgfVxuXG4gIHJlbG9hZCgpOiB2b2lkIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyBiYWNrIGluIGhpc3RvcnlcbiAgICovXG4gIGJhY2soKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuYmFjaygpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBgcHVzaFN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovXG4gIHB1c2godXJsOiBVcmwsIGFzPzogVXJsLCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIHdoZW4gd2UgdXBkYXRlIGhpc3RvcnkgYmVmb3JlIHJvdXRlIGNoYW5nZVxuICAgICAgLy8gaXMgY29tcGxldGUsIGFzIHRoZSBwb3BzdGF0ZSBldmVudCBzaG91bGQgaGFuZGxlIHRoaXMgY2FwdHVyZS5cbiAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFNuYXBzaG90IHNjcm9sbCBwb3NpdGlvbiByaWdodCBiZWZvcmUgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlOlxuICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgICAnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5faWR4LFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyB4OiBzZWxmLnBhZ2VYT2Zmc2V0LCB5OiBzZWxmLnBhZ2VZT2Zmc2V0IH0pXG4gICAgICAgICAgKVxuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfVxuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqL1xuICByZXBsYWNlKHVybDogVXJsLCBhcz86IFVybCwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjaGFuZ2UoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMsXG4gICAgZm9yY2VkU2Nyb2xsPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9XG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghaXNMb2NhbFVSTCh1cmwpKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybFxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gZm9yIHN0YXRpYyBwYWdlcyB3aXRoIHF1ZXJ5IHBhcmFtcyBpbiB0aGUgVVJMIHdlIGRlbGF5XG4gICAgLy8gbWFya2luZyB0aGUgcm91dGVyIHJlYWR5IHVudGlsIGFmdGVyIHRoZSBxdWVyeSBpcyB1cGRhdGVkXG4gICAgaWYgKChvcHRpb25zIGFzIGFueSkuX2gpIHtcbiAgICAgIHRoaXMuaXNSZWFkeSA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IHRvIHNjcm9sbCByZXNldCBiZWhhdmlvciB1bmxlc3MgZXhwbGljaXRseSBzcGVjaWZpZWQgdG8gYmVcbiAgICAvLyBgZmFsc2VgISBUaGlzIG1ha2VzIHRoZSBiZWhhdmlvciBiZXR3ZWVuIHVzaW5nIGBSb3V0ZXIjcHVzaGAgYW5kIGFcbiAgICAvLyBgPExpbmsgLz5gIGNvbnNpc3RlbnQuXG4gICAgb3B0aW9ucy5zY3JvbGwgPSAhIShvcHRpb25zLnNjcm9sbCA/PyB0cnVlKVxuXG4gICAgbGV0IGxvY2FsZUNoYW5nZSA9IG9wdGlvbnMubG9jYWxlICE9PSB0aGlzLmxvY2FsZVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgIHRoaXMubG9jYWxlID1cbiAgICAgICAgb3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlXG4gICAgICAgICAgPyB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICA6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMubG9jYWxlXG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnMubG9jYWxlID0gdGhpcy5sb2NhbGVcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKGhhc0Jhc2VQYXRoKGFzKSA/IGRlbEJhc2VQYXRoKGFzKSA6IGFzKVxuICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9IG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lLFxuICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgIClcblxuICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlXG4gICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gYWRkQmFzZVBhdGgocGFyc2VkQXMucGF0aG5hbWUpXG4gICAgICAgIGFzID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpXG4gICAgICAgIHVybCA9IGFkZEJhc2VQYXRoKFxuICAgICAgICAgIG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gICAgICAgICAgICBoYXNCYXNlUGF0aCh1cmwpID8gZGVsQmFzZVBhdGgodXJsKSA6IHVybCxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgICAgICkucGF0aG5hbWVcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgbGV0IGRpZE5hdmlnYXRlID0gZmFsc2VcblxuICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIC8vIGlmIHRoZSBsb2NhbGUgaXNuJ3QgY29uZmlndXJlZCBoYXJkIG5hdmlnYXRlIHRvIHNob3cgNDA0IHBhZ2VcbiAgICAgICAgaWYgKCF0aGlzLmxvY2FsZXM/LmluY2x1ZGVzKHRoaXMubG9jYWxlISkpIHtcbiAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGFkZExvY2FsZShwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGUpXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcylcbiAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUoXG4gICAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB0aGlzLmxvY2FsZVxuICAgICAgKVxuXG4gICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgLy8gY29ycmVjdCBkb21haW5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICFkaWROYXZpZ2F0ZSAmJlxuICAgICAgICAgIGRldGVjdGVkRG9tYWluICYmXG4gICAgICAgICAgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSAhPT0gZGV0ZWN0ZWREb21haW4uZG9tYWluXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IGFzTm9CYXNlUGF0aCA9IGRlbEJhc2VQYXRoKGFzKVxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYGh0dHAke2RldGVjdGVkRG9tYWluLmh0dHAgPyAnJyA6ICdzJ306Ly8ke1xuICAgICAgICAgICAgZGV0ZWN0ZWREb21haW4uZG9tYWluXG4gICAgICAgICAgfSR7YWRkQmFzZVBhdGgoXG4gICAgICAgICAgICBgJHtcbiAgICAgICAgICAgICAgdGhpcy5sb2NhbGUgPT09IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICAgICAgOiBgLyR7dGhpcy5sb2NhbGV9YFxuICAgICAgICAgICAgfSR7YXNOb0Jhc2VQYXRoID09PSAnLycgPyAnJyA6IGFzTm9CYXNlUGF0aH1gIHx8ICcvJ1xuICAgICAgICAgICl9YFxuICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGlkTmF2aWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKG9wdGlvbnMgYXMgYW55KS5faCkge1xuICAgICAgdGhpcy5pc1NzciA9IGZhbHNlXG4gICAgfVxuICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICBpZiAoU1QpIHtcbiAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ3JvdXRlQ2hhbmdlJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNoYWxsb3cgPSBmYWxzZSB9ID0gb3B0aW9uc1xuICAgIGNvbnN0IHJvdXRlUHJvcHMgPSB7IHNoYWxsb3cgfVxuXG4gICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUpIHtcbiAgICAgIHRoaXMuYWJvcnRDb21wb25lbnRMb2FkKHRoaXMuX2luRmxpZ2h0Um91dGUsIHJvdXRlUHJvcHMpXG4gICAgfVxuXG4gICAgYXMgPSBhZGRCYXNlUGF0aChcbiAgICAgIGFkZExvY2FsZShcbiAgICAgICAgaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMsXG4gICAgICAgIG9wdGlvbnMubG9jYWxlLFxuICAgICAgICB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgIClcbiAgICApXG4gICAgY29uc3QgY2xlYW5lZEFzID0gZGVsTG9jYWxlKFxuICAgICAgaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMsXG4gICAgICB0aGlzLmxvY2FsZVxuICAgIClcbiAgICB0aGlzLl9pbkZsaWdodFJvdXRlID0gYXNcblxuICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBwcm9jZWVkLiBXZSBzaG91bGQgb25seSBjaGFuZ2UgdGhlIHN0YXRlLlxuXG4gICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICBpZiAoIShvcHRpb25zIGFzIGFueSkuX2ggJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSkge1xuICAgICAgdGhpcy5hc1BhdGggPSBjbGVhbmVkQXNcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpXG4gICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoZSByZXNvbHZlZCBocmVmIHdoZW4gb25seSBhIGhhc2ggY2hhbmdlP1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpXG4gICAgICB0aGlzLnNjcm9sbFRvSGFzaChjbGVhbmVkQXMpXG4gICAgICB0aGlzLm5vdGlmeSh0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0sIG51bGwpXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VDb21wbGV0ZScsIGFzLCByb3V0ZVByb3BzKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBsZXQgcGFyc2VkID0gcGFyc2VSZWxhdGl2ZVVybCh1cmwpXG4gICAgbGV0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZWRcblxuICAgIC8vIFRoZSBidWlsZCBtYW5pZmVzdCBuZWVkcyB0byBiZSBsb2FkZWQgYmVmb3JlIGF1dG8tc3RhdGljIGR5bmFtaWMgcGFnZXNcbiAgICAvLyBnZXQgdGhlaXIgcXVlcnkgcGFyYW1ldGVycyB0byBhbGxvdyBlbnN1cmluZyB0aGV5IGNhbiBiZSBwYXJzZWQgcHJvcGVybHlcbiAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgIGxldCBwYWdlczogYW55LCByZXdyaXRlczogYW55XG4gICAgdHJ5IHtcbiAgICAgIHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KClcbiAgICAgIDsoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9ID0gYXdhaXQgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSWYgd2UgZmFpbCB0byByZXNvbHZlIHRoZSBwYWdlIGxpc3Qgb3IgY2xpZW50LWJ1aWxkIG1hbmlmZXN0LCB3ZSBtdXN0XG4gICAgICAvLyBkbyBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb246XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBwYXJzZWQgPSB0aGlzLl9yZXNvbHZlSHJlZihwYXJzZWQsIHBhZ2VzKSBhcyB0eXBlb2YgcGFyc2VkXG5cbiAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWVcbiAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICB9XG5cbiAgICAvLyB1cmwgYW5kIGFzIHNob3VsZCBhbHdheXMgYmUgcHJlZml4ZWQgd2l0aCBiYXNlUGF0aCBieSB0aGlzXG4gICAgLy8gcG9pbnQgYnkgZWl0aGVyIG5leHQvbGluayBvciByb3V0ZXIucHVzaC9yZXBsYWNlIHNvIHN0cmlwIHRoZVxuICAgIC8vIGJhc2VQYXRoIGZyb20gdGhlIHBhdGhuYW1lIHRvIG1hdGNoIHRoZSBwYWdlcyBkaXIgMS10by0xXG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZVxuICAgICAgPyByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChkZWxCYXNlUGF0aChwYXRobmFtZSkpXG4gICAgICA6IHBhdGhuYW1lXG5cbiAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICBpZiAoIXRoaXMudXJsSXNOZXcoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICBtZXRob2QgPSAncmVwbGFjZVN0YXRlJ1xuICAgIH1cblxuICAgIGxldCByb3V0ZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuXG4gICAgLy8gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBhcyB2YWx1ZSB1c2luZyByZXdyaXRlcyBmb3IgZHluYW1pYyBTU0dcbiAgICAvLyBwYWdlcyB0byBhbGxvdyBidWlsZGluZyB0aGUgZGF0YSBVUkwgY29ycmVjdGx5XG4gICAgbGV0IHJlc29sdmVkQXMgPSBhc1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXMuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICByZXNvbHZlZEFzID0gcmVzb2x2ZVJld3JpdGVzKFxuICAgICAgICBhZGRCYXNlUGF0aChcbiAgICAgICAgICBhZGRMb2NhbGUoZGVsQmFzZVBhdGgocGFyc2VSZWxhdGl2ZVVybChhcykucGF0aG5hbWUpLCB0aGlzLmxvY2FsZSlcbiAgICAgICAgKSxcbiAgICAgICAgcGFnZXMsXG4gICAgICAgIHJld3JpdGVzLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgKHA6IHN0cmluZykgPT4gdGhpcy5fcmVzb2x2ZUhyZWYoeyBwYXRobmFtZTogcCB9LCBwYWdlcykucGF0aG5hbWUhLFxuICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgIClcblxuICAgICAgaWYgKHJlc29sdmVkQXMgIT09IGFzKSB7XG4gICAgICAgIGNvbnN0IHBvdGVudGlhbEhyZWYgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlSHJlZihcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZCwge1xuICAgICAgICAgICAgICBwYXRobmFtZTogbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgICAgICAgICAgICAgICBoYXNCYXNlUGF0aChyZXNvbHZlZEFzKSA/IGRlbEJhc2VQYXRoKHJlc29sdmVkQXMpIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgICAgICAgICAgKS5wYXRobmFtZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcGFnZXMsXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICkucGF0aG5hbWUhXG4gICAgICAgIClcblxuICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgIGlmIChwYWdlcy5pbmNsdWRlcyhwb3RlbnRpYWxIcmVmKSkge1xuICAgICAgICAgIHJvdXRlID0gcG90ZW50aWFsSHJlZlxuICAgICAgICAgIHBhdGhuYW1lID0gcG90ZW50aWFsSHJlZlxuICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpc0xvY2FsVVJMKGFzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIGhyZWY6IFwiJHt1cmx9XCIgYW5kIGFzOiBcIiR7YXN9XCIsIHJlY2VpdmVkIHJlbGF0aXZlIGhyZWYgYW5kIGV4dGVybmFsIGFzYCArXG4gICAgICAgICAgICBgXFxuU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9lcnIuc2gvbmV4dC5qcy9pbnZhbGlkLXJlbGF0aXZlLXVybC1leHRlcm5hbC1hc2BcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGFzXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICByZXNvbHZlZEFzID0gZGVsTG9jYWxlKGRlbEJhc2VQYXRoKHJlc29sdmVkQXMpLCB0aGlzLmxvY2FsZSlcblxuICAgIGlmIChpc0R5bmFtaWNSb3V0ZShyb3V0ZSkpIHtcbiAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChyZXNvbHZlZEFzKVxuICAgICAgY29uc3QgYXNQYXRobmFtZSA9IHBhcnNlZEFzLnBhdGhuYW1lXG5cbiAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSBnZXRSb3V0ZVJlZ2V4KHJvdXRlKVxuICAgICAgY29uc3Qgcm91dGVNYXRjaCA9IGdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKVxuICAgICAgY29uc3Qgc2hvdWxkSW50ZXJwb2xhdGUgPSByb3V0ZSA9PT0gYXNQYXRobmFtZVxuICAgICAgY29uc3QgaW50ZXJwb2xhdGVkQXMgPSBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICA/IGludGVycG9sYXRlQXMocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KVxuICAgICAgICA6ICh7fSBhcyB7IHJlc3VsdDogdW5kZWZpbmVkOyBwYXJhbXM6IHVuZGVmaW5lZCB9KVxuXG4gICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgKHNob3VsZEludGVycG9sYXRlICYmICFpbnRlcnBvbGF0ZWRBcy5yZXN1bHQpKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdQYXJhbXMgPSBPYmplY3Qua2V5cyhyb3V0ZVJlZ2V4Lmdyb3VwcykuZmlsdGVyKFxuICAgICAgICAgIChwYXJhbSkgPT4gIXF1ZXJ5W3BhcmFtXVxuICAgICAgICApXG5cbiAgICAgICAgaWYgKG1pc3NpbmdQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIGAke1xuICAgICAgICAgICAgICAgIHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgICAgICA/IGBJbnRlcnBvbGF0aW5nIGhyZWZgXG4gICAgICAgICAgICAgICAgICA6IGBNaXNtYXRjaGluZyBcXGBhc1xcYCBhbmQgXFxgaHJlZlxcYGBcbiAgICAgICAgICAgICAgfSBmYWlsZWQgdG8gbWFudWFsbHkgcHJvdmlkZSBgICtcbiAgICAgICAgICAgICAgICBgdGhlIHBhcmFtczogJHttaXNzaW5nUGFyYW1zLmpvaW4oXG4gICAgICAgICAgICAgICAgICAnLCAnXG4gICAgICAgICAgICAgICAgKX0gaW4gdGhlIFxcYGhyZWZcXGAncyBcXGBxdWVyeVxcYGBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAoc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgPyBgVGhlIHByb3ZpZGVkIFxcYGhyZWZcXGAgKCR7dXJsfSkgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKCR7bWlzc2luZ1BhcmFtcy5qb2luKFxuICAgICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICAgICl9KSB0byBiZSBpbnRlcnBvbGF0ZWQgcHJvcGVybHkuIGBcbiAgICAgICAgICAgICAgOiBgVGhlIHByb3ZpZGVkIFxcYGFzXFxgIHZhbHVlICgke2FzUGF0aG5hbWV9KSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgXFxgaHJlZlxcYCB2YWx1ZSAoJHtyb3V0ZX0pLiBgKSArXG4gICAgICAgICAgICAgIGBSZWFkIG1vcmU6IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzLyR7XG4gICAgICAgICAgICAgICAgc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgICAgID8gJ2hyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWQnXG4gICAgICAgICAgICAgICAgICA6ICdpbmNvbXBhdGlibGUtaHJlZi1hcydcbiAgICAgICAgICAgICAgfWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgYXMgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBwYXJzZWRBcywge1xuICAgICAgICAgICAgcGF0aG5hbWU6IGludGVycG9sYXRlZEFzLnJlc3VsdCxcbiAgICAgICAgICAgIHF1ZXJ5OiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIGludGVycG9sYXRlZEFzLnBhcmFtcyEpLFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpXG4gICAgICB9XG4gICAgfVxuXG4gICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZVN0YXJ0JywgYXMsIHJvdXRlUHJvcHMpXG5cbiAgICB0cnkge1xuICAgICAgbGV0IHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBhZGRCYXNlUGF0aChhZGRMb2NhbGUocmVzb2x2ZWRBcywgdGhpcy5sb2NhbGUpKSxcbiAgICAgICAgcm91dGVQcm9wc1xuICAgICAgKVxuICAgICAgbGV0IHsgZXJyb3IsIHByb3BzLCBfX05fU1NHLCBfX05fU1NQIH0gPSByb3V0ZUluZm9cblxuICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXG4gICAgICBpZiAoKF9fTl9TU0cgfHwgX19OX1NTUCkgJiYgcHJvcHMpIHtcbiAgICAgICAgaWYgKChwcm9wcyBhcyBhbnkpLnBhZ2VQcm9wcyAmJiAocHJvcHMgYXMgYW55KS5wYWdlUHJvcHMuX19OX1JFRElSRUNUKSB7XG4gICAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSAocHJvcHMgYXMgYW55KS5wYWdlUHJvcHMuX19OX1JFRElSRUNUXG5cbiAgICAgICAgICAvLyBjaGVjayBpZiBkZXN0aW5hdGlvbiBpcyBpbnRlcm5hbCAocmVzb2x2ZXMgdG8gYSBwYWdlKSBhbmQgYXR0ZW1wdFxuICAgICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcbiAgICAgICAgICAvLyBpdCdzIG5vdFxuICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSBwYXJzZVJlbGF0aXZlVXJsKGRlc3RpbmF0aW9uKVxuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZUhyZWYocGFyc2VkSHJlZiwgcGFnZXMsIGZhbHNlKVxuXG4gICAgICAgICAgICBpZiAocGFnZXMuaW5jbHVkZXMocGFyc2VkSHJlZi5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCwgYXM6IG5ld0FzIH0gPSBwcmVwYXJlVXJsQXMoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvblxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkZXN0aW5hdGlvblxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7fSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBTU0cgZGF0YSA0MDRcbiAgICAgICAgaWYgKHByb3BzLm5vdEZvdW5kID09PSBTU0dfREFUQV9OT1RfRk9VTkQpIHtcbiAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoJy80MDQnKVxuICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9ICcvNDA0J1xuICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnL19lcnJvcidcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyhcbiAgICAgICAgICAgIG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBhcyxcbiAgICAgICAgICAgIHsgc2hhbGxvdzogZmFsc2UgfVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLCBhcywgcm91dGVQcm9wcylcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCBhcHBDb21wOiBhbnkgPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50XG4gICAgICAgIDsod2luZG93IGFzIGFueSkubmV4dC5pc1ByZXJlbmRlcmVkID1cbiAgICAgICAgICBhcHBDb21wLmdldEluaXRpYWxQcm9wcyA9PT0gYXBwQ29tcC5vcmlnR2V0SW5pdGlhbFByb3BzICYmXG4gICAgICAgICAgIShyb3V0ZUluZm8uQ29tcG9uZW50IGFzIGFueSkuZ2V0SW5pdGlhbFByb3BzXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRoaXMuc2V0KFxuICAgICAgICByb3V0ZSxcbiAgICAgICAgcGF0aG5hbWUhLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgY2xlYW5lZEFzLFxuICAgICAgICByb3V0ZUluZm8sXG4gICAgICAgIGZvcmNlZFNjcm9sbCB8fCAob3B0aW9ucy5zY3JvbGwgPyB7IHg6IDAsIHk6IDAgfSA6IG51bGwpXG4gICAgICApLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIGlmIChlLmNhbmNlbGxlZCkgZXJyb3IgPSBlcnJvciB8fCBlXG4gICAgICAgIGVsc2UgdGhyb3cgZVxuICAgICAgfSlcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVycm9yLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2FsZSkge1xuICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID0gdGhpcy5sb2NhbGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywgYXMsIHJvdXRlUHJvcHMpXG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIGNoYW5nZVN0YXRlKFxuICAgIG1ldGhvZDogSGlzdG9yeU1ldGhvZCxcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhczogc3RyaW5nLFxuICAgIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge31cbiAgKTogdm9pZCB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkuJHttZXRob2R9IGlzIG5vdCBhdmFpbGFibGVgKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWV0aG9kICE9PSAncHVzaFN0YXRlJyB8fCBnZXRVUkwoKSAhPT0gYXMpIHtcbiAgICAgIHRoaXMuX3NoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3dcbiAgICAgIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0oXG4gICAgICAgIHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgYXMsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBfX046IHRydWUsXG4gICAgICAgICAgaWR4OiB0aGlzLl9pZHggPSBtZXRob2QgIT09ICdwdXNoU3RhdGUnID8gdGhpcy5faWR4IDogdGhpcy5faWR4ICsgMSxcbiAgICAgICAgfSBhcyBIaXN0b3J5U3RhdGUsXG4gICAgICAgIC8vIE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGlnbm9yZXMgdGhpcyBwYXJhbWV0ZXIsIGFsdGhvdWdoIHRoZXkgbWF5IHVzZSBpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IaXN0b3J5L3JlcGxhY2VTdGF0ZVxuICAgICAgICAnJyxcbiAgICAgICAgYXNcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBhc3luYyBoYW5kbGVSb3V0ZUluZm9FcnJvcihcbiAgICBlcnI6IEVycm9yICYgeyBjb2RlOiBhbnk7IGNhbmNlbGxlZDogYm9vbGVhbiB9LFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAgcm91dGVQcm9wczogUm91dGVQcm9wZXJ0aWVzLFxuICAgIGxvYWRFcnJvckZhaWw/OiBib29sZWFuXG4gICk6IFByb21pc2U8Q29tcGxldGVQcml2YXRlUm91dGVJbmZvPiB7XG4gICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxsYXRpb24gZXJyb3JzXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICBpZiAoaXNBc3NldEVycm9yKGVycikgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyLCBhcywgcm91dGVQcm9wcylcblxuICAgICAgLy8gSWYgd2UgY2FuJ3QgbG9hZCB0aGUgcGFnZSBpdCBjb3VsZCBiZSBvbmUgb2YgZm9sbG93aW5nIHJlYXNvbnNcbiAgICAgIC8vICAxLiBQYWdlIGRvZXNuJ3QgZXhpc3RzXG4gICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgIC8vICAzLiBJbnRlcm5hbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBwYWdlXG5cbiAgICAgIC8vIFNvLCBkb2luZyBhIGhhcmQgcmVsb2FkIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhc1xuXG4gICAgICAvLyBDaGFuZ2luZyB0aGUgVVJMIGRvZXNuJ3QgYmxvY2sgZXhlY3V0aW5nIHRoZSBjdXJyZW50IGNvZGUgcGF0aC5cbiAgICAgIC8vIFNvIGxldCdzIHRocm93IGEgY2FuY2VsbGF0aW9uIGVycm9yIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICB0aHJvdyBidWlsZENhbmNlbGxhdGlvbkVycm9yKClcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgbGV0IENvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICAgICAgbGV0IHN0eWxlU2hlZXRzOiBTdHlsZVNoZWV0VHVwbGVbXVxuICAgICAgbGV0IHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkXG5cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIENvbXBvbmVudCEgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgIHR5cGVvZiBzdHlsZVNoZWV0cyEgPT09ICd1bmRlZmluZWQnXG4gICAgICApIHtcbiAgICAgICAgOyh7IHBhZ2U6IENvbXBvbmVudCwgc3R5bGVTaGVldHMgfSA9IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoXG4gICAgICAgICAgJy9fZXJyb3InXG4gICAgICAgICkpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJvdXRlSW5mbzogQ29tcGxldGVQcml2YXRlUm91dGVJbmZvID0ge1xuICAgICAgICBwcm9wcyxcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgZXJyLFxuICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgfVxuXG4gICAgICBpZiAoIXJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IGF3YWl0IHRoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwge1xuICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICB9IGFzIGFueSlcbiAgICAgICAgfSBjYXRjaCAoZ2lwRXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZXJyb3IgcGFnZSBgZ2V0SW5pdGlhbFByb3BzYDogJywgZ2lwRXJyKVxuICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJvdXRlSW5mb1xuICAgIH0gY2F0Y2ggKHJvdXRlSW5mb0Vycikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoXG4gICAgICAgIHJvdXRlSW5mb0VycixcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBhcyxcbiAgICAgICAgcm91dGVQcm9wcyxcbiAgICAgICAgdHJ1ZVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFJvdXRlSW5mbyhcbiAgICByb3V0ZTogc3RyaW5nLFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IGFueSxcbiAgICBhczogc3RyaW5nLFxuICAgIHJvdXRlUHJvcHM6IFJvdXRlUHJvcGVydGllc1xuICApOiBQcm9taXNlPFByaXZhdGVSb3V0ZUluZm8+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXhpc3RpbmdSb3V0ZUluZm86IFByaXZhdGVSb3V0ZUluZm8gfCB1bmRlZmluZWQgPSB0aGlzLmNvbXBvbmVudHNbXG4gICAgICAgIHJvdXRlXG4gICAgICBdXG4gICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nUm91dGVJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1JvdXRlSW5mb1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjYWNoZWRSb3V0ZUluZm86IENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbyB8IHVuZGVmaW5lZCA9XG4gICAgICAgIGV4aXN0aW5nUm91dGVJbmZvICYmICdpbml0aWFsJyBpbiBleGlzdGluZ1JvdXRlSW5mb1xuICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgOiBleGlzdGluZ1JvdXRlSW5mb1xuICAgICAgY29uc3Qgcm91dGVJbmZvOiBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm9cbiAgICAgICAgPyBjYWNoZWRSb3V0ZUluZm9cbiAgICAgICAgOiBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KHJvdXRlKS50aGVuKChyZXMpID0+ICh7XG4gICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgIF9fTl9TU1A6IHJlcy5tb2QuX19OX1NTUCxcbiAgICAgICAgICB9KSlcblxuICAgICAgY29uc3QgeyBDb21wb25lbnQsIF9fTl9TU0csIF9fTl9TU1AgfSA9IHJvdXRlSW5mb1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCB7IGlzVmFsaWRFbGVtZW50VHlwZSB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKVxuICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDb21wb25lbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke3BhdGhuYW1lfVwiYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YUhyZWY6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gICAgICBpZiAoX19OX1NTRyB8fCBfX05fU1NQKSB7XG4gICAgICAgIGRhdGFIcmVmID0gdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKFxuICAgICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWUsIHF1ZXJ5IH0pLFxuICAgICAgICAgIGRlbEJhc2VQYXRoKGFzKSxcbiAgICAgICAgICBfX05fU1NHLFxuICAgICAgICAgIHRoaXMubG9jYWxlXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvcHMgPSBhd2FpdCB0aGlzLl9nZXREYXRhPENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbz4oKCkgPT5cbiAgICAgICAgX19OX1NTR1xuICAgICAgICAgID8gdGhpcy5fZ2V0U3RhdGljRGF0YShkYXRhSHJlZiEpXG4gICAgICAgICAgOiBfX05fU1NQXG4gICAgICAgICAgPyB0aGlzLl9nZXRTZXJ2ZXJEYXRhKGRhdGFIcmVmISlcbiAgICAgICAgICA6IHRoaXMuZ2V0SW5pdGlhbFByb3BzKFxuICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgIC8vIHdlIHByb3ZpZGUgQXBwVHJlZSBsYXRlciBzbyB0aGlzIG5lZWRzIHRvIGJlIGBhbnlgXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgICB9IGFzIGFueVxuICAgICAgICAgICAgKVxuICAgICAgKVxuXG4gICAgICByb3V0ZUluZm8ucHJvcHMgPSBwcm9wc1xuICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mb1xuICAgICAgcmV0dXJuIHJvdXRlSW5mb1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzKVxuICAgIH1cbiAgfVxuXG4gIHNldChcbiAgICByb3V0ZTogc3RyaW5nLFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAgZGF0YTogUHJpdmF0ZVJvdXRlSW5mbyxcbiAgICByZXNldFNjcm9sbDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgbnVsbFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmlzRmFsbGJhY2sgPSBmYWxzZVxuXG4gICAgdGhpcy5yb3V0ZSA9IHJvdXRlXG4gICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5XG4gICAgdGhpcy5hc1BhdGggPSBhc1xuICAgIHJldHVybiB0aGlzLm5vdGlmeShkYXRhLCByZXNldFNjcm9sbClcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0byBleGVjdXRlIGJlZm9yZSByZXBsYWNpbmcgcm91dGVyIHN0YXRlXG4gICAqIEBwYXJhbSBjYiBjYWxsYmFjayB0byBiZSBleGVjdXRlZFxuICAgKi9cbiAgYmVmb3JlUG9wU3RhdGUoY2I6IEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2spIHtcbiAgICB0aGlzLl9icHMgPSBjYlxuICB9XG5cbiAgb25seUFIYXNoQ2hhbmdlKGFzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuYXNQYXRoKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KCcjJylcbiAgICBjb25zdCBbbmV3VXJsTm9IYXNoLCBuZXdIYXNoXSA9IGFzLnNwbGl0KCcjJylcblxuICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICBpZiAobmV3SGFzaCAmJiBvbGRVcmxOb0hhc2ggPT09IG5ld1VybE5vSGFzaCAmJiBvbGRIYXNoID09PSBuZXdIYXNoKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSB1cmxzIGFyZSBjaGFuZ2UsIHRoZXJlJ3MgbW9yZSB0aGFuIGEgaGFzaCBjaGFuZ2VcbiAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGVuIGl0J3MgYSBoYXNoIG9ubHkgY2hhbmdlLlxuICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBib3RoIHRoZSBlbnRlciBhbmRcbiAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgIC8vIGFuZCBpcyB0cmVhdGVkIGFzIGEgbmV4dCByZWxvYWQuXG4gICAgcmV0dXJuIG9sZEhhc2ggIT09IG5ld0hhc2hcbiAgfVxuXG4gIHNjcm9sbFRvSGFzaChhczogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgWywgaGFzaF0gPSBhcy5zcGxpdCgnIycpXG4gICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlXG4gICAgaWYgKGhhc2ggPT09ICcnKSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpXG4gICAgaWYgKGlkRWwpIHtcbiAgICAgIGlkRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGhhc2gpWzBdXG4gICAgaWYgKG5hbWVFbCkge1xuICAgICAgbmFtZUVsLnNjcm9sbEludG9WaWV3KClcbiAgICB9XG4gIH1cblxuICB1cmxJc05ldyhhc1BhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoXG4gIH1cblxuICBfcmVzb2x2ZUhyZWYocGFyc2VkSHJlZjogVXJsT2JqZWN0LCBwYWdlczogc3RyaW5nW10sIGFwcGx5QmFzZVBhdGggPSB0cnVlKSB7XG4gICAgY29uc3QgeyBwYXRobmFtZSB9ID0gcGFyc2VkSHJlZlxuICAgIGNvbnN0IGNsZWFuUGF0aG5hbWUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChcbiAgICAgIGRlbm9ybWFsaXplUGFnZVBhdGgoYXBwbHlCYXNlUGF0aCA/IGRlbEJhc2VQYXRoKHBhdGhuYW1lISkgOiBwYXRobmFtZSEpXG4gICAgKVxuXG4gICAgaWYgKGNsZWFuUGF0aG5hbWUgPT09ICcvNDA0JyB8fCBjbGVhblBhdGhuYW1lID09PSAnL19lcnJvcicpIHtcbiAgICAgIHJldHVybiBwYXJzZWRIcmVmXG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIHJlc29sdmluZyBocmVmIGZvciBkeW5hbWljIHJvdXRlc1xuICAgIGlmICghcGFnZXMuaW5jbHVkZXMoY2xlYW5QYXRobmFtZSEpKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYXJyYXktY2FsbGJhY2stcmV0dXJuXG4gICAgICBwYWdlcy5zb21lKChwYWdlKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBpc0R5bmFtaWNSb3V0ZShwYWdlKSAmJlxuICAgICAgICAgIGdldFJvdXRlUmVnZXgocGFnZSkucmUudGVzdChjbGVhblBhdGhuYW1lISlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IGFwcGx5QmFzZVBhdGggPyBhZGRCYXNlUGF0aChwYWdlKSA6IHBhZ2VcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBwYXJzZWRIcmVmLnBhdGhuYW1lID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGFyc2VkSHJlZi5wYXRobmFtZSEpXG4gICAgcmV0dXJuIHBhcnNlZEhyZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVmZXRjaCBwYWdlIGNvZGUsIHlvdSBtYXkgd2FpdCBmb3IgdGhlIGRhdGEgZHVyaW5nIHBhZ2UgcmVuZGVyaW5nLlxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxuICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgKiBAcGFyYW0gYXNQYXRoIHRoZSBhcyBwYXRoIG9mIHRoZSBwcmVmZXRjaGVkIHBhZ2VcbiAgICovXG4gIGFzeW5jIHByZWZldGNoKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzUGF0aDogc3RyaW5nID0gdXJsLFxuICAgIG9wdGlvbnM6IFByZWZldGNoT3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCBwYXJzZWQgPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcblxuICAgIGxldCB7IHBhdGhuYW1lIH0gPSBwYXJzZWRcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICBpZiAob3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHBhdGhuYW1lID0gbm9ybWFsaXplTG9jYWxlUGF0aCEocGF0aG5hbWUsIHRoaXMubG9jYWxlcykucGF0aG5hbWVcbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuXG4gICAgICAgIGxldCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKVxuICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aCEoXG4gICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUsXG4gICAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICAgIClcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBsb2NhbGVQYXRoUmVzdWx0LnBhdGhuYW1lXG4gICAgICAgIG9wdGlvbnMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgYXNQYXRoID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKVxuXG4gICAgcGFyc2VkID0gdGhpcy5fcmVzb2x2ZUhyZWYocGFyc2VkLCBwYWdlcywgZmFsc2UpIGFzIHR5cGVvZiBwYXJzZWRcblxuICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZVxuICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgIH1cblxuICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnBhZ2VMb2FkZXIuX2lzU3NnKHVybCkudGhlbigoaXNTc2c6IGJvb2xlYW4pID0+IHtcbiAgICAgICAgcmV0dXJuIGlzU3NnXG4gICAgICAgICAgPyB0aGlzLl9nZXRTdGF0aWNEYXRhKFxuICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGFzUGF0aCxcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5sb2NhbGVcbiAgICAgICAgICAgICAgICAgIDogdGhpcy5sb2NhbGVcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIDogZmFsc2VcbiAgICAgIH0pLFxuICAgICAgdGhpcy5wYWdlTG9hZGVyW29wdGlvbnMucHJpb3JpdHkgPyAnbG9hZFBhZ2UnIDogJ3ByZWZldGNoJ10ocm91dGUpLFxuICAgIF0pXG4gIH1cblxuICBhc3luYyBmZXRjaENvbXBvbmVudChyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTxHb29kUGFnZUNhY2hlPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKHRoaXMuY2xjID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH0pXG5cbiAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpXG5cbiAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKFxuICAgICAgICBgQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCIke3JvdXRlfVwiYFxuICAgICAgKVxuICAgICAgZXJyb3IuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG5cbiAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBvbmVudFJlc3VsdFxuICB9XG5cbiAgX2dldERhdGE8VD4oZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2VcbiAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlXG4gICAgfVxuICAgIHRoaXMuY2xjID0gY2FuY2VsXG4gICAgcmV0dXJuIGZuKCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgY29uc3QgZXJyOiBhbnkgPSBuZXcgRXJyb3IoJ0xvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWQnKVxuICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFcbiAgICB9KVxuICB9XG5cbiAgX2dldFN0YXRpY0RhdGEoZGF0YUhyZWY6IHN0cmluZyk6IFByb21pc2U8b2JqZWN0PiB7XG4gICAgY29uc3QgeyBocmVmOiBjYWNoZUtleSB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiYgdGhpcy5zZGNbY2FjaGVLZXldKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc2RjW2NhY2hlS2V5XSlcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoTmV4dERhdGEoZGF0YUhyZWYsIHRoaXMuaXNTc3IpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIHRoaXMuc2RjW2NhY2hlS2V5XSA9IGRhdGFcbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRTZXJ2ZXJEYXRhKGRhdGFIcmVmOiBzdHJpbmcpOiBQcm9taXNlPG9iamVjdD4ge1xuICAgIHJldHVybiBmZXRjaE5leHREYXRhKGRhdGFIcmVmLCB0aGlzLmlzU3NyKVxuICB9XG5cbiAgZ2V0SW5pdGlhbFByb3BzKFxuICAgIENvbXBvbmVudDogQ29tcG9uZW50VHlwZSxcbiAgICBjdHg6IE5leHRQYWdlQ29udGV4dFxuICApOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHsgQ29tcG9uZW50OiBBcHAgfSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXVxuICAgIGNvbnN0IEFwcFRyZWUgPSB0aGlzLl93cmFwQXBwKEFwcCBhcyBBcHBDb21wb25lbnQpXG4gICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlXG4gICAgcmV0dXJuIGxvYWRHZXRJbml0aWFsUHJvcHM8QXBwQ29udGV4dFR5cGU8Um91dGVyPj4oQXBwLCB7XG4gICAgICBBcHBUcmVlLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgY3R4LFxuICAgIH0pXG4gIH1cblxuICBhYm9ydENvbXBvbmVudExvYWQoYXM6IHN0cmluZywgcm91dGVQcm9wczogUm91dGVQcm9wZXJ0aWVzKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY2xjKSB7XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXG4gICAgICAgICdyb3V0ZUNoYW5nZUVycm9yJyxcbiAgICAgICAgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpLFxuICAgICAgICBhcyxcbiAgICAgICAgcm91dGVQcm9wc1xuICAgICAgKVxuICAgICAgdGhpcy5jbGMoKVxuICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgbm90aWZ5KFxuICAgIGRhdGE6IFByaXZhdGVSb3V0ZUluZm8sXG4gICAgcmVzZXRTY3JvbGw6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB8IG51bGxcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuc3ViKFxuICAgICAgZGF0YSxcbiAgICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnQgYXMgQXBwQ29tcG9uZW50LFxuICAgICAgcmVzZXRTY3JvbGxcbiAgICApXG4gIH1cbn1cbiIsIi8vIEZvcm1hdCBmdW5jdGlvbiBtb2RpZmllZCBmcm9tIG5vZGVqc1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG5jb25zdCBzbGFzaGVkUHJvdG9jb2xzID0gL2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVcmwodXJsT2JqOiBVcmxPYmplY3QpIHtcbiAgbGV0IHsgYXV0aCwgaG9zdG5hbWUgfSA9IHVybE9ialxuICBsZXQgcHJvdG9jb2wgPSB1cmxPYmoucHJvdG9jb2wgfHwgJydcbiAgbGV0IHBhdGhuYW1lID0gdXJsT2JqLnBhdGhuYW1lIHx8ICcnXG4gIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgJydcbiAgbGV0IHF1ZXJ5ID0gdXJsT2JqLnF1ZXJ5IHx8ICcnXG4gIGxldCBob3N0OiBzdHJpbmcgfCBmYWxzZSA9IGZhbHNlXG5cbiAgYXV0aCA9IGF1dGggPyBlbmNvZGVVUklDb21wb25lbnQoYXV0aCkucmVwbGFjZSgvJTNBL2ksICc6JykgKyAnQCcgOiAnJ1xuXG4gIGlmICh1cmxPYmouaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3RcbiAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKH5ob3N0bmFtZS5pbmRleE9mKCc6JykgPyBgWyR7aG9zdG5hbWV9XWAgOiBob3N0bmFtZSlcbiAgICBpZiAodXJsT2JqLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdXJsT2JqLnBvcnRcbiAgICB9XG4gIH1cblxuICBpZiAocXVlcnkgJiYgdHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgIHF1ZXJ5ID0gU3RyaW5nKHF1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkgYXMgUGFyc2VkVXJsUXVlcnkpKVxuICB9XG5cbiAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgKHF1ZXJ5ICYmIGA/JHtxdWVyeX1gKSB8fCAnJ1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6J1xuXG4gIGlmIChcbiAgICB1cmxPYmouc2xhc2hlcyB8fFxuICAgICgoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbHMudGVzdChwcm90b2NvbCkpICYmIGhvc3QgIT09IGZhbHNlKVxuICApIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKVxuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZVswXSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lXG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJydcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2hbMF0gIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2hcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2hbMF0gIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoXG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGVuY29kZVVSSUNvbXBvbmVudClcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJylcblxuICByZXR1cm4gYCR7cHJvdG9jb2x9JHtob3N0fSR7cGF0aG5hbWV9JHtzZWFyY2h9JHtoYXNofWBcbn1cbiIsIi8vIFRyYW5zbGF0ZXMgYSBsb2dpY2FsIHJvdXRlIGludG8gaXRzIHBhZ2VzIGFzc2V0IHBhdGggKHJlbGF0aXZlIGZyb20gYSBjb21tb24gcHJlZml4KVxuLy8gXCJhc3NldCBwYXRoXCIgYmVpbmcgaXRzIGphdmFzY3JpcHQgZmlsZSwgZGF0YSBmaWxlLCBwcmVyZW5kZXJlZCBodG1sLC4uLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QXNzZXRQYXRoRnJvbVJvdXRlKFxuICByb3V0ZTogc3RyaW5nLFxuICBleHQ6IHN0cmluZyA9ICcnXG4pOiBzdHJpbmcge1xuICBjb25zdCBwYXRoID1cbiAgICByb3V0ZSA9PT0gJy8nXG4gICAgICA/ICcvaW5kZXgnXG4gICAgICA6IC9eXFwvaW5kZXgoXFwvfCQpLy50ZXN0KHJvdXRlKVxuICAgICAgPyBgL2luZGV4JHtyb3V0ZX1gXG4gICAgICA6IGAke3JvdXRlfWBcbiAgcmV0dXJuIHBhdGggKyBleHRcbn1cbiIsIi8vIElkZW50aWZ5IC9bcGFyYW1dLyBpbiByb3V0ZSBzdHJpbmdcbmNvbnN0IFRFU1RfUk9VVEUgPSAvXFwvXFxbW14vXSs/XFxdKD89XFwvfCQpL1xuXG5leHBvcnQgZnVuY3Rpb24gaXNEeW5hbWljUm91dGUocm91dGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gVEVTVF9ST1VURS50ZXN0KHJvdXRlKVxufVxuIiwiaW1wb3J0IHsgZ2V0TG9jYXRpb25PcmlnaW4gfSBmcm9tICcuLi8uLi91dGlscydcbmltcG9ydCB7IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkgfSBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG4vKipcbiAqIFBhcnNlcyBwYXRoLXJlbGF0aXZlIHVybHMgKGUuZy4gYC9oZWxsby93b3JsZD9mb289YmFyYCkuIElmIHVybCBpc24ndCBwYXRoLXJlbGF0aXZlXG4gKiAoZS5nLiBgLi9oZWxsb2ApIHRoZW4gYXQgbGVhc3QgYmFzZSBtdXN0IGJlLlxuICogQWJzb2x1dGUgdXJscyBhcmUgcmVqZWN0ZWQgd2l0aCBvbmUgZXhjZXB0aW9uLCBpbiB0aGUgYnJvd3NlciwgYWJzb2x1dGUgdXJscyB0aGF0IGFyZSBvblxuICogdGhlIGN1cnJlbnQgb3JpZ2luIHdpbGwgYmUgcGFyc2VkIGFzIHJlbGF0aXZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlbGF0aXZlVXJsKHVybDogc3RyaW5nLCBiYXNlPzogc3RyaW5nKSB7XG4gIGNvbnN0IGdsb2JhbEJhc2UgPSBuZXcgVVJMKFxuICAgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gJ2h0dHA6Ly9uJyA6IGdldExvY2F0aW9uT3JpZ2luKClcbiAgKVxuICBjb25zdCByZXNvbHZlZEJhc2UgPSBiYXNlID8gbmV3IFVSTChiYXNlLCBnbG9iYWxCYXNlKSA6IGdsb2JhbEJhc2VcbiAgY29uc3QgeyBwYXRobmFtZSwgc2VhcmNoUGFyYW1zLCBzZWFyY2gsIGhhc2gsIGhyZWYsIG9yaWdpbiB9ID0gbmV3IFVSTChcbiAgICB1cmwsXG4gICAgcmVzb2x2ZWRCYXNlXG4gIClcbiAgaWYgKG9yaWdpbiAhPT0gZ2xvYmFsQmFzZS5vcmlnaW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFyaWFudDogaW52YWxpZCByZWxhdGl2ZSBVUkwsIHJvdXRlciByZWNlaXZlZCAke3VybH1gKVxuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgcXVlcnk6IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSxcbiAgICBzZWFyY2gsXG4gICAgaGFzaCxcbiAgICBocmVmOiBocmVmLnNsaWNlKGdsb2JhbEJhc2Uub3JpZ2luLmxlbmd0aCksXG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIHBhdGhUb1JlZ2V4cCBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC10by1yZWdleHAnXG5cbmV4cG9ydCB7IHBhdGhUb1JlZ2V4cCB9XG5cbmV4cG9ydCBjb25zdCBtYXRjaGVyT3B0aW9uczogcGF0aFRvUmVnZXhwLlRva2Vuc1RvUmVnZXhwT3B0aW9ucyAmXG4gIHBhdGhUb1JlZ2V4cC5QYXJzZU9wdGlvbnMgPSB7XG4gIHNlbnNpdGl2ZTogZmFsc2UsXG4gIGRlbGltaXRlcjogJy8nLFxufVxuXG5leHBvcnQgY29uc3QgY3VzdG9tUm91dGVNYXRjaGVyT3B0aW9uczogcGF0aFRvUmVnZXhwLlRva2Vuc1RvUmVnZXhwT3B0aW9ucyAmXG4gIHBhdGhUb1JlZ2V4cC5QYXJzZU9wdGlvbnMgPSB7XG4gIC4uLm1hdGNoZXJPcHRpb25zLFxuICBzdHJpY3Q6IHRydWUsXG59XG5cbmV4cG9ydCBkZWZhdWx0IChjdXN0b21Sb3V0ZSA9IGZhbHNlKSA9PiB7XG4gIHJldHVybiAocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3Qga2V5czogcGF0aFRvUmVnZXhwLktleVtdID0gW11cbiAgICBjb25zdCBtYXRjaGVyUmVnZXggPSBwYXRoVG9SZWdleHAucGF0aFRvUmVnZXhwKFxuICAgICAgcGF0aCxcbiAgICAgIGtleXMsXG4gICAgICBjdXN0b21Sb3V0ZSA/IGN1c3RvbVJvdXRlTWF0Y2hlck9wdGlvbnMgOiBtYXRjaGVyT3B0aW9uc1xuICAgIClcbiAgICBjb25zdCBtYXRjaGVyID0gcGF0aFRvUmVnZXhwLnJlZ2V4cFRvRnVuY3Rpb24obWF0Y2hlclJlZ2V4LCBrZXlzKVxuXG4gICAgcmV0dXJuIChwYXRobmFtZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCwgcGFyYW1zPzogYW55KSA9PiB7XG4gICAgICBjb25zdCByZXMgPSBwYXRobmFtZSA9PSBudWxsID8gZmFsc2UgOiBtYXRjaGVyKHBhdGhuYW1lKVxuICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmIChjdXN0b21Sb3V0ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgLy8gdW5uYW1lZCBwYXJhbXMgc2hvdWxkIGJlIHJlbW92ZWQgYXMgdGhleVxuICAgICAgICAgIC8vIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIHRoZSBkZXN0aW5hdGlvblxuICAgICAgICAgIGlmICh0eXBlb2Yga2V5Lm5hbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkZWxldGUgKHJlcy5wYXJhbXMgYXMgYW55KVtrZXkubmFtZV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgLi4ucGFyYW1zLCAuLi5yZXMucGFyYW1zIH1cbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5IH0gZnJvbSAnLi9xdWVyeXN0cmluZydcbmltcG9ydCB7IHBhcnNlUmVsYXRpdmVVcmwgfSBmcm9tICcuL3BhcnNlLXJlbGF0aXZlLXVybCdcbmltcG9ydCAqIGFzIHBhdGhUb1JlZ2V4cCBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC10by1yZWdleHAnXG5cbnR5cGUgUGFyYW1zID0geyBbcGFyYW06IHN0cmluZ106IGFueSB9XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlTm9uUGF0aCh2YWx1ZTogc3RyaW5nLCBwYXJhbXM6IFBhcmFtcyk6IHN0cmluZyB7XG4gIGlmICghdmFsdWUuaW5jbHVkZXMoJzonKSkge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGFyYW1zKSkge1xuICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhgOiR7a2V5fWApKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgIG5ldyBSZWdFeHAoYDoke2tleX1cXFxcKmAsICdnJyksXG4gICAgICAgICAgYDoke2tleX0tLUVTQ0FQRURfUEFSQU1fQVNURVJJU0tTYFxuICAgICAgICApXG4gICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgIG5ldyBSZWdFeHAoYDoke2tleX1cXFxcP2AsICdnJyksXG4gICAgICAgICAgYDoke2tleX0tLUVTQ0FQRURfUEFSQU1fUVVFU1RJT05gXG4gICAgICAgIClcbiAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChgOiR7a2V5fVxcXFwrYCwgJ2cnKSwgYDoke2tleX0tLUVTQ0FQRURfUEFSQU1fUExVU2ApXG4gICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgIG5ldyBSZWdFeHAoYDoke2tleX0oPyFcXFxcdylgLCAnZycpLFxuICAgICAgICAgIGAtLUVTQ0FQRURfUEFSQU1fQ09MT04ke2tleX1gXG4gICAgICAgIClcbiAgICB9XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZVxuICAgIC5yZXBsYWNlKC8oOnxcXCp8XFw/fFxcK3xcXCh8XFwpfFxce3xcXH0pL2csICdcXFxcJDEnKVxuICAgIC5yZXBsYWNlKC8tLUVTQ0FQRURfUEFSQU1fUExVUy9nLCAnKycpXG4gICAgLnJlcGxhY2UoLy0tRVNDQVBFRF9QQVJBTV9DT0xPTi9nLCAnOicpXG4gICAgLnJlcGxhY2UoLy0tRVNDQVBFRF9QQVJBTV9RVUVTVElPTi9nLCAnPycpXG4gICAgLnJlcGxhY2UoLy0tRVNDQVBFRF9QQVJBTV9BU1RFUklTS1MvZywgJyonKVxuXG4gIC8vIHRoZSB2YWx1ZSBuZWVkcyB0byBzdGFydCB3aXRoIGEgZm9yd2FyZC1zbGFzaCB0byBiZSBjb21waWxlZFxuICAvLyBjb3JyZWN0bHlcbiAgcmV0dXJuIHBhdGhUb1JlZ2V4cFxuICAgIC5jb21waWxlKGAvJHt2YWx1ZX1gLCB7IHZhbGlkYXRlOiBmYWxzZSB9KShwYXJhbXMpXG4gICAgLnN1YnN0cigxKVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcmVwYXJlRGVzdGluYXRpb24oXG4gIGRlc3RpbmF0aW9uOiBzdHJpbmcsXG4gIHBhcmFtczogUGFyYW1zLFxuICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gIGFwcGVuZFBhcmFtc1RvUXVlcnk6IGJvb2xlYW5cbikge1xuICBsZXQgcGFyc2VkRGVzdGluYXRpb246IHtcbiAgICBxdWVyeT86IFBhcnNlZFVybFF1ZXJ5XG4gICAgcHJvdG9jb2w/OiBzdHJpbmdcbiAgICBob3N0bmFtZT86IHN0cmluZ1xuICAgIHBvcnQ/OiBzdHJpbmdcbiAgfSAmIFJldHVyblR5cGU8dHlwZW9mIHBhcnNlUmVsYXRpdmVVcmw+ID0ge30gYXMgYW55XG5cbiAgLy8gY2xvbmUgcXVlcnkgc28gd2UgZG9uJ3QgbW9kaWZ5IHRoZSBvcmlnaW5hbFxuICBxdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIHF1ZXJ5KVxuICBjb25zdCBoYWRMb2NhbGUgPSBxdWVyeS5fX25leHRMb2NhbGVcbiAgZGVsZXRlIHF1ZXJ5Ll9fbmV4dExvY2FsZVxuICBkZWxldGUgcXVlcnkuX19uZXh0RGVmYXVsdExvY2FsZVxuXG4gIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykpIHtcbiAgICBwYXJzZWREZXN0aW5hdGlvbiA9IHBhcnNlUmVsYXRpdmVVcmwoZGVzdGluYXRpb24pXG4gIH0gZWxzZSB7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aG5hbWUsXG4gICAgICBzZWFyY2hQYXJhbXMsXG4gICAgICBoYXNoLFxuICAgICAgaG9zdG5hbWUsXG4gICAgICBwb3J0LFxuICAgICAgcHJvdG9jb2wsXG4gICAgICBzZWFyY2gsXG4gICAgICBocmVmLFxuICAgIH0gPSBuZXcgVVJMKGRlc3RpbmF0aW9uKVxuXG4gICAgcGFyc2VkRGVzdGluYXRpb24gPSB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIHF1ZXJ5OiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KHNlYXJjaFBhcmFtcyksXG4gICAgICBoYXNoLFxuICAgICAgcHJvdG9jb2wsXG4gICAgICBob3N0bmFtZSxcbiAgICAgIHBvcnQsXG4gICAgICBzZWFyY2gsXG4gICAgICBocmVmLFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGRlc3RRdWVyeSA9IHBhcnNlZERlc3RpbmF0aW9uLnF1ZXJ5XG4gIGNvbnN0IGRlc3RQYXRoID0gYCR7cGFyc2VkRGVzdGluYXRpb24ucGF0aG5hbWUhfSR7XG4gICAgcGFyc2VkRGVzdGluYXRpb24uaGFzaCB8fCAnJ1xuICB9YFxuICBjb25zdCBkZXN0UGF0aFBhcmFtS2V5czogcGF0aFRvUmVnZXhwLktleVtdID0gW11cbiAgcGF0aFRvUmVnZXhwLnBhdGhUb1JlZ2V4cChkZXN0UGF0aCwgZGVzdFBhdGhQYXJhbUtleXMpXG5cbiAgY29uc3QgZGVzdFBhdGhQYXJhbXMgPSBkZXN0UGF0aFBhcmFtS2V5cy5tYXAoKGtleSkgPT4ga2V5Lm5hbWUpXG5cbiAgbGV0IGRlc3RpbmF0aW9uQ29tcGlsZXIgPSBwYXRoVG9SZWdleHAuY29tcGlsZShcbiAgICBkZXN0UGF0aCxcbiAgICAvLyB3ZSBkb24ndCB2YWxpZGF0ZSB3aGlsZSBjb21waWxpbmcgdGhlIGRlc3RpbmF0aW9uIHNpbmNlIHdlIHNob3VsZFxuICAgIC8vIGhhdmUgYWxyZWFkeSB2YWxpZGF0ZWQgYmVmb3JlIHdlIGdvdCB0byB0aGlzIHBvaW50IGFuZCB2YWxpZGF0aW5nXG4gICAgLy8gYnJlYWtzIGNvbXBpbGluZyBkZXN0aW5hdGlvbnMgd2l0aCBuYW1lZCBwYXR0ZXJuIHBhcmFtcyBmcm9tIHRoZSBzb3VyY2VcbiAgICAvLyBlLmcuIC9zb21ldGhpbmc6aGVsbG8oLiopIC0+IC9hbm90aGVyLzpoZWxsbyBpcyBicm9rZW4gd2l0aCB2YWxpZGF0aW9uXG4gICAgLy8gc2luY2UgY29tcGlsZSB2YWxpZGF0aW9uIGlzIG1lYW50IGZvciByZXZlcnNpbmcgYW5kIG5vdCBmb3IgaW5zZXJ0aW5nXG4gICAgLy8gcGFyYW1zIGZyb20gYSBzZXBhcmF0ZSBwYXRoLXJlZ2V4IGludG8gYW5vdGhlclxuICAgIHsgdmFsaWRhdGU6IGZhbHNlIH1cbiAgKVxuICBsZXQgbmV3VXJsXG5cbiAgLy8gdXBkYXRlIGFueSBwYXJhbXMgaW4gcXVlcnkgdmFsdWVzXG4gIGZvciAoY29uc3QgW2tleSwgc3RyT3JBcnJheV0gb2YgT2JqZWN0LmVudHJpZXMoZGVzdFF1ZXJ5KSkge1xuICAgIGxldCB2YWx1ZSA9IEFycmF5LmlzQXJyYXkoc3RyT3JBcnJheSkgPyBzdHJPckFycmF5WzBdIDogc3RyT3JBcnJheVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgLy8gdGhlIHZhbHVlIG5lZWRzIHRvIHN0YXJ0IHdpdGggYSBmb3J3YXJkLXNsYXNoIHRvIGJlIGNvbXBpbGVkXG4gICAgICAvLyBjb3JyZWN0bHlcbiAgICAgIHZhbHVlID0gY29tcGlsZU5vblBhdGgodmFsdWUsIHBhcmFtcylcbiAgICB9XG4gICAgZGVzdFF1ZXJ5W2tleV0gPSB2YWx1ZVxuICB9XG5cbiAgLy8gYWRkIHBhdGggcGFyYW1zIHRvIHF1ZXJ5IGlmIGl0J3Mgbm90IGEgcmVkaXJlY3QgYW5kIG5vdFxuICAvLyBhbHJlYWR5IGRlZmluZWQgaW4gZGVzdGluYXRpb24gcXVlcnkgb3IgcGF0aFxuICBsZXQgcGFyYW1LZXlzID0gT2JqZWN0LmtleXMocGFyYW1zKVxuXG4gIC8vIHJlbW92ZSBpbnRlcm5hbCBwYXJhbSBmb3IgaTE4blxuICBpZiAoaGFkTG9jYWxlKSB7XG4gICAgcGFyYW1LZXlzID0gcGFyYW1LZXlzLmZpbHRlcigobmFtZSkgPT4gbmFtZSAhPT0gJ25leHRJbnRlcm5hbExvY2FsZScpXG4gIH1cblxuICBpZiAoXG4gICAgYXBwZW5kUGFyYW1zVG9RdWVyeSAmJlxuICAgICFwYXJhbUtleXMuc29tZSgoa2V5KSA9PiBkZXN0UGF0aFBhcmFtcy5pbmNsdWRlcyhrZXkpKVxuICApIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBwYXJhbUtleXMpIHtcbiAgICAgIGlmICghKGtleSBpbiBkZXN0UXVlcnkpKSB7XG4gICAgICAgIGRlc3RRdWVyeVtrZXldID0gcGFyYW1zW2tleV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIG5ld1VybCA9IGRlc3RpbmF0aW9uQ29tcGlsZXIocGFyYW1zKVxuXG4gICAgY29uc3QgW3BhdGhuYW1lLCBoYXNoXSA9IG5ld1VybC5zcGxpdCgnIycpXG4gICAgcGFyc2VkRGVzdGluYXRpb24ucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgIHBhcnNlZERlc3RpbmF0aW9uLmhhc2ggPSBgJHtoYXNoID8gJyMnIDogJyd9JHtoYXNoIHx8ICcnfWBcbiAgICBkZWxldGUgKHBhcnNlZERlc3RpbmF0aW9uIGFzIGFueSkuc2VhcmNoXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubWVzc2FnZS5tYXRjaCgvRXhwZWN0ZWQgLio/IHRvIG5vdCByZXBlYXQsIGJ1dCBnb3QgYW4gYXJyYXkvKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVG8gdXNlIGEgbXVsdGktbWF0Y2ggaW4gdGhlIGRlc3RpbmF0aW9uIHlvdSBtdXN0IGFkZCBcXGAqXFxgIGF0IHRoZSBlbmQgb2YgdGhlIHBhcmFtIG5hbWUgdG8gc2lnbmlmeSBpdCBzaG91bGQgcmVwZWF0LiBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9pbnZhbGlkLW11bHRpLW1hdGNoYFxuICAgICAgKVxuICAgIH1cbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIC8vIFF1ZXJ5IG1lcmdlIG9yZGVyIGxvd2VzdCBwcmlvcml0eSB0byBoaWdoZXN0XG4gIC8vIDEuIGluaXRpYWwgVVJMIHF1ZXJ5IHZhbHVlc1xuICAvLyAyLiBwYXRoIHNlZ21lbnQgdmFsdWVzXG4gIC8vIDMuIGRlc3RpbmF0aW9uIHNwZWNpZmllZCBxdWVyeSB2YWx1ZXNcbiAgcGFyc2VkRGVzdGluYXRpb24ucXVlcnkgPSB7XG4gICAgLi4ucXVlcnksXG4gICAgLi4ucGFyc2VkRGVzdGluYXRpb24ucXVlcnksXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5ld1VybCxcbiAgICBwYXJzZWREZXN0aW5hdGlvbixcbiAgfVxufVxuIiwiaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcblxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoXG4gIHNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zXG4pOiBQYXJzZWRVcmxRdWVyeSB7XG4gIGNvbnN0IHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSA9IHt9XG4gIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBxdWVyeVtrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcXVlcnlba2V5XSA9IHZhbHVlXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5W2tleV0pKSB7XG4gICAgICA7KHF1ZXJ5W2tleV0gYXMgc3RyaW5nW10pLnB1c2godmFsdWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXJ5W2tleV0gPSBbcXVlcnlba2V5XSBhcyBzdHJpbmcsIHZhbHVlXVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHF1ZXJ5XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0ocGFyYW06IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmIChcbiAgICB0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnIHx8XG4gICAgKHR5cGVvZiBwYXJhbSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHBhcmFtKSkgfHxcbiAgICB0eXBlb2YgcGFyYW0gPT09ICdib29sZWFuJ1xuICApIHtcbiAgICByZXR1cm4gU3RyaW5nKHBhcmFtKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAnJ1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cmxRdWVyeVRvU2VhcmNoUGFyYW1zKFxuICB1cmxRdWVyeTogUGFyc2VkVXJsUXVlcnlcbik6IFVSTFNlYXJjaFBhcmFtcyB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKVxuICBPYmplY3QuZW50cmllcyh1cmxRdWVyeSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtKSA9PiByZXN1bHQuYXBwZW5kKGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbShpdGVtKSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHZhbHVlKSlcbiAgICB9XG4gIH0pXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihcbiAgdGFyZ2V0OiBVUkxTZWFyY2hQYXJhbXMsXG4gIC4uLnNlYXJjaFBhcmFtc0xpc3Q6IFVSTFNlYXJjaFBhcmFtc1tdXG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICBzZWFyY2hQYXJhbXNMaXN0LmZvckVhY2goKHNlYXJjaFBhcmFtcykgPT4ge1xuICAgIEFycmF5LmZyb20oc2VhcmNoUGFyYW1zLmtleXMoKSkuZm9yRWFjaCgoa2V5KSA9PiB0YXJnZXQuZGVsZXRlKGtleSkpXG4gICAgc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHRhcmdldC5hcHBlbmQoa2V5LCB2YWx1ZSkpXG4gIH0pXG4gIHJldHVybiB0YXJnZXRcbn1cbiIsImltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgcGF0aE1hdGNoIGZyb20gJy4vcGF0aC1tYXRjaCdcbmltcG9ydCBwcmVwYXJlRGVzdGluYXRpb24gZnJvbSAnLi9wcmVwYXJlLWRlc3RpbmF0aW9uJ1xuaW1wb3J0IHsgUmV3cml0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL2xpYi9sb2FkLWN1c3RvbS1yb3V0ZXMnXG5pbXBvcnQgeyByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCB9IGZyb20gJy4uLy4uLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gnXG5pbXBvcnQgeyBub3JtYWxpemVMb2NhbGVQYXRoIH0gZnJvbSAnLi4vLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnXG5cbmNvbnN0IGN1c3RvbVJvdXRlTWF0Y2hlciA9IHBhdGhNYXRjaCh0cnVlKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXNvbHZlUmV3cml0ZXMoXG4gIGFzUGF0aDogc3RyaW5nLFxuICBwYWdlczogc3RyaW5nW10sXG4gIHJld3JpdGVzOiBSZXdyaXRlW10sXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgcmVzb2x2ZUhyZWY6IChwYXRoOiBzdHJpbmcpID0+IHN0cmluZyxcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4pIHtcbiAgaWYgKCFwYWdlcy5pbmNsdWRlcyhub3JtYWxpemVMb2NhbGVQYXRoKGFzUGF0aCwgbG9jYWxlcykucGF0aG5hbWUpKSB7XG4gICAgZm9yIChjb25zdCByZXdyaXRlIG9mIHJld3JpdGVzKSB7XG4gICAgICBjb25zdCBtYXRjaGVyID0gY3VzdG9tUm91dGVNYXRjaGVyKHJld3JpdGUuc291cmNlKVxuICAgICAgY29uc3QgcGFyYW1zID0gbWF0Y2hlcihhc1BhdGgpXG5cbiAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFyZXdyaXRlLmRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBhIHByb3hpZWQgcmV3cml0ZSB3aGljaCBpc24ndCBoYW5kbGVkIG9uIHRoZSBjbGllbnRcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlc3RSZXMgPSBwcmVwYXJlRGVzdGluYXRpb24oXG4gICAgICAgICAgcmV3cml0ZS5kZXN0aW5hdGlvbixcbiAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgcXVlcnksXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApXG4gICAgICAgIGFzUGF0aCA9IGRlc3RSZXMucGFyc2VkRGVzdGluYXRpb24ucGF0aG5hbWUhXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIGRlc3RSZXMucGFyc2VkRGVzdGluYXRpb24ucXVlcnkpXG5cbiAgICAgICAgY29uc3QgZnNQYXRobmFtZSA9IG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gICAgICAgICAgcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goYXNQYXRoKSxcbiAgICAgICAgICBsb2NhbGVzXG4gICAgICAgICkucGF0aG5hbWVcblxuICAgICAgICBpZiAocGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkpIHtcbiAgICAgICAgICBhc1BhdGggPSBmc1BhdGhuYW1lXG4gICAgICAgICAgLy8gY2hlY2sgaWYgd2Ugbm93IG1hdGNoIGEgcGFnZSBhcyB0aGlzIG1lYW5zIHdlIGFyZSBkb25lXG4gICAgICAgICAgLy8gcmVzb2x2aW5nIHRoZSByZXdyaXRlc1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBtYXRjaCBhIGR5bmFtaWMtcm91dGUsIGlmIHNvIHdlIGJyZWFrIHRoZSByZXdyaXRlcyBjaGFpblxuICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSByZXNvbHZlSHJlZihmc1BhdGhuYW1lKVxuXG4gICAgICAgIGlmIChyZXNvbHZlZEhyZWYgIT09IGFzUGF0aCAmJiBwYWdlcy5pbmNsdWRlcyhyZXNvbHZlZEhyZWYpKSB7XG4gICAgICAgICAgYXNQYXRoID0gZnNQYXRobmFtZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFzUGF0aFxufVxuIiwiaW1wb3J0IHsgZ2V0Um91dGVSZWdleCB9IGZyb20gJy4vcm91dGUtcmVnZXgnXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleDogUmV0dXJuVHlwZTx0eXBlb2YgZ2V0Um91dGVSZWdleD4pIHtcbiAgY29uc3QgeyByZSwgZ3JvdXBzIH0gPSByb3V0ZVJlZ2V4XG4gIHJldHVybiAocGF0aG5hbWU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcbiAgICBjb25zdCByb3V0ZU1hdGNoID0gcmUuZXhlYyhwYXRobmFtZSEpXG4gICAgaWYgKCFyb3V0ZU1hdGNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBkZWNvZGUgPSAocGFyYW06IHN0cmluZykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChwYXJhbSlcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgY29uc3QgZXJyOiBFcnJvciAmIHsgY29kZT86IHN0cmluZyB9ID0gbmV3IEVycm9yKFxuICAgICAgICAgICdmYWlsZWQgdG8gZGVjb2RlIHBhcmFtJ1xuICAgICAgICApXG4gICAgICAgIGVyci5jb2RlID0gJ0RFQ09ERV9GQUlMRUQnXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwYXJhbXM6IHsgW3BhcmFtTmFtZTogc3RyaW5nXTogc3RyaW5nIHwgc3RyaW5nW10gfSA9IHt9XG5cbiAgICBPYmplY3Qua2V5cyhncm91cHMpLmZvckVhY2goKHNsdWdOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGcgPSBncm91cHNbc2x1Z05hbWVdXG4gICAgICBjb25zdCBtID0gcm91dGVNYXRjaFtnLnBvc11cbiAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zW3NsdWdOYW1lXSA9IH5tLmluZGV4T2YoJy8nKVxuICAgICAgICAgID8gbS5zcGxpdCgnLycpLm1hcCgoZW50cnkpID0+IGRlY29kZShlbnRyeSkpXG4gICAgICAgICAgOiBnLnJlcGVhdFxuICAgICAgICAgID8gW2RlY29kZShtKV1cbiAgICAgICAgICA6IGRlY29kZShtKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG59XG4iLCJleHBvcnQgaW50ZXJmYWNlIEdyb3VwIHtcbiAgcG9zOiBudW1iZXJcbiAgcmVwZWF0OiBib29sZWFuXG4gIG9wdGlvbmFsOiBib29sZWFuXG59XG5cbi8vIHRoaXMgaXNuJ3QgaW1wb3J0aW5nIHRoZSBlc2NhcGUtc3RyaW5nLXJlZ2V4IG1vZHVsZVxuLy8gdG8gcmVkdWNlIGJ5dGVzXG5mdW5jdGlvbiBlc2NhcGVSZWdleChzdHI6IHN0cmluZykge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uLV0vZywgJ1xcXFwkJicpXG59XG5cbmZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyKHBhcmFtOiBzdHJpbmcpIHtcbiAgY29uc3Qgb3B0aW9uYWwgPSBwYXJhbS5zdGFydHNXaXRoKCdbJykgJiYgcGFyYW0uZW5kc1dpdGgoJ10nKVxuICBpZiAob3B0aW9uYWwpIHtcbiAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDEsIC0xKVxuICB9XG4gIGNvbnN0IHJlcGVhdCA9IHBhcmFtLnN0YXJ0c1dpdGgoJy4uLicpXG4gIGlmIChyZXBlYXQpIHtcbiAgICBwYXJhbSA9IHBhcmFtLnNsaWNlKDMpXG4gIH1cbiAgcmV0dXJuIHsga2V5OiBwYXJhbSwgcmVwZWF0LCBvcHRpb25hbCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3V0ZVJlZ2V4KFxuICBub3JtYWxpemVkUm91dGU6IHN0cmluZ1xuKToge1xuICByZTogUmVnRXhwXG4gIG5hbWVkUmVnZXg/OiBzdHJpbmdcbiAgcm91dGVLZXlzPzogeyBbbmFtZWQ6IHN0cmluZ106IHN0cmluZyB9XG4gIGdyb3VwczogeyBbZ3JvdXBOYW1lOiBzdHJpbmddOiBHcm91cCB9XG59IHtcbiAgY29uc3Qgc2VnbWVudHMgPSAobm9ybWFsaXplZFJvdXRlLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nKVxuICAgIC5zbGljZSgxKVxuICAgIC5zcGxpdCgnLycpXG5cbiAgY29uc3QgZ3JvdXBzOiB7IFtncm91cE5hbWU6IHN0cmluZ106IEdyb3VwIH0gPSB7fVxuICBsZXQgZ3JvdXBJbmRleCA9IDFcbiAgY29uc3QgcGFyYW1ldGVyaXplZFJvdXRlID0gc2VnbWVudHNcbiAgICAubWFwKChzZWdtZW50KSA9PiB7XG4gICAgICBpZiAoc2VnbWVudC5zdGFydHNXaXRoKCdbJykgJiYgc2VnbWVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50LnNsaWNlKDEsIC0xKSlcbiAgICAgICAgZ3JvdXBzW2tleV0gPSB7IHBvczogZ3JvdXBJbmRleCsrLCByZXBlYXQsIG9wdGlvbmFsIH1cbiAgICAgICAgcmV0dXJuIHJlcGVhdCA/IChvcHRpb25hbCA/ICcoPzovKC4rPykpPycgOiAnLyguKz8pJykgOiAnLyhbXi9dKz8pJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAvJHtlc2NhcGVSZWdleChzZWdtZW50KX1gXG4gICAgICB9XG4gICAgfSlcbiAgICAuam9pbignJylcblxuICAvLyBkZWFkIGNvZGUgZWxpbWluYXRlIGZvciBicm93c2VyIHNpbmNlIGl0J3Mgb25seSBuZWVkZWRcbiAgLy8gd2hpbGUgZ2VuZXJhdGluZyByb3V0ZXMtbWFuaWZlc3RcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbGV0IHJvdXRlS2V5Q2hhckNvZGUgPSA5N1xuICAgIGxldCByb3V0ZUtleUNoYXJMZW5ndGggPSAxXG5cbiAgICAvLyBidWlsZHMgYSBtaW5pbWFsIHJvdXRlS2V5IHVzaW5nIG9ubHkgYS16IGFuZCBtaW5pbWFsIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgY29uc3QgZ2V0U2FmZVJvdXRlS2V5ID0gKCkgPT4ge1xuICAgICAgbGV0IHJvdXRlS2V5ID0gJydcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZUtleUNoYXJMZW5ndGg7IGkrKykge1xuICAgICAgICByb3V0ZUtleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHJvdXRlS2V5Q2hhckNvZGUpXG4gICAgICAgIHJvdXRlS2V5Q2hhckNvZGUrK1xuXG4gICAgICAgIGlmIChyb3V0ZUtleUNoYXJDb2RlID4gMTIyKSB7XG4gICAgICAgICAgcm91dGVLZXlDaGFyTGVuZ3RoKytcbiAgICAgICAgICByb3V0ZUtleUNoYXJDb2RlID0gOTdcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJvdXRlS2V5XG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGVLZXlzOiB7IFtuYW1lZDogc3RyaW5nXTogc3RyaW5nIH0gPSB7fVxuXG4gICAgbGV0IG5hbWVkUGFyYW1ldGVyaXplZFJvdXRlID0gc2VnbWVudHNcbiAgICAgIC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICAgICAgaWYgKHNlZ21lbnQuc3RhcnRzV2l0aCgnWycpICYmIHNlZ21lbnQuZW5kc1dpdGgoJ10nKSkge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCBvcHRpb25hbCwgcmVwZWF0IH0gPSBwYXJzZVBhcmFtZXRlcihzZWdtZW50LnNsaWNlKDEsIC0xKSlcbiAgICAgICAgICAvLyByZXBsYWNlIGFueSBub24td29yZCBjaGFyYWN0ZXJzIHNpbmNlIHRoZXkgY2FuIGJyZWFrXG4gICAgICAgICAgLy8gdGhlIG5hbWVkIHJlZ2V4XG4gICAgICAgICAgbGV0IGNsZWFuZWRLZXkgPSBrZXkucmVwbGFjZSgvXFxXL2csICcnKVxuICAgICAgICAgIGxldCBpbnZhbGlkS2V5ID0gZmFsc2VcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBrZXkgaXMgc3RpbGwgaW52YWxpZCBhbmQgZmFsbGJhY2sgdG8gdXNpbmcgYSBrbm93blxuICAgICAgICAgIC8vIHNhZmUga2V5XG4gICAgICAgICAgaWYgKGNsZWFuZWRLZXkubGVuZ3RoID09PSAwIHx8IGNsZWFuZWRLZXkubGVuZ3RoID4gMzApIHtcbiAgICAgICAgICAgIGludmFsaWRLZXkgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VJbnQoY2xlYW5lZEtleS5zdWJzdHIoMCwgMSkpKSkge1xuICAgICAgICAgICAgaW52YWxpZEtleSA9IHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW52YWxpZEtleSkge1xuICAgICAgICAgICAgY2xlYW5lZEtleSA9IGdldFNhZmVSb3V0ZUtleSgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm91dGVLZXlzW2NsZWFuZWRLZXldID0ga2V5XG4gICAgICAgICAgcmV0dXJuIHJlcGVhdFxuICAgICAgICAgICAgPyBvcHRpb25hbFxuICAgICAgICAgICAgICA/IGAoPzovKD88JHtjbGVhbmVkS2V5fT4uKz8pKT9gXG4gICAgICAgICAgICAgIDogYC8oPzwke2NsZWFuZWRLZXl9Pi4rPylgXG4gICAgICAgICAgICA6IGAvKD88JHtjbGVhbmVkS2V5fT5bXi9dKz8pYFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBgLyR7ZXNjYXBlUmVnZXgoc2VnbWVudCl9YFxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmpvaW4oJycpXG5cbiAgICByZXR1cm4ge1xuICAgICAgcmU6IG5ldyBSZWdFeHAoYF4ke3BhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCksXG4gICAgICBncm91cHMsXG4gICAgICByb3V0ZUtleXMsXG4gICAgICBuYW1lZFJlZ2V4OiBgXiR7bmFtZWRQYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGAsXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZTogbmV3IFJlZ0V4cChgXiR7cGFyYW1ldGVyaXplZFJvdXRlfSg/Oi8pPyRgKSxcbiAgICBncm91cHMsXG4gIH1cbn1cbiIsImxldCBydW50aW1lQ29uZmlnOiBhbnlcblxuZXhwb3J0IGRlZmF1bHQgKCkgPT4ge1xuICByZXR1cm4gcnVudGltZUNvbmZpZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0Q29uZmlnKGNvbmZpZ1ZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgcnVudGltZUNvbmZpZyA9IGNvbmZpZ1ZhbHVlXG59XG4iLCJpbXBvcnQgeyBJbmNvbWluZ01lc3NhZ2UsIFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnaHR0cCdcbmltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBDb21wb25lbnRUeXBlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgeyBmb3JtYXRVcmwgfSBmcm9tICcuL3JvdXRlci91dGlscy9mb3JtYXQtdXJsJ1xuaW1wb3J0IHsgTWFuaWZlc3RJdGVtIH0gZnJvbSAnLi4vc2VydmVyL2xvYWQtY29tcG9uZW50cydcbmltcG9ydCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgeyBFbnYgfSBmcm9tICdAbmV4dC9lbnYnXG5pbXBvcnQgeyBCdWlsZE1hbmlmZXN0IH0gZnJvbSAnLi4vc2VydmVyL2dldC1wYWdlLWZpbGVzJ1xuaW1wb3J0IHsgRG9tYWluTG9jYWxlcyB9IGZyb20gJy4uL3NlcnZlci9jb25maWcnXG5cbi8qKlxuICogVHlwZXMgdXNlZCBieSBib3RoIG5leHQgYW5kIG5leHQtc2VydmVyXG4gKi9cblxuZXhwb3J0IHR5cGUgTmV4dENvbXBvbmVudFR5cGU8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCA9IE5leHRQYWdlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9XG4+ID0gQ29tcG9uZW50VHlwZTxQPiAmIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGluaXRpYWwgcGFnZSBsb2FkIGRhdGEgcG9wdWxhdGlvbi4gRGF0YSByZXR1cm5lZCBmcm9tIGBnZXRJbml0aWFsUHJvcHNgIGlzIHNlcmlhbGl6ZWQgd2hlbiBzZXJ2ZXIgcmVuZGVyZWQuXG4gICAqIE1ha2Ugc3VyZSB0byByZXR1cm4gcGxhaW4gYE9iamVjdGAgd2l0aG91dCB1c2luZyBgRGF0ZWAsIGBNYXBgLCBgU2V0YC5cbiAgICogQHBhcmFtIGN0eCBDb250ZXh0IG9mIGBwYWdlYFxuICAgKi9cbiAgZ2V0SW5pdGlhbFByb3BzPyhjb250ZXh0OiBDKTogSVAgfCBQcm9taXNlPElQPlxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgRG9jdW1lbnRDb250ZXh0LFxuICBEb2N1bWVudEluaXRpYWxQcm9wcyxcbiAgRG9jdW1lbnRQcm9wc1xuPiAmIHtcbiAgcmVuZGVyRG9jdW1lbnQoXG4gICAgRG9jdW1lbnQ6IERvY3VtZW50VHlwZSxcbiAgICBwcm9wczogRG9jdW1lbnRQcm9wc1xuICApOiBSZWFjdC5SZWFjdEVsZW1lbnRcbn1cblxuZXhwb3J0IHR5cGUgQXBwVHlwZSA9IE5leHRDb21wb25lbnRUeXBlPFxuICBBcHBDb250ZXh0VHlwZSxcbiAgQXBwSW5pdGlhbFByb3BzLFxuICBBcHBQcm9wc1R5cGVcbj5cblxuZXhwb3J0IHR5cGUgQXBwVHJlZVR5cGUgPSBDb21wb25lbnRUeXBlPFxuICBBcHBJbml0aWFsUHJvcHMgJiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfVxuPlxuXG4vKipcbiAqIFdlYiB2aXRhbHMgcHJvdmlkZWQgdG8gX2FwcC5yZXBvcnRXZWJWaXRhbHMgYnkgQ29yZSBXZWIgVml0YWxzIHBsdWdpbiBkZXZlbG9wZWQgYnkgR29vZ2xlIENocm9tZSB0ZWFtLlxuICogaHR0cHM6Ly9uZXh0anMub3JnL2Jsb2cvbmV4dC05LTQjaW50ZWdyYXRlZC13ZWItdml0YWxzLXJlcG9ydGluZ1xuICovXG5leHBvcnQgdHlwZSBOZXh0V2ViVml0YWxzTWV0cmljID0ge1xuICBpZDogc3RyaW5nXG4gIGxhYmVsOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4gIHZhbHVlOiBudW1iZXJcbn1cblxuZXhwb3J0IHR5cGUgRW5oYW5jZXI8Qz4gPSAoQ29tcG9uZW50OiBDKSA9PiBDXG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudHNFbmhhbmNlciA9XG4gIHwge1xuICAgICAgZW5oYW5jZUFwcD86IEVuaGFuY2VyPEFwcFR5cGU+XG4gICAgICBlbmhhbmNlQ29tcG9uZW50PzogRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG4gICAgfVxuICB8IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlUmVzdWx0ID0ge1xuICBodG1sOiBzdHJpbmdcbiAgaGVhZD86IEFycmF5PEpTWC5FbGVtZW50IHwgbnVsbD5cbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZSA9IChcbiAgb3B0aW9ucz86IENvbXBvbmVudHNFbmhhbmNlclxuKSA9PiBSZW5kZXJQYWdlUmVzdWx0IHwgUHJvbWlzZTxSZW5kZXJQYWdlUmVzdWx0PlxuXG5leHBvcnQgdHlwZSBCYXNlQ29udGV4dCA9IHtcbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgW2s6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQgdHlwZSBORVhUX0RBVEEgPSB7XG4gIHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIHBhZ2U6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYnVpbGRJZDogc3RyaW5nXG4gIGFzc2V0UHJlZml4Pzogc3RyaW5nXG4gIHJ1bnRpbWVDb25maWc/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9XG4gIG5leHRFeHBvcnQ/OiBib29sZWFuXG4gIGF1dG9FeHBvcnQ/OiBib29sZWFuXG4gIGlzRmFsbGJhY2s/OiBib29sZWFuXG4gIGR5bmFtaWNJZHM/OiBzdHJpbmdbXVxuICBlcnI/OiBFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9XG4gIGdzcD86IGJvb2xlYW5cbiAgZ3NzcD86IGJvb2xlYW5cbiAgY3VzdG9tU2VydmVyPzogYm9vbGVhblxuICBnaXA/OiBib29sZWFuXG4gIGFwcEdpcD86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gIGRvbWFpbkxvY2FsZXM/OiBEb21haW5Mb2NhbGVzXG59XG5cbi8qKlxuICogYE5leHRgIGNvbnRleHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0UGFnZUNvbnRleHQge1xuICAvKipcbiAgICogRXJyb3Igb2JqZWN0IGlmIGVuY291bnRlcmVkIGR1cmluZyByZW5kZXJpbmdcbiAgICovXG4gIGVycj86IChFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9KSB8IG51bGxcbiAgLyoqXG4gICAqIGBIVFRQYCByZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIHJlcT86IEluY29taW5nTWVzc2FnZVxuICAvKipcbiAgICogYEhUVFBgIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIC8qKlxuICAgKiBQYXRoIHNlY3Rpb24gb2YgYFVSTGAuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nXG4gIC8qKlxuICAgKiBRdWVyeSBzdHJpbmcgc2VjdGlvbiBvZiBgVVJMYCBwYXJzZWQgYXMgYW4gb2JqZWN0LlxuICAgKi9cbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIC8qKlxuICAgKiBgU3RyaW5nYCBvZiB0aGUgYWN0dWFsIHBhdGggaW5jbHVkaW5nIHF1ZXJ5LlxuICAgKi9cbiAgYXNQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBgQ29tcG9uZW50YCB0aGUgdHJlZSBvZiB0aGUgQXBwIHRvIHVzZSBpZiBuZWVkaW5nIHRvIHJlbmRlciBzZXBhcmF0ZWx5XG4gICAqL1xuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxufVxuXG5leHBvcnQgdHlwZSBBcHBDb250ZXh0VHlwZTxSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXI+ID0ge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dD5cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbiAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgcm91dGVyOiBSXG59XG5cbmV4cG9ydCB0eXBlIEFwcEluaXRpYWxQcm9wcyA9IHtcbiAgcGFnZVByb3BzOiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgQXBwUHJvcHNUeXBlPFxuICBSIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXIsXG4gIFAgPSB7fVxuPiA9IEFwcEluaXRpYWxQcm9wcyAmIHtcbiAgQ29tcG9uZW50OiBOZXh0Q29tcG9uZW50VHlwZTxOZXh0UGFnZUNvbnRleHQsIGFueSwgUD5cbiAgcm91dGVyOiBSXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50Q29udGV4dCA9IE5leHRQYWdlQ29udGV4dCAmIHtcbiAgcmVuZGVyUGFnZTogUmVuZGVyUGFnZVxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudEluaXRpYWxQcm9wcyA9IFJlbmRlclBhZ2VSZXN1bHQgJiB7XG4gIHN0eWxlcz86IFJlYWN0LlJlYWN0RWxlbWVudFtdIHwgUmVhY3QuUmVhY3RGcmFnbWVudFxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFByb3BzID0gRG9jdW1lbnRJbml0aWFsUHJvcHMgJiB7XG4gIF9fTkVYVF9EQVRBX186IE5FWFRfREFUQVxuICBkYW5nZXJvdXNBc1BhdGg6IHN0cmluZ1xuICBkb2NDb21wb25lbnRzUmVuZGVyZWQ6IHtcbiAgICBIdG1sPzogYm9vbGVhblxuICAgIE1haW4/OiBib29sZWFuXG4gICAgSGVhZD86IGJvb2xlYW5cbiAgICBOZXh0U2NyaXB0PzogYm9vbGVhblxuICB9XG4gIGJ1aWxkTWFuaWZlc3Q6IEJ1aWxkTWFuaWZlc3RcbiAgYW1wUGF0aDogc3RyaW5nXG4gIGluQW1wTW9kZTogYm9vbGVhblxuICBoeWJyaWRBbXA6IGJvb2xlYW5cbiAgaXNEZXZlbG9wbWVudDogYm9vbGVhblxuICBkeW5hbWljSW1wb3J0czogTWFuaWZlc3RJdGVtW11cbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgY2Fub25pY2FsQmFzZTogc3RyaW5nXG4gIGhlYWRUYWdzOiBhbnlbXVxuICB1bnN0YWJsZV9ydW50aW1lSlM/OiBmYWxzZVxuICBkZXZPbmx5Q2FjaGVCdXN0ZXJRdWVyeVN0cmluZzogc3RyaW5nXG4gIHNjcmlwdExvYWRlcjogeyBkZWZlcj86IHN0cmluZ1tdOyBlYWdlcj86IGFueVtdIH1cbiAgbG9jYWxlPzogc3RyaW5nXG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dEFwaVJlcXVlc3QgZXh0ZW5kcyBJbmNvbWluZ01lc3NhZ2Uge1xuICAvKipcbiAgICogT2JqZWN0IG9mIGBxdWVyeWAgdmFsdWVzIGZyb20gdXJsXG4gICAqL1xuICBxdWVyeToge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdXG4gIH1cbiAgLyoqXG4gICAqIE9iamVjdCBvZiBgY29va2llc2AgZnJvbSBoZWFkZXJcbiAgICovXG4gIGNvb2tpZXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuXG4gIGJvZHk6IGFueVxuXG4gIGVudjogRW52XG5cbiAgcHJldmlldz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFByZXZpZXcgZGF0YSBzZXQgb24gdGhlIHJlcXVlc3QsIGlmIGFueVxuICAgKiAqL1xuICBwcmV2aWV3RGF0YT86IGFueVxufVxuXG4vKipcbiAqIFNlbmQgYm9keSBvZiByZXNwb25zZVxuICovXG50eXBlIFNlbmQ8VD4gPSAoYm9keTogVCkgPT4gdm9pZFxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgcmVzcG9uc2VcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dEFwaVJlc3BvbnNlPFQgPSBhbnk+ID0gU2VydmVyUmVzcG9uc2UgJiB7XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGFueWAgZGF0YSBpbiByZXNwb25zZVxuICAgKi9cbiAgc2VuZDogU2VuZDxUPlxuICAvKipcbiAgICogU2VuZCBkYXRhIGBqc29uYCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBqc29uOiBTZW5kPFQ+XG4gIHN0YXR1czogKHN0YXR1c0NvZGU6IG51bWJlcikgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG4gIHJlZGlyZWN0KHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPFQ+XG4gIHJlZGlyZWN0KHN0YXR1czogbnVtYmVyLCB1cmw6IHN0cmluZyk6IE5leHRBcGlSZXNwb25zZTxUPlxuXG4gIC8qKlxuICAgKiBTZXQgcHJldmlldyBkYXRhIGZvciBOZXh0LmpzJyBwcmVyZW5kZXIgbW9kZVxuICAgKi9cbiAgc2V0UHJldmlld0RhdGE6IChcbiAgICBkYXRhOiBvYmplY3QgfCBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHRoZSBudW1iZXIgKGluIHNlY29uZHMpIGZvciB0aGUgcHJldmlldyBzZXNzaW9uIHRvIGxhc3QgZm9yLlxuICAgICAgICogVGhlIGdpdmVuIG51bWJlciB3aWxsIGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyIGJ5IHJvdW5kaW5nIGRvd24uXG4gICAgICAgKiBCeSBkZWZhdWx0LCBubyBtYXhpbXVtIGFnZSBpcyBzZXQgYW5kIHRoZSBwcmV2aWV3IHNlc3Npb24gZmluaXNoZXNcbiAgICAgICAqIHdoZW4gdGhlIGNsaWVudCBzaHV0cyBkb3duIChicm93c2VyIGlzIGNsb3NlZCkuXG4gICAgICAgKi9cbiAgICAgIG1heEFnZT86IG51bWJlclxuICAgIH1cbiAgKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbiAgY2xlYXJQcmV2aWV3RGF0YTogKCkgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSBoYW5kbGVyXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlIYW5kbGVyPFQgPSBhbnk+ID0gKFxuICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICByZXM6IE5leHRBcGlSZXNwb25zZTxUPlxuKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPlxuXG4vKipcbiAqIFV0aWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjT25jZTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBSZXR1cm5UeXBlPFQ+PihcbiAgZm46IFRcbik6IFQge1xuICBsZXQgdXNlZCA9IGZhbHNlXG4gIGxldCByZXN1bHQ6IFJldHVyblR5cGU8VD5cblxuICByZXR1cm4gKCguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGlmICghdXNlZCkge1xuICAgICAgdXNlZCA9IHRydWVcbiAgICAgIHJlc3VsdCA9IGZuKC4uLmFyZ3MpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSkgYXMgVFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYXRpb25PcmlnaW4oKSB7XG4gIGNvbnN0IHsgcHJvdG9jb2wsIGhvc3RuYW1lLCBwb3J0IH0gPSB3aW5kb3cubG9jYXRpb25cbiAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0bmFtZX0ke3BvcnQgPyAnOicgKyBwb3J0IDogJyd9YFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VVJMKCkge1xuICBjb25zdCB7IGhyZWYgfSA9IHdpbmRvdy5sb2NhdGlvblxuICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gIHJldHVybiBocmVmLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWU8UD4oQ29tcG9uZW50OiBDb21wb25lbnRUeXBlPFA+KSB7XG4gIHJldHVybiB0eXBlb2YgQ29tcG9uZW50ID09PSAnc3RyaW5nJ1xuICAgID8gQ29tcG9uZW50XG4gICAgOiBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Jlc1NlbnQocmVzOiBTZXJ2ZXJSZXNwb25zZSkge1xuICByZXR1cm4gcmVzLmZpbmlzaGVkIHx8IHJlcy5oZWFkZXJzU2VudFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEdldEluaXRpYWxQcm9wczxcbiAgQyBleHRlbmRzIEJhc2VDb250ZXh0LFxuICBJUCA9IHt9LFxuICBQID0ge31cbj4oQXBwOiBOZXh0Q29tcG9uZW50VHlwZTxDLCBJUCwgUD4sIGN0eDogQyk6IFByb21pc2U8SVA+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoQXBwLnByb3RvdHlwZT8uZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgQXBwXG4gICAgICApfS5nZXRJbml0aWFsUHJvcHMoKVwiIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIC0gdmlzaXQgaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvZ2V0LWluaXRpYWwtcHJvcHMtYXMtYW4taW5zdGFuY2UtbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLmBcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIH1cbiAgfVxuICAvLyB3aGVuIGNhbGxlZCBmcm9tIF9hcHAgYGN0eGAgaXMgbmVzdGVkIGluIGBjdHhgXG4gIGNvbnN0IHJlcyA9IGN0eC5yZXMgfHwgKGN0eC5jdHggJiYgY3R4LmN0eC5yZXMpXG5cbiAgaWYgKCFBcHAuZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgaWYgKGN0eC5jdHggJiYgY3R4LkNvbXBvbmVudCkge1xuICAgICAgLy8gQHRzLWlnbm9yZSBwYWdlUHJvcHMgZGVmYXVsdFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZVByb3BzOiBhd2FpdCBsb2FkR2V0SW5pdGlhbFByb3BzKGN0eC5Db21wb25lbnQsIGN0eC5jdHgpLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge30gYXMgSVBcbiAgfVxuXG4gIGNvbnN0IHByb3BzID0gYXdhaXQgQXBwLmdldEluaXRpYWxQcm9wcyhjdHgpXG5cbiAgaWYgKHJlcyAmJiBpc1Jlc1NlbnQocmVzKSkge1xuICAgIHJldHVybiBwcm9wc1xuICB9XG5cbiAgaWYgKCFwcm9wcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKFxuICAgICAgQXBwXG4gICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIiR7cHJvcHN9XCIgaW5zdGVhZC5gXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID09PSAwICYmICFjdHguY3R4KSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGAke2dldERpc3BsYXlOYW1lKFxuICAgICAgICAgIEFwcFxuICAgICAgICApfSByZXR1cm5lZCBhbiBlbXB0eSBvYmplY3QgZnJvbSBcXGBnZXRJbml0aWFsUHJvcHNcXGAuIFRoaXMgZGUtb3B0aW1pemVzIGFuZCBwcmV2ZW50cyBhdXRvbWF0aWMgc3RhdGljIG9wdGltaXphdGlvbi4gaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvZW1wdHktb2JqZWN0LWdldEluaXRpYWxQcm9wc2BcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvcHNcbn1cblxuZXhwb3J0IGNvbnN0IHVybE9iamVjdEtleXMgPSBbXG4gICdhdXRoJyxcbiAgJ2hhc2gnLFxuICAnaG9zdCcsXG4gICdob3N0bmFtZScsXG4gICdocmVmJyxcbiAgJ3BhdGgnLFxuICAncGF0aG5hbWUnLFxuICAncG9ydCcsXG4gICdwcm90b2NvbCcsXG4gICdxdWVyeScsXG4gICdzZWFyY2gnLFxuICAnc2xhc2hlcycsXG5dXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmw6IFVybE9iamVjdCk6IHN0cmluZyB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGlmICh1cmwgIT09IG51bGwgJiYgdHlwZW9mIHVybCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKHVybCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmICh1cmxPYmplY3RLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgVW5rbm93biBrZXkgcGFzc2VkIHZpYSB1cmxPYmplY3QgaW50byB1cmwuZm9ybWF0OiAke2tleX1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3JtYXRVcmwodXJsKVxufVxuXG5leHBvcnQgY29uc3QgU1AgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnXG5leHBvcnQgY29uc3QgU1QgPVxuICBTUCAmJlxuICB0eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJ1xuIiwiXCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0cy5ub3JtYWxpemVQYXRoU2VwPW5vcm1hbGl6ZVBhdGhTZXA7ZXhwb3J0cy5kZW5vcm1hbGl6ZVBhZ2VQYXRoPWRlbm9ybWFsaXplUGFnZVBhdGg7ZnVuY3Rpb24gbm9ybWFsaXplUGF0aFNlcChwYXRoKXtyZXR1cm4gcGF0aC5yZXBsYWNlKC9cXFxcL2csJy8nKTt9ZnVuY3Rpb24gZGVub3JtYWxpemVQYWdlUGF0aChwYWdlKXtwYWdlPW5vcm1hbGl6ZVBhdGhTZXAocGFnZSk7aWYocGFnZS5zdGFydHNXaXRoKCcvaW5kZXgvJykpe3BhZ2U9cGFnZS5zbGljZSg2KTt9ZWxzZSBpZihwYWdlPT09Jy9pbmRleCcpe3BhZ2U9Jy8nO31yZXR1cm4gcGFnZTt9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZW5vcm1hbGl6ZS1wYWdlLXBhdGguanMubWFwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L3JvdXRlcicpXG4iLCIvKiFcbiAqIFBsYXRmb3JtLmpzIHYxLjMuNlxuICogQ29weXJpZ2h0IDIwMTQtMjAyMCBCZW5qYW1pbiBUYW5cbiAqIENvcHlyaWdodCAyMDExLTIwMTMgSm9obi1EYXZpZCBEYWx0b25cbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZVxuICovXG47KGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgYE9iamVjdGAuICovXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnZnVuY3Rpb24nOiB0cnVlLFxuICAgICdvYmplY3QnOiB0cnVlXG4gIH07XG5cbiAgLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG4gIHZhciByb290ID0gKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdykgfHwgdGhpcztcblxuICAvKiogQmFja3VwIHBvc3NpYmxlIGdsb2JhbCBvYmplY3QuICovXG4gIHZhciBvbGRSb290ID0gcm9vdDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG4gIHZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUgYW5kIHVzZSBpdCBhcyBgcm9vdGAuICovXG4gIHZhciBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGFzIHRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhbiBhcnJheS1saWtlIG9iamVjdC5cbiAgICogU2VlIHRoZSBbRVM2IHNwZWNdKGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoKVxuICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKi9cbiAgdmFyIG1heFNhZmVJbnRlZ2VyID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcblxuICAvKiogUmVndWxhciBleHByZXNzaW9uIHRvIGRldGVjdCBPcGVyYS4gKi9cbiAgdmFyIHJlT3BlcmEgPSAvXFxiT3BlcmEvO1xuXG4gIC8qKiBQb3NzaWJsZSBnbG9iYWwgb2JqZWN0LiAqL1xuICB2YXIgdGhpc0JpbmRpbmcgPSB0aGlzO1xuXG4gIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG4gIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgLyoqIFVzZWQgdG8gY2hlY2sgZm9yIG93biBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdC4gKi9cbiAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgaW50ZXJuYWwgYFtbQ2xhc3NdXWAgb2YgdmFsdWVzLiAqL1xuICB2YXIgdG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ2FwaXRhbGl6ZXMgYSBzdHJpbmcgdmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICBzdHJpbmcgPSBTdHJpbmcoc3RyaW5nKTtcbiAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0byBjbGVhbiB1cCB0aGUgT1MgbmFtZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9zIFRoZSBPUyBuYW1lIHRvIGNsZWFuIHVwLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhdHRlcm5dIEEgYFJlZ0V4cGAgcGF0dGVybiBtYXRjaGluZyB0aGUgT1MgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsYWJlbF0gQSBsYWJlbCBmb3IgdGhlIE9TLlxuICAgKi9cbiAgZnVuY3Rpb24gY2xlYW51cE9TKG9zLCBwYXR0ZXJuLCBsYWJlbCkge1xuICAgIC8vIFBsYXRmb3JtIHRva2VucyBhcmUgZGVmaW5lZCBhdDpcbiAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1Mzc1MDMoVlMuODUpLmFzcHhcbiAgICAvLyBodHRwOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDA4MTEyMjA1Mzk1MC9odHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1Mzc1MDMoVlMuODUpLmFzcHhcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICcxMC4wJzogJzEwJyxcbiAgICAgICc2LjQnOiAgJzEwIFRlY2huaWNhbCBQcmV2aWV3JyxcbiAgICAgICc2LjMnOiAgJzguMScsXG4gICAgICAnNi4yJzogICc4JyxcbiAgICAgICc2LjEnOiAgJ1NlcnZlciAyMDA4IFIyIC8gNycsXG4gICAgICAnNi4wJzogICdTZXJ2ZXIgMjAwOCAvIFZpc3RhJyxcbiAgICAgICc1LjInOiAgJ1NlcnZlciAyMDAzIC8gWFAgNjQtYml0JyxcbiAgICAgICc1LjEnOiAgJ1hQJyxcbiAgICAgICc1LjAxJzogJzIwMDAgU1AxJyxcbiAgICAgICc1LjAnOiAgJzIwMDAnLFxuICAgICAgJzQuMCc6ICAnTlQnLFxuICAgICAgJzQuOTAnOiAnTUUnXG4gICAgfTtcbiAgICAvLyBEZXRlY3QgV2luZG93cyB2ZXJzaW9uIGZyb20gcGxhdGZvcm0gdG9rZW5zLlxuICAgIGlmIChwYXR0ZXJuICYmIGxhYmVsICYmIC9eV2luL2kudGVzdChvcykgJiYgIS9eV2luZG93cyBQaG9uZSAvaS50ZXN0KG9zKSAmJlxuICAgICAgICAoZGF0YSA9IGRhdGFbL1tcXGQuXSskLy5leGVjKG9zKV0pKSB7XG4gICAgICBvcyA9ICdXaW5kb3dzICcgKyBkYXRhO1xuICAgIH1cbiAgICAvLyBDb3JyZWN0IGNoYXJhY3RlciBjYXNlIGFuZCBjbGVhbnVwIHN0cmluZy5cbiAgICBvcyA9IFN0cmluZyhvcyk7XG5cbiAgICBpZiAocGF0dGVybiAmJiBsYWJlbCkge1xuICAgICAgb3MgPSBvcy5yZXBsYWNlKFJlZ0V4cChwYXR0ZXJuLCAnaScpLCBsYWJlbCk7XG4gICAgfVxuXG4gICAgb3MgPSBmb3JtYXQoXG4gICAgICBvcy5yZXBsYWNlKC8gY2UkL2ksICcgQ0UnKVxuICAgICAgICAucmVwbGFjZSgvXFxiaHB3L2ksICd3ZWInKVxuICAgICAgICAucmVwbGFjZSgvXFxiTWFjaW50b3NoXFxiLywgJ01hYyBPUycpXG4gICAgICAgIC5yZXBsYWNlKC9fUG93ZXJQQ1xcYi9pLCAnIE9TJylcbiAgICAgICAgLnJlcGxhY2UoL1xcYihPUyBYKSBbXiBcXGRdKy9pLCAnJDEnKVxuICAgICAgICAucmVwbGFjZSgvXFxiTWFjIChPUyBYKVxcYi8sICckMScpXG4gICAgICAgIC5yZXBsYWNlKC9cXC8oXFxkKS8sICcgJDEnKVxuICAgICAgICAucmVwbGFjZSgvXy9nLCAnLicpXG4gICAgICAgIC5yZXBsYWNlKC8oPzogQmVQQ3xbIC5dKmZjWyBcXGQuXSspJC9pLCAnJylcbiAgICAgICAgLnJlcGxhY2UoL1xcYng4NlxcLjY0XFxiL2dpLCAneDg2XzY0JylcbiAgICAgICAgLnJlcGxhY2UoL1xcYihXaW5kb3dzIFBob25lKSBPU1xcYi8sICckMScpXG4gICAgICAgIC5yZXBsYWNlKC9cXGIoQ2hyb21lIE9TIFxcdyspIFtcXGQuXStcXGIvLCAnJDEnKVxuICAgICAgICAuc3BsaXQoJyBvbiAnKVswXVxuICAgICk7XG5cbiAgICByZXR1cm4gb3M7XG4gIH1cblxuICAvKipcbiAgICogQW4gaXRlcmF0aW9uIHV0aWxpdHkgZm9yIGFycmF5cyBhbmQgb2JqZWN0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gZWFjaChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG9iamVjdCA/IG9iamVjdC5sZW5ndGggOiAwO1xuXG4gICAgaWYgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID4gLTEgJiYgbGVuZ3RoIDw9IG1heFNhZmVJbnRlZ2VyKSB7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBjYWxsYmFjayhvYmplY3RbaW5kZXhdLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yT3duKG9iamVjdCwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmltIGFuZCBjb25kaXRpb25hbGx5IGNhcGl0YWxpemUgc3RyaW5nIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGZvcm1hdC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBmb3JtYXQoc3RyaW5nKSB7XG4gICAgc3RyaW5nID0gdHJpbShzdHJpbmcpO1xuICAgIHJldHVybiAvXig/OndlYk9TfGkoPzpPU3xQKSkvLnRlc3Qoc3RyaW5nKVxuICAgICAgPyBzdHJpbmdcbiAgICAgIDogY2FwaXRhbGl6ZShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMsIGV4ZWN1dGluZyB0aGUgYGNhbGxiYWNrYCBmb3IgZWFjaC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGV4ZWN1dGVkIHBlciBvd24gcHJvcGVydHkuXG4gICAqL1xuICBmdW5jdGlvbiBmb3JPd24ob2JqZWN0LCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICBjYWxsYmFjayhvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbnRlcm5hbCBgW1tDbGFzc11dYCBvZiBhIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGBbW0NsYXNzXV1gLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NPZih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsXG4gICAgICA/IGNhcGl0YWxpemUodmFsdWUpXG4gICAgICA6IHRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIb3N0IG9iamVjdHMgY2FuIHJldHVybiB0eXBlIHZhbHVlcyB0aGF0IGFyZSBkaWZmZXJlbnQgZnJvbSB0aGVpciBhY3R1YWxcbiAgICogZGF0YSB0eXBlLiBUaGUgb2JqZWN0cyB3ZSBhcmUgY29uY2VybmVkIHdpdGggdXN1YWxseSByZXR1cm4gbm9uLXByaW1pdGl2ZVxuICAgKiB0eXBlcyBvZiBcIm9iamVjdFwiLCBcImZ1bmN0aW9uXCIsIG9yIFwidW5rbm93blwiLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb3duZXIgb2YgdGhlIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IHZhbHVlIGlzIGEgbm9uLXByaW1pdGl2ZSwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNIb3N0VHlwZShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgdmFyIHR5cGUgPSBvYmplY3QgIT0gbnVsbCA/IHR5cGVvZiBvYmplY3RbcHJvcGVydHldIDogJ251bWJlcic7XG4gICAgcmV0dXJuICEvXig/OmJvb2xlYW58bnVtYmVyfHN0cmluZ3x1bmRlZmluZWQpJC8udGVzdCh0eXBlKSAmJlxuICAgICAgKHR5cGUgPT0gJ29iamVjdCcgPyAhIW9iamVjdFtwcm9wZXJ0eV0gOiB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlcyBhIHN0cmluZyBmb3IgdXNlIGluIGEgYFJlZ0V4cGAgYnkgbWFraW5nIGh5cGhlbnMgYW5kIHNwYWNlcyBvcHRpb25hbC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHF1YWxpZnkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBxdWFsaWZpZWQgc3RyaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gcXVhbGlmeShzdHJpbmcpIHtcbiAgICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZSgvKFsgLV0pKD8hJCkvZywgJyQxPycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgYmFyZS1ib25lcyBgQXJyYXkjcmVkdWNlYCBsaWtlIHV0aWxpdHkgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMgeyp9IFRoZSBhY2N1bXVsYXRlZCByZXN1bHQuXG4gICAqL1xuICBmdW5jdGlvbiByZWR1Y2UoYXJyYXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFjY3VtdWxhdG9yID0gbnVsbDtcbiAgICBlYWNoKGFycmF5LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgYXJyYXkpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UgZnJvbSBhIHN0cmluZy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0cmltbWVkIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHRyaW0oc3RyaW5nKSB7XG4gICAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UoL14gK3wgKyQvZywgJycpO1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcGxhdGZvcm0gb2JqZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbdWE9bmF2aWdhdG9yLnVzZXJBZ2VudF0gVGhlIHVzZXIgYWdlbnQgc3RyaW5nIG9yXG4gICAqICBjb250ZXh0IG9iamVjdC5cbiAgICogQHJldHVybnMge09iamVjdH0gQSBwbGF0Zm9ybSBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZSh1YSkge1xuXG4gICAgLyoqIFRoZSBlbnZpcm9ubWVudCBjb250ZXh0IG9iamVjdC4gKi9cbiAgICB2YXIgY29udGV4dCA9IHJvb3Q7XG5cbiAgICAvKiogVXNlZCB0byBmbGFnIHdoZW4gYSBjdXN0b20gY29udGV4dCBpcyBwcm92aWRlZC4gKi9cbiAgICB2YXIgaXNDdXN0b21Db250ZXh0ID0gdWEgJiYgdHlwZW9mIHVhID09ICdvYmplY3QnICYmIGdldENsYXNzT2YodWEpICE9ICdTdHJpbmcnO1xuXG4gICAgLy8gSnVnZ2xlIGFyZ3VtZW50cy5cbiAgICBpZiAoaXNDdXN0b21Db250ZXh0KSB7XG4gICAgICBjb250ZXh0ID0gdWE7XG4gICAgICB1YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqIEJyb3dzZXIgbmF2aWdhdG9yIG9iamVjdC4gKi9cbiAgICB2YXIgbmF2ID0gY29udGV4dC5uYXZpZ2F0b3IgfHwge307XG5cbiAgICAvKiogQnJvd3NlciB1c2VyIGFnZW50IHN0cmluZy4gKi9cbiAgICB2YXIgdXNlckFnZW50ID0gbmF2LnVzZXJBZ2VudCB8fCAnJztcblxuICAgIHVhIHx8ICh1YSA9IHVzZXJBZ2VudCk7XG5cbiAgICAvKiogVXNlZCB0byBmbGFnIHdoZW4gYHRoaXNCaW5kaW5nYCBpcyB0aGUgW01vZHVsZVNjb3BlXS4gKi9cbiAgICB2YXIgaXNNb2R1bGVTY29wZSA9IGlzQ3VzdG9tQ29udGV4dCB8fCB0aGlzQmluZGluZyA9PSBvbGRSb290O1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGJyb3dzZXIgaXMgbGlrZSBDaHJvbWUuICovXG4gICAgdmFyIGxpa2VDaHJvbWUgPSBpc0N1c3RvbUNvbnRleHRcbiAgICAgID8gISFuYXYubGlrZUNocm9tZVxuICAgICAgOiAvXFxiQ2hyb21lXFxiLy50ZXN0KHVhKSAmJiAhL2ludGVybmFsfFxcbi9pLnRlc3QodG9TdHJpbmcudG9TdHJpbmcoKSk7XG5cbiAgICAvKiogSW50ZXJuYWwgYFtbQ2xhc3NdXWAgdmFsdWUgc2hvcnRjdXRzLiAqL1xuICAgIHZhciBvYmplY3RDbGFzcyA9ICdPYmplY3QnLFxuICAgICAgICBhaXJSdW50aW1lQ2xhc3MgPSBpc0N1c3RvbUNvbnRleHQgPyBvYmplY3RDbGFzcyA6ICdTY3JpcHRCcmlkZ2luZ1Byb3h5T2JqZWN0JyxcbiAgICAgICAgZW52aXJvQ2xhc3MgPSBpc0N1c3RvbUNvbnRleHQgPyBvYmplY3RDbGFzcyA6ICdFbnZpcm9ubWVudCcsXG4gICAgICAgIGphdmFDbGFzcyA9IChpc0N1c3RvbUNvbnRleHQgJiYgY29udGV4dC5qYXZhKSA/ICdKYXZhUGFja2FnZScgOiBnZXRDbGFzc09mKGNvbnRleHQuamF2YSksXG4gICAgICAgIHBoYW50b21DbGFzcyA9IGlzQ3VzdG9tQ29udGV4dCA/IG9iamVjdENsYXNzIDogJ1J1bnRpbWVPYmplY3QnO1xuXG4gICAgLyoqIERldGVjdCBKYXZhIGVudmlyb25tZW50cy4gKi9cbiAgICB2YXIgamF2YSA9IC9cXGJKYXZhLy50ZXN0KGphdmFDbGFzcykgJiYgY29udGV4dC5qYXZhO1xuXG4gICAgLyoqIERldGVjdCBSaGluby4gKi9cbiAgICB2YXIgcmhpbm8gPSBqYXZhICYmIGdldENsYXNzT2YoY29udGV4dC5lbnZpcm9ubWVudCkgPT0gZW52aXJvQ2xhc3M7XG5cbiAgICAvKiogQSBjaGFyYWN0ZXIgdG8gcmVwcmVzZW50IGFscGhhLiAqL1xuICAgIHZhciBhbHBoYSA9IGphdmEgPyAnYScgOiAnXFx1MDNiMSc7XG5cbiAgICAvKiogQSBjaGFyYWN0ZXIgdG8gcmVwcmVzZW50IGJldGEuICovXG4gICAgdmFyIGJldGEgPSBqYXZhID8gJ2InIDogJ1xcdTAzYjInO1xuXG4gICAgLyoqIEJyb3dzZXIgZG9jdW1lbnQgb2JqZWN0LiAqL1xuICAgIHZhciBkb2MgPSBjb250ZXh0LmRvY3VtZW50IHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogRGV0ZWN0IE9wZXJhIGJyb3dzZXIgKFByZXN0by1iYXNlZCkuXG4gICAgICogaHR0cDovL3d3dy5ob3d0b2NyZWF0ZS5jby51ay9vcGVyYVN0dWZmL29wZXJhT2JqZWN0Lmh0bWxcbiAgICAgKiBodHRwOi8vZGV2Lm9wZXJhLmNvbS9hcnRpY2xlcy92aWV3L29wZXJhLW1pbmktd2ViLWNvbnRlbnQtYXV0aG9yaW5nLWd1aWRlbGluZXMvI29wZXJhbWluaVxuICAgICAqL1xuICAgIHZhciBvcGVyYSA9IGNvbnRleHQub3BlcmFtaW5pIHx8IGNvbnRleHQub3BlcmE7XG5cbiAgICAvKiogT3BlcmEgYFtbQ2xhc3NdXWAuICovXG4gICAgdmFyIG9wZXJhQ2xhc3MgPSByZU9wZXJhLnRlc3Qob3BlcmFDbGFzcyA9IChpc0N1c3RvbUNvbnRleHQgJiYgb3BlcmEpID8gb3BlcmFbJ1tbQ2xhc3NdXSddIDogZ2V0Q2xhc3NPZihvcGVyYSkpXG4gICAgICA/IG9wZXJhQ2xhc3NcbiAgICAgIDogKG9wZXJhID0gbnVsbCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKiogVGVtcG9yYXJ5IHZhcmlhYmxlIHVzZWQgb3ZlciB0aGUgc2NyaXB0J3MgbGlmZXRpbWUuICovXG4gICAgdmFyIGRhdGE7XG5cbiAgICAvKiogVGhlIENQVSBhcmNoaXRlY3R1cmUuICovXG4gICAgdmFyIGFyY2ggPSB1YTtcblxuICAgIC8qKiBQbGF0Zm9ybSBkZXNjcmlwdGlvbiBhcnJheS4gKi9cbiAgICB2YXIgZGVzY3JpcHRpb24gPSBbXTtcblxuICAgIC8qKiBQbGF0Zm9ybSBhbHBoYS9iZXRhIGluZGljYXRvci4gKi9cbiAgICB2YXIgcHJlcmVsZWFzZSA9IG51bGw7XG5cbiAgICAvKiogQSBmbGFnIHRvIGluZGljYXRlIHRoYXQgZW52aXJvbm1lbnQgZmVhdHVyZXMgc2hvdWxkIGJlIHVzZWQgdG8gcmVzb2x2ZSB0aGUgcGxhdGZvcm0uICovXG4gICAgdmFyIHVzZUZlYXR1cmVzID0gdWEgPT0gdXNlckFnZW50O1xuXG4gICAgLyoqIFRoZSBicm93c2VyL2Vudmlyb25tZW50IHZlcnNpb24uICovXG4gICAgdmFyIHZlcnNpb24gPSB1c2VGZWF0dXJlcyAmJiBvcGVyYSAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PSAnZnVuY3Rpb24nICYmIG9wZXJhLnZlcnNpb24oKTtcblxuICAgIC8qKiBBIGZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIE9TIGVuZHMgd2l0aCBcIi8gVmVyc2lvblwiICovXG4gICAgdmFyIGlzU3BlY2lhbENhc2VkT1M7XG5cbiAgICAvKiBEZXRlY3RhYmxlIGxheW91dCBlbmdpbmVzIChvcmRlciBpcyBpbXBvcnRhbnQpLiAqL1xuICAgIHZhciBsYXlvdXQgPSBnZXRMYXlvdXQoW1xuICAgICAgeyAnbGFiZWwnOiAnRWRnZUhUTUwnLCAncGF0dGVybic6ICdFZGdlJyB9LFxuICAgICAgJ1RyaWRlbnQnLFxuICAgICAgeyAnbGFiZWwnOiAnV2ViS2l0JywgJ3BhdHRlcm4nOiAnQXBwbGVXZWJLaXQnIH0sXG4gICAgICAnaUNhYicsXG4gICAgICAnUHJlc3RvJyxcbiAgICAgICdOZXRGcm9udCcsXG4gICAgICAnVGFzbWFuJyxcbiAgICAgICdLSFRNTCcsXG4gICAgICAnR2Vja28nXG4gICAgXSk7XG5cbiAgICAvKiBEZXRlY3RhYmxlIGJyb3dzZXIgbmFtZXMgKG9yZGVyIGlzIGltcG9ydGFudCkuICovXG4gICAgdmFyIG5hbWUgPSBnZXROYW1lKFtcbiAgICAgICdBZG9iZSBBSVInLFxuICAgICAgJ0Fyb3JhJyxcbiAgICAgICdBdmFudCBCcm93c2VyJyxcbiAgICAgICdCcmVhY2gnLFxuICAgICAgJ0NhbWlubycsXG4gICAgICAnRWxlY3Ryb24nLFxuICAgICAgJ0VwaXBoYW55JyxcbiAgICAgICdGZW5uZWMnLFxuICAgICAgJ0Zsb2NrJyxcbiAgICAgICdHYWxlb24nLFxuICAgICAgJ0dyZWVuQnJvd3NlcicsXG4gICAgICAnaUNhYicsXG4gICAgICAnSWNld2Vhc2VsJyxcbiAgICAgICdLLU1lbGVvbicsXG4gICAgICAnS29ucXVlcm9yJyxcbiAgICAgICdMdW5hc2NhcGUnLFxuICAgICAgJ01heHRob24nLFxuICAgICAgeyAnbGFiZWwnOiAnTWljcm9zb2Z0IEVkZ2UnLCAncGF0dGVybic6ICcoPzpFZGdlfEVkZ3xFZGdBfEVkZ2lPUyknIH0sXG4gICAgICAnTWlkb3JpJyxcbiAgICAgICdOb29rIEJyb3dzZXInLFxuICAgICAgJ1BhbGVNb29uJyxcbiAgICAgICdQaGFudG9tSlMnLFxuICAgICAgJ1JhdmVuJyxcbiAgICAgICdSZWtvbnEnLFxuICAgICAgJ1JvY2tNZWx0JyxcbiAgICAgIHsgJ2xhYmVsJzogJ1NhbXN1bmcgSW50ZXJuZXQnLCAncGF0dGVybic6ICdTYW1zdW5nQnJvd3NlcicgfSxcbiAgICAgICdTZWFNb25rZXknLFxuICAgICAgeyAnbGFiZWwnOiAnU2lsaycsICdwYXR0ZXJuJzogJyg/OkNsb3VkOXxTaWxrLUFjY2VsZXJhdGVkKScgfSxcbiAgICAgICdTbGVpcG5pcicsXG4gICAgICAnU2xpbUJyb3dzZXInLFxuICAgICAgeyAnbGFiZWwnOiAnU1JXYXJlIElyb24nLCAncGF0dGVybic6ICdJcm9uJyB9LFxuICAgICAgJ1N1bnJpc2UnLFxuICAgICAgJ1N3aWZ0Zm94JyxcbiAgICAgICdWaXZhbGRpJyxcbiAgICAgICdXYXRlcmZveCcsXG4gICAgICAnV2ViUG9zaXRpdmUnLFxuICAgICAgeyAnbGFiZWwnOiAnWWFuZGV4IEJyb3dzZXInLCAncGF0dGVybic6ICdZYUJyb3dzZXInIH0sXG4gICAgICB7ICdsYWJlbCc6ICdVQyBCcm93c2VyJywgJ3BhdHRlcm4nOiAnVUNCcm93c2VyJyB9LFxuICAgICAgJ09wZXJhIE1pbmknLFxuICAgICAgeyAnbGFiZWwnOiAnT3BlcmEgTWluaScsICdwYXR0ZXJuJzogJ09QaU9TJyB9LFxuICAgICAgJ09wZXJhJyxcbiAgICAgIHsgJ2xhYmVsJzogJ09wZXJhJywgJ3BhdHRlcm4nOiAnT1BSJyB9LFxuICAgICAgJ0Nocm9taXVtJyxcbiAgICAgICdDaHJvbWUnLFxuICAgICAgeyAnbGFiZWwnOiAnQ2hyb21lJywgJ3BhdHRlcm4nOiAnKD86SGVhZGxlc3NDaHJvbWUpJyB9LFxuICAgICAgeyAnbGFiZWwnOiAnQ2hyb21lIE1vYmlsZScsICdwYXR0ZXJuJzogJyg/OkNyaU9TfENyTW8pJyB9LFxuICAgICAgeyAnbGFiZWwnOiAnRmlyZWZveCcsICdwYXR0ZXJuJzogJyg/OkZpcmVmb3h8TWluZWZpZWxkKScgfSxcbiAgICAgIHsgJ2xhYmVsJzogJ0ZpcmVmb3ggZm9yIGlPUycsICdwYXR0ZXJuJzogJ0Z4aU9TJyB9LFxuICAgICAgeyAnbGFiZWwnOiAnSUUnLCAncGF0dGVybic6ICdJRU1vYmlsZScgfSxcbiAgICAgIHsgJ2xhYmVsJzogJ0lFJywgJ3BhdHRlcm4nOiAnTVNJRScgfSxcbiAgICAgICdTYWZhcmknXG4gICAgXSk7XG5cbiAgICAvKiBEZXRlY3RhYmxlIHByb2R1Y3RzIChvcmRlciBpcyBpbXBvcnRhbnQpLiAqL1xuICAgIHZhciBwcm9kdWN0ID0gZ2V0UHJvZHVjdChbXG4gICAgICB7ICdsYWJlbCc6ICdCbGFja0JlcnJ5JywgJ3BhdHRlcm4nOiAnQkIxMCcgfSxcbiAgICAgICdCbGFja0JlcnJ5JyxcbiAgICAgIHsgJ2xhYmVsJzogJ0dhbGF4eSBTJywgJ3BhdHRlcm4nOiAnR1QtSTkwMDAnIH0sXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUzInLCAncGF0dGVybic6ICdHVC1JOTEwMCcgfSxcbiAgICAgIHsgJ2xhYmVsJzogJ0dhbGF4eSBTMycsICdwYXR0ZXJuJzogJ0dULUk5MzAwJyB9LFxuICAgICAgeyAnbGFiZWwnOiAnR2FsYXh5IFM0JywgJ3BhdHRlcm4nOiAnR1QtSTk1MDAnIH0sXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUzUnLCAncGF0dGVybic6ICdTTS1HOTAwJyB9LFxuICAgICAgeyAnbGFiZWwnOiAnR2FsYXh5IFM2JywgJ3BhdHRlcm4nOiAnU00tRzkyMCcgfSxcbiAgICAgIHsgJ2xhYmVsJzogJ0dhbGF4eSBTNiBFZGdlJywgJ3BhdHRlcm4nOiAnU00tRzkyNScgfSxcbiAgICAgIHsgJ2xhYmVsJzogJ0dhbGF4eSBTNycsICdwYXR0ZXJuJzogJ1NNLUc5MzAnIH0sXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUzcgRWRnZScsICdwYXR0ZXJuJzogJ1NNLUc5MzUnIH0sXG4gICAgICAnR29vZ2xlIFRWJyxcbiAgICAgICdMdW1pYScsXG4gICAgICAnaVBhZCcsXG4gICAgICAnaVBvZCcsXG4gICAgICAnaVBob25lJyxcbiAgICAgICdLaW5kbGUnLFxuICAgICAgeyAnbGFiZWwnOiAnS2luZGxlIEZpcmUnLCAncGF0dGVybic6ICcoPzpDbG91ZDl8U2lsay1BY2NlbGVyYXRlZCknIH0sXG4gICAgICAnTmV4dXMnLFxuICAgICAgJ05vb2snLFxuICAgICAgJ1BsYXlCb29rJyxcbiAgICAgICdQbGF5U3RhdGlvbiBWaXRhJyxcbiAgICAgICdQbGF5U3RhdGlvbicsXG4gICAgICAnVG91Y2hQYWQnLFxuICAgICAgJ1RyYW5zZm9ybWVyJyxcbiAgICAgIHsgJ2xhYmVsJzogJ1dpaSBVJywgJ3BhdHRlcm4nOiAnV2lpVScgfSxcbiAgICAgICdXaWknLFxuICAgICAgJ1hib3ggT25lJyxcbiAgICAgIHsgJ2xhYmVsJzogJ1hib3ggMzYwJywgJ3BhdHRlcm4nOiAnWGJveCcgfSxcbiAgICAgICdYb29tJ1xuICAgIF0pO1xuXG4gICAgLyogRGV0ZWN0YWJsZSBtYW51ZmFjdHVyZXJzLiAqL1xuICAgIHZhciBtYW51ZmFjdHVyZXIgPSBnZXRNYW51ZmFjdHVyZXIoe1xuICAgICAgJ0FwcGxlJzogeyAnaVBhZCc6IDEsICdpUGhvbmUnOiAxLCAnaVBvZCc6IDEgfSxcbiAgICAgICdBbGNhdGVsJzoge30sXG4gICAgICAnQXJjaG9zJzoge30sXG4gICAgICAnQW1hem9uJzogeyAnS2luZGxlJzogMSwgJ0tpbmRsZSBGaXJlJzogMSB9LFxuICAgICAgJ0FzdXMnOiB7ICdUcmFuc2Zvcm1lcic6IDEgfSxcbiAgICAgICdCYXJuZXMgJiBOb2JsZSc6IHsgJ05vb2snOiAxIH0sXG4gICAgICAnQmxhY2tCZXJyeSc6IHsgJ1BsYXlCb29rJzogMSB9LFxuICAgICAgJ0dvb2dsZSc6IHsgJ0dvb2dsZSBUVic6IDEsICdOZXh1cyc6IDEgfSxcbiAgICAgICdIUCc6IHsgJ1RvdWNoUGFkJzogMSB9LFxuICAgICAgJ0hUQyc6IHt9LFxuICAgICAgJ0h1YXdlaSc6IHt9LFxuICAgICAgJ0xlbm92byc6IHt9LFxuICAgICAgJ0xHJzoge30sXG4gICAgICAnTWljcm9zb2Z0JzogeyAnWGJveCc6IDEsICdYYm94IE9uZSc6IDEgfSxcbiAgICAgICdNb3Rvcm9sYSc6IHsgJ1hvb20nOiAxIH0sXG4gICAgICAnTmludGVuZG8nOiB7ICdXaWkgVSc6IDEsICAnV2lpJzogMSB9LFxuICAgICAgJ05va2lhJzogeyAnTHVtaWEnOiAxIH0sXG4gICAgICAnT3Bwbyc6IHt9LFxuICAgICAgJ1NhbXN1bmcnOiB7ICdHYWxheHkgUyc6IDEsICdHYWxheHkgUzInOiAxLCAnR2FsYXh5IFMzJzogMSwgJ0dhbGF4eSBTNCc6IDEgfSxcbiAgICAgICdTb255JzogeyAnUGxheVN0YXRpb24nOiAxLCAnUGxheVN0YXRpb24gVml0YSc6IDEgfSxcbiAgICAgICdYaWFvbWknOiB7ICdNaSc6IDEsICdSZWRtaSc6IDEgfVxuICAgIH0pO1xuXG4gICAgLyogRGV0ZWN0YWJsZSBvcGVyYXRpbmcgc3lzdGVtcyAob3JkZXIgaXMgaW1wb3J0YW50KS4gKi9cbiAgICB2YXIgb3MgPSBnZXRPUyhbXG4gICAgICAnV2luZG93cyBQaG9uZScsXG4gICAgICAnS2FpT1MnLFxuICAgICAgJ0FuZHJvaWQnLFxuICAgICAgJ0NlbnRPUycsXG4gICAgICB7ICdsYWJlbCc6ICdDaHJvbWUgT1MnLCAncGF0dGVybic6ICdDck9TJyB9LFxuICAgICAgJ0RlYmlhbicsXG4gICAgICB7ICdsYWJlbCc6ICdEcmFnb25GbHkgQlNEJywgJ3BhdHRlcm4nOiAnRHJhZ29uRmx5JyB9LFxuICAgICAgJ0ZlZG9yYScsXG4gICAgICAnRnJlZUJTRCcsXG4gICAgICAnR2VudG9vJyxcbiAgICAgICdIYWlrdScsXG4gICAgICAnS3VidW50dScsXG4gICAgICAnTGludXggTWludCcsXG4gICAgICAnT3BlbkJTRCcsXG4gICAgICAnUmVkIEhhdCcsXG4gICAgICAnU3VTRScsXG4gICAgICAnVWJ1bnR1JyxcbiAgICAgICdYdWJ1bnR1JyxcbiAgICAgICdDeWd3aW4nLFxuICAgICAgJ1N5bWJpYW4gT1MnLFxuICAgICAgJ2hwd09TJyxcbiAgICAgICd3ZWJPUyAnLFxuICAgICAgJ3dlYk9TJyxcbiAgICAgICdUYWJsZXQgT1MnLFxuICAgICAgJ1RpemVuJyxcbiAgICAgICdMaW51eCcsXG4gICAgICAnTWFjIE9TIFgnLFxuICAgICAgJ01hY2ludG9zaCcsXG4gICAgICAnTWFjJyxcbiAgICAgICdXaW5kb3dzIDk4OycsXG4gICAgICAnV2luZG93cyAnXG4gICAgXSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBQaWNrcyB0aGUgbGF5b3V0IGVuZ2luZSBmcm9tIGFuIGFycmF5IG9mIGd1ZXNzZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGd1ZXNzZXMgQW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cbiAgICAgKiBAcmV0dXJucyB7bnVsbHxzdHJpbmd9IFRoZSBkZXRlY3RlZCBsYXlvdXQgZW5naW5lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldExheW91dChndWVzc2VzKSB7XG4gICAgICByZXR1cm4gcmVkdWNlKGd1ZXNzZXMsIGZ1bmN0aW9uKHJlc3VsdCwgZ3Vlc3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBSZWdFeHAoJ1xcXFxiJyArIChcbiAgICAgICAgICBndWVzcy5wYXR0ZXJuIHx8IHF1YWxpZnkoZ3Vlc3MpXG4gICAgICAgICkgKyAnXFxcXGInLCAnaScpLmV4ZWModWEpICYmIChndWVzcy5sYWJlbCB8fCBndWVzcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQaWNrcyB0aGUgbWFudWZhY3R1cmVyIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBvYmplY3Qgb2YgZ3Vlc3Nlcy5cbiAgICAgKiBAcmV0dXJucyB7bnVsbHxzdHJpbmd9IFRoZSBkZXRlY3RlZCBtYW51ZmFjdHVyZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWFudWZhY3R1cmVyKGd1ZXNzZXMpIHtcbiAgICAgIHJldHVybiByZWR1Y2UoZ3Vlc3NlcywgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICAgIC8vIExvb2t1cCB0aGUgbWFudWZhY3R1cmVyIGJ5IHByb2R1Y3Qgb3Igc2NhbiB0aGUgVUEgZm9yIHRoZSBtYW51ZmFjdHVyZXIuXG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgKFxuICAgICAgICAgIHZhbHVlW3Byb2R1Y3RdIHx8XG4gICAgICAgICAgdmFsdWVbL15bYS16XSsoPzogK1thLXpdK1xcYikqL2kuZXhlYyhwcm9kdWN0KV0gfHxcbiAgICAgICAgICBSZWdFeHAoJ1xcXFxiJyArIHF1YWxpZnkoa2V5KSArICcoPzpcXFxcYnxcXFxcdypcXFxcZCknLCAnaScpLmV4ZWModWEpXG4gICAgICAgICkgJiYga2V5O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGlja3MgdGhlIGJyb3dzZXIgbmFtZSBmcm9tIGFuIGFycmF5IG9mIGd1ZXNzZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGd1ZXNzZXMgQW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cbiAgICAgKiBAcmV0dXJucyB7bnVsbHxzdHJpbmd9IFRoZSBkZXRlY3RlZCBicm93c2VyIG5hbWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmFtZShndWVzc2VzKSB7XG4gICAgICByZXR1cm4gcmVkdWNlKGd1ZXNzZXMsIGZ1bmN0aW9uKHJlc3VsdCwgZ3Vlc3MpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBSZWdFeHAoJ1xcXFxiJyArIChcbiAgICAgICAgICBndWVzcy5wYXR0ZXJuIHx8IHF1YWxpZnkoZ3Vlc3MpXG4gICAgICAgICkgKyAnXFxcXGInLCAnaScpLmV4ZWModWEpICYmIChndWVzcy5sYWJlbCB8fCBndWVzcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQaWNrcyB0aGUgT1MgbmFtZSBmcm9tIGFuIGFycmF5IG9mIGd1ZXNzZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGd1ZXNzZXMgQW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cbiAgICAgKiBAcmV0dXJucyB7bnVsbHxzdHJpbmd9IFRoZSBkZXRlY3RlZCBPUyBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE9TKGd1ZXNzZXMpIHtcbiAgICAgIHJldHVybiByZWR1Y2UoZ3Vlc3NlcywgZnVuY3Rpb24ocmVzdWx0LCBndWVzcykge1xuICAgICAgICB2YXIgcGF0dGVybiA9IGd1ZXNzLnBhdHRlcm4gfHwgcXVhbGlmeShndWVzcyk7XG4gICAgICAgIGlmICghcmVzdWx0ICYmIChyZXN1bHQgPVxuICAgICAgICAgICAgICBSZWdFeHAoJ1xcXFxiJyArIHBhdHRlcm4gKyAnKD86L1tcXFxcZC5dK3xbIFxcXFx3Ll0qKScsICdpJykuZXhlYyh1YSlcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBjbGVhbnVwT1MocmVzdWx0LCBwYXR0ZXJuLCBndWVzcy5sYWJlbCB8fCBndWVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBpY2tzIHRoZSBwcm9kdWN0IG5hbWUgZnJvbSBhbiBhcnJheSBvZiBndWVzc2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBndWVzc2VzIEFuIGFycmF5IG9mIGd1ZXNzZXMuXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgcHJvZHVjdCBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFByb2R1Y3QoZ3Vlc3Nlcykge1xuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIGd1ZXNzKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gZ3Vlc3MucGF0dGVybiB8fCBxdWFsaWZ5KGd1ZXNzKTtcbiAgICAgICAgaWYgKCFyZXN1bHQgJiYgKHJlc3VsdCA9XG4gICAgICAgICAgICAgIFJlZ0V4cCgnXFxcXGInICsgcGF0dGVybiArICcgKlxcXFxkK1suXFxcXHdfXSonLCAnaScpLmV4ZWModWEpIHx8XG4gICAgICAgICAgICAgIFJlZ0V4cCgnXFxcXGInICsgcGF0dGVybiArICcgKlxcXFx3Ky1bXFxcXHddKicsICdpJykuZXhlYyh1YSkgfHxcbiAgICAgICAgICAgICAgUmVnRXhwKCdcXFxcYicgKyBwYXR0ZXJuICsgJyg/OjsgKig/OlthLXpdK1tfLV0pP1thLXpdK1xcXFxkK3xbXiAoKTstXSopJywgJ2knKS5leGVjKHVhKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIC8vIFNwbGl0IGJ5IGZvcndhcmQgc2xhc2ggYW5kIGFwcGVuZCBwcm9kdWN0IHZlcnNpb24gaWYgbmVlZGVkLlxuICAgICAgICAgIGlmICgocmVzdWx0ID0gU3RyaW5nKChndWVzcy5sYWJlbCAmJiAhUmVnRXhwKHBhdHRlcm4sICdpJykudGVzdChndWVzcy5sYWJlbCkpID8gZ3Vlc3MubGFiZWwgOiByZXN1bHQpLnNwbGl0KCcvJykpWzFdICYmICEvW1xcZC5dKy8udGVzdChyZXN1bHRbMF0pKSB7XG4gICAgICAgICAgICByZXN1bHRbMF0gKz0gJyAnICsgcmVzdWx0WzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDb3JyZWN0IGNoYXJhY3RlciBjYXNlIGFuZCBjbGVhbnVwIHN0cmluZy5cbiAgICAgICAgICBndWVzcyA9IGd1ZXNzLmxhYmVsIHx8IGd1ZXNzO1xuICAgICAgICAgIHJlc3VsdCA9IGZvcm1hdChyZXN1bHRbMF1cbiAgICAgICAgICAgIC5yZXBsYWNlKFJlZ0V4cChwYXR0ZXJuLCAnaScpLCBndWVzcylcbiAgICAgICAgICAgIC5yZXBsYWNlKFJlZ0V4cCgnOyAqKD86JyArIGd1ZXNzICsgJ1tfLV0pPycsICdpJyksICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKFJlZ0V4cCgnKCcgKyBndWVzcyArICcpWy1fLl0/KFxcXFx3KScsICdpJyksICckMSAkMicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdGhlIHZlcnNpb24gdXNpbmcgYW4gYXJyYXkgb2YgVUEgcGF0dGVybnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdHRlcm5zIEFuIGFycmF5IG9mIFVBIHBhdHRlcm5zLlxuICAgICAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gVGhlIGRldGVjdGVkIHZlcnNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0VmVyc2lvbihwYXR0ZXJucykge1xuICAgICAgcmV0dXJuIHJlZHVjZShwYXR0ZXJucywgZnVuY3Rpb24ocmVzdWx0LCBwYXR0ZXJuKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgfHwgKFJlZ0V4cChwYXR0ZXJuICtcbiAgICAgICAgICAnKD86LVtcXFxcZC5dKy98KD86IGZvciBbXFxcXHctXSspP1sgLy1dKShbXFxcXGQuXStbXiAoKTsvXy1dKiknLCAnaScpLmV4ZWModWEpIHx8IDApWzFdIHx8IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGBwbGF0Zm9ybS5kZXNjcmlwdGlvbmAgd2hlbiB0aGUgcGxhdGZvcm0gb2JqZWN0IGlzIGNvZXJjZWQgdG8gYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAbmFtZSB0b1N0cmluZ1xuICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgYHBsYXRmb3JtLmRlc2NyaXB0aW9uYCBpZiBhdmFpbGFibGUsIGVsc2UgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nUGxhdGZvcm0oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kZXNjcmlwdGlvbiB8fCAnJztcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBDb252ZXJ0IGxheW91dCB0byBhbiBhcnJheSBzbyB3ZSBjYW4gYWRkIGV4dHJhIGRldGFpbHMuXG4gICAgbGF5b3V0ICYmIChsYXlvdXQgPSBbbGF5b3V0XSk7XG5cbiAgICAvLyBEZXRlY3QgQW5kcm9pZCBwcm9kdWN0cy5cbiAgICAvLyBCcm93c2VycyBvbiBBbmRyb2lkIGRldmljZXMgdHlwaWNhbGx5IHByb3ZpZGUgdGhlaXIgcHJvZHVjdCBJRFMgYWZ0ZXIgXCJBbmRyb2lkO1wiXG4gICAgLy8gdXAgdG8gXCJCdWlsZFwiIG9yIFwiKSBBcHBsZVdlYktpdFwiLlxuICAgIC8vIEV4YW1wbGU6XG4gICAgLy8gXCJNb3ppbGxhLzUuMCAoTGludXg7IEFuZHJvaWQgOC4xLjA7IE1vdG8gRyAoNSkgUGx1cykgQXBwbGVXZWJLaXQvNTM3LjM2XG4gICAgLy8gKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvNzAuMC4zNTM4LjgwIE1vYmlsZSBTYWZhcmkvNTM3LjM2XCJcbiAgICBpZiAoL1xcYkFuZHJvaWRcXGIvLnRlc3Qob3MpICYmICFwcm9kdWN0ICYmXG4gICAgICAgIChkYXRhID0gL1xcYkFuZHJvaWRbXjtdKjsoLio/KSg/OkJ1aWxkfFxcKSBBcHBsZVdlYktpdClcXGIvaS5leGVjKHVhKSkpIHtcbiAgICAgIHByb2R1Y3QgPSB0cmltKGRhdGFbMV0pXG4gICAgICAgIC8vIFJlcGxhY2UgYW55IGxhbmd1YWdlIGNvZGVzIChlZy4gXCJlbi1VU1wiKS5cbiAgICAgICAgLnJlcGxhY2UoL15bYS16XXsyfS1bYS16XXsyfTtcXHMqL2ksICcnKVxuICAgICAgICB8fCBudWxsO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgcHJvZHVjdCBuYW1lcyB0aGF0IGNvbnRhaW4gdGhlaXIgbWFudWZhY3R1cmVyJ3MgbmFtZS5cbiAgICBpZiAobWFudWZhY3R1cmVyICYmICFwcm9kdWN0KSB7XG4gICAgICBwcm9kdWN0ID0gZ2V0UHJvZHVjdChbbWFudWZhY3R1cmVyXSk7XG4gICAgfSBlbHNlIGlmIChtYW51ZmFjdHVyZXIgJiYgcHJvZHVjdCkge1xuICAgICAgcHJvZHVjdCA9IHByb2R1Y3RcbiAgICAgICAgLnJlcGxhY2UoUmVnRXhwKCdeKCcgKyBxdWFsaWZ5KG1hbnVmYWN0dXJlcikgKyAnKVstXy5cXFxcc10nLCAnaScpLCBtYW51ZmFjdHVyZXIgKyAnICcpXG4gICAgICAgIC5yZXBsYWNlKFJlZ0V4cCgnXignICsgcXVhbGlmeShtYW51ZmFjdHVyZXIpICsgJylbLV8uXT8oXFxcXHcpJywgJ2knKSwgbWFudWZhY3R1cmVyICsgJyAkMicpO1xuICAgIH1cbiAgICAvLyBDbGVhbiB1cCBHb29nbGUgVFYuXG4gICAgaWYgKChkYXRhID0gL1xcYkdvb2dsZSBUVlxcYi8uZXhlYyhwcm9kdWN0KSkpIHtcbiAgICAgIHByb2R1Y3QgPSBkYXRhWzBdO1xuICAgIH1cbiAgICAvLyBEZXRlY3Qgc2ltdWxhdG9ycy5cbiAgICBpZiAoL1xcYlNpbXVsYXRvclxcYi9pLnRlc3QodWEpKSB7XG4gICAgICBwcm9kdWN0ID0gKHByb2R1Y3QgPyBwcm9kdWN0ICsgJyAnIDogJycpICsgJ1NpbXVsYXRvcic7XG4gICAgfVxuICAgIC8vIERldGVjdCBPcGVyYSBNaW5pIDgrIHJ1bm5pbmcgaW4gVHVyYm8vVW5jb21wcmVzc2VkIG1vZGUgb24gaU9TLlxuICAgIGlmIChuYW1lID09ICdPcGVyYSBNaW5pJyAmJiAvXFxiT1BpT1NcXGIvLnRlc3QodWEpKSB7XG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKCdydW5uaW5nIGluIFR1cmJvL1VuY29tcHJlc3NlZCBtb2RlJyk7XG4gICAgfVxuICAgIC8vIERldGVjdCBJRSBNb2JpbGUgMTEuXG4gICAgaWYgKG5hbWUgPT0gJ0lFJyAmJiAvXFxibGlrZSBpUGhvbmUgT1NcXGIvLnRlc3QodWEpKSB7XG4gICAgICBkYXRhID0gcGFyc2UodWEucmVwbGFjZSgvbGlrZSBpUGhvbmUgT1MvLCAnJykpO1xuICAgICAgbWFudWZhY3R1cmVyID0gZGF0YS5tYW51ZmFjdHVyZXI7XG4gICAgICBwcm9kdWN0ID0gZGF0YS5wcm9kdWN0O1xuICAgIH1cbiAgICAvLyBEZXRlY3QgaU9TLlxuICAgIGVsc2UgaWYgKC9eaVAvLnRlc3QocHJvZHVjdCkpIHtcbiAgICAgIG5hbWUgfHwgKG5hbWUgPSAnU2FmYXJpJyk7XG4gICAgICBvcyA9ICdpT1MnICsgKChkYXRhID0gLyBPUyAoW1xcZF9dKykvaS5leGVjKHVhKSlcbiAgICAgICAgPyAnICcgKyBkYXRhWzFdLnJlcGxhY2UoL18vZywgJy4nKVxuICAgICAgICA6ICcnKTtcbiAgICB9XG4gICAgLy8gRGV0ZWN0IEt1YnVudHUuXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnS29ucXVlcm9yJyAmJiAvXkxpbnV4XFxiL2kudGVzdChvcykpIHtcbiAgICAgIG9zID0gJ0t1YnVudHUnO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgQW5kcm9pZCBicm93c2Vycy5cbiAgICBlbHNlIGlmICgobWFudWZhY3R1cmVyICYmIG1hbnVmYWN0dXJlciAhPSAnR29vZ2xlJyAmJlxuICAgICAgICAoKC9DaHJvbWUvLnRlc3QobmFtZSkgJiYgIS9cXGJNb2JpbGUgU2FmYXJpXFxiL2kudGVzdCh1YSkpIHx8IC9cXGJWaXRhXFxiLy50ZXN0KHByb2R1Y3QpKSkgfHxcbiAgICAgICAgKC9cXGJBbmRyb2lkXFxiLy50ZXN0KG9zKSAmJiAvXkNocm9tZS8udGVzdChuYW1lKSAmJiAvXFxiVmVyc2lvblxcLy9pLnRlc3QodWEpKSkge1xuICAgICAgbmFtZSA9ICdBbmRyb2lkIEJyb3dzZXInO1xuICAgICAgb3MgPSAvXFxiQW5kcm9pZFxcYi8udGVzdChvcykgPyBvcyA6ICdBbmRyb2lkJztcbiAgICB9XG4gICAgLy8gRGV0ZWN0IFNpbGsgZGVza3RvcC9hY2NlbGVyYXRlZCBtb2Rlcy5cbiAgICBlbHNlIGlmIChuYW1lID09ICdTaWxrJykge1xuICAgICAgaWYgKCEvXFxiTW9iaS9pLnRlc3QodWEpKSB7XG4gICAgICAgIG9zID0gJ0FuZHJvaWQnO1xuICAgICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdkZXNrdG9wIG1vZGUnKTtcbiAgICAgIH1cbiAgICAgIGlmICgvQWNjZWxlcmF0ZWQgKj0gKnRydWUvaS50ZXN0KHVhKSkge1xuICAgICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdhY2NlbGVyYXRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBEZXRlY3QgVUMgQnJvd3NlciBzcGVlZCBtb2RlLlxuICAgIGVsc2UgaWYgKG5hbWUgPT0gJ1VDIEJyb3dzZXInICYmIC9cXGJVQ1dFQlxcYi8udGVzdCh1YSkpIHtcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goJ3NwZWVkIG1vZGUnKTtcbiAgICB9XG4gICAgLy8gRGV0ZWN0IFBhbGVNb29uIGlkZW50aWZ5aW5nIGFzIEZpcmVmb3guXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnUGFsZU1vb24nICYmIChkYXRhID0gL1xcYkZpcmVmb3hcXC8oW1xcZC5dKylcXGIvLmV4ZWModWEpKSkge1xuICAgICAgZGVzY3JpcHRpb24ucHVzaCgnaWRlbnRpZnlpbmcgYXMgRmlyZWZveCAnICsgZGF0YVsxXSk7XG4gICAgfVxuICAgIC8vIERldGVjdCBGaXJlZm94IE9TIGFuZCBwcm9kdWN0cyBydW5uaW5nIEZpcmVmb3guXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnRmlyZWZveCcgJiYgKGRhdGEgPSAvXFxiKE1vYmlsZXxUYWJsZXR8VFYpXFxiL2kuZXhlYyh1YSkpKSB7XG4gICAgICBvcyB8fCAob3MgPSAnRmlyZWZveCBPUycpO1xuICAgICAgcHJvZHVjdCB8fCAocHJvZHVjdCA9IGRhdGFbMV0pO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgZmFsc2UgcG9zaXRpdmVzIGZvciBGaXJlZm94L1NhZmFyaS5cbiAgICBlbHNlIGlmICghbmFtZSB8fCAoZGF0YSA9ICEvXFxiTWluZWZpZWxkXFxiL2kudGVzdCh1YSkgJiYgL1xcYig/OkZpcmVmb3h8U2FmYXJpKVxcYi8uZXhlYyhuYW1lKSkpIHtcbiAgICAgIC8vIEVzY2FwZSB0aGUgYC9gIGZvciBGaXJlZm94IDEuXG4gICAgICBpZiAobmFtZSAmJiAhcHJvZHVjdCAmJiAvW1xcLyxdfF5bXihdKz9cXCkvLnRlc3QodWEuc2xpY2UodWEuaW5kZXhPZihkYXRhICsgJy8nKSArIDgpKSkge1xuICAgICAgICAvLyBDbGVhciBuYW1lIG9mIGZhbHNlIHBvc2l0aXZlcy5cbiAgICAgICAgbmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgICAvLyBSZWFzc2lnbiBhIGdlbmVyaWMgbmFtZS5cbiAgICAgIGlmICgoZGF0YSA9IHByb2R1Y3QgfHwgbWFudWZhY3R1cmVyIHx8IG9zKSAmJlxuICAgICAgICAgIChwcm9kdWN0IHx8IG1hbnVmYWN0dXJlciB8fCAvXFxiKD86QW5kcm9pZHxTeW1iaWFuIE9TfFRhYmxldCBPU3x3ZWJPUylcXGIvLnRlc3Qob3MpKSkge1xuICAgICAgICBuYW1lID0gL1thLXpdKyg/OiBIYXQpPy9pLmV4ZWMoL1xcYkFuZHJvaWRcXGIvLnRlc3Qob3MpID8gb3MgOiBkYXRhKSArICcgQnJvd3Nlcic7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFkZCBDaHJvbWUgdmVyc2lvbiB0byBkZXNjcmlwdGlvbiBmb3IgRWxlY3Ryb24uXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnRWxlY3Ryb24nICYmIChkYXRhID0gKC9cXGJDaHJvbWVcXC8oW1xcZC5dKylcXGIvLmV4ZWModWEpIHx8IDApWzFdKSkge1xuICAgICAgZGVzY3JpcHRpb24ucHVzaCgnQ2hyb21pdW0gJyArIGRhdGEpO1xuICAgIH1cbiAgICAvLyBEZXRlY3Qgbm9uLU9wZXJhIChQcmVzdG8tYmFzZWQpIHZlcnNpb25zIChvcmRlciBpcyBpbXBvcnRhbnQpLlxuICAgIGlmICghdmVyc2lvbikge1xuICAgICAgdmVyc2lvbiA9IGdldFZlcnNpb24oW1xuICAgICAgICAnKD86Q2xvdWQ5fENyaU9TfENyTW98RWRnZXxFZGd8RWRnQXxFZGdpT1N8RnhpT1N8SGVhZGxlc3NDaHJvbWV8SUVNb2JpbGV8SXJvbnxPcGVyYSA/TWluaXxPUGlPU3xPUFJ8UmF2ZW58U2Ftc3VuZ0Jyb3dzZXJ8U2lsayg/IS9bXFxcXGQuXSskKXxVQ0Jyb3dzZXJ8WWFCcm93c2VyKScsXG4gICAgICAgICdWZXJzaW9uJyxcbiAgICAgICAgcXVhbGlmeShuYW1lKSxcbiAgICAgICAgJyg/OkZpcmVmb3h8TWluZWZpZWxkfE5ldEZyb250KSdcbiAgICAgIF0pO1xuICAgIH1cbiAgICAvLyBEZXRlY3Qgc3R1YmJvcm4gbGF5b3V0IGVuZ2luZXMuXG4gICAgaWYgKChkYXRhID1cbiAgICAgICAgICBsYXlvdXQgPT0gJ2lDYWInICYmIHBhcnNlRmxvYXQodmVyc2lvbikgPiAzICYmICdXZWJLaXQnIHx8XG4gICAgICAgICAgL1xcYk9wZXJhXFxiLy50ZXN0KG5hbWUpICYmICgvXFxiT1BSXFxiLy50ZXN0KHVhKSA/ICdCbGluaycgOiAnUHJlc3RvJykgfHxcbiAgICAgICAgICAvXFxiKD86TWlkb3JpfE5vb2t8U2FmYXJpKVxcYi9pLnRlc3QodWEpICYmICEvXig/OlRyaWRlbnR8RWRnZUhUTUwpJC8udGVzdChsYXlvdXQpICYmICdXZWJLaXQnIHx8XG4gICAgICAgICAgIWxheW91dCAmJiAvXFxiTVNJRVxcYi9pLnRlc3QodWEpICYmIChvcyA9PSAnTWFjIE9TJyA/ICdUYXNtYW4nIDogJ1RyaWRlbnQnKSB8fFxuICAgICAgICAgIGxheW91dCA9PSAnV2ViS2l0JyAmJiAvXFxiUGxheVN0YXRpb25cXGIoPyEgVml0YVxcYikvaS50ZXN0KG5hbWUpICYmICdOZXRGcm9udCdcbiAgICAgICAgKSkge1xuICAgICAgbGF5b3V0ID0gW2RhdGFdO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgV2luZG93cyBQaG9uZSA3IGRlc2t0b3AgbW9kZS5cbiAgICBpZiAobmFtZSA9PSAnSUUnICYmIChkYXRhID0gKC87ICooPzpYQkxXUHxadW5lV1ApKFxcZCspL2kuZXhlYyh1YSkgfHwgMClbMV0pKSB7XG4gICAgICBuYW1lICs9ICcgTW9iaWxlJztcbiAgICAgIG9zID0gJ1dpbmRvd3MgUGhvbmUgJyArICgvXFwrJC8udGVzdChkYXRhKSA/IGRhdGEgOiBkYXRhICsgJy54Jyk7XG4gICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdkZXNrdG9wIG1vZGUnKTtcbiAgICB9XG4gICAgLy8gRGV0ZWN0IFdpbmRvd3MgUGhvbmUgOC54IGRlc2t0b3AgbW9kZS5cbiAgICBlbHNlIGlmICgvXFxiV1BEZXNrdG9wXFxiL2kudGVzdCh1YSkpIHtcbiAgICAgIG5hbWUgPSAnSUUgTW9iaWxlJztcbiAgICAgIG9zID0gJ1dpbmRvd3MgUGhvbmUgOC54JztcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ2Rlc2t0b3AgbW9kZScpO1xuICAgICAgdmVyc2lvbiB8fCAodmVyc2lvbiA9ICgvXFxicnY6KFtcXGQuXSspLy5leGVjKHVhKSB8fCAwKVsxXSk7XG4gICAgfVxuICAgIC8vIERldGVjdCBJRSAxMSBpZGVudGlmeWluZyBhcyBvdGhlciBicm93c2Vycy5cbiAgICBlbHNlIGlmIChuYW1lICE9ICdJRScgJiYgbGF5b3V0ID09ICdUcmlkZW50JyAmJiAoZGF0YSA9IC9cXGJydjooW1xcZC5dKykvLmV4ZWModWEpKSkge1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgZGVzY3JpcHRpb24ucHVzaCgnaWRlbnRpZnlpbmcgYXMgJyArIG5hbWUgKyAodmVyc2lvbiA/ICcgJyArIHZlcnNpb24gOiAnJykpO1xuICAgICAgfVxuICAgICAgbmFtZSA9ICdJRSc7XG4gICAgICB2ZXJzaW9uID0gZGF0YVsxXTtcbiAgICB9XG4gICAgLy8gTGV2ZXJhZ2UgZW52aXJvbm1lbnQgZmVhdHVyZXMuXG4gICAgaWYgKHVzZUZlYXR1cmVzKSB7XG4gICAgICAvLyBEZXRlY3Qgc2VydmVyLXNpZGUgZW52aXJvbm1lbnRzLlxuICAgICAgLy8gUmhpbm8gaGFzIGEgZ2xvYmFsIGZ1bmN0aW9uIHdoaWxlIG90aGVycyBoYXZlIGEgZ2xvYmFsIG9iamVjdC5cbiAgICAgIGlmIChpc0hvc3RUeXBlKGNvbnRleHQsICdnbG9iYWwnKSkge1xuICAgICAgICBpZiAoamF2YSkge1xuICAgICAgICAgIGRhdGEgPSBqYXZhLmxhbmcuU3lzdGVtO1xuICAgICAgICAgIGFyY2ggPSBkYXRhLmdldFByb3BlcnR5KCdvcy5hcmNoJyk7XG4gICAgICAgICAgb3MgPSBvcyB8fCBkYXRhLmdldFByb3BlcnR5KCdvcy5uYW1lJykgKyAnICcgKyBkYXRhLmdldFByb3BlcnR5KCdvcy52ZXJzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJoaW5vKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZlcnNpb24gPSBjb250ZXh0LnJlcXVpcmUoJ3JpbmdvL2VuZ2luZScpLnZlcnNpb24uam9pbignLicpO1xuICAgICAgICAgICAgbmFtZSA9ICdSaW5nb0pTJztcbiAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgIGlmICgoZGF0YSA9IGNvbnRleHQuc3lzdGVtKSAmJiBkYXRhLmdsb2JhbC5zeXN0ZW0gPT0gY29udGV4dC5zeXN0ZW0pIHtcbiAgICAgICAgICAgICAgbmFtZSA9ICdOYXJ3aGFsJztcbiAgICAgICAgICAgICAgb3MgfHwgKG9zID0gZGF0YVswXS5vcyB8fCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gJ1JoaW5vJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgdHlwZW9mIGNvbnRleHQucHJvY2VzcyA9PSAnb2JqZWN0JyAmJiAhY29udGV4dC5wcm9jZXNzLmJyb3dzZXIgJiZcbiAgICAgICAgICAoZGF0YSA9IGNvbnRleHQucHJvY2VzcylcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhLnZlcnNpb25zID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEudmVyc2lvbnMuZWxlY3Ryb24gPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb24ucHVzaCgnTm9kZSAnICsgZGF0YS52ZXJzaW9ucy5ub2RlKTtcbiAgICAgICAgICAgICAgbmFtZSA9ICdFbGVjdHJvbic7XG4gICAgICAgICAgICAgIHZlcnNpb24gPSBkYXRhLnZlcnNpb25zLmVsZWN0cm9uO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YS52ZXJzaW9ucy5udyA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBkZXNjcmlwdGlvbi5wdXNoKCdDaHJvbWl1bSAnICsgdmVyc2lvbiwgJ05vZGUgJyArIGRhdGEudmVyc2lvbnMubm9kZSk7XG4gICAgICAgICAgICAgIG5hbWUgPSAnTlcuanMnO1xuICAgICAgICAgICAgICB2ZXJzaW9uID0gZGF0YS52ZXJzaW9ucy5udztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gJ05vZGUuanMnO1xuICAgICAgICAgICAgYXJjaCA9IGRhdGEuYXJjaDtcbiAgICAgICAgICAgIG9zID0gZGF0YS5wbGF0Zm9ybTtcbiAgICAgICAgICAgIHZlcnNpb24gPSAvW1xcZC5dKy8uZXhlYyhkYXRhLnZlcnNpb24pO1xuICAgICAgICAgICAgdmVyc2lvbiA9IHZlcnNpb24gPyB2ZXJzaW9uWzBdIDogbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCBBZG9iZSBBSVIuXG4gICAgICBlbHNlIGlmIChnZXRDbGFzc09mKChkYXRhID0gY29udGV4dC5ydW50aW1lKSkgPT0gYWlyUnVudGltZUNsYXNzKSB7XG4gICAgICAgIG5hbWUgPSAnQWRvYmUgQUlSJztcbiAgICAgICAgb3MgPSBkYXRhLmZsYXNoLnN5c3RlbS5DYXBhYmlsaXRpZXMub3M7XG4gICAgICB9XG4gICAgICAvLyBEZXRlY3QgUGhhbnRvbUpTLlxuICAgICAgZWxzZSBpZiAoZ2V0Q2xhc3NPZigoZGF0YSA9IGNvbnRleHQucGhhbnRvbSkpID09IHBoYW50b21DbGFzcykge1xuICAgICAgICBuYW1lID0gJ1BoYW50b21KUyc7XG4gICAgICAgIHZlcnNpb24gPSAoZGF0YSA9IGRhdGEudmVyc2lvbiB8fCBudWxsKSAmJiAoZGF0YS5tYWpvciArICcuJyArIGRhdGEubWlub3IgKyAnLicgKyBkYXRhLnBhdGNoKTtcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCBJRSBjb21wYXRpYmlsaXR5IG1vZGVzLlxuICAgICAgZWxzZSBpZiAodHlwZW9mIGRvYy5kb2N1bWVudE1vZGUgPT0gJ251bWJlcicgJiYgKGRhdGEgPSAvXFxiVHJpZGVudFxcLyhcXGQrKS9pLmV4ZWModWEpKSkge1xuICAgICAgICAvLyBXZSdyZSBpbiBjb21wYXRpYmlsaXR5IG1vZGUgd2hlbiB0aGUgVHJpZGVudCB2ZXJzaW9uICsgNCBkb2Vzbid0XG4gICAgICAgIC8vIGVxdWFsIHRoZSBkb2N1bWVudCBtb2RlLlxuICAgICAgICB2ZXJzaW9uID0gW3ZlcnNpb24sIGRvYy5kb2N1bWVudE1vZGVdO1xuICAgICAgICBpZiAoKGRhdGEgPSArZGF0YVsxXSArIDQpICE9IHZlcnNpb25bMV0pIHtcbiAgICAgICAgICBkZXNjcmlwdGlvbi5wdXNoKCdJRSAnICsgdmVyc2lvblsxXSArICcgbW9kZScpO1xuICAgICAgICAgIGxheW91dCAmJiAobGF5b3V0WzFdID0gJycpO1xuICAgICAgICAgIHZlcnNpb25bMV0gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHZlcnNpb24gPSBuYW1lID09ICdJRScgPyBTdHJpbmcodmVyc2lvblsxXS50b0ZpeGVkKDEpKSA6IHZlcnNpb25bMF07XG4gICAgICB9XG4gICAgICAvLyBEZXRlY3QgSUUgMTEgbWFza2luZyBhcyBvdGhlciBicm93c2Vycy5cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkb2MuZG9jdW1lbnRNb2RlID09ICdudW1iZXInICYmIC9eKD86Q2hyb21lfEZpcmVmb3gpXFxiLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGRlc2NyaXB0aW9uLnB1c2goJ21hc2tpbmcgYXMgJyArIG5hbWUgKyAnICcgKyB2ZXJzaW9uKTtcbiAgICAgICAgbmFtZSA9ICdJRSc7XG4gICAgICAgIHZlcnNpb24gPSAnMTEuMCc7XG4gICAgICAgIGxheW91dCA9IFsnVHJpZGVudCddO1xuICAgICAgICBvcyA9ICdXaW5kb3dzJztcbiAgICAgIH1cbiAgICAgIG9zID0gb3MgJiYgZm9ybWF0KG9zKTtcbiAgICB9XG4gICAgLy8gRGV0ZWN0IHByZXJlbGVhc2UgcGhhc2VzLlxuICAgIGlmICh2ZXJzaW9uICYmIChkYXRhID1cbiAgICAgICAgICAvKD86W2FiXXxkcHxwcmV8W2FiXVxcZCtwcmUpKD86XFxkK1xcKz8pPyQvaS5leGVjKHZlcnNpb24pIHx8XG4gICAgICAgICAgLyg/OmFscGhhfGJldGEpKD86ID9cXGQpPy9pLmV4ZWModWEgKyAnOycgKyAodXNlRmVhdHVyZXMgJiYgbmF2LmFwcE1pbm9yVmVyc2lvbikpIHx8XG4gICAgICAgICAgL1xcYk1pbmVmaWVsZFxcYi9pLnRlc3QodWEpICYmICdhJ1xuICAgICAgICApKSB7XG4gICAgICBwcmVyZWxlYXNlID0gL2IvaS50ZXN0KGRhdGEpID8gJ2JldGEnIDogJ2FscGhhJztcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnJlcGxhY2UoUmVnRXhwKGRhdGEgKyAnXFxcXCs/JCcpLCAnJykgK1xuICAgICAgICAocHJlcmVsZWFzZSA9PSAnYmV0YScgPyBiZXRhIDogYWxwaGEpICsgKC9cXGQrXFwrPy8uZXhlYyhkYXRhKSB8fCAnJyk7XG4gICAgfVxuICAgIC8vIERldGVjdCBGaXJlZm94IE1vYmlsZS5cbiAgICBpZiAobmFtZSA9PSAnRmVubmVjJyB8fCBuYW1lID09ICdGaXJlZm94JyAmJiAvXFxiKD86QW5kcm9pZHxGaXJlZm94IE9TfEthaU9TKVxcYi8udGVzdChvcykpIHtcbiAgICAgIG5hbWUgPSAnRmlyZWZveCBNb2JpbGUnO1xuICAgIH1cbiAgICAvLyBPYnNjdXJlIE1heHRob24ncyB1bnJlbGlhYmxlIHZlcnNpb24uXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnTWF4dGhvbicgJiYgdmVyc2lvbikge1xuICAgICAgdmVyc2lvbiA9IHZlcnNpb24ucmVwbGFjZSgvXFwuW1xcZC5dKy8sICcueCcpO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgWGJveCAzNjAgYW5kIFhib3ggT25lLlxuICAgIGVsc2UgaWYgKC9cXGJYYm94XFxiL2kudGVzdChwcm9kdWN0KSkge1xuICAgICAgaWYgKHByb2R1Y3QgPT0gJ1hib3ggMzYwJykge1xuICAgICAgICBvcyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAocHJvZHVjdCA9PSAnWGJveCAzNjAnICYmIC9cXGJJRU1vYmlsZVxcYi8udGVzdCh1YSkpIHtcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnbW9iaWxlIG1vZGUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQWRkIG1vYmlsZSBwb3N0Zml4LlxuICAgIGVsc2UgaWYgKCgvXig/OkNocm9tZXxJRXxPcGVyYSkkLy50ZXN0KG5hbWUpIHx8IG5hbWUgJiYgIXByb2R1Y3QgJiYgIS9Ccm93c2VyfE1vYmkvLnRlc3QobmFtZSkpICYmXG4gICAgICAgIChvcyA9PSAnV2luZG93cyBDRScgfHwgL01vYmkvaS50ZXN0KHVhKSkpIHtcbiAgICAgIG5hbWUgKz0gJyBNb2JpbGUnO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgSUUgcGxhdGZvcm0gcHJldmlldy5cbiAgICBlbHNlIGlmIChuYW1lID09ICdJRScgJiYgdXNlRmVhdHVyZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChjb250ZXh0LmV4dGVybmFsID09PSBudWxsKSB7XG4gICAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgncGxhdGZvcm0gcHJldmlldycpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZW1iZWRkZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRGV0ZWN0IEJsYWNrQmVycnkgT1MgdmVyc2lvbi5cbiAgICAvLyBodHRwOi8vZG9jcy5ibGFja2JlcnJ5LmNvbS9lbi9kZXZlbG9wZXJzL2RlbGl2ZXJhYmxlcy8xODE2OS9IVFRQX2hlYWRlcnNfc2VudF9ieV9CQl9Ccm93c2VyXzEyMzQ5MTFfMTEuanNwXG4gICAgZWxzZSBpZiAoKC9cXGJCbGFja0JlcnJ5XFxiLy50ZXN0KHByb2R1Y3QpIHx8IC9cXGJCQjEwXFxiLy50ZXN0KHVhKSkgJiYgKGRhdGEgPVxuICAgICAgICAgIChSZWdFeHAocHJvZHVjdC5yZXBsYWNlKC8gKy9nLCAnIConKSArICcvKFsuXFxcXGRdKyknLCAnaScpLmV4ZWModWEpIHx8IDApWzFdIHx8XG4gICAgICAgICAgdmVyc2lvblxuICAgICAgICApKSB7XG4gICAgICBkYXRhID0gW2RhdGEsIC9CQjEwLy50ZXN0KHVhKV07XG4gICAgICBvcyA9IChkYXRhWzFdID8gKHByb2R1Y3QgPSBudWxsLCBtYW51ZmFjdHVyZXIgPSAnQmxhY2tCZXJyeScpIDogJ0RldmljZSBTb2Z0d2FyZScpICsgJyAnICsgZGF0YVswXTtcbiAgICAgIHZlcnNpb24gPSBudWxsO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgT3BlcmEgaWRlbnRpZnlpbmcvbWFza2luZyBpdHNlbGYgYXMgYW5vdGhlciBicm93c2VyLlxuICAgIC8vIGh0dHA6Ly93d3cub3BlcmEuY29tL3N1cHBvcnQva2Ivdmlldy84NDMvXG4gICAgZWxzZSBpZiAodGhpcyAhPSBmb3JPd24gJiYgcHJvZHVjdCAhPSAnV2lpJyAmJiAoXG4gICAgICAgICAgKHVzZUZlYXR1cmVzICYmIG9wZXJhKSB8fFxuICAgICAgICAgICgvT3BlcmEvLnRlc3QobmFtZSkgJiYgL1xcYig/Ok1TSUV8RmlyZWZveClcXGIvaS50ZXN0KHVhKSkgfHxcbiAgICAgICAgICAobmFtZSA9PSAnRmlyZWZveCcgJiYgL1xcYk9TIFggKD86XFxkK1xcLil7Mix9Ly50ZXN0KG9zKSkgfHxcbiAgICAgICAgICAobmFtZSA9PSAnSUUnICYmIChcbiAgICAgICAgICAgIChvcyAmJiAhL15XaW4vLnRlc3Qob3MpICYmIHZlcnNpb24gPiA1LjUpIHx8XG4gICAgICAgICAgICAvXFxiV2luZG93cyBYUFxcYi8udGVzdChvcykgJiYgdmVyc2lvbiA+IDggfHxcbiAgICAgICAgICAgIHZlcnNpb24gPT0gOCAmJiAhL1xcYlRyaWRlbnRcXGIvLnRlc3QodWEpXG4gICAgICAgICAgKSlcbiAgICAgICAgKSAmJiAhcmVPcGVyYS50ZXN0KChkYXRhID0gcGFyc2UuY2FsbChmb3JPd24sIHVhLnJlcGxhY2UocmVPcGVyYSwgJycpICsgJzsnKSkpICYmIGRhdGEubmFtZSkge1xuICAgICAgLy8gV2hlbiBcImlkZW50aWZ5aW5nXCIsIHRoZSBVQSBjb250YWlucyBib3RoIE9wZXJhIGFuZCB0aGUgb3RoZXIgYnJvd3NlcidzIG5hbWUuXG4gICAgICBkYXRhID0gJ2luZyBhcyAnICsgZGF0YS5uYW1lICsgKChkYXRhID0gZGF0YS52ZXJzaW9uKSA/ICcgJyArIGRhdGEgOiAnJyk7XG4gICAgICBpZiAocmVPcGVyYS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGlmICgvXFxiSUVcXGIvLnRlc3QoZGF0YSkgJiYgb3MgPT0gJ01hYyBPUycpIHtcbiAgICAgICAgICBvcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9ICdpZGVudGlmeScgKyBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gV2hlbiBcIm1hc2tpbmdcIiwgdGhlIFVBIGNvbnRhaW5zIG9ubHkgdGhlIG90aGVyIGJyb3dzZXIncyBuYW1lLlxuICAgICAgZWxzZSB7XG4gICAgICAgIGRhdGEgPSAnbWFzaycgKyBkYXRhO1xuICAgICAgICBpZiAob3BlcmFDbGFzcykge1xuICAgICAgICAgIG5hbWUgPSBmb3JtYXQob3BlcmFDbGFzcy5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEgJDInKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9ICdPcGVyYSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9cXGJJRVxcYi8udGVzdChkYXRhKSkge1xuICAgICAgICAgIG9zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXVzZUZlYXR1cmVzKSB7XG4gICAgICAgICAgdmVyc2lvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxheW91dCA9IFsnUHJlc3RvJ107XG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKGRhdGEpO1xuICAgIH1cbiAgICAvLyBEZXRlY3QgV2ViS2l0IE5pZ2h0bHkgYW5kIGFwcHJveGltYXRlIENocm9tZS9TYWZhcmkgdmVyc2lvbnMuXG4gICAgaWYgKChkYXRhID0gKC9cXGJBcHBsZVdlYktpdFxcLyhbXFxkLl0rXFwrPykvaS5leGVjKHVhKSB8fCAwKVsxXSkpIHtcbiAgICAgIC8vIENvcnJlY3QgYnVpbGQgbnVtYmVyIGZvciBudW1lcmljIGNvbXBhcmlzb24uXG4gICAgICAvLyAoZS5nLiBcIjUzMi41XCIgYmVjb21lcyBcIjUzMi4wNVwiKVxuICAgICAgZGF0YSA9IFtwYXJzZUZsb2F0KGRhdGEucmVwbGFjZSgvXFwuKFxcZCkkLywgJy4wJDEnKSksIGRhdGFdO1xuICAgICAgLy8gTmlnaHRseSBidWlsZHMgYXJlIHBvc3RmaXhlZCB3aXRoIGEgXCIrXCIuXG4gICAgICBpZiAobmFtZSA9PSAnU2FmYXJpJyAmJiBkYXRhWzFdLnNsaWNlKC0xKSA9PSAnKycpIHtcbiAgICAgICAgbmFtZSA9ICdXZWJLaXQgTmlnaHRseSc7XG4gICAgICAgIHByZXJlbGVhc2UgPSAnYWxwaGEnO1xuICAgICAgICB2ZXJzaW9uID0gZGF0YVsxXS5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgICAvLyBDbGVhciBpbmNvcnJlY3QgYnJvd3NlciB2ZXJzaW9ucy5cbiAgICAgIGVsc2UgaWYgKHZlcnNpb24gPT0gZGF0YVsxXSB8fFxuICAgICAgICAgIHZlcnNpb24gPT0gKGRhdGFbMl0gPSAoL1xcYlNhZmFyaVxcLyhbXFxkLl0rXFwrPykvaS5leGVjKHVhKSB8fCAwKVsxXSkpIHtcbiAgICAgICAgdmVyc2lvbiA9IG51bGw7XG4gICAgICB9XG4gICAgICAvLyBVc2UgdGhlIGZ1bGwgQ2hyb21lIHZlcnNpb24gd2hlbiBhdmFpbGFibGUuXG4gICAgICBkYXRhWzFdID0gKC9cXGIoPzpIZWFkbGVzcyk/Q2hyb21lXFwvKFtcXGQuXSspL2kuZXhlYyh1YSkgfHwgMClbMV07XG4gICAgICAvLyBEZXRlY3QgQmxpbmsgbGF5b3V0IGVuZ2luZS5cbiAgICAgIGlmIChkYXRhWzBdID09IDUzNy4zNiAmJiBkYXRhWzJdID09IDUzNy4zNiAmJiBwYXJzZUZsb2F0KGRhdGFbMV0pID49IDI4ICYmIGxheW91dCA9PSAnV2ViS2l0Jykge1xuICAgICAgICBsYXlvdXQgPSBbJ0JsaW5rJ107XG4gICAgICB9XG4gICAgICAvLyBEZXRlY3QgSmF2YVNjcmlwdENvcmUuXG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY3Njg0NzQvaG93LWNhbi1pLWRldGVjdC13aGljaC1qYXZhc2NyaXB0LWVuZ2luZS12OC1vci1qc2MtaXMtdXNlZC1hdC1ydW50aW1lLWluLWFuZHJvaVxuICAgICAgaWYgKCF1c2VGZWF0dXJlcyB8fCAoIWxpa2VDaHJvbWUgJiYgIWRhdGFbMV0pKSB7XG4gICAgICAgIGxheW91dCAmJiAobGF5b3V0WzFdID0gJ2xpa2UgU2FmYXJpJyk7XG4gICAgICAgIGRhdGEgPSAoZGF0YSA9IGRhdGFbMF0sIGRhdGEgPCA0MDAgPyAxIDogZGF0YSA8IDUwMCA/IDIgOiBkYXRhIDwgNTI2ID8gMyA6IGRhdGEgPCA1MzMgPyA0IDogZGF0YSA8IDUzNCA/ICc0KycgOiBkYXRhIDwgNTM1ID8gNSA6IGRhdGEgPCA1MzcgPyA2IDogZGF0YSA8IDUzOCA/IDcgOiBkYXRhIDwgNjAxID8gOCA6IGRhdGEgPCA2MDIgPyA5IDogZGF0YSA8IDYwNCA/IDEwIDogZGF0YSA8IDYwNiA/IDExIDogZGF0YSA8IDYwOCA/IDEyIDogJzEyJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXlvdXQgJiYgKGxheW91dFsxXSA9ICdsaWtlIENocm9tZScpO1xuICAgICAgICBkYXRhID0gZGF0YVsxXSB8fCAoZGF0YSA9IGRhdGFbMF0sIGRhdGEgPCA1MzAgPyAxIDogZGF0YSA8IDUzMiA/IDIgOiBkYXRhIDwgNTMyLjA1ID8gMyA6IGRhdGEgPCA1MzMgPyA0IDogZGF0YSA8IDUzNC4wMyA/IDUgOiBkYXRhIDwgNTM0LjA3ID8gNiA6IGRhdGEgPCA1MzQuMTAgPyA3IDogZGF0YSA8IDUzNC4xMyA/IDggOiBkYXRhIDwgNTM0LjE2ID8gOSA6IGRhdGEgPCA1MzQuMjQgPyAxMCA6IGRhdGEgPCA1MzQuMzAgPyAxMSA6IGRhdGEgPCA1MzUuMDEgPyAxMiA6IGRhdGEgPCA1MzUuMDIgPyAnMTMrJyA6IGRhdGEgPCA1MzUuMDcgPyAxNSA6IGRhdGEgPCA1MzUuMTEgPyAxNiA6IGRhdGEgPCA1MzUuMTkgPyAxNyA6IGRhdGEgPCA1MzYuMDUgPyAxOCA6IGRhdGEgPCA1MzYuMTAgPyAxOSA6IGRhdGEgPCA1MzcuMDEgPyAyMCA6IGRhdGEgPCA1MzcuMTEgPyAnMjErJyA6IGRhdGEgPCA1MzcuMTMgPyAyMyA6IGRhdGEgPCA1MzcuMTggPyAyNCA6IGRhdGEgPCA1MzcuMjQgPyAyNSA6IGRhdGEgPCA1MzcuMzYgPyAyNiA6IGxheW91dCAhPSAnQmxpbmsnID8gJzI3JyA6ICcyOCcpO1xuICAgICAgfVxuICAgICAgLy8gQWRkIHRoZSBwb3N0Zml4IG9mIFwiLnhcIiBvciBcIitcIiBmb3IgYXBwcm94aW1hdGUgdmVyc2lvbnMuXG4gICAgICBsYXlvdXQgJiYgKGxheW91dFsxXSArPSAnICcgKyAoZGF0YSArPSB0eXBlb2YgZGF0YSA9PSAnbnVtYmVyJyA/ICcueCcgOiAvWy4rXS8udGVzdChkYXRhKSA/ICcnIDogJysnKSk7XG4gICAgICAvLyBPYnNjdXJlIHZlcnNpb24gZm9yIHNvbWUgU2FmYXJpIDEtMiByZWxlYXNlcy5cbiAgICAgIGlmIChuYW1lID09ICdTYWZhcmknICYmICghdmVyc2lvbiB8fCBwYXJzZUludCh2ZXJzaW9uKSA+IDQ1KSkge1xuICAgICAgICB2ZXJzaW9uID0gZGF0YTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSAnQ2hyb21lJyAmJiAvXFxiSGVhZGxlc3NDaHJvbWUvaS50ZXN0KHVhKSkge1xuICAgICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdoZWFkbGVzcycpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBEZXRlY3QgT3BlcmEgZGVza3RvcCBtb2Rlcy5cbiAgICBpZiAobmFtZSA9PSAnT3BlcmEnICYmICAoZGF0YSA9IC9cXGJ6Ym92fHp2YXYkLy5leGVjKG9zKSkpIHtcbiAgICAgIG5hbWUgKz0gJyAnO1xuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XG4gICAgICBpZiAoZGF0YSA9PSAnenZhdicpIHtcbiAgICAgICAgbmFtZSArPSAnTWluaSc7XG4gICAgICAgIHZlcnNpb24gPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSArPSAnTW9iaWxlJztcbiAgICAgIH1cbiAgICAgIG9zID0gb3MucmVwbGFjZShSZWdFeHAoJyAqJyArIGRhdGEgKyAnJCcpLCAnJyk7XG4gICAgfVxuICAgIC8vIERldGVjdCBDaHJvbWUgZGVza3RvcCBtb2RlLlxuICAgIGVsc2UgaWYgKG5hbWUgPT0gJ1NhZmFyaScgJiYgL1xcYkNocm9tZVxcYi8uZXhlYyhsYXlvdXQgJiYgbGF5b3V0WzFdKSkge1xuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XG4gICAgICBuYW1lID0gJ0Nocm9tZSBNb2JpbGUnO1xuICAgICAgdmVyc2lvbiA9IG51bGw7XG5cbiAgICAgIGlmICgvXFxiT1MgWFxcYi8udGVzdChvcykpIHtcbiAgICAgICAgbWFudWZhY3R1cmVyID0gJ0FwcGxlJztcbiAgICAgICAgb3MgPSAnaU9TIDQuMysnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3MgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBOZXdlciB2ZXJzaW9ucyBvZiBTUldhcmUgSXJvbiB1c2VzIHRoZSBDaHJvbWUgdGFnIHRvIGluZGljYXRlIGl0cyB2ZXJzaW9uIG51bWJlci5cbiAgICBlbHNlIGlmICgvXFxiU1JXYXJlIElyb25cXGIvLnRlc3QobmFtZSkgJiYgIXZlcnNpb24pIHtcbiAgICAgIHZlcnNpb24gPSBnZXRWZXJzaW9uKCdDaHJvbWUnKTtcbiAgICB9XG4gICAgLy8gU3RyaXAgaW5jb3JyZWN0IE9TIHZlcnNpb25zLlxuICAgIGlmICh2ZXJzaW9uICYmIHZlcnNpb24uaW5kZXhPZigoZGF0YSA9IC9bXFxkLl0rJC8uZXhlYyhvcykpKSA9PSAwICYmXG4gICAgICAgIHVhLmluZGV4T2YoJy8nICsgZGF0YSArICctJykgPiAtMSkge1xuICAgICAgb3MgPSB0cmltKG9zLnJlcGxhY2UoZGF0YSwgJycpKTtcbiAgICB9XG4gICAgLy8gRW5zdXJlIE9TIGRvZXMgbm90IGluY2x1ZGUgdGhlIGJyb3dzZXIgbmFtZS5cbiAgICBpZiAob3MgJiYgb3MuaW5kZXhPZihuYW1lKSAhPSAtMSAmJiAhUmVnRXhwKG5hbWUgKyAnIE9TJykudGVzdChvcykpIHtcbiAgICAgIG9zID0gb3MucmVwbGFjZShSZWdFeHAoJyAqJyArIHF1YWxpZnkobmFtZSkgKyAnIConKSwgJycpO1xuICAgIH1cbiAgICAvLyBBZGQgbGF5b3V0IGVuZ2luZS5cbiAgICBpZiAobGF5b3V0ICYmICEvXFxiKD86QXZhbnR8Tm9vaylcXGIvLnRlc3QobmFtZSkgJiYgKFxuICAgICAgICAvQnJvd3NlcnxMdW5hc2NhcGV8TWF4dGhvbi8udGVzdChuYW1lKSB8fFxuICAgICAgICBuYW1lICE9ICdTYWZhcmknICYmIC9eaU9TLy50ZXN0KG9zKSAmJiAvXFxiU2FmYXJpXFxiLy50ZXN0KGxheW91dFsxXSkgfHxcbiAgICAgICAgL14oPzpBZG9iZXxBcm9yYXxCcmVhY2h8TWlkb3JpfE9wZXJhfFBoYW50b218UmVrb25xfFJvY2t8U2Ftc3VuZyBJbnRlcm5ldHxTbGVpcG5pcnxTUldhcmUgSXJvbnxWaXZhbGRpfFdlYikvLnRlc3QobmFtZSkgJiYgbGF5b3V0WzFdKSkge1xuICAgICAgLy8gRG9uJ3QgYWRkIGxheW91dCBkZXRhaWxzIHRvIGRlc2NyaXB0aW9uIGlmIHRoZXkgYXJlIGZhbHNleS5cbiAgICAgIChkYXRhID0gbGF5b3V0W2xheW91dC5sZW5ndGggLSAxXSkgJiYgZGVzY3JpcHRpb24ucHVzaChkYXRhKTtcbiAgICB9XG4gICAgLy8gQ29tYmluZSBjb250ZXh0dWFsIGluZm9ybWF0aW9uLlxuICAgIGlmIChkZXNjcmlwdGlvbi5sZW5ndGgpIHtcbiAgICAgIGRlc2NyaXB0aW9uID0gWycoJyArIGRlc2NyaXB0aW9uLmpvaW4oJzsgJykgKyAnKSddO1xuICAgIH1cbiAgICAvLyBBcHBlbmQgbWFudWZhY3R1cmVyIHRvIGRlc2NyaXB0aW9uLlxuICAgIGlmIChtYW51ZmFjdHVyZXIgJiYgcHJvZHVjdCAmJiBwcm9kdWN0LmluZGV4T2YobWFudWZhY3R1cmVyKSA8IDApIHtcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goJ29uICcgKyBtYW51ZmFjdHVyZXIpO1xuICAgIH1cbiAgICAvLyBBcHBlbmQgcHJvZHVjdCB0byBkZXNjcmlwdGlvbi5cbiAgICBpZiAocHJvZHVjdCkge1xuICAgICAgZGVzY3JpcHRpb24ucHVzaCgoL15vbiAvLnRlc3QoZGVzY3JpcHRpb25bZGVzY3JpcHRpb24ubGVuZ3RoIC0gMV0pID8gJycgOiAnb24gJykgKyBwcm9kdWN0KTtcbiAgICB9XG4gICAgLy8gUGFyc2UgdGhlIE9TIGludG8gYW4gb2JqZWN0LlxuICAgIGlmIChvcykge1xuICAgICAgZGF0YSA9IC8gKFtcXGQuK10rKSQvLmV4ZWMob3MpO1xuICAgICAgaXNTcGVjaWFsQ2FzZWRPUyA9IGRhdGEgJiYgb3MuY2hhckF0KG9zLmxlbmd0aCAtIGRhdGFbMF0ubGVuZ3RoIC0gMSkgPT0gJy8nO1xuICAgICAgb3MgPSB7XG4gICAgICAgICdhcmNoaXRlY3R1cmUnOiAzMixcbiAgICAgICAgJ2ZhbWlseSc6IChkYXRhICYmICFpc1NwZWNpYWxDYXNlZE9TKSA/IG9zLnJlcGxhY2UoZGF0YVswXSwgJycpIDogb3MsXG4gICAgICAgICd2ZXJzaW9uJzogZGF0YSA/IGRhdGFbMV0gOiBudWxsLFxuICAgICAgICAndG9TdHJpbmcnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdmVyc2lvbiA9IHRoaXMudmVyc2lvbjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mYW1pbHkgKyAoKHZlcnNpb24gJiYgIWlzU3BlY2lhbENhc2VkT1MpID8gJyAnICsgdmVyc2lvbiA6ICcnKSArICh0aGlzLmFyY2hpdGVjdHVyZSA9PSA2NCA/ICcgNjQtYml0JyA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gQWRkIGJyb3dzZXIvT1MgYXJjaGl0ZWN0dXJlLlxuICAgIGlmICgoZGF0YSA9IC9cXGIoPzpBTUR8SUF8V2lufFdPV3x4ODZffHgpNjRcXGIvaS5leGVjKGFyY2gpKSAmJiAhL1xcYmk2ODZcXGIvaS50ZXN0KGFyY2gpKSB7XG4gICAgICBpZiAob3MpIHtcbiAgICAgICAgb3MuYXJjaGl0ZWN0dXJlID0gNjQ7XG4gICAgICAgIG9zLmZhbWlseSA9IG9zLmZhbWlseS5yZXBsYWNlKFJlZ0V4cCgnIConICsgZGF0YSksICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgICBuYW1lICYmICgvXFxiV09XNjRcXGIvaS50ZXN0KHVhKSB8fFxuICAgICAgICAgICh1c2VGZWF0dXJlcyAmJiAvXFx3KD86ODZ8MzIpJC8udGVzdChuYXYuY3B1Q2xhc3MgfHwgbmF2LnBsYXRmb3JtKSAmJiAhL1xcYldpbjY0OyB4NjRcXGIvaS50ZXN0KHVhKSkpXG4gICAgICApIHtcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnMzItYml0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENocm9tZSAzOSBhbmQgYWJvdmUgb24gT1MgWCBpcyBhbHdheXMgNjQtYml0LlxuICAgIGVsc2UgaWYgKFxuICAgICAgICBvcyAmJiAvXk9TIFgvLnRlc3Qob3MuZmFtaWx5KSAmJlxuICAgICAgICBuYW1lID09ICdDaHJvbWUnICYmIHBhcnNlRmxvYXQodmVyc2lvbikgPj0gMzlcbiAgICApIHtcbiAgICAgIG9zLmFyY2hpdGVjdHVyZSA9IDY0O1xuICAgIH1cblxuICAgIHVhIHx8ICh1YSA9IG51bGwpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBsYXRmb3JtIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYXRmb3JtXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICovXG4gICAgdmFyIHBsYXRmb3JtID0ge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGxhdGZvcm0gZGVzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxuICAgICAqL1xuICAgIHBsYXRmb3JtLmRlc2NyaXB0aW9uID0gdWE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgYnJvd3NlcidzIGxheW91dCBlbmdpbmUuXG4gICAgICpcbiAgICAgKiBUaGUgbGlzdCBvZiBjb21tb24gbGF5b3V0IGVuZ2luZXMgaW5jbHVkZTpcbiAgICAgKiBcIkJsaW5rXCIsIFwiRWRnZUhUTUxcIiwgXCJHZWNrb1wiLCBcIlRyaWRlbnRcIiBhbmQgXCJXZWJLaXRcIlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICBwbGF0Zm9ybS5sYXlvdXQgPSBsYXlvdXQgJiYgbGF5b3V0WzBdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb2R1Y3QncyBtYW51ZmFjdHVyZXIuXG4gICAgICpcbiAgICAgKiBUaGUgbGlzdCBvZiBtYW51ZmFjdHVyZXJzIGluY2x1ZGU6XG4gICAgICogXCJBcHBsZVwiLCBcIkFyY2hvc1wiLCBcIkFtYXpvblwiLCBcIkFzdXNcIiwgXCJCYXJuZXMgJiBOb2JsZVwiLCBcIkJsYWNrQmVycnlcIixcbiAgICAgKiBcIkdvb2dsZVwiLCBcIkhQXCIsIFwiSFRDXCIsIFwiTEdcIiwgXCJNaWNyb3NvZnRcIiwgXCJNb3Rvcm9sYVwiLCBcIk5pbnRlbmRvXCIsXG4gICAgICogXCJOb2tpYVwiLCBcIlNhbXN1bmdcIiBhbmQgXCJTb255XCJcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybVxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXG4gICAgICovXG4gICAgcGxhdGZvcm0ubWFudWZhY3R1cmVyID0gbWFudWZhY3R1cmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGJyb3dzZXIvZW52aXJvbm1lbnQuXG4gICAgICpcbiAgICAgKiBUaGUgbGlzdCBvZiBjb21tb24gYnJvd3NlciBuYW1lcyBpbmNsdWRlOlxuICAgICAqIFwiQ2hyb21lXCIsIFwiRWxlY3Ryb25cIiwgXCJGaXJlZm94XCIsIFwiRmlyZWZveCBmb3IgaU9TXCIsIFwiSUVcIixcbiAgICAgKiBcIk1pY3Jvc29mdCBFZGdlXCIsIFwiUGhhbnRvbUpTXCIsIFwiU2FmYXJpXCIsIFwiU2VhTW9ua2V5XCIsIFwiU2lsa1wiLFxuICAgICAqIFwiT3BlcmEgTWluaVwiIGFuZCBcIk9wZXJhXCJcbiAgICAgKlxuICAgICAqIE1vYmlsZSB2ZXJzaW9ucyBvZiBzb21lIGJyb3dzZXJzIGhhdmUgXCJNb2JpbGVcIiBhcHBlbmRlZCB0byB0aGVpciBuYW1lOlxuICAgICAqIGVnLiBcIkNocm9tZSBNb2JpbGVcIiwgXCJGaXJlZm94IE1vYmlsZVwiLCBcIklFIE1vYmlsZVwiIGFuZCBcIk9wZXJhIE1vYmlsZVwiXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxuICAgICAqL1xuICAgIHBsYXRmb3JtLm5hbWUgPSBuYW1lO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGFscGhhL2JldGEgcmVsZWFzZSBpbmRpY2F0b3IuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxuICAgICAqL1xuICAgIHBsYXRmb3JtLnByZXJlbGVhc2UgPSBwcmVyZWxlYXNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb2R1Y3QgaG9zdGluZyB0aGUgYnJvd3Nlci5cbiAgICAgKlxuICAgICAqIFRoZSBsaXN0IG9mIGNvbW1vbiBwcm9kdWN0cyBpbmNsdWRlOlxuICAgICAqXG4gICAgICogXCJCbGFja0JlcnJ5XCIsIFwiR2FsYXh5IFM0XCIsIFwiTHVtaWFcIiwgXCJpUGFkXCIsIFwiaVBvZFwiLCBcImlQaG9uZVwiLCBcIktpbmRsZVwiLFxuICAgICAqIFwiS2luZGxlIEZpcmVcIiwgXCJOZXh1c1wiLCBcIk5vb2tcIiwgXCJQbGF5Qm9va1wiLCBcIlRvdWNoUGFkXCIgYW5kIFwiVHJhbnNmb3JtZXJcIlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICBwbGF0Zm9ybS5wcm9kdWN0ID0gcHJvZHVjdDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBicm93c2VyJ3MgdXNlciBhZ2VudCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxuICAgICAqL1xuICAgIHBsYXRmb3JtLnVhID0gdWE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYnJvd3Nlci9lbnZpcm9ubWVudCB2ZXJzaW9uLlxuICAgICAqXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXG4gICAgICogQHR5cGUgc3RyaW5nfG51bGxcbiAgICAgKi9cbiAgICBwbGF0Zm9ybS52ZXJzaW9uID0gbmFtZSAmJiB2ZXJzaW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIG9wZXJhdGluZyBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cbiAgICBwbGF0Zm9ybS5vcyA9IG9zIHx8IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgQ1BVIGFyY2hpdGVjdHVyZSB0aGUgT1MgaXMgYnVpbHQgZm9yLlxuICAgICAgICpcbiAgICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybS5vc1xuICAgICAgICogQHR5cGUgbnVtYmVyfG51bGxcbiAgICAgICAqL1xuICAgICAgJ2FyY2hpdGVjdHVyZSc6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGZhbWlseSBvZiB0aGUgT1MuXG4gICAgICAgKlxuICAgICAgICogQ29tbW9uIHZhbHVlcyBpbmNsdWRlOlxuICAgICAgICogXCJXaW5kb3dzXCIsIFwiV2luZG93cyBTZXJ2ZXIgMjAwOCBSMiAvIDdcIiwgXCJXaW5kb3dzIFNlcnZlciAyMDA4IC8gVmlzdGFcIixcbiAgICAgICAqIFwiV2luZG93cyBYUFwiLCBcIk9TIFhcIiwgXCJMaW51eFwiLCBcIlVidW50dVwiLCBcIkRlYmlhblwiLCBcIkZlZG9yYVwiLCBcIlJlZCBIYXRcIixcbiAgICAgICAqIFwiU3VTRVwiLCBcIkFuZHJvaWRcIiwgXCJpT1NcIiBhbmQgXCJXaW5kb3dzIFBob25lXCJcbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm0ub3NcbiAgICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXG4gICAgICAgKi9cbiAgICAgICdmYW1pbHknOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPUy5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm0ub3NcbiAgICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXG4gICAgICAgKi9cbiAgICAgICd2ZXJzaW9uJzogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBPUyBzdHJpbmcuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIHBsYXRmb3JtLm9zXG4gICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgT1Mgc3RyaW5nLlxuICAgICAgICovXG4gICAgICAndG9TdHJpbmcnOiBmdW5jdGlvbigpIHsgcmV0dXJuICdudWxsJzsgfVxuICAgIH07XG5cbiAgICBwbGF0Zm9ybS5wYXJzZSA9IHBhcnNlO1xuICAgIHBsYXRmb3JtLnRvU3RyaW5nID0gdG9TdHJpbmdQbGF0Zm9ybTtcblxuICAgIGlmIChwbGF0Zm9ybS52ZXJzaW9uKSB7XG4gICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KHZlcnNpb24pO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm0ubmFtZSkge1xuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdChuYW1lKTtcbiAgICB9XG4gICAgaWYgKG9zICYmIG5hbWUgJiYgIShvcyA9PSBTdHJpbmcob3MpLnNwbGl0KCcgJylbMF0gJiYgKG9zID09IG5hbWUuc3BsaXQoJyAnKVswXSB8fCBwcm9kdWN0KSkpIHtcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2gocHJvZHVjdCA/ICcoJyArIG9zICsgJyknIDogJ29uICcgKyBvcyk7XG4gICAgfVxuICAgIGlmIChkZXNjcmlwdGlvbi5sZW5ndGgpIHtcbiAgICAgIHBsYXRmb3JtLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24uam9pbignICcpO1xuICAgIH1cbiAgICByZXR1cm4gcGxhdGZvcm07XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBFeHBvcnQgcGxhdGZvcm0uXG4gIHZhciBwbGF0Zm9ybSA9IHBhcnNlKCk7XG5cbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2UgdGhlIGZvbGxvd2luZzpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIHBsYXRmb3JtIG9uIHRoZSBnbG9iYWwgb2JqZWN0IHRvIHByZXZlbnQgZXJyb3JzIHdoZW4gcGxhdGZvcm0gaXNcbiAgICAvLyBsb2FkZWQgYnkgYSBzY3JpcHQgdGFnIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTUQgbG9hZGVyLlxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvciBtb3JlIGRldGFpbHMuXG4gICAgcm9vdC5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28gcGxhdGZvcm0gY2FuIGJlIGFsaWFzZWQgdGhyb3VnaCBwYXRoIG1hcHBpbmcuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHBsYXRmb3JtO1xuICAgIH0pO1xuICB9XG4gIC8vIENoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuIGBleHBvcnRzYCBvYmplY3QuXG4gIGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIHN1cHBvcnQuXG4gICAgZm9yT3duKHBsYXRmb3JtLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICBmcmVlRXhwb3J0c1trZXldID0gdmFsdWU7XG4gICAgfSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gRXhwb3J0IHRvIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiIsImltcG9ydHt1c2VTdGF0ZSBhcyBuLHVzZVJlZHVjZXIgYXMgdCx1c2VFZmZlY3QgYXMgZSx1c2VMYXlvdXRFZmZlY3QgYXMgcix1c2VSZWYgYXMgbyx1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHUsdXNlTWVtbyBhcyBpLHVzZUNhbGxiYWNrIGFzIGYsdXNlQ29udGV4dCBhcyBjLHVzZURlYnVnVmFsdWUgYXMgbH1mcm9tXCJwcmVhY3QvaG9va3NcIjtleHBvcnQqZnJvbVwicHJlYWN0L2hvb2tzXCI7aW1wb3J0e0NvbXBvbmVudCBhcyBhLGNyZWF0ZUVsZW1lbnQgYXMgcyxvcHRpb25zIGFzIGgsdG9DaGlsZEFycmF5IGFzIHAsRnJhZ21lbnQgYXMgdixyZW5kZXIgYXMgZCxoeWRyYXRlIGFzIG0sY2xvbmVFbGVtZW50IGFzIHksY3JlYXRlUmVmIGFzIGIsY3JlYXRlQ29udGV4dCBhcyBffWZyb21cInByZWFjdFwiO2V4cG9ydHtjcmVhdGVFbGVtZW50LGNyZWF0ZUNvbnRleHQsY3JlYXRlUmVmLEZyYWdtZW50LENvbXBvbmVudH1mcm9tXCJwcmVhY3RcIjtmdW5jdGlvbiBDKG4sdCl7Zm9yKHZhciBlIGluIHQpbltlXT10W2VdO3JldHVybiBufWZ1bmN0aW9uIFMobix0KXtmb3IodmFyIGUgaW4gbilpZihcIl9fc291cmNlXCIhPT1lJiYhKGUgaW4gdCkpcmV0dXJuITA7Zm9yKHZhciByIGluIHQpaWYoXCJfX3NvdXJjZVwiIT09ciYmbltyXSE9PXRbcl0pcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gRShuKXt0aGlzLnByb3BzPW59ZnVuY3Rpb24gZyhuLHQpe2Z1bmN0aW9uIGUobil7dmFyIGU9dGhpcy5wcm9wcy5yZWYscj1lPT1uLnJlZjtyZXR1cm4hciYmZSYmKGUuY2FsbD9lKG51bGwpOmUuY3VycmVudD1udWxsKSx0PyF0KHRoaXMucHJvcHMsbil8fCFyOlModGhpcy5wcm9wcyxuKX1mdW5jdGlvbiByKHQpe3JldHVybiB0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZT1lLHMobix0KX1yZXR1cm4gci5kaXNwbGF5TmFtZT1cIk1lbW8oXCIrKG4uZGlzcGxheU5hbWV8fG4ubmFtZSkrXCIpXCIsci5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD0hMCxyLl9fZj0hMCxyfShFLnByb3RvdHlwZT1uZXcgYSkuaXNQdXJlUmVhY3RDb21wb25lbnQ9ITAsRS5wcm90b3R5cGUuc2hvdWxkQ29tcG9uZW50VXBkYXRlPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIFModGhpcy5wcm9wcyxuKXx8Uyh0aGlzLnN0YXRlLHQpfTt2YXIgdz1oLl9fYjtoLl9fYj1mdW5jdGlvbihuKXtuLnR5cGUmJm4udHlwZS5fX2YmJm4ucmVmJiYobi5wcm9wcy5yZWY9bi5yZWYsbi5yZWY9bnVsbCksdyYmdyhuKX07dmFyIFI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLmZvciYmU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpfHwzOTExO2Z1bmN0aW9uIHgobil7ZnVuY3Rpb24gdCh0LGUpe3ZhciByPUMoe30sdCk7cmV0dXJuIGRlbGV0ZSByLnJlZixuKHIsKGU9dC5yZWZ8fGUpJiYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fFwiY3VycmVudFwiaW4gZSk/ZTpudWxsKX1yZXR1cm4gdC4kJHR5cGVvZj1SLHQucmVuZGVyPXQsdC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD10Ll9fZj0hMCx0LmRpc3BsYXlOYW1lPVwiRm9yd2FyZFJlZihcIisobi5kaXNwbGF5TmFtZXx8bi5uYW1lKStcIilcIix0fXZhciBOPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG51bGw9PW4/bnVsbDpwKHAobikubWFwKHQpKX0saz17bWFwOk4sZm9yRWFjaDpOLGNvdW50OmZ1bmN0aW9uKG4pe3JldHVybiBuP3AobikubGVuZ3RoOjB9LG9ubHk6ZnVuY3Rpb24obil7dmFyIHQ9cChuKTtpZigxIT09dC5sZW5ndGgpdGhyb3dcIkNoaWxkcmVuLm9ubHlcIjtyZXR1cm4gdFswXX0sdG9BcnJheTpwfSxBPWguX19lO2Z1bmN0aW9uIE8oKXt0aGlzLl9fdT0wLHRoaXMudD1udWxsLHRoaXMuX19iPW51bGx9ZnVuY3Rpb24gTChuKXt2YXIgdD1uLl9fLl9fYztyZXR1cm4gdCYmdC5fX2UmJnQuX19lKG4pfWZ1bmN0aW9uIFUobil7dmFyIHQsZSxyO2Z1bmN0aW9uIG8obyl7aWYodHx8KHQ9bigpKS50aGVuKGZ1bmN0aW9uKG4pe2U9bi5kZWZhdWx0fHxufSxmdW5jdGlvbihuKXtyPW59KSxyKXRocm93IHI7aWYoIWUpdGhyb3cgdDtyZXR1cm4gcyhlLG8pfXJldHVybiBvLmRpc3BsYXlOYW1lPVwiTGF6eVwiLG8uX19mPSEwLG99ZnVuY3Rpb24gRCgpe3RoaXMubz1udWxsLHRoaXMudT1udWxsfWguX19lPWZ1bmN0aW9uKG4sdCxlKXtpZihuLnRoZW4pZm9yKHZhciByLG89dDtvPW8uX187KWlmKChyPW8uX19jKSYmci5fX2MpcmV0dXJuIG51bGw9PXQuX19lJiYodC5fX2U9ZS5fX2UsdC5fX2s9ZS5fX2spLHIuX19jKG4sdCk7QShuLHQsZSl9LChPLnByb3RvdHlwZT1uZXcgYSkuX19jPWZ1bmN0aW9uKG4sdCl7dmFyIGU9dC5fX2Mscj10aGlzO251bGw9PXIudCYmKHIudD1bXSksci50LnB1c2goZSk7dmFyIG89TChyLl9fdiksdT0hMSxpPWZ1bmN0aW9uKCl7dXx8KHU9ITAsZS5jb21wb25lbnRXaWxsVW5tb3VudD1lLl9fYyxvP28oZik6ZigpKX07ZS5fX2M9ZS5jb21wb25lbnRXaWxsVW5tb3VudCxlLmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7aSgpLGUuX19jJiZlLl9fYygpfTt2YXIgZj1mdW5jdGlvbigpe2lmKCEtLXIuX191KXtpZihyLnN0YXRlLl9fZSl7dmFyIG49ci5zdGF0ZS5fX2U7ci5fX3YuX19rWzBdPWZ1bmN0aW9uIG4odCxlLHIpe3JldHVybiB0JiYodC5fX3Y9bnVsbCx0Ll9faz10Ll9fayYmdC5fX2subWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuKHQsZSxyKX0pLHQuX19jJiZ0Ll9fYy5fX1A9PT1lJiYodC5fX2UmJnIuaW5zZXJ0QmVmb3JlKHQuX19lLHQuX19kKSx0Ll9fYy5fX2U9ITAsdC5fX2MuX19QPXIpKSx0fShuLG4uX19jLl9fUCxuLl9fYy5fX08pfXZhciB0O2ZvcihyLnNldFN0YXRlKHtfX2U6ci5fX2I9bnVsbH0pO3Q9ci50LnBvcCgpOyl0LmZvcmNlVXBkYXRlKCl9fSxjPSEwPT09dC5fX2g7ci5fX3UrK3x8Y3x8ci5zZXRTdGF0ZSh7X19lOnIuX19iPXIuX192Ll9fa1swXX0pLG4udGhlbihpLGkpfSxPLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudD1mdW5jdGlvbigpe3RoaXMudD1bXX0sTy5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKG4sdCl7aWYodGhpcy5fX2Ipe2lmKHRoaXMuX192Ll9fayl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxyPXRoaXMuX192Ll9fa1swXS5fX2M7dGhpcy5fX3YuX19rWzBdPWZ1bmN0aW9uIG4odCxlLHIpe3JldHVybiB0JiYodC5fX2MmJnQuX19jLl9fSCYmKHQuX19jLl9fSC5fXy5mb3JFYWNoKGZ1bmN0aW9uKG4pe1wiZnVuY3Rpb25cIj09dHlwZW9mIG4uX19jJiZuLl9fYygpfSksdC5fX2MuX19IPW51bGwpLG51bGwhPSh0PUMoe30sdCkpLl9fYyYmKHQuX19jLl9fUD09PXImJih0Ll9fYy5fX1A9ZSksdC5fX2M9bnVsbCksdC5fX2s9dC5fX2smJnQuX19rLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbih0LGUscil9KSksdH0odGhpcy5fX2IsZSxyLl9fTz1yLl9fUCl9dGhpcy5fX2I9bnVsbH12YXIgbz10Ll9fZSYmcyh2LG51bGwsbi5mYWxsYmFjayk7cmV0dXJuIG8mJihvLl9faD1udWxsKSxbcyh2LG51bGwsdC5fX2U/bnVsbDpuLmNoaWxkcmVuKSxvXX07dmFyIEY9ZnVuY3Rpb24obix0LGUpe2lmKCsrZVsxXT09PWVbMF0mJm4udS5kZWxldGUodCksbi5wcm9wcy5yZXZlYWxPcmRlciYmKFwidFwiIT09bi5wcm9wcy5yZXZlYWxPcmRlclswXXx8IW4udS5zaXplKSlmb3IoZT1uLm87ZTspe2Zvcig7ZS5sZW5ndGg+MzspZS5wb3AoKSgpO2lmKGVbMV08ZVswXSlicmVhaztuLm89ZT1lWzJdfX07ZnVuY3Rpb24gTShuKXtyZXR1cm4gdGhpcy5nZXRDaGlsZENvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm4gbi5jb250ZXh0fSxuLmNoaWxkcmVufWZ1bmN0aW9uIFQobil7dmFyIHQ9dGhpcyxlPW4uaTt0LmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7ZChudWxsLHQubCksdC5sPW51bGwsdC5pPW51bGx9LHQuaSYmdC5pIT09ZSYmdC5jb21wb25lbnRXaWxsVW5tb3VudCgpLG4uX192Pyh0Lmx8fCh0Lmk9ZSx0Lmw9e25vZGVUeXBlOjEscGFyZW50Tm9kZTplLGNoaWxkTm9kZXM6W10sYXBwZW5kQ2hpbGQ6ZnVuY3Rpb24obil7dGhpcy5jaGlsZE5vZGVzLnB1c2gobiksdC5pLmFwcGVuZENoaWxkKG4pfSxpbnNlcnRCZWZvcmU6ZnVuY3Rpb24obixlKXt0aGlzLmNoaWxkTm9kZXMucHVzaChuKSx0LmkuYXBwZW5kQ2hpbGQobil9LHJlbW92ZUNoaWxkOmZ1bmN0aW9uKG4pe3RoaXMuY2hpbGROb2Rlcy5zcGxpY2UodGhpcy5jaGlsZE5vZGVzLmluZGV4T2Yobik+Pj4xLDEpLHQuaS5yZW1vdmVDaGlsZChuKX19KSxkKHMoTSx7Y29udGV4dDp0LmNvbnRleHR9LG4uX192KSx0LmwpKTp0LmwmJnQuY29tcG9uZW50V2lsbFVubW91bnQoKX1mdW5jdGlvbiBqKG4sdCl7cmV0dXJuIHMoVCx7X192Om4saTp0fSl9KEQucHJvdG90eXBlPW5ldyBhKS5fX2U9ZnVuY3Rpb24obil7dmFyIHQ9dGhpcyxlPUwodC5fX3YpLHI9dC51LmdldChuKTtyZXR1cm4gclswXSsrLGZ1bmN0aW9uKG8pe3ZhciB1PWZ1bmN0aW9uKCl7dC5wcm9wcy5yZXZlYWxPcmRlcj8oci5wdXNoKG8pLEYodCxuLHIpKTpvKCl9O2U/ZSh1KTp1KCl9fSxELnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24obil7dGhpcy5vPW51bGwsdGhpcy51PW5ldyBNYXA7dmFyIHQ9cChuLmNoaWxkcmVuKTtuLnJldmVhbE9yZGVyJiZcImJcIj09PW4ucmV2ZWFsT3JkZXJbMF0mJnQucmV2ZXJzZSgpO2Zvcih2YXIgZT10Lmxlbmd0aDtlLS07KXRoaXMudS5zZXQodFtlXSx0aGlzLm89WzEsMCx0aGlzLm9dKTtyZXR1cm4gbi5jaGlsZHJlbn0sRC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlPUQucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50PWZ1bmN0aW9uKCl7dmFyIG49dGhpczt0aGlzLnUuZm9yRWFjaChmdW5jdGlvbih0LGUpe0YobixlLHQpfSl9O3ZhciBJPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5mb3ImJlN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpfHw2MDEwMyxXPS9eKD86YWNjZW50fGFsaWdubWVudHxhcmFiaWN8YmFzZWxpbmV8Y2FwfGNsaXAoPyFQYXRoVSl8Y29sb3J8ZmlsbHxmbG9vZHxmb250fGdseXBoKD8hUil8aG9yaXp8bWFya2VyKD8hSHxXfFUpfG92ZXJsaW5lfHBhaW50fHN0b3B8c3RyaWtldGhyb3VnaHxzdHJva2V8dGV4dCg/IUwpfHVuZGVybGluZXx1bmljb2RlfHVuaXRzfHZ8dmVjdG9yfHZlcnR8d29yZHx3cml0aW5nfHgoPyFDKSlbQS1aXS8sUD1mdW5jdGlvbihuKXtyZXR1cm4oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbCgpPy9maWx8Y2hlfHJhZC9pOi9maWx8Y2hlfHJhL2kpLnRlc3Qobil9O2Z1bmN0aW9uIHoobix0LGUpe3JldHVybiBudWxsPT10Ll9fayYmKHQudGV4dENvbnRlbnQ9XCJcIiksZChuLHQpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJmUoKSxuP24uX19jOm51bGx9ZnVuY3Rpb24gQihuLHQsZSl7cmV0dXJuIG0obix0KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlKCksbj9uLl9fYzpudWxsfWEucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ9e30sW1wiY29tcG9uZW50V2lsbE1vdW50XCIsXCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXCIsXCJjb21wb25lbnRXaWxsVXBkYXRlXCJdLmZvckVhY2goZnVuY3Rpb24obil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEucHJvdG90eXBlLG4se2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tcIlVOU0FGRV9cIituXX0sc2V0OmZ1bmN0aW9uKHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLG4se2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSl9fSl9KTt2YXIgVj1oLmV2ZW50O2Z1bmN0aW9uIEgoKXt9ZnVuY3Rpb24gWigpe3JldHVybiB0aGlzLmNhbmNlbEJ1YmJsZX1mdW5jdGlvbiBZKCl7cmV0dXJuIHRoaXMuZGVmYXVsdFByZXZlbnRlZH1oLmV2ZW50PWZ1bmN0aW9uKG4pe3JldHVybiBWJiYobj1WKG4pKSxuLnBlcnNpc3Q9SCxuLmlzUHJvcGFnYXRpb25TdG9wcGVkPVosbi5pc0RlZmF1bHRQcmV2ZW50ZWQ9WSxuLm5hdGl2ZUV2ZW50PW59O3ZhciAkLHE9e2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbGFzc319LEc9aC52bm9kZTtoLnZub2RlPWZ1bmN0aW9uKG4pe3ZhciB0PW4udHlwZSxlPW4ucHJvcHMscj1lO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXtmb3IodmFyIG8gaW4gcj17fSxlKXt2YXIgdT1lW29dO1wiZGVmYXVsdFZhbHVlXCI9PT1vJiZcInZhbHVlXCJpbiBlJiZudWxsPT1lLnZhbHVlP289XCJ2YWx1ZVwiOlwiZG93bmxvYWRcIj09PW8mJiEwPT09dT91PVwiXCI6L29uZG91YmxlY2xpY2svaS50ZXN0KG8pP289XCJvbmRibGNsaWNrXCI6L15vbmNoYW5nZSh0ZXh0YXJlYXxpbnB1dCkvaS50ZXN0KG8rdCkmJiFQKGUudHlwZSk/bz1cIm9uaW5wdXRcIjovXm9uKEFuaXxUcmF8VG91fEJlZm9yZUlucCkvLnRlc3Qobyk/bz1vLnRvTG93ZXJDYXNlKCk6Vy50ZXN0KG8pP289by5yZXBsYWNlKC9bQS1aMC05XS8sXCItJCZcIikudG9Mb3dlckNhc2UoKTpudWxsPT09dSYmKHU9dm9pZCAwKSxyW29dPXV9XCJzZWxlY3RcIj09dCYmci5tdWx0aXBsZSYmQXJyYXkuaXNBcnJheShyLnZhbHVlKSYmKHIudmFsdWU9cChlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe24ucHJvcHMuc2VsZWN0ZWQ9LTEhPXIudmFsdWUuaW5kZXhPZihuLnByb3BzLnZhbHVlKX0pKSxcInNlbGVjdFwiPT10JiZudWxsIT1yLmRlZmF1bHRWYWx1ZSYmKHIudmFsdWU9cChlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe24ucHJvcHMuc2VsZWN0ZWQ9ci5tdWx0aXBsZT8tMSE9ci5kZWZhdWx0VmFsdWUuaW5kZXhPZihuLnByb3BzLnZhbHVlKTpyLmRlZmF1bHRWYWx1ZT09bi5wcm9wcy52YWx1ZX0pKSxuLnByb3BzPXJ9dCYmZS5jbGFzcyE9ZS5jbGFzc05hbWUmJihxLmVudW1lcmFibGU9XCJjbGFzc05hbWVcImluIGUsbnVsbCE9ZS5jbGFzc05hbWUmJihyLmNsYXNzPWUuY2xhc3NOYW1lKSxPYmplY3QuZGVmaW5lUHJvcGVydHkocixcImNsYXNzTmFtZVwiLHEpKSxuLiQkdHlwZW9mPUksRyYmRyhuKX07dmFyIEo9aC5fX3I7aC5fX3I9ZnVuY3Rpb24obil7SiYmSihuKSwkPW4uX19jfTt2YXIgSz17UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjp7Y3VycmVudDp7cmVhZENvbnRleHQ6ZnVuY3Rpb24obil7cmV0dXJuICQuX19uW24uX19jXS5wcm9wcy52YWx1ZX19fX0sUT0xLFg9Mixubj0zLHRuPTQsZW49NTtmdW5jdGlvbiBybihuLHQpe3JldHVybiB0KCl9dmFyIG9uPVwib2JqZWN0XCI9PXR5cGVvZiBwZXJmb3JtYW5jZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgcGVyZm9ybWFuY2Uubm93P3BlcmZvcm1hbmNlLm5vdy5iaW5kKHBlcmZvcm1hbmNlKTpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfSx1bj1cIjE2LjguMFwiO2Z1bmN0aW9uIGZuKG4pe3JldHVybiBzLmJpbmQobnVsbCxuKX1mdW5jdGlvbiBjbihuKXtyZXR1cm4hIW4mJm4uJCR0eXBlb2Y9PT1JfWZ1bmN0aW9uIGxuKG4pe3JldHVybiBjbihuKT95LmFwcGx5KG51bGwsYXJndW1lbnRzKTpufWZ1bmN0aW9uIGFuKG4pe3JldHVybiEhbi5fX2smJihkKG51bGwsbiksITApfWZ1bmN0aW9uIHNuKG4pe3JldHVybiBuJiYobi5iYXNlfHwxPT09bi5ub2RlVHlwZSYmbil8fG51bGx9dmFyIGhuPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4odCl9LHBuPXY7ZXhwb3J0IGRlZmF1bHR7dXNlU3RhdGU6bix1c2VSZWR1Y2VyOnQsdXNlRWZmZWN0OmUsdXNlTGF5b3V0RWZmZWN0OnIsdXNlUmVmOm8sdXNlSW1wZXJhdGl2ZUhhbmRsZTp1LHVzZU1lbW86aSx1c2VDYWxsYmFjazpmLHVzZUNvbnRleHQ6Yyx1c2VEZWJ1Z1ZhbHVlOmwsdmVyc2lvbjpcIjE2LjguMFwiLENoaWxkcmVuOmsscmVuZGVyOnosaHlkcmF0ZTpCLHVubW91bnRDb21wb25lbnRBdE5vZGU6YW4sY3JlYXRlUG9ydGFsOmosY3JlYXRlRWxlbWVudDpzLGNyZWF0ZUNvbnRleHQ6XyxjcmVhdGVGYWN0b3J5OmZuLGNsb25lRWxlbWVudDpsbixjcmVhdGVSZWY6YixGcmFnbWVudDp2LGlzVmFsaWRFbGVtZW50OmNuLGZpbmRET01Ob2RlOnNuLENvbXBvbmVudDphLFB1cmVDb21wb25lbnQ6RSxtZW1vOmcsZm9yd2FyZFJlZjp4LHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOmhuLFN0cmljdE1vZGU6dixTdXNwZW5zZTpPLFN1c3BlbnNlTGlzdDpELGxhenk6VSxfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDpLfTtleHBvcnR7dW4gYXMgdmVyc2lvbixrIGFzIENoaWxkcmVuLHogYXMgcmVuZGVyLEIgYXMgaHlkcmF0ZSxhbiBhcyB1bm1vdW50Q29tcG9uZW50QXROb2RlLGogYXMgY3JlYXRlUG9ydGFsLGZuIGFzIGNyZWF0ZUZhY3RvcnksbG4gYXMgY2xvbmVFbGVtZW50LGNuIGFzIGlzVmFsaWRFbGVtZW50LHNuIGFzIGZpbmRET01Ob2RlLEUgYXMgUHVyZUNvbXBvbmVudCxnIGFzIG1lbW8seCBhcyBmb3J3YXJkUmVmLGhuIGFzIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzLHBuIGFzIFN0cmljdE1vZGUsTyBhcyBTdXNwZW5zZSxEIGFzIFN1c3BlbnNlTGlzdCxVIGFzIGxhenksSyBhcyBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCxRIGFzIHVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5LFggYXMgdW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHksbm4gYXMgdW5zdGFibGVfTm9ybWFsUHJpb3JpdHksdG4gYXMgdW5zdGFibGVfTG93UHJpb3JpdHksZW4gYXMgdW5zdGFibGVfSWRsZVByaW9yaXR5LHJuIGFzIHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSxvbiBhcyB1bnN0YWJsZV9ub3d9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGF0Lm1vZHVsZS5qcy5tYXBcbiIsInZhciBuLGwsdSxpLHQscixvPXt9LGY9W10sZT0vYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofGdyaWR8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZHxpdGVyYS9pO2Z1bmN0aW9uIGMobixsKXtmb3IodmFyIHUgaW4gbCluW3VdPWxbdV07cmV0dXJuIG59ZnVuY3Rpb24gcyhuKXt2YXIgbD1uLnBhcmVudE5vZGU7bCYmbC5yZW1vdmVDaGlsZChuKX1mdW5jdGlvbiBhKG4sbCx1KXt2YXIgaSx0LHIsbz1hcmd1bWVudHMsZj17fTtmb3IociBpbiBsKVwia2V5XCI9PXI/aT1sW3JdOlwicmVmXCI9PXI/dD1sW3JdOmZbcl09bFtyXTtpZihhcmd1bWVudHMubGVuZ3RoPjMpZm9yKHU9W3VdLHI9MztyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXUucHVzaChvW3JdKTtpZihudWxsIT11JiYoZi5jaGlsZHJlbj11KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBuJiZudWxsIT1uLmRlZmF1bHRQcm9wcylmb3IociBpbiBuLmRlZmF1bHRQcm9wcyl2b2lkIDA9PT1mW3JdJiYoZltyXT1uLmRlZmF1bHRQcm9wc1tyXSk7cmV0dXJuIHYobixmLGksdCxudWxsKX1mdW5jdGlvbiB2KGwsdSxpLHQscil7dmFyIG89e3R5cGU6bCxwcm9wczp1LGtleTppLHJlZjp0LF9fazpudWxsLF9fOm51bGwsX19iOjAsX19lOm51bGwsX19kOnZvaWQgMCxfX2M6bnVsbCxfX2g6bnVsbCxjb25zdHJ1Y3Rvcjp2b2lkIDAsX192Om51bGw9PXI/KytuLl9fdjpyfTtyZXR1cm4gbnVsbCE9bi52bm9kZSYmbi52bm9kZShvKSxvfWZ1bmN0aW9uIGgoKXtyZXR1cm57Y3VycmVudDpudWxsfX1mdW5jdGlvbiB5KG4pe3JldHVybiBuLmNoaWxkcmVufWZ1bmN0aW9uIHAobixsKXt0aGlzLnByb3BzPW4sdGhpcy5jb250ZXh0PWx9ZnVuY3Rpb24gZChuLGwpe2lmKG51bGw9PWwpcmV0dXJuIG4uX18/ZChuLl9fLG4uX18uX19rLmluZGV4T2YobikrMSk6bnVsbDtmb3IodmFyIHU7bDxuLl9fay5sZW5ndGg7bCsrKWlmKG51bGwhPSh1PW4uX19rW2xdKSYmbnVsbCE9dS5fX2UpcmV0dXJuIHUuX19lO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIG4udHlwZT9kKG4pOm51bGx9ZnVuY3Rpb24gXyhuKXt2YXIgbCx1O2lmKG51bGwhPShuPW4uX18pJiZudWxsIT1uLl9fYyl7Zm9yKG4uX19lPW4uX19jLmJhc2U9bnVsbCxsPTA7bDxuLl9fay5sZW5ndGg7bCsrKWlmKG51bGwhPSh1PW4uX19rW2xdKSYmbnVsbCE9dS5fX2Upe24uX19lPW4uX19jLmJhc2U9dS5fX2U7YnJlYWt9cmV0dXJuIF8obil9fWZ1bmN0aW9uIGsobCl7KCFsLl9fZCYmKGwuX19kPSEwKSYmdS5wdXNoKGwpJiYhbS5fX3IrK3x8dCE9PW4uZGVib3VuY2VSZW5kZXJpbmcpJiYoKHQ9bi5kZWJvdW5jZVJlbmRlcmluZyl8fGkpKG0pfWZ1bmN0aW9uIG0oKXtmb3IodmFyIG47bS5fX3I9dS5sZW5ndGg7KW49dS5zb3J0KGZ1bmN0aW9uKG4sbCl7cmV0dXJuIG4uX192Ll9fYi1sLl9fdi5fX2J9KSx1PVtdLG4uc29tZShmdW5jdGlvbihuKXt2YXIgbCx1LGksdCxyLG87bi5fX2QmJihyPSh0PShsPW4pLl9fdikuX19lLChvPWwuX19QKSYmKHU9W10sKGk9Yyh7fSx0KSkuX192PXQuX192KzEsVChvLHQsaSxsLl9fbix2b2lkIDAhPT1vLm93bmVyU1ZHRWxlbWVudCxudWxsIT10Ll9faD9bcl06bnVsbCx1LG51bGw9PXI/ZCh0KTpyLHQuX19oKSxqKHUsdCksdC5fX2UhPXImJl8odCkpKX0pfWZ1bmN0aW9uIGIobixsLHUsaSx0LHIsZSxjLHMsYSl7dmFyIGgscCxfLGssbSxiLHcsQT1pJiZpLl9fa3x8ZixQPUEubGVuZ3RoO2Zvcih1Ll9faz1bXSxoPTA7aDxsLmxlbmd0aDtoKyspaWYobnVsbCE9KGs9dS5fX2tbaF09bnVsbD09KGs9bFtoXSl8fFwiYm9vbGVhblwiPT10eXBlb2Ygaz9udWxsOlwic3RyaW5nXCI9PXR5cGVvZiBrfHxcIm51bWJlclwiPT10eXBlb2Ygaz92KG51bGwsayxudWxsLG51bGwsayk6QXJyYXkuaXNBcnJheShrKT92KHkse2NoaWxkcmVuOmt9LG51bGwsbnVsbCxudWxsKTprLl9fYj4wP3Yoay50eXBlLGsucHJvcHMsay5rZXksbnVsbCxrLl9fdik6aykpe2lmKGsuX189dSxrLl9fYj11Ll9fYisxLG51bGw9PT0oXz1BW2hdKXx8XyYmay5rZXk9PV8ua2V5JiZrLnR5cGU9PT1fLnR5cGUpQVtoXT12b2lkIDA7ZWxzZSBmb3IocD0wO3A8UDtwKyspe2lmKChfPUFbcF0pJiZrLmtleT09Xy5rZXkmJmsudHlwZT09PV8udHlwZSl7QVtwXT12b2lkIDA7YnJlYWt9Xz1udWxsfVQobixrLF89X3x8byx0LHIsZSxjLHMsYSksbT1rLl9fZSwocD1rLnJlZikmJl8ucmVmIT1wJiYod3x8KHc9W10pLF8ucmVmJiZ3LnB1c2goXy5yZWYsbnVsbCxrKSx3LnB1c2gocCxrLl9fY3x8bSxrKSksbnVsbCE9bT8obnVsbD09YiYmKGI9bSksXCJmdW5jdGlvblwiPT10eXBlb2Ygay50eXBlJiZudWxsIT1rLl9fayYmay5fX2s9PT1fLl9faz9rLl9fZD1zPWcoayxzLG4pOnM9eChuLGssXyxBLG0scyksYXx8XCJvcHRpb25cIiE9PXUudHlwZT9cImZ1bmN0aW9uXCI9PXR5cGVvZiB1LnR5cGUmJih1Ll9fZD1zKTpuLnZhbHVlPVwiXCIpOnMmJl8uX19lPT1zJiZzLnBhcmVudE5vZGUhPW4mJihzPWQoXykpfWZvcih1Ll9fZT1iLGg9UDtoLS07KW51bGwhPUFbaF0mJihcImZ1bmN0aW9uXCI9PXR5cGVvZiB1LnR5cGUmJm51bGwhPUFbaF0uX19lJiZBW2hdLl9fZT09dS5fX2QmJih1Ll9fZD1kKGksaCsxKSksTChBW2hdLEFbaF0pKTtpZih3KWZvcihoPTA7aDx3Lmxlbmd0aDtoKyspSSh3W2hdLHdbKytoXSx3WysraF0pfWZ1bmN0aW9uIGcobixsLHUpe3ZhciBpLHQ7Zm9yKGk9MDtpPG4uX19rLmxlbmd0aDtpKyspKHQ9bi5fX2tbaV0pJiYodC5fXz1uLGw9XCJmdW5jdGlvblwiPT10eXBlb2YgdC50eXBlP2codCxsLHUpOngodSx0LHQsbi5fX2ssdC5fX2UsbCkpO3JldHVybiBsfWZ1bmN0aW9uIHcobixsKXtyZXR1cm4gbD1sfHxbXSxudWxsPT1ufHxcImJvb2xlYW5cIj09dHlwZW9mIG58fChBcnJheS5pc0FycmF5KG4pP24uc29tZShmdW5jdGlvbihuKXt3KG4sbCl9KTpsLnB1c2gobikpLGx9ZnVuY3Rpb24geChuLGwsdSxpLHQscil7dmFyIG8sZixlO2lmKHZvaWQgMCE9PWwuX19kKW89bC5fX2QsbC5fX2Q9dm9pZCAwO2Vsc2UgaWYobnVsbD09dXx8dCE9cnx8bnVsbD09dC5wYXJlbnROb2RlKW46aWYobnVsbD09cnx8ci5wYXJlbnROb2RlIT09biluLmFwcGVuZENoaWxkKHQpLG89bnVsbDtlbHNle2ZvcihmPXIsZT0wOyhmPWYubmV4dFNpYmxpbmcpJiZlPGkubGVuZ3RoO2UrPTIpaWYoZj09dClicmVhayBuO24uaW5zZXJ0QmVmb3JlKHQsciksbz1yfXJldHVybiB2b2lkIDAhPT1vP286dC5uZXh0U2libGluZ31mdW5jdGlvbiBBKG4sbCx1LGksdCl7dmFyIHI7Zm9yKHIgaW4gdSlcImNoaWxkcmVuXCI9PT1yfHxcImtleVwiPT09cnx8ciBpbiBsfHxDKG4scixudWxsLHVbcl0saSk7Zm9yKHIgaW4gbCl0JiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBsW3JdfHxcImNoaWxkcmVuXCI9PT1yfHxcImtleVwiPT09cnx8XCJ2YWx1ZVwiPT09cnx8XCJjaGVja2VkXCI9PT1yfHx1W3JdPT09bFtyXXx8QyhuLHIsbFtyXSx1W3JdLGkpfWZ1bmN0aW9uIFAobixsLHUpe1wiLVwiPT09bFswXT9uLnNldFByb3BlcnR5KGwsdSk6bltsXT1udWxsPT11P1wiXCI6XCJudW1iZXJcIiE9dHlwZW9mIHV8fGUudGVzdChsKT91OnUrXCJweFwifWZ1bmN0aW9uIEMobixsLHUsaSx0KXt2YXIgcjtuOmlmKFwic3R5bGVcIj09PWwpaWYoXCJzdHJpbmdcIj09dHlwZW9mIHUpbi5zdHlsZS5jc3NUZXh0PXU7ZWxzZXtpZihcInN0cmluZ1wiPT10eXBlb2YgaSYmKG4uc3R5bGUuY3NzVGV4dD1pPVwiXCIpLGkpZm9yKGwgaW4gaSl1JiZsIGluIHV8fFAobi5zdHlsZSxsLFwiXCIpO2lmKHUpZm9yKGwgaW4gdSlpJiZ1W2xdPT09aVtsXXx8UChuLnN0eWxlLGwsdVtsXSl9ZWxzZSBpZihcIm9cIj09PWxbMF0mJlwiblwiPT09bFsxXSlyPWwhPT0obD1sLnJlcGxhY2UoL0NhcHR1cmUkLyxcIlwiKSksbD1sLnRvTG93ZXJDYXNlKClpbiBuP2wudG9Mb3dlckNhc2UoKS5zbGljZSgyKTpsLnNsaWNlKDIpLG4ubHx8KG4ubD17fSksbi5sW2wrcl09dSx1P2l8fG4uYWRkRXZlbnRMaXN0ZW5lcihsLHI/SDokLHIpOm4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihsLHI/SDokLHIpO2Vsc2UgaWYoXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiIT09bCl7aWYodClsPWwucmVwbGFjZSgveGxpbmtbSDpoXS8sXCJoXCIpLnJlcGxhY2UoL3NOYW1lJC8sXCJzXCIpO2Vsc2UgaWYoXCJocmVmXCIhPT1sJiZcImxpc3RcIiE9PWwmJlwiZm9ybVwiIT09bCYmXCJkb3dubG9hZFwiIT09bCYmbCBpbiBuKXRyeXtuW2xdPW51bGw9PXU/XCJcIjp1O2JyZWFrIG59Y2F0Y2gobil7fVwiZnVuY3Rpb25cIj09dHlwZW9mIHV8fChudWxsIT11JiYoITEhPT11fHxcImFcIj09PWxbMF0mJlwiclwiPT09bFsxXSk/bi5zZXRBdHRyaWJ1dGUobCx1KTpuLnJlbW92ZUF0dHJpYnV0ZShsKSl9fWZ1bmN0aW9uICQobCl7dGhpcy5sW2wudHlwZSshMV0obi5ldmVudD9uLmV2ZW50KGwpOmwpfWZ1bmN0aW9uIEgobCl7dGhpcy5sW2wudHlwZSshMF0obi5ldmVudD9uLmV2ZW50KGwpOmwpfWZ1bmN0aW9uIFQobCx1LGksdCxyLG8sZixlLHMpe3ZhciBhLHYsaCxkLF8sayxtLGcsdyx4LEEsUD11LnR5cGU7aWYodm9pZCAwIT09dS5jb25zdHJ1Y3RvcilyZXR1cm4gbnVsbDtudWxsIT1pLl9faCYmKHM9aS5fX2gsZT11Ll9fZT1pLl9fZSx1Ll9faD1udWxsLG89W2VdKSwoYT1uLl9fYikmJmEodSk7dHJ5e246aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUCl7aWYoZz11LnByb3BzLHc9KGE9UC5jb250ZXh0VHlwZSkmJnRbYS5fX2NdLHg9YT93P3cucHJvcHMudmFsdWU6YS5fXzp0LGkuX19jP209KHY9dS5fX2M9aS5fX2MpLl9fPXYuX19FOihcInByb3RvdHlwZVwiaW4gUCYmUC5wcm90b3R5cGUucmVuZGVyP3UuX19jPXY9bmV3IFAoZyx4KToodS5fX2M9dj1uZXcgcChnLHgpLHYuY29uc3RydWN0b3I9UCx2LnJlbmRlcj1NKSx3JiZ3LnN1Yih2KSx2LnByb3BzPWcsdi5zdGF0ZXx8KHYuc3RhdGU9e30pLHYuY29udGV4dD14LHYuX19uPXQsaD12Ll9fZD0hMCx2Ll9faD1bXSksbnVsbD09di5fX3MmJih2Ll9fcz12LnN0YXRlKSxudWxsIT1QLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyYmKHYuX19zPT12LnN0YXRlJiYodi5fX3M9Yyh7fSx2Ll9fcykpLGModi5fX3MsUC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoZyx2Ll9fcykpKSxkPXYucHJvcHMsXz12LnN0YXRlLGgpbnVsbD09UC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMmJm51bGwhPXYuY29tcG9uZW50V2lsbE1vdW50JiZ2LmNvbXBvbmVudFdpbGxNb3VudCgpLG51bGwhPXYuY29tcG9uZW50RGlkTW91bnQmJnYuX19oLnB1c2godi5jb21wb25lbnREaWRNb3VudCk7ZWxzZXtpZihudWxsPT1QLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyYmZyE9PWQmJm51bGwhPXYuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyYmdi5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKGcseCksIXYuX19lJiZudWxsIT12LnNob3VsZENvbXBvbmVudFVwZGF0ZSYmITE9PT12LnNob3VsZENvbXBvbmVudFVwZGF0ZShnLHYuX19zLHgpfHx1Ll9fdj09PWkuX192KXt2LnByb3BzPWcsdi5zdGF0ZT12Ll9fcyx1Ll9fdiE9PWkuX192JiYodi5fX2Q9ITEpLHYuX192PXUsdS5fX2U9aS5fX2UsdS5fX2s9aS5fX2ssdi5fX2gubGVuZ3RoJiZmLnB1c2godik7YnJlYWsgbn1udWxsIT12LmNvbXBvbmVudFdpbGxVcGRhdGUmJnYuY29tcG9uZW50V2lsbFVwZGF0ZShnLHYuX19zLHgpLG51bGwhPXYuY29tcG9uZW50RGlkVXBkYXRlJiZ2Ll9faC5wdXNoKGZ1bmN0aW9uKCl7di5jb21wb25lbnREaWRVcGRhdGUoZCxfLGspfSl9di5jb250ZXh0PXgsdi5wcm9wcz1nLHYuc3RhdGU9di5fX3MsKGE9bi5fX3IpJiZhKHUpLHYuX19kPSExLHYuX192PXUsdi5fX1A9bCxhPXYucmVuZGVyKHYucHJvcHMsdi5zdGF0ZSx2LmNvbnRleHQpLHYuc3RhdGU9di5fX3MsbnVsbCE9di5nZXRDaGlsZENvbnRleHQmJih0PWMoYyh7fSx0KSx2LmdldENoaWxkQ29udGV4dCgpKSksaHx8bnVsbD09di5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZXx8KGs9di5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShkLF8pKSxBPW51bGwhPWEmJmEudHlwZT09PXkmJm51bGw9PWEua2V5P2EucHJvcHMuY2hpbGRyZW46YSxiKGwsQXJyYXkuaXNBcnJheShBKT9BOltBXSx1LGksdCxyLG8sZixlLHMpLHYuYmFzZT11Ll9fZSx1Ll9faD1udWxsLHYuX19oLmxlbmd0aCYmZi5wdXNoKHYpLG0mJih2Ll9fRT12Ll9fPW51bGwpLHYuX19lPSExfWVsc2UgbnVsbD09byYmdS5fX3Y9PT1pLl9fdj8odS5fX2s9aS5fX2ssdS5fX2U9aS5fX2UpOnUuX19lPXooaS5fX2UsdSxpLHQscixvLGYscyk7KGE9bi5kaWZmZWQpJiZhKHUpfWNhdGNoKGwpe3UuX192PW51bGwsKHN8fG51bGwhPW8pJiYodS5fX2U9ZSx1Ll9faD0hIXMsb1tvLmluZGV4T2YoZSldPW51bGwpLG4uX19lKGwsdSxpKX19ZnVuY3Rpb24gaihsLHUpe24uX19jJiZuLl9fYyh1LGwpLGwuc29tZShmdW5jdGlvbih1KXt0cnl7bD11Ll9faCx1Ll9faD1bXSxsLnNvbWUoZnVuY3Rpb24obil7bi5jYWxsKHUpfSl9Y2F0Y2gobCl7bi5fX2UobCx1Ll9fdil9fSl9ZnVuY3Rpb24geihuLGwsdSxpLHQscixlLGMpe3ZhciBhLHYsaCx5LHAsZD11LnByb3BzLF89bC5wcm9wcyxrPWwudHlwZTtpZihcInN2Z1wiPT09ayYmKHQ9ITApLG51bGwhPXIpZm9yKGE9MDthPHIubGVuZ3RoO2ErKylpZihudWxsIT0odj1yW2FdKSYmKG49PXZ8fHYubG9jYWxOYW1lPT1rKSl7bj12LHJbYV09bnVsbDticmVha31pZihudWxsPT1uKXtpZihudWxsPT09aylyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXyk7bj10P2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsayk6ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChrLF8uaXMmJl8pLHI9bnVsbCxjPSExfWlmKG51bGw9PT1rKWQ9PT1ffHxjJiZuLmRhdGE9PT1ffHwobi5kYXRhPV8pO2Vsc2V7aWYobnVsbCE9ciYmKHI9Zi5zbGljZS5jYWxsKG4uY2hpbGROb2RlcykpLGg9KGQ9dS5wcm9wc3x8bykuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwseT1fLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLCFjKXtpZihudWxsIT1yKWZvcihkPXt9LHA9MDtwPG4uYXR0cmlidXRlcy5sZW5ndGg7cCsrKWRbbi5hdHRyaWJ1dGVzW3BdLm5hbWVdPW4uYXR0cmlidXRlc1twXS52YWx1ZTsoeXx8aCkmJih5JiYoaCYmeS5fX2h0bWw9PWguX19odG1sfHx5Ll9faHRtbD09PW4uaW5uZXJIVE1MKXx8KG4uaW5uZXJIVE1MPXkmJnkuX19odG1sfHxcIlwiKSl9aWYoQShuLF8sZCx0LGMpLHkpbC5fX2s9W107ZWxzZSBpZihhPWwucHJvcHMuY2hpbGRyZW4sYihuLEFycmF5LmlzQXJyYXkoYSk/YTpbYV0sbCx1LGksdCYmXCJmb3JlaWduT2JqZWN0XCIhPT1rLHIsZSxuLmZpcnN0Q2hpbGQsYyksbnVsbCE9cilmb3IoYT1yLmxlbmd0aDthLS07KW51bGwhPXJbYV0mJnMoclthXSk7Y3x8KFwidmFsdWVcImluIF8mJnZvaWQgMCE9PShhPV8udmFsdWUpJiYoYSE9PW4udmFsdWV8fFwicHJvZ3Jlc3NcIj09PWsmJiFhKSYmQyhuLFwidmFsdWVcIixhLGQudmFsdWUsITEpLFwiY2hlY2tlZFwiaW4gXyYmdm9pZCAwIT09KGE9Xy5jaGVja2VkKSYmYSE9PW4uY2hlY2tlZCYmQyhuLFwiY2hlY2tlZFwiLGEsZC5jaGVja2VkLCExKSl9cmV0dXJuIG59ZnVuY3Rpb24gSShsLHUsaSl7dHJ5e1wiZnVuY3Rpb25cIj09dHlwZW9mIGw/bCh1KTpsLmN1cnJlbnQ9dX1jYXRjaChsKXtuLl9fZShsLGkpfX1mdW5jdGlvbiBMKGwsdSxpKXt2YXIgdCxyLG87aWYobi51bm1vdW50JiZuLnVubW91bnQobCksKHQ9bC5yZWYpJiYodC5jdXJyZW50JiZ0LmN1cnJlbnQhPT1sLl9fZXx8SSh0LG51bGwsdSkpLGl8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGwudHlwZXx8KGk9bnVsbCE9KHI9bC5fX2UpKSxsLl9fZT1sLl9fZD12b2lkIDAsbnVsbCE9KHQ9bC5fX2MpKXtpZih0LmNvbXBvbmVudFdpbGxVbm1vdW50KXRyeXt0LmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2gobCl7bi5fX2UobCx1KX10LmJhc2U9dC5fX1A9bnVsbH1pZih0PWwuX19rKWZvcihvPTA7bzx0Lmxlbmd0aDtvKyspdFtvXSYmTCh0W29dLHUsaSk7bnVsbCE9ciYmcyhyKX1mdW5jdGlvbiBNKG4sbCx1KXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvcihuLHUpfWZ1bmN0aW9uIE4obCx1LGkpe3ZhciB0LHIsZTtuLl9fJiZuLl9fKGwsdSkscj0odD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBpKT9udWxsOmkmJmkuX19rfHx1Ll9fayxlPVtdLFQodSxsPSghdCYmaXx8dSkuX19rPWEoeSxudWxsLFtsXSkscnx8byxvLHZvaWQgMCE9PXUub3duZXJTVkdFbGVtZW50LCF0JiZpP1tpXTpyP251bGw6dS5maXJzdENoaWxkP2Yuc2xpY2UuY2FsbCh1LmNoaWxkTm9kZXMpOm51bGwsZSwhdCYmaT9pOnI/ci5fX2U6dS5maXJzdENoaWxkLHQpLGooZSxsKX1mdW5jdGlvbiBPKG4sbCl7TihuLGwsTyl9ZnVuY3Rpb24gUyhuLGwsdSl7dmFyIGksdCxyLG89YXJndW1lbnRzLGY9Yyh7fSxuLnByb3BzKTtmb3IociBpbiBsKVwia2V5XCI9PXI/aT1sW3JdOlwicmVmXCI9PXI/dD1sW3JdOmZbcl09bFtyXTtpZihhcmd1bWVudHMubGVuZ3RoPjMpZm9yKHU9W3VdLHI9MztyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXUucHVzaChvW3JdKTtyZXR1cm4gbnVsbCE9dSYmKGYuY2hpbGRyZW49dSksdihuLnR5cGUsZixpfHxuLmtleSx0fHxuLnJlZixudWxsKX1mdW5jdGlvbiBxKG4sbCl7dmFyIHU9e19fYzpsPVwiX19jQ1wiK3IrKyxfXzpuLENvbnN1bWVyOmZ1bmN0aW9uKG4sbCl7cmV0dXJuIG4uY2hpbGRyZW4obCl9LFByb3ZpZGVyOmZ1bmN0aW9uKG4pe3ZhciB1LGk7cmV0dXJuIHRoaXMuZ2V0Q2hpbGRDb250ZXh0fHwodT1bXSwoaT17fSlbbF09dGhpcyx0aGlzLmdldENoaWxkQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiBpfSx0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZT1mdW5jdGlvbihuKXt0aGlzLnByb3BzLnZhbHVlIT09bi52YWx1ZSYmdS5zb21lKGspfSx0aGlzLnN1Yj1mdW5jdGlvbihuKXt1LnB1c2gobik7dmFyIGw9bi5jb21wb25lbnRXaWxsVW5tb3VudDtuLmNvbXBvbmVudFdpbGxVbm1vdW50PWZ1bmN0aW9uKCl7dS5zcGxpY2UodS5pbmRleE9mKG4pLDEpLGwmJmwuY2FsbChuKX19KSxuLmNoaWxkcmVufX07cmV0dXJuIHUuUHJvdmlkZXIuX189dS5Db25zdW1lci5jb250ZXh0VHlwZT11fW49e19fZTpmdW5jdGlvbihuLGwpe2Zvcih2YXIgdSxpLHQ7bD1sLl9fOylpZigodT1sLl9fYykmJiF1Ll9fKXRyeXtpZigoaT11LmNvbnN0cnVjdG9yKSYmbnVsbCE9aS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3ImJih1LnNldFN0YXRlKGkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKG4pKSx0PXUuX19kKSxudWxsIT11LmNvbXBvbmVudERpZENhdGNoJiYodS5jb21wb25lbnREaWRDYXRjaChuKSx0PXUuX19kKSx0KXJldHVybiB1Ll9fRT11fWNhdGNoKGwpe249bH10aHJvdyBufSxfX3Y6MH0sbD1mdW5jdGlvbihuKXtyZXR1cm4gbnVsbCE9biYmdm9pZCAwPT09bi5jb25zdHJ1Y3Rvcn0scC5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24obixsKXt2YXIgdTt1PW51bGwhPXRoaXMuX19zJiZ0aGlzLl9fcyE9PXRoaXMuc3RhdGU/dGhpcy5fX3M6dGhpcy5fX3M9Yyh7fSx0aGlzLnN0YXRlKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBuJiYobj1uKGMoe30sdSksdGhpcy5wcm9wcykpLG4mJmModSxuKSxudWxsIT1uJiZ0aGlzLl9fdiYmKGwmJnRoaXMuX19oLnB1c2gobCksayh0aGlzKSl9LHAucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKG4pe3RoaXMuX192JiYodGhpcy5fX2U9ITAsbiYmdGhpcy5fX2gucHVzaChuKSxrKHRoaXMpKX0scC5wcm90b3R5cGUucmVuZGVyPXksdT1bXSxpPVwiZnVuY3Rpb25cIj09dHlwZW9mIFByb21pc2U/UHJvbWlzZS5wcm90b3R5cGUudGhlbi5iaW5kKFByb21pc2UucmVzb2x2ZSgpKTpzZXRUaW1lb3V0LG0uX19yPTAscj0wO2V4cG9ydHtOIGFzIHJlbmRlcixPIGFzIGh5ZHJhdGUsYSBhcyBjcmVhdGVFbGVtZW50LGEgYXMgaCx5IGFzIEZyYWdtZW50LGggYXMgY3JlYXRlUmVmLGwgYXMgaXNWYWxpZEVsZW1lbnQscCBhcyBDb21wb25lbnQsUyBhcyBjbG9uZUVsZW1lbnQscSBhcyBjcmVhdGVDb250ZXh0LHcgYXMgdG9DaGlsZEFycmF5LG4gYXMgb3B0aW9uc307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVhY3QubW9kdWxlLmpzLm1hcFxuIiwiaW1wb3J0e29wdGlvbnMgYXMgbn1mcm9tXCJwcmVhY3RcIjt2YXIgdCx1LHIsbz0wLGk9W10sYz1uLl9fYixmPW4uX19yLGU9bi5kaWZmZWQsYT1uLl9fYyx2PW4udW5tb3VudDtmdW5jdGlvbiBtKHQscil7bi5fX2gmJm4uX19oKHUsdCxvfHxyKSxvPTA7dmFyIGk9dS5fX0h8fCh1Ll9fSD17X186W10sX19oOltdfSk7cmV0dXJuIHQ+PWkuX18ubGVuZ3RoJiZpLl9fLnB1c2goe30pLGkuX19bdF19ZnVuY3Rpb24gbChuKXtyZXR1cm4gbz0xLHAodyxuKX1mdW5jdGlvbiBwKG4scixvKXt2YXIgaT1tKHQrKywyKTtyZXR1cm4gaS50PW4saS5fX2N8fChpLl9fPVtvP28ocik6dyh2b2lkIDAsciksZnVuY3Rpb24obil7dmFyIHQ9aS50KGkuX19bMF0sbik7aS5fX1swXSE9PXQmJihpLl9fPVt0LGkuX19bMV1dLGkuX19jLnNldFN0YXRlKHt9KSl9XSxpLl9fYz11KSxpLl9ffWZ1bmN0aW9uIHkocixvKXt2YXIgaT1tKHQrKywzKTshbi5fX3MmJmsoaS5fX0gsbykmJihpLl9fPXIsaS5fX0g9byx1Ll9fSC5fX2gucHVzaChpKSl9ZnVuY3Rpb24gaChyLG8pe3ZhciBpPW0odCsrLDQpOyFuLl9fcyYmayhpLl9fSCxvKSYmKGkuX189cixpLl9fSD1vLHUuX19oLnB1c2goaSkpfWZ1bmN0aW9uIHMobil7cmV0dXJuIG89NSxkKGZ1bmN0aW9uKCl7cmV0dXJue2N1cnJlbnQ6bn19LFtdKX1mdW5jdGlvbiBfKG4sdCx1KXtvPTYsaChmdW5jdGlvbigpe1wiZnVuY3Rpb25cIj09dHlwZW9mIG4/bih0KCkpOm4mJihuLmN1cnJlbnQ9dCgpKX0sbnVsbD09dT91OnUuY29uY2F0KG4pKX1mdW5jdGlvbiBkKG4sdSl7dmFyIHI9bSh0KyssNyk7cmV0dXJuIGsoci5fX0gsdSkmJihyLl9fPW4oKSxyLl9fSD11LHIuX19oPW4pLHIuX199ZnVuY3Rpb24gQShuLHQpe3JldHVybiBvPTgsZChmdW5jdGlvbigpe3JldHVybiBufSx0KX1mdW5jdGlvbiBGKG4pe3ZhciByPXUuY29udGV4dFtuLl9fY10sbz1tKHQrKyw5KTtyZXR1cm4gby5fX2M9bixyPyhudWxsPT1vLl9fJiYoby5fXz0hMCxyLnN1Yih1KSksci5wcm9wcy52YWx1ZSk6bi5fX31mdW5jdGlvbiBUKHQsdSl7bi51c2VEZWJ1Z1ZhbHVlJiZuLnVzZURlYnVnVmFsdWUodT91KHQpOnQpfWZ1bmN0aW9uIHEobil7dmFyIHI9bSh0KyssMTApLG89bCgpO3JldHVybiByLl9fPW4sdS5jb21wb25lbnREaWRDYXRjaHx8KHUuY29tcG9uZW50RGlkQ2F0Y2g9ZnVuY3Rpb24obil7ci5fXyYmci5fXyhuKSxvWzFdKG4pfSksW29bMF0sZnVuY3Rpb24oKXtvWzFdKHZvaWQgMCl9XX1mdW5jdGlvbiB4KCl7aS5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lmKHQuX19QKXRyeXt0Ll9fSC5fX2guZm9yRWFjaChnKSx0Ll9fSC5fX2guZm9yRWFjaChqKSx0Ll9fSC5fX2g9W119Y2F0Y2godSl7dC5fX0guX19oPVtdLG4uX19lKHUsdC5fX3YpfX0pLGk9W119bi5fX2I9ZnVuY3Rpb24obil7dT1udWxsLGMmJmMobil9LG4uX19yPWZ1bmN0aW9uKG4pe2YmJmYobiksdD0wO3ZhciByPSh1PW4uX19jKS5fX0g7ciYmKHIuX19oLmZvckVhY2goZyksci5fX2guZm9yRWFjaChqKSxyLl9faD1bXSl9LG4uZGlmZmVkPWZ1bmN0aW9uKHQpe2UmJmUodCk7dmFyIG89dC5fX2M7byYmby5fX0gmJm8uX19ILl9faC5sZW5ndGgmJigxIT09aS5wdXNoKG8pJiZyPT09bi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWV8fCgocj1uLnJlcXVlc3RBbmltYXRpb25GcmFtZSl8fGZ1bmN0aW9uKG4pe3ZhciB0LHU9ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQociksYiYmY2FuY2VsQW5pbWF0aW9uRnJhbWUodCksc2V0VGltZW91dChuKX0scj1zZXRUaW1lb3V0KHUsMTAwKTtiJiYodD1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodSkpfSkoeCkpLHU9dm9pZCAwfSxuLl9fYz1mdW5jdGlvbih0LHUpe3Uuc29tZShmdW5jdGlvbih0KXt0cnl7dC5fX2guZm9yRWFjaChnKSx0Ll9faD10Ll9faC5maWx0ZXIoZnVuY3Rpb24obil7cmV0dXJuIW4uX198fGoobil9KX1jYXRjaChyKXt1LnNvbWUoZnVuY3Rpb24obil7bi5fX2gmJihuLl9faD1bXSl9KSx1PVtdLG4uX19lKHIsdC5fX3YpfX0pLGEmJmEodCx1KX0sbi51bm1vdW50PWZ1bmN0aW9uKHQpe3YmJnYodCk7dmFyIHU9dC5fX2M7aWYodSYmdS5fX0gpdHJ5e3UuX19ILl9fLmZvckVhY2goZyl9Y2F0Y2godCl7bi5fX2UodCx1Ll9fdil9fTt2YXIgYj1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ZnVuY3Rpb24gZyhuKXt2YXIgdD11O1wiZnVuY3Rpb25cIj09dHlwZW9mIG4uX19jJiZuLl9fYygpLHU9dH1mdW5jdGlvbiBqKG4pe3ZhciB0PXU7bi5fX2M9bi5fXygpLHU9dH1mdW5jdGlvbiBrKG4sdCl7cmV0dXJuIW58fG4ubGVuZ3RoIT09dC5sZW5ndGh8fHQuc29tZShmdW5jdGlvbih0LHUpe3JldHVybiB0IT09blt1XX0pfWZ1bmN0aW9uIHcobix0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Qobik6dH1leHBvcnR7bCBhcyB1c2VTdGF0ZSxwIGFzIHVzZVJlZHVjZXIseSBhcyB1c2VFZmZlY3QsaCBhcyB1c2VMYXlvdXRFZmZlY3QscyBhcyB1c2VSZWYsXyBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlLGQgYXMgdXNlTWVtbyxBIGFzIHVzZUNhbGxiYWNrLEYgYXMgdXNlQ29udGV4dCxUIGFzIHVzZURlYnVnVmFsdWUscSBhcyB1c2VFcnJvckJvdW5kYXJ5fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvb2tzLm1vZHVsZS5qcy5tYXBcbiIsImV4cG9ydCAqIGZyb20gJ3ByZWFjdC9jb21wYXQnO1xuZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJ3ByZWFjdC9jb21wYXQnO1xuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxuLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9SRVNQT05ERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9TQ09QRV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUpO1xufVxuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BPUlRBTF9UWVBFO1xufVxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG59XG5cbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsImV4cG9ydCAqIGZyb20gJ3ByZWFjdC9jb21wYXQnO1xuZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJ3ByZWFjdC9jb21wYXQnO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgT3AgPSBPYmplY3QucHJvdG90eXBlO1xuICB2YXIgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHk7XG4gIHZhciB1bmRlZmluZWQ7IC8vIE1vcmUgY29tcHJlc3NpYmxlIHRoYW4gdm9pZCAwLlxuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIC8vIElFIDggaGFzIGEgYnJva2VuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0aGF0IG9ubHkgd29ya3Mgb24gRE9NIG9iamVjdHMuXG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIC8vIElmIG91dGVyRm4gcHJvdmlkZWQgYW5kIG91dGVyRm4ucHJvdG90eXBlIGlzIGEgR2VuZXJhdG9yLCB0aGVuIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yLlxuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yO1xuICAgIHZhciBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSk7XG4gICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7XG5cbiAgICAvLyBUaGUgLl9pbnZva2UgbWV0aG9kIHVuaWZpZXMgdGhlIGltcGxlbWVudGF0aW9ucyBvZiB0aGUgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzLlxuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICAvLyBUcnkvY2F0Y2ggaGVscGVyIHRvIG1pbmltaXplIGRlb3B0aW1pemF0aW9ucy4gUmV0dXJucyBhIGNvbXBsZXRpb25cbiAgLy8gcmVjb3JkIGxpa2UgY29udGV4dC50cnlFbnRyaWVzW2ldLmNvbXBsZXRpb24uIFRoaXMgaW50ZXJmYWNlIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiAoYW5kIHdhcyBwcmV2aW91c2x5KSBkZXNpZ25lZCB0byB0YWtlIGEgY2xvc3VyZSB0byBiZVxuICAvLyBpbnZva2VkIHdpdGhvdXQgYXJndW1lbnRzLCBidXQgaW4gYWxsIHRoZSBjYXNlcyB3ZSBjYXJlIGFib3V0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBtZXRob2Qgd2Ugd2FudCB0byBjYWxsLCBzbyB0aGVyZSdzIG5vIG5lZWRcbiAgLy8gdG8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9iamVjdC4gV2UgY2FuIGV2ZW4gZ2V0IGF3YXkgd2l0aCBhc3N1bWluZ1xuICAvLyB0aGUgbWV0aG9kIHRha2VzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBzaW5jZSB0aGF0IGhhcHBlbnMgdG8gYmUgdHJ1ZVxuICAvLyBpbiBldmVyeSBjYXNlLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHRvdWNoIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBUaGVcbiAgLy8gb25seSBhZGRpdGlvbmFsIGFsbG9jYXRpb24gcmVxdWlyZWQgaXMgdGhlIGNvbXBsZXRpb24gcmVjb3JkLCB3aGljaFxuICAvLyBoYXMgYSBzdGFibGUgc2hhcGUgYW5kIHNvIGhvcGVmdWxseSBzaG91bGQgYmUgY2hlYXAgdG8gYWxsb2NhdGUuXG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuXG4gIC8vIFJldHVybmluZyB0aGlzIG9iamVjdCBmcm9tIHRoZSBpbm5lckZuIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXNcbiAgLy8gYnJlYWtpbmcgb3V0IG9mIHRoZSBkaXNwYXRjaCBzd2l0Y2ggc3RhdGVtZW50LlxuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIC8vIER1bW15IGNvbnN0cnVjdG9yIGZ1bmN0aW9ucyB0aGF0IHdlIHVzZSBhcyB0aGUgLmNvbnN0cnVjdG9yIGFuZFxuICAvLyAuY29uc3RydWN0b3IucHJvdG90eXBlIHByb3BlcnRpZXMgZm9yIGZ1bmN0aW9ucyB0aGF0IHJldHVybiBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0cy4gRm9yIGZ1bGwgc3BlYyBjb21wbGlhbmNlLCB5b3UgbWF5IHdpc2ggdG8gY29uZmlndXJlIHlvdXJcbiAgLy8gbWluaWZpZXIgbm90IHRvIG1hbmdsZSB0aGUgbmFtZXMgb2YgdGhlc2UgdHdvIGZ1bmN0aW9ucy5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgLy8gVGhpcyBpcyBhIHBvbHlmaWxsIGZvciAlSXRlcmF0b3JQcm90b3R5cGUlIGZvciBlbnZpcm9ubWVudHMgdGhhdFxuICAvLyBkb24ndCBuYXRpdmVseSBzdXBwb3J0IGl0LlxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkge1xuICAgIGlmIChQcm9taXNlSW1wbCA9PT0gdm9pZCAwKSBQcm9taXNlSW1wbCA9IFByb21pc2U7XG5cbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKFxuICAgICAgd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksXG4gICAgICBQcm9taXNlSW1wbFxuICAgICk7XG5cbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pXG4gICAgICA/IGl0ZXIgLy8gSWYgb3V0ZXJGbiBpcyBhIGdlbmVyYXRvciwgcmV0dXJuIHRoZSBmdWxsIGl0ZXJhdG9yLlxuICAgICAgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgICAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlIGZvcmdpdmluZywgcGVyIDI1LjMuMy4zLjMgb2YgdGhlIHNwZWM6XG4gICAgICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1nZW5lcmF0b3JyZXN1bWVcbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG4gICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInJldHVyblwiKSB7XG4gICAgICAgICAgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUV4ZWN1dGluZztcblxuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIC8vIElmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gZnJvbSBpbm5lckZuLCB3ZSBsZWF2ZSBzdGF0ZSA9PT1cbiAgICAgICAgICAvLyBHZW5TdGF0ZUV4ZWN1dGluZyBhbmQgbG9vcCBiYWNrIGZvciBhbm90aGVyIGludm9jYXRpb24uXG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmVcbiAgICAgICAgICAgID8gR2VuU3RhdGVDb21wbGV0ZWRcbiAgICAgICAgICAgIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgLy8gRGlzcGF0Y2ggdGhlIGV4Y2VwdGlvbiBieSBsb29waW5nIGJhY2sgYXJvdW5kIHRvIHRoZVxuICAgICAgICAgIC8vIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpIGNhbGwgYWJvdmUuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIENhbGwgZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdKGNvbnRleHQuYXJnKSBhbmQgaGFuZGxlIHRoZVxuICAvLyByZXN1bHQsIGVpdGhlciBieSByZXR1cm5pbmcgYSB7IHZhbHVlLCBkb25lIH0gcmVzdWx0IGZyb20gdGhlXG4gIC8vIGRlbGVnYXRlIGl0ZXJhdG9yLCBvciBieSBtb2RpZnlpbmcgY29udGV4dC5tZXRob2QgYW5kIGNvbnRleHQuYXJnLFxuICAvLyBzZXR0aW5nIGNvbnRleHQuZGVsZWdhdGUgdG8gbnVsbCwgYW5kIHJldHVybmluZyB0aGUgQ29udGludWVTZW50aW5lbC5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG4gICAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iLCJ2YXIgVU5LTk9XTl9GVU5DVElPTiA9ICc8dW5rbm93bj4nO1xuLyoqXG4gKiBUaGlzIHBhcnNlcyB0aGUgZGlmZmVyZW50IHN0YWNrIHRyYWNlcyBhbmQgcHV0cyB0aGVtIGludG8gb25lIGZvcm1hdFxuICogVGhpcyBib3Jyb3dzIGhlYXZpbHkgZnJvbSBUcmFjZUtpdCAoaHR0cHM6Ly9naXRodWIuY29tL2Nzbm92ZXIvVHJhY2VLaXQpXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RhY2tTdHJpbmcpIHtcbiAgdmFyIGxpbmVzID0gc3RhY2tTdHJpbmcuc3BsaXQoJ1xcbicpO1xuICByZXR1cm4gbGluZXMucmVkdWNlKGZ1bmN0aW9uIChzdGFjaywgbGluZSkge1xuICAgIHZhciBwYXJzZVJlc3VsdCA9IHBhcnNlQ2hyb21lKGxpbmUpIHx8IHBhcnNlV2luanMobGluZSkgfHwgcGFyc2VHZWNrbyhsaW5lKSB8fCBwYXJzZU5vZGUobGluZSkgfHwgcGFyc2VKU0MobGluZSk7XG5cbiAgICBpZiAocGFyc2VSZXN1bHQpIHtcbiAgICAgIHN0YWNrLnB1c2gocGFyc2VSZXN1bHQpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfSwgW10pO1xufVxudmFyIGNocm9tZVJlID0gL15cXHMqYXQgKC4qPykgP1xcKCgoPzpmaWxlfGh0dHBzP3xibG9ifGNocm9tZS1leHRlbnNpb258bmF0aXZlfGV2YWx8d2VicGFja3w8YW5vbnltb3VzPnxcXC98W2Etel06XFxcXHxcXFxcXFxcXCkuKj8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/XFwpP1xccyokL2k7XG52YXIgY2hyb21lRXZhbFJlID0gL1xcKChcXFMqKSg/OjooXFxkKykpKD86OihcXGQrKSlcXCkvO1xuXG5mdW5jdGlvbiBwYXJzZUNocm9tZShsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGNocm9tZVJlLmV4ZWMobGluZSk7XG5cbiAgaWYgKCFwYXJ0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGlzTmF0aXZlID0gcGFydHNbMl0gJiYgcGFydHNbMl0uaW5kZXhPZignbmF0aXZlJykgPT09IDA7IC8vIHN0YXJ0IG9mIGxpbmVcblxuICB2YXIgaXNFdmFsID0gcGFydHNbMl0gJiYgcGFydHNbMl0uaW5kZXhPZignZXZhbCcpID09PSAwOyAvLyBzdGFydCBvZiBsaW5lXG5cbiAgdmFyIHN1Ym1hdGNoID0gY2hyb21lRXZhbFJlLmV4ZWMocGFydHNbMl0pO1xuXG4gIGlmIChpc0V2YWwgJiYgc3VibWF0Y2ggIT0gbnVsbCkge1xuICAgIC8vIHRocm93IG91dCBldmFsIGxpbmUvY29sdW1uIGFuZCB1c2UgdG9wLW1vc3QgbGluZS9jb2x1bW4gbnVtYmVyXG4gICAgcGFydHNbMl0gPSBzdWJtYXRjaFsxXTsgLy8gdXJsXG5cbiAgICBwYXJ0c1szXSA9IHN1Ym1hdGNoWzJdOyAvLyBsaW5lXG5cbiAgICBwYXJ0c1s0XSA9IHN1Ym1hdGNoWzNdOyAvLyBjb2x1bW5cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZmlsZTogIWlzTmF0aXZlID8gcGFydHNbMl0gOiBudWxsLFxuICAgIG1ldGhvZE5hbWU6IHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT04sXG4gICAgYXJndW1lbnRzOiBpc05hdGl2ZSA/IFtwYXJ0c1syXV0gOiBbXSxcbiAgICBsaW5lTnVtYmVyOiBwYXJ0c1szXSA/ICtwYXJ0c1szXSA6IG51bGwsXG4gICAgY29sdW1uOiBwYXJ0c1s0XSA/ICtwYXJ0c1s0XSA6IG51bGxcbiAgfTtcbn1cblxudmFyIHdpbmpzUmUgPSAvXlxccyphdCAoPzooKD86XFxbb2JqZWN0IG9iamVjdFxcXSk/LispICk/XFwoPygoPzpmaWxlfG1zLWFwcHh8aHR0cHM/fHdlYnBhY2t8YmxvYik6Lio/KTooXFxkKykoPzo6KFxcZCspKT9cXCk/XFxzKiQvaTtcblxuZnVuY3Rpb24gcGFyc2VXaW5qcyhsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IHdpbmpzUmUuZXhlYyhsaW5lKTtcblxuICBpZiAoIXBhcnRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZpbGU6IHBhcnRzWzJdLFxuICAgIG1ldGhvZE5hbWU6IHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT04sXG4gICAgYXJndW1lbnRzOiBbXSxcbiAgICBsaW5lTnVtYmVyOiArcGFydHNbM10sXG4gICAgY29sdW1uOiBwYXJ0c1s0XSA/ICtwYXJ0c1s0XSA6IG51bGxcbiAgfTtcbn1cblxudmFyIGdlY2tvUmUgPSAvXlxccyooLio/KSg/OlxcKCguKj8pXFwpKT8oPzpefEApKCg/OmZpbGV8aHR0cHM/fGJsb2J8Y2hyb21lfHdlYnBhY2t8cmVzb3VyY2V8XFxbbmF0aXZlKS4qP3xbXkBdKmJ1bmRsZSkoPzo6KFxcZCspKT8oPzo6KFxcZCspKT9cXHMqJC9pO1xudmFyIGdlY2tvRXZhbFJlID0gLyhcXFMrKSBsaW5lIChcXGQrKSg/OiA+IGV2YWwgbGluZSBcXGQrKSogPiBldmFsL2k7XG5cbmZ1bmN0aW9uIHBhcnNlR2Vja28obGluZSkge1xuICB2YXIgcGFydHMgPSBnZWNrb1JlLmV4ZWMobGluZSk7XG5cbiAgaWYgKCFwYXJ0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGlzRXZhbCA9IHBhcnRzWzNdICYmIHBhcnRzWzNdLmluZGV4T2YoJyA+IGV2YWwnKSA+IC0xO1xuICB2YXIgc3VibWF0Y2ggPSBnZWNrb0V2YWxSZS5leGVjKHBhcnRzWzNdKTtcblxuICBpZiAoaXNFdmFsICYmIHN1Ym1hdGNoICE9IG51bGwpIHtcbiAgICAvLyB0aHJvdyBvdXQgZXZhbCBsaW5lL2NvbHVtbiBhbmQgdXNlIHRvcC1tb3N0IGxpbmUgbnVtYmVyXG4gICAgcGFydHNbM10gPSBzdWJtYXRjaFsxXTtcbiAgICBwYXJ0c1s0XSA9IHN1Ym1hdGNoWzJdO1xuICAgIHBhcnRzWzVdID0gbnVsbDsgLy8gbm8gY29sdW1uIHdoZW4gZXZhbFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmaWxlOiBwYXJ0c1szXSxcbiAgICBtZXRob2ROYW1lOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxuICAgIGFyZ3VtZW50czogcGFydHNbMl0gPyBwYXJ0c1syXS5zcGxpdCgnLCcpIDogW10sXG4gICAgbGluZU51bWJlcjogcGFydHNbNF0gPyArcGFydHNbNF0gOiBudWxsLFxuICAgIGNvbHVtbjogcGFydHNbNV0gPyArcGFydHNbNV0gOiBudWxsXG4gIH07XG59XG5cbnZhciBqYXZhU2NyaXB0Q29yZVJlID0gL15cXHMqKD86KFteQF0qKSg/OlxcKCguKj8pXFwpKT9AKT8oXFxTLio/KTooXFxkKykoPzo6KFxcZCspKT9cXHMqJC9pO1xuXG5mdW5jdGlvbiBwYXJzZUpTQyhsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGphdmFTY3JpcHRDb3JlUmUuZXhlYyhsaW5lKTtcblxuICBpZiAoIXBhcnRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZpbGU6IHBhcnRzWzNdLFxuICAgIG1ldGhvZE5hbWU6IHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT04sXG4gICAgYXJndW1lbnRzOiBbXSxcbiAgICBsaW5lTnVtYmVyOiArcGFydHNbNF0sXG4gICAgY29sdW1uOiBwYXJ0c1s1XSA/ICtwYXJ0c1s1XSA6IG51bGxcbiAgfTtcbn1cblxudmFyIG5vZGVSZSA9IC9eXFxzKmF0ICg/OigoPzpcXFtvYmplY3Qgb2JqZWN0XFxdKT9bXlxcXFwvXSsoPzogXFxbYXMgXFxTK1xcXSk/KSApP1xcKD8oLio/KTooXFxkKykoPzo6KFxcZCspKT9cXCk/XFxzKiQvaTtcblxuZnVuY3Rpb24gcGFyc2VOb2RlKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gbm9kZVJlLmV4ZWMobGluZSk7XG5cbiAgaWYgKCFwYXJ0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmaWxlOiBwYXJ0c1syXSxcbiAgICBtZXRob2ROYW1lOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxuICAgIGFyZ3VtZW50czogW10sXG4gICAgbGluZU51bWJlcjogK3BhcnRzWzNdLFxuICAgIGNvbHVtbjogcGFydHNbNF0gPyArcGFydHNbNF0gOiBudWxsXG4gIH07XG59XG5cbmV4cG9ydCB7IHBhcnNlIH07XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJ0cnl7c2VsZltcIndvcmtib3g6d2luZG93OjUuMS40XCJdJiZfKCl9Y2F0Y2gobil7fWZ1bmN0aW9uIG4obix0KXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHIpe3ZhciBlPW5ldyBNZXNzYWdlQ2hhbm5lbDtlLnBvcnQxLm9ubWVzc2FnZT1mdW5jdGlvbihuKXtyKG4uZGF0YSl9LG4ucG9zdE1lc3NhZ2UodCxbZS5wb3J0Ml0pfSkpfWZ1bmN0aW9uIHQobix0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIGU9dFtyXTtlLmVudW1lcmFibGU9ZS5lbnVtZXJhYmxlfHwhMSxlLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBlJiYoZS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sZS5rZXksZSl9fWZ1bmN0aW9uIHIobix0KXsobnVsbD09dHx8dD5uLmxlbmd0aCkmJih0PW4ubGVuZ3RoKTtmb3IodmFyIHI9MCxlPW5ldyBBcnJheSh0KTtyPHQ7cisrKWVbcl09bltyXTtyZXR1cm4gZX1mdW5jdGlvbiBlKG4sdCl7dmFyIGU7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFN5bWJvbHx8bnVsbD09bltTeW1ib2wuaXRlcmF0b3JdKXtpZihBcnJheS5pc0FycmF5KG4pfHwoZT1mdW5jdGlvbihuLHQpe2lmKG4pe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBuKXJldHVybiByKG4sdCk7dmFyIGU9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG4pLnNsaWNlKDgsLTEpO3JldHVyblwiT2JqZWN0XCI9PT1lJiZuLmNvbnN0cnVjdG9yJiYoZT1uLmNvbnN0cnVjdG9yLm5hbWUpLFwiTWFwXCI9PT1lfHxcIlNldFwiPT09ZT9BcnJheS5mcm9tKG4pOlwiQXJndW1lbnRzXCI9PT1lfHwvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChlKT9yKG4sdCk6dm9pZCAwfX0obikpfHx0JiZuJiZcIm51bWJlclwiPT10eXBlb2Ygbi5sZW5ndGgpe2UmJihuPWUpO3ZhciBpPTA7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGk+PW4ubGVuZ3RoP3tkb25lOiEwfTp7ZG9uZTohMSx2YWx1ZTpuW2krK119fX10aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIil9cmV0dXJuKGU9bltTeW1ib2wuaXRlcmF0b3JdKCkpLm5leHQuYmluZChlKX10cnl7c2VsZltcIndvcmtib3g6Y29yZTo1LjEuNFwiXSYmXygpfWNhdGNoKG4pe312YXIgaT1mdW5jdGlvbigpe3ZhciBuPXRoaXM7dGhpcy5wcm9taXNlPW5ldyBQcm9taXNlKChmdW5jdGlvbih0LHIpe24ucmVzb2x2ZT10LG4ucmVqZWN0PXJ9KSl9O2Z1bmN0aW9uIG8obix0KXt2YXIgcj1sb2NhdGlvbi5ocmVmO3JldHVybiBuZXcgVVJMKG4scikuaHJlZj09PW5ldyBVUkwodCxyKS5ocmVmfXZhciB1PWZ1bmN0aW9uKG4sdCl7dGhpcy50eXBlPW4sT2JqZWN0LmFzc2lnbih0aGlzLHQpfTtmdW5jdGlvbiBhKG4sdCxyKXtyZXR1cm4gcj90P3Qobik6bjoobiYmbi50aGVufHwobj1Qcm9taXNlLnJlc29sdmUobikpLHQ/bi50aGVuKHQpOm4pfWZ1bmN0aW9uIGMoKXt9dmFyIGY9ZnVuY3Rpb24ocil7dmFyIGUsYztmdW5jdGlvbiBmKG4sdCl7dmFyIGUsYztyZXR1cm4gdm9pZCAwPT09dCYmKHQ9e30pLChlPXIuY2FsbCh0aGlzKXx8dGhpcykudD17fSxlLmk9MCxlLm89bmV3IGksZS51PW5ldyBpLGUucz1uZXcgaSxlLnY9MCxlLmg9bmV3IFNldCxlLmw9ZnVuY3Rpb24oKXt2YXIgbj1lLm0sdD1uLmluc3RhbGxpbmc7ZS5pPjB8fCFvKHQuc2NyaXB0VVJMLGUuZyl8fHBlcmZvcm1hbmNlLm5vdygpPmUudis2ZTQ/KGUucD10LG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZvdW5kXCIsZS5sKSk6KGUuUD10LGUuaC5hZGQodCksZS5vLnJlc29sdmUodCkpLCsrZS5pLHQuYWRkRXZlbnRMaXN0ZW5lcihcInN0YXRlY2hhbmdlXCIsZS5TKX0sZS5TPWZ1bmN0aW9uKG4pe3ZhciB0PWUubSxyPW4udGFyZ2V0LGk9ci5zdGF0ZSxvPXI9PT1lLnAsYT1vP1wiZXh0ZXJuYWxcIjpcIlwiLGM9e3N3OnIsb3JpZ2luYWxFdmVudDpufTshbyYmZS5qJiYoYy5pc1VwZGF0ZT0hMCksZS5kaXNwYXRjaEV2ZW50KG5ldyB1KGEraSxjKSksXCJpbnN0YWxsZWRcIj09PWk/ZS5BPXNlbGYuc2V0VGltZW91dCgoZnVuY3Rpb24oKXtcImluc3RhbGxlZFwiPT09aSYmdC53YWl0aW5nPT09ciYmZS5kaXNwYXRjaEV2ZW50KG5ldyB1KGErXCJ3YWl0aW5nXCIsYykpfSksMjAwKTpcImFjdGl2YXRpbmdcIj09PWkmJihjbGVhclRpbWVvdXQoZS5BKSxvfHxlLnUucmVzb2x2ZShyKSl9LGUuTz1mdW5jdGlvbihuKXt2YXIgdD1lLlA7dD09PW5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmNvbnRyb2xsZXImJihlLmRpc3BhdGNoRXZlbnQobmV3IHUoXCJjb250cm9sbGluZ1wiLHtzdzp0LG9yaWdpbmFsRXZlbnQ6bixpc1VwZGF0ZTplLmp9KSksZS5zLnJlc29sdmUodCkpfSxlLlU9KGM9ZnVuY3Rpb24obil7dmFyIHQ9bi5kYXRhLHI9bi5zb3VyY2U7cmV0dXJuIGEoZS5nZXRTVygpLChmdW5jdGlvbigpe2UuaC5oYXMocikmJmUuZGlzcGF0Y2hFdmVudChuZXcgdShcIm1lc3NhZ2VcIix7ZGF0YTp0LHN3OnIsb3JpZ2luYWxFdmVudDpufSkpfSkpfSxmdW5jdGlvbigpe2Zvcih2YXIgbj1bXSx0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyluW3RdPWFyZ3VtZW50c1t0XTt0cnl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShjLmFwcGx5KHRoaXMsbikpfWNhdGNoKG4pe3JldHVybiBQcm9taXNlLnJlamVjdChuKX19KSxlLmc9bixlLnQ9dCxuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGUuVSksZX1jPXIsKGU9ZikucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoYy5wcm90b3R5cGUpLGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPWUsZS5fX3Byb3RvX189Yzt2YXIgdixoLGwsbT1mLnByb3RvdHlwZTtyZXR1cm4gbS5yZWdpc3Rlcj1mdW5jdGlvbihuKXt2YXIgdD0odm9pZCAwPT09bj97fTpuKS5pbW1lZGlhdGUscj12b2lkIDAhPT10JiZ0O3RyeXt2YXIgZT10aGlzO3JldHVybiBmdW5jdGlvbihuLHQpe3ZhciByPW4oKTtpZihyJiZyLnRoZW4pcmV0dXJuIHIudGhlbih0KTtyZXR1cm4gdChyKX0oKGZ1bmN0aW9uKCl7aWYoIXImJlwiY29tcGxldGVcIiE9PWRvY3VtZW50LnJlYWR5U3RhdGUpcmV0dXJuIHMobmV3IFByb21pc2UoKGZ1bmN0aW9uKG4pe3JldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixuKX0pKSl9KSwoZnVuY3Rpb24oKXtyZXR1cm4gZS5qPUJvb2xlYW4obmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlciksZS5JPWUuTSgpLGEoZS5SKCksKGZ1bmN0aW9uKG4pe2UubT1uLGUuSSYmKGUuUD1lLkksZS51LnJlc29sdmUoZS5JKSxlLnMucmVzb2x2ZShlLkkpLGUuSS5hZGRFdmVudExpc3RlbmVyKFwic3RhdGVjaGFuZ2VcIixlLlMse29uY2U6ITB9KSk7dmFyIHQ9ZS5tLndhaXRpbmc7cmV0dXJuIHQmJm8odC5zY3JpcHRVUkwsZS5nKSYmKGUuUD10LFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKGZ1bmN0aW9uKCl7ZS5kaXNwYXRjaEV2ZW50KG5ldyB1KFwid2FpdGluZ1wiLHtzdzp0LHdhc1dhaXRpbmdCZWZvcmVSZWdpc3RlcjohMH0pKX0pKS50aGVuKChmdW5jdGlvbigpe30pKSksZS5QJiYoZS5vLnJlc29sdmUoZS5QKSxlLmguYWRkKGUuUCkpLGUubS5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZm91bmRcIixlLmwpLG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250cm9sbGVyY2hhbmdlXCIsZS5PLHtvbmNlOiEwfSksZS5tfSkpfSkpfWNhdGNoKG4pe3JldHVybiBQcm9taXNlLnJlamVjdChuKX19LG0udXBkYXRlPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiB0aGlzLm0/cyh0aGlzLm0udXBkYXRlKCkpOnZvaWQgMH1jYXRjaChuKXtyZXR1cm4gUHJvbWlzZS5yZWplY3Qobil9fSxtLmdldFNXPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiB2b2lkIDAhPT10aGlzLlA/dGhpcy5QOnRoaXMuby5wcm9taXNlfWNhdGNoKG4pe3JldHVybiBQcm9taXNlLnJlamVjdChuKX19LG0ubWVzc2FnZVNXPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4gYSh0aGlzLmdldFNXKCksKGZ1bmN0aW9uKHIpe3JldHVybiBuKHIsdCl9KSl9Y2F0Y2gobil7cmV0dXJuIFByb21pc2UucmVqZWN0KG4pfX0sbS5NPWZ1bmN0aW9uKCl7dmFyIG49bmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIuY29udHJvbGxlcjtyZXR1cm4gbiYmbyhuLnNjcmlwdFVSTCx0aGlzLmcpP246dm9pZCAwfSxtLlI9ZnVuY3Rpb24oKXt0cnl7dmFyIG49dGhpcztyZXR1cm4gZnVuY3Rpb24obix0KXt0cnl7dmFyIHI9bigpfWNhdGNoKG4pe3JldHVybiB0KG4pfWlmKHImJnIudGhlbilyZXR1cm4gci50aGVuKHZvaWQgMCx0KTtyZXR1cm4gcn0oKGZ1bmN0aW9uKCl7cmV0dXJuIGEobmF2aWdhdG9yLnNlcnZpY2VXb3JrZXIucmVnaXN0ZXIobi5nLG4udCksKGZ1bmN0aW9uKHQpe3JldHVybiBuLnY9cGVyZm9ybWFuY2Uubm93KCksdH0pKX0pLChmdW5jdGlvbihuKXt0aHJvdyBufSkpfWNhdGNoKG4pe3JldHVybiBQcm9taXNlLnJlamVjdChuKX19LHY9ZiwoaD1be2tleTpcImFjdGl2ZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnUucHJvbWlzZX19LHtrZXk6XCJjb250cm9sbGluZ1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnMucHJvbWlzZX19XSkmJnQodi5wcm90b3R5cGUsaCksbCYmdCh2LGwpLGZ9KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gbigpe3RoaXMuaz1uZXcgTWFwfXZhciB0PW4ucHJvdG90eXBlO3JldHVybiB0LmFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24obix0KXt0aGlzLkIobikuYWRkKHQpfSx0LnJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24obix0KXt0aGlzLkIobikuZGVsZXRlKHQpfSx0LmRpc3BhdGNoRXZlbnQ9ZnVuY3Rpb24obil7bi50YXJnZXQ9dGhpcztmb3IodmFyIHQscj1lKHRoaXMuQihuLnR5cGUpKTshKHQ9cigpKS5kb25lOyl7KDAsdC52YWx1ZSkobil9fSx0LkI9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMuay5oYXMobil8fHRoaXMuay5zZXQobixuZXcgU2V0KSx0aGlzLmsuZ2V0KG4pfSxufSgpKTtmdW5jdGlvbiBzKG4sdCl7aWYoIXQpcmV0dXJuIG4mJm4udGhlbj9uLnRoZW4oYyk6UHJvbWlzZS5yZXNvbHZlKCl9ZXhwb3J0e2YgYXMgV29ya2JveCxuIGFzIG1lc3NhZ2VTV307XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JrYm94LXdpbmRvdy5wcm9kLmVzNS5tanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9